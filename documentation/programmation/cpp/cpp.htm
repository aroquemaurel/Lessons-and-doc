<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0095)#ss_part_420440 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="./cpp_files/widget51.css" media="all">

        


        
        <meta name="keywords" content="tutoriels, concernant, programmation, c++">
        <meta name="description" content="Tutoriels concernant la programmation en C++">
        <meta name="robots" content="index,follow">
        <meta name="verify-v1" content="UL/4+QUCNTv1xBkNcC4sv4EjPUAoVj1yE+fMZClqLsc=">

        <title>
            Apprenez à programmer en C++ !
        </title>

        <link rel="shortcut icon" type="image/x-icon" href="http://www.siteduzero.com/Templates/images/designs/2/favicon.ico">
        <link rel="alternate" type="application/rss+xml" title="News du Site du Zéro" href="http://www.siteduzero.com/Templates/xml/news_fr.xml">
        
        <link rel="alternate" type="application/rss+xml" title="Derniers tutoriels du Site du Zéro" href="http://www.siteduzero.com/Templates/xml/tutoriels_fr.xml">
        

        <link rel="index" href="http://www.siteduzero.com/plan.html">
        <link rel="start" title="Accueil" href="http://www.siteduzero.com/">
        <link rel="search" type="application/opensearchdescription+xml" title="Site Du Zero" href="http://www.siteduzero.com/Templates/xml/xpi/fr/siteduzero.xpi">
        <link rel="search" href="http://www.siteduzero.com/recherche.html" title="Rechercher">
        <link rel="help" title="Accessibilité" href="http://www.siteduzero.com/accessibilite.html">
        <link rel="accesskeys" title="Raccourcis et Accesskeys" href="http://www.siteduzero.com/accessibilite.html">


        <link href="./cpp_files/design.min.css" rel="stylesheet" type="text/css" media="screen, handheld, tv, projection">
        <link href="./cpp_files/zcode.min.css" rel="stylesheet" type="text/css" media="screen, handheld, tv, projection">
        <link href="./cpp_files/impression.min.css" rel="stylesheet" type="text/css" media="print">


        

        

        <!--[if lt IE 8]>
            <link href="/css/ie_old.min.css?1296830240" rel="stylesheet" type="text/css" media="screen" />
        <![endif]-->

        
            <style type="text/css">
                .spoiler3
                {
                        visibility: hidden;
                }
                .spoiler3_hidden
                {
                        display: none;
                }
            </style>
        
        <script type="text/javascript" async="" src="./cpp_files/ga.js"></script><script type="text/javascript" src="./cpp_files/jquery.min.js"></script>
        <script type="text/javascript" src="./cpp_files/jqueryui.min.js"></script>
    </head>

    <body><div style="visibility: hidden; height: 1px; width: 1px; position: absolute; z-index: 100000; " id="_atssh"><iframe id="_atssh917" style="height: 1px; width: 1px; position: absolute; z-index: 100000; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; left: 0px; top: 0px; " src="./cpp_files/sh31.htm"></iframe></div>
		
            <div id="acces_rapide">
                <a href="#menu">Aller au menu</a> - <a href="#corps">Aller au contenu</a>
            </div>

            <div id="top">
                <ul class="intersites">
                    
                    <li class="selected"><a href="http://www.siteduzero.com/">Informatique</a></li>
                    <li><a href="#" id="bientot_lien">Bientôt...</a></li>
                </ul>

		<ul class="stats_sites">
                    
                    <li class="last_items"><a href="http://www.siteduzero.com/connectes.html">2 662 Zéros connectés</a> - </li>
                    <li class="last_items"><a href="http://www.siteduzero.com/membres-292.html">225 021 Membres inscrits</a></li>
		</ul>
            </div>

            <div id="header">
                <div class="header_gauche">
                    <a href="http://www.siteduzero.com/"><img src="./cpp_files/logo_sdz_fr.png" alt=""></a>
                </div>

                <div class="header_droit">
                    <div class="fr">
                        <div id="logbox">
                            
                                <p class="bloc_inscription">
                                    <a href="http://www.siteduzero.com/membres-315.html">
                                        <strong class="liens_invites">Inscription</strong><br>
                                        Inscription rapide en 2 minutes
                                    </a>
                                </p>
                                <p class="bloc_connexion">
                                    <a href="http://www.siteduzero.com/connexion.html">
                                        <strong class="liens_invites">Connexion</strong><br>
                                        Utilisez votre compte
                                    </a>
                                    <a class="rpxnow" onclick="return false;" href="https://site-du-zero.rpxnow.com/openid/v2/signin?token_url=http%3A%2F%2Fwww.siteduzero.com%2Fmembres-348-1.html%3Freferer%3Dtutoriel-3-11406-apprenez-a-programmer-en-c.html%3Fall%3D1"><img src="./cpp_files/rpx_icons.png" alt="connexion_rpx"></a>
                                    <script type="text/javascript">
                                        var rpxJsHost = (("https:" == document.location.protocol) ? "https://" : "http://static.");
                                        document.write(unescape("%3Cscript src='" + rpxJsHost +
                                        "rpxnow.com/js/lib/rpx.js' type='text/javascript'%3E%3C/script%3E"));
                                    </script><script src="./cpp_files/rpx.js" type="text/javascript"></script>
                                    <script type="text/javascript">
                                        RPXNOW.overlay = true;
                                        RPXNOW.language_preference = 'fr';
                                    </script>
                                </p>
                            
                        </div>

                        
                    </div>


                        <div id="publicite_banniere" class="publicite">
                            <script type="text/javascript">
                                <!--
                                ord=Math.random();
                                ord=ord*10000000000000000000;
                                document.write('<scr'+'ipt type="text/javascript" src="pub.js.php?cb='+ord+'&amp;l=468&amp;h=60&amp;age=0&amp;pays=0&amp;cid=261"><\/scr'+'ipt>');
                                -->
                            </script><script type="text/javascript" src="./cpp_files/pub.js.php"></script>
                        </div>
                    </div>
                </div>

                    <div id="speedbarre">
                            <ul class="smenu">
                                <li id="speed_accueil" class="home">
                                    <a href="http://www.siteduzero.com/" accesskey="1" class="">
                                        <span title="Accueil">Accueil</span>
                                    </a>
                                </li>
                                
                                <li id="speed_cours" class="">
                                    <a href="http://www.siteduzero.com/tutoriel.html" class="">
                                        <span>Cours</span>
                                    </a>
                                    <span class="speedbarre_arrow"></span>
                                </li>
                                <li id="speed_forum" class="">
                                    <a href="http://www.siteduzero.com/forum.html" class="">
                                        <span>Forums</span>
                                    </a>
                                    <span class="speedbarre_arrow"></span>
                                </li>
                                
                                    <li id="speed_concours" class="">
                                        <a href="http://www.siteduzero.com/participez.html" class="">
                                            <span>Participez</span>
                                        </a>
                                        <span class="speedbarre_arrow"></span>
                                    </li>
                                    <li id="speed_etudes" class="">
                                        <a href="http://www.siteduzero.com/etudes.html" class="last_item">
                                            <span>Études</span>
                                        </a>
                                        <span class="speedbarre_arrow"></span>
                                    </li>
                                    <li id="speed_job" class="">
                                        <a href="http://www.siteduzero.com/emploi.html" class="last_item">
                                            <span>Emploi</span>
                                        </a>
                                        <span class="speedbarre_arrow"></span>
                                    </li>

                                    <li id="speed_boutique" class="">
                                    <a href="http://www.siteduzero.com/boutique.html" class="last_item">
                                            <span>Boutique</span>
                                        </a>
                                        <span class="speedbarre_arrow"></span>
                                        <img id="discount_teaser" style="position:absolute; top:-10px; left: 80px; " src="./cpp_files/soldes.png" alt="Les soldes du Site du Zéro">
                                    </li>
                                
                            </ul>

                            <div id="speedbar_expand" class="menuh" style="display:none;">
                                <div class="menuh_content">
                                    <div id="menuh_tutorials" style="display: none; ">
                                        

                                        <div id="menu_tutorials">
                                            <div class="menu_prim">
                                                <h5>Les cours phares</h5>
                                                <div class="menuh_list_category">
                                                    <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-67-site-web.html"><img src="./cpp_files/67.png" alt=""></a></div>
                                                    <h6><a href="http://www.siteduzero.com/tutoriel-1-67-site-web.html"><strong>Site Web</strong></a></h6>
                                                    <ul>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-13666-apprenez-a-creer-votre-site-web.html"><span style="display:block">XHTML / CSS</span></a></li>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-309961-dynamisez-vos-sites-web-avec-javascript.html">Javascript</a></li>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-14668-concevez-votre-site-web-avec-php-et-mysql.html">PHP / MySQL</a>
                                                            <a href="http://www.siteduzero.com/boutique-614-107-concevez-votre-site-web-avec-php-et-mysql.html">
                                                                <span class="in_book"><img src="./cpp_files/ico_livre.png" alt=""></span>
                                                                <span style="display:none">Ce cours existe en livre :<br>(Concevez votre site web avec PHP et MySQL)</span>
                                                            </a>
                                                        </li>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-112219-apprenez-a-creer-des-applications-web-dynamiques-avec-jee.html">Java EE (J2EE)</a></li>
                                                    </ul>
                                                </div>

                                                <div class="menuh_list_category">
                                                    <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-57-programmation.html"><img src="./cpp_files/57.png" alt=""></a></div>
                                                    <h6><a href="http://www.siteduzero.com/tutoriel-1-57-programmation.html"><strong>Programmation</strong></a></h6>
                                                    <ul>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-14189-apprenez-a-programmer-en-c.html">Langage C</a>
                                                            <a href="http://www.siteduzero.com/boutique-614-65-apprenez-a-programmer-en-c.html">
                                                                <span class="in_book"><img src="./cpp_files/ico_livre.png" alt=""></span>
                                                                <span style="display:none">Ce cours existe en livre :<br>(Apprenez à programmer en C)</span>
                                                            </a>
                                                        </li>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-11406-apprenez-a-programmer-en-c.html">Langage C++</a></li>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-10601-programmation-en-java.html">Java</a></li>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-119239-programmation-en-java-api.html">Java (API)</a></li>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-223267-apprendre-python.html">Python</a></li>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-134798-visual_basic_net.html">VB .NET </a></li>
                                                    </ul>
                                                </div>


                                                <div class="menuh_list_category">
                                                    <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-60-systemes-d-exploitation.html"><img src="./cpp_files/60.png" alt=""></a></div>
                                                    <h6><a href="http://www.siteduzero.com/tutoriel-1-60-systemes-d-exploitation.html"><strong>Systèmes d'exploitation</strong></a></h6>
                                                    <ul>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-12827-reprenez-le-controle-a-l-aide-de-linux.html">Linux</a>
                                                            <a href="http://www.siteduzero.com/boutique-614-171-reprenez-le-controle-a-l-aide-de-linux.html">
                                                                <span class="in_book"><img src="./cpp_files/ico_livre.png" alt=""></span>
                                                                <span style="display:none">Ce cours existe en livre :<br>(Reprenez le contrôle a l'aide de Linux)</span>
                                                            </a>
                                                        </li>                                                    
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-273305-freebsd-et-l-envers-du-decor.html">FreeBSD</a></li>
                                                    </ul>
                                                </div>

                                                <div class="menuh_list_category">
                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-56-graphisme.html"><img src="./cpp_files/56.png" alt=""></a></div>
                                                    <h6><a href="http://www.siteduzero.com/tutoriel-1-56-graphisme.html"><strong>Graphisme</strong></a></h6>
                                                    <ul>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-351765-debuter-sur-adobe-photoshop.html">Photoshop</a></li>
                                                    </ul>
                                                </div>

                                                <div class="menuh_list_category">
                                                    <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-58-infographie-3d.html"><img src="./cpp_files/58.png" alt=""></a></div>
                                                    <h6><a href="http://www.siteduzero.com/tutoriel-1-58-infographie-3d.html"><strong>Infographie 3D</strong></a></h6>
                                                    <ul>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-11714-debutez-dans-la-3d-avec-blender.html">Blender</a></li>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-228998-apprenez-a-modeliser-en-3d-avec-autodesk-maya.html">Maya </a></li>
                                                    </ul>
                                                </div>

                                                <div class="menuh_list_category">
                                                    <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-55-bureautique.html"><img src="./cpp_files/55.png" alt=""></a></div>
                                                    <h6><a href="http://www.siteduzero.com/tutoriel-1-55-bureautique.html"><strong>Bureautique</strong></a></h6>
                                                    <ul>
                                                        <li><a href="http://www.siteduzero.com/tutoriel-3-258577-redigez-des-documents-de-qualite-professionnelle-avec-latex.html">LaTeX</a>
                                                            <a href="http://www.siteduzero.com/boutique-614-207-redigez-des-documents-de-qualite-professionnelle-avec-latex.html">
                                                                <span class="in_book"><img src="./cpp_files/ico_livre.png" alt=""></span>
                                                                <span style="display:none">Ce cours existe en livre :<br>(Rédigez des documents de qualité avec LaTeX)</span>
                                                            </a>
                                                        </li>
                                                    </ul>
                                                </div>
                                            </div>
                                            
                                            <div class="menu_princi menuhcattuto ">
                                                <h5>Tous les cours par catégories</h5>
                                                <div class="menuh_princi_col">
                                                    
                                                            <div class="menuh_list_category">
                                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-67-site-web.html"><img src="./cpp_files/67.png" alt=""></a></div>
                                                                <h6><a href="http://www.siteduzero.com/tutoriel-1-67-site-web.html">Site Web <span style="font-weight:normal;">(206 Cours)</span></a></h6>
                                                                <ul>
                                                                    <li>
                                                                        
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-69-xhtml-css.html">XHTML / CSS</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-1-210-php.html">PHP</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-71-divers.html">Divers</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-73-forums.html">Forums</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-77-hebergement.html">Hébergement</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-70-javascript.html">Javascript</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-74-serveur.html">Serveur</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-309-ide.html">IDE</a>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        
                                                            <div class="menuh_list_category">
                                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-60-systemes-d-exploitation.html"><img src="./cpp_files/60.png" alt=""></a></div>
                                                                <h6><a href="http://www.siteduzero.com/tutoriel-1-60-systemes-d-exploitation.html">Systèmes d'exploitation <span style="font-weight:normal;">(96 Cours)</span></a></h6>
                                                                <ul>
                                                                    <li>
                                                                        
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-96-linux.html">Linux</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-147-macos.html">MacOS</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-1-97-windows.html">Windows</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-408-bsd.html">BSD</a>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        
                                                            <div class="menuh_list_category">
                                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-54-mapping.html"><img src="./cpp_files/54.png" alt=""></a></div>
                                                                <h6><a href="http://www.siteduzero.com/tutoriel-1-54-mapping.html">Mapping <span style="font-weight:normal;">(31 Cours)</span></a></h6>
                                                                <ul>
                                                                    <li>
                                                                        
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-63-half-life.html">Half-Life</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-66-half-life.html">Half-Life²</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-173-warcraft.html">Warcraft</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-188-autres.html">Autres</a>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        
                                                            <div class="menuh_list_category">
                                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-55-bureautique.html"><img src="./cpp_files/55.png" alt=""></a></div>
                                                                <h6><a href="http://www.siteduzero.com/tutoriel-1-55-bureautique.html">Bureautique <span style="font-weight:normal;">(29 Cours)</span></a></h6>
                                                                <ul>
                                                                    <li>
                                                                        
                                                                            <a href="http://www.siteduzero.com/tutoriel-1-290-microsoft-office.html">Microsoft Office</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-1-291-openoffice-org.html">OpenOffice.org</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-87-firefox.html">Firefox</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-195-irc.html">IRC</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-192-divers.html">Divers</a>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        
                                                            <div class="menuh_list_category">
                                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-59-jeux-video.html"><img src="./cpp_files/59.png" alt=""></a></div>
                                                                <h6><a href="http://www.siteduzero.com/tutoriel-1-59-jeux-video.html">Jeux Vidéo <span style="font-weight:normal;">(22 Cours)</span></a></h6>
                                                                <ul>
                                                                    <li>
                                                                        
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-102-hl-ses-mods.html">HL &amp; ses mods</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-185-autres-jeux.html">Autres jeux</a>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        
                                                            <div class="menuh_list_category">
                                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-61-materiel.html"><img src="./cpp_files/61.png" alt=""></a></div>
                                                                <h6><a href="http://www.siteduzero.com/tutoriel-1-61-materiel.html">Matériel <span style="font-weight:normal;">(11 Cours)</span></a></h6>
                                                                <ul>
                                                                    <li>
                                                                        
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-101-general.html">Général</a>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        

                                                    <div class="menuh_list_category">
                                                        <div class="ico"><img src="./cpp_files/tuto_cat_thb.png" alt=""></div>
                                                        <h6>Autres</h6>
                                                        <ul>
                                                            
                                                                <li>
                                                                    <a style="display:block" href="http://www.siteduzero.com/tutoriel-2-404-bases-de-donnees.html">Bases de données</a>
                                                                </li>
                                                            
                                                                <li>
                                                                    <a style="display:block" href="http://www.siteduzero.com/tutoriel-2-403-mobiles.html">Mobiles</a>
                                                                </li>
                                                            
                                                                <li>
                                                                    <a style="display:block" href="http://www.siteduzero.com/tutoriel-2-141-site-du-zero.html">Site du Zéro</a>
                                                                </li>
                                                            
                                                        </ul>
                                                    </div>
                                                </div>

                                                <div class="menuh_princi_col">
                                                    
                                                            <div class="menuh_list_category">
                                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-57-programmation.html">
                                                                    <img src="./cpp_files/57.png" alt=""></a>
                                                                </div>
                                                                <h6><a href="http://www.siteduzero.com/tutoriel-1-57-programmation.html">Programmation</a> <span style="font-weight:normal;">(244 Cours)</span></h6>
                                                                <ul>
                                                                    <li>
                                                                        
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-91-as-flash-flex.html">AS / Flash / Flex</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-217-algorithmique.html">Algorithmique</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-254-basic-et-derives.html">Basic et dérivés</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-1-344-bibliotheques.html">Bibliothèques</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-262-c.html">C</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-261-c.html">C++</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-201-c-net.html">C# / .NET</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-1-258-calculatrices.html">Calculatrices</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-242-ide.html">IDE</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-336-erlang.html">Erlang</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-227-general.html">Général</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-178-java.html">Java</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-93-mirc.html">mIRC</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-196-python.html">Python</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-355-caml-ocaml.html">Caml / OCaml</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-386-cocoa-objective-c.html">Cocoa / Objective-C</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-253-autres-langages.html">Autres langages</a>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        
                                                            <div class="menuh_list_category">
                                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-56-graphisme.html">
                                                                    <img src="./cpp_files/56.png" alt=""></a>
                                                                </div>
                                                                <h6><a href="http://www.siteduzero.com/tutoriel-1-56-graphisme.html">Graphisme</a> <span style="font-weight:normal;">(27 Cours)</span></h6>
                                                                <ul>
                                                                    <li>
                                                                        
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-176-dessin.html">Dessin</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-177-divers.html">Divers</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-79-flash.html">Flash</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-157-gimp.html">Gimp</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-153-dessin-vectoriel.html">Dessin vectoriel</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-190-photofiltre.html">PhotoFiltre</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-78-photoshop.html">Photoshop</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-197-pov-ray.html">POV-Ray</a>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        
                                                            <div class="menuh_list_category">
                                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-58-infographie-3d.html">
                                                                    <img src="./cpp_files/58.png" alt=""></a>
                                                                </div>
                                                                <h6><a href="http://www.siteduzero.com/tutoriel-1-58-infographie-3d.html">Infographie 3D</a> <span style="font-weight:normal;">(25 Cours)</span></h6>
                                                                <ul>
                                                                    <li>
                                                                        
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-95-3d-studio-max.html">3D Studio Max</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-152-blender.html">Blender</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-296-maya.html">Maya</a>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        
                                                            <div class="menuh_list_category">
                                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-62-multimedia.html">
                                                                    <img src="./cpp_files/62.png" alt=""></a>
                                                                </div>
                                                                <h6><a href="http://www.siteduzero.com/tutoriel-1-62-multimedia.html">Multimédia</a> <span style="font-weight:normal;">(24 Cours)</span></h6>
                                                                <ul>
                                                                    <li>
                                                                        
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-99-audio.html">Audio</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-100-video.html">Vidéo</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-382-after-effects.html">After Effects</a>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        
                                                            <div class="menuh_list_category">
                                                                <div class="ico"><a href="http://www.siteduzero.com/tutoriel-1-182-reseaux.html">
                                                                    <img src="./cpp_files/182.png" alt=""></a>
                                                                </div>
                                                                <h6><a href="http://www.siteduzero.com/tutoriel-1-182-reseaux.html">Réseaux</a> <span style="font-weight:normal;">(18 Cours)</span></h6>
                                                                <ul>
                                                                    <li>
                                                                        
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-183-general.html">Général</a>,
                                                                            <a href="http://www.siteduzero.com/tutoriel-2-189-securite.html">Sécurité</a>
                                                                    </li>
                                                                </ul>
                                                            </div>
                                                        

                                                    <div class="menuh_list_category">
                                                        <div id="create_tutorials_button">
                                                            
                                                                <div><a href="http://www.siteduzero.com/connexion.html"><img src="./cpp_files/redigercours.png" alt=""></a></div>
                                                            
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="clear"></div>
                                            </div>
                                            <div class="clear"></div>
                                        </div>
                                    </div>
                                    
                                    <div id="menuh_forum" style="display: none; ">
                                        <div class="menu_princi">
                                            <a class="button_all_forums" href="http://www.siteduzero.com/forum.html">Accueil des forums</a>
                                            <div class="menuh_princi_col">
                                                
                                                        <div class="menuh_list_category">
                                                            <div class="ico"><a href="http://www.siteduzero.com/forum-89-121-site-web.html"><img src="./cpp_files/121.png" alt=""></a></div>
                                                            <h6><a href="http://www.siteduzero.com/forum-89-121-site-web.html">Site Web</a></h6>
                                                            <ul>
                                                                <li>
                                                                    
                                                                            <a href="http://www.siteduzero.com/forum-81-122-xhtml-css.html">XHTML / CSS</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-338-javascript.html">Javascript</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-123-php.html">PHP</a>
                                                                        
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    
                                                        <div class="menuh_list_category">
                                                            <div class="ico"><a href="http://www.siteduzero.com/forum-89-128-mapping.html"><img src="./cpp_files/128.png" alt=""></a></div>
                                                            <h6><a href="http://www.siteduzero.com/forum-89-128-mapping.html">Mapping</a></h6>
                                                            <ul>
                                                                <li>
                                                                    
                                                                            <a href="http://www.siteduzero.com/forum-81-129-goldsource-hl1.html">GoldSource (HL1)</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-130-source-hl2.html">Source (HL2)</a>
                                                                        
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    
                                                        <div class="menuh_list_category">
                                                            <div class="ico"><a href="http://www.siteduzero.com/forum-89-24-communaute-des-zeros.html"><img src="./cpp_files/24.png" alt=""></a></div>
                                                            <h6><a href="http://www.siteduzero.com/forum-89-24-communaute-des-zeros.html">Communauté des zéros</a></h6>
                                                            <ul>
                                                                <li>
                                                                    
                                                                            <a href="http://www.siteduzero.com/forum-81-28-discussions-generales.html">Discussions générales</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-278-vos-etudes.html">Vos études</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-239-presentation-de-vos-projets.html">Présentation de vos projets</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-200-recrutements-pour-vos-projets.html">Recrutements pour vos projets</a>
                                                                        
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    
                                                        <div class="menuh_list_category">
                                                            <div class="ico"><a href="http://www.siteduzero.com/forum-89-440-sciences.html"><img src="./cpp_files/440.png" alt=""></a></div>
                                                            <h6><a href="http://www.siteduzero.com/forum-89-440-sciences.html">Sciences</a></h6>
                                                            <ul>
                                                                <li>
                                                                    
                                                                            <a href="http://www.siteduzero.com/forum-81-441-mathematiques.html">Mathématiques</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-442-physique-chimie.html">Physique - Chimie</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-443-biologie-et-geologie.html">Biologie et Géologie</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-444-autres-sciences.html">Autres sciences</a>
                                                                        
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    
                                            </div>

                                            <div class="menuh_princi_col">
                                                
                                                        <div class="menuh_list_category">
                                                            <div class="ico"><a href="http://www.siteduzero.com/forum-89-125-programmation.html"><img src="./cpp_files/125.png" alt=""></a></div>
                                                            <h6><a href="http://www.siteduzero.com/forum-89-125-programmation.html">Programmation</a></h6>
                                                            <ul>
                                                                <li>
                                                                    
                                                                            <a href="http://www.siteduzero.com/forum-81-126-langage-c.html">Langage C</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-237-langage-c.html">Langage C++</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-305-langage-java.html">Langage Java</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-407-langage-python.html">Langage Python</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-406-bases-de-donnees.html">Bases de données</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-127-autres-langages-outils-et-approches.html">Autres langages, outils et approches</a>
                                                                        
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    
                                                        <div class="menuh_list_category">
                                                            <div class="ico"><a href="http://www.siteduzero.com/forum-89-219-materiel-et-logiciels.html"><img src="./cpp_files/219.png" alt=""></a></div>
                                                            <h6><a href="http://www.siteduzero.com/forum-89-219-materiel-et-logiciels.html">Matériel et logiciels</a></h6>
                                                            <ul>
                                                                <li>
                                                                    
                                                                            <a href="http://www.siteduzero.com/forum-81-339-discussions-informatiques.html">Discussions informatiques</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-220-linux-mac-et-bsd.html">Linux, Mac et *BSD</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-221-windows.html">Windows</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-116-jeux-video.html">Jeux vidéo</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-117-graphisme.html">Graphisme</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-223-materiel.html">Matériel</a>
                                                                        
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    
                                                        <div class="menuh_list_category">
                                                            <div class="ico"><a href="http://www.siteduzero.com/forum-89-310-concours.html"><img src="./cpp_files/310.png" alt=""></a></div>
                                                            <h6><a href="http://www.siteduzero.com/forum-89-310-concours.html">Concours</a></h6>
                                                            <ul>
                                                                <li>
                                                                    
                                                                            <a href="http://www.siteduzero.com/forum-81-435-innov-game-2011-a-la-gloire-de.html">Innov'Game 2011 : A la gloire de</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-447-atelier-de-noel-faites-votre-jeu.html">Atelier de noël : "Faites votre jeu"</a>
                                                                        
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    
                                                        <div class="menuh_list_category">
                                                            <div class="ico"><a href="http://www.siteduzero.com/forum-89-143-le-site-du-zero.html"><img src="./cpp_files/143.png" alt=""></a></div>
                                                            <h6><a href="http://www.siteduzero.com/forum-89-143-le-site-du-zero.html">Le Site du Zéro</a></h6>
                                                            <ul>
                                                                <li>
                                                                    
                                                                            <a href="http://www.siteduzero.com/forum-81-144-suggestions-et-commentaires.html">Suggestions et Commentaires</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-145-designs-du-site-du-zero.html">Designs du Site du Zéro</a>
                                                                        
                                                                            <a href="http://www.siteduzero.com/forum-81-429-tutoriels-du-site-du-zero.html">Tutoriels du Site du Zéro</a>
                                                                        
                                                                </li>
                                                            </ul>
                                                        </div>
                                                    
                                            </div>
                                        </div>

                                        
                                    <div class="clear"></div>
                                    </div>
                                    <div id="menuh_collaborate" style="display: none; ">
                                        <div class="menuh_list_category">
                                            
                                                <div class="ico"><a href="http://www.siteduzero.com/membres-315.html"><img src="./cpp_files/tuto_cat_thb.png" alt=""></a></div>
                                                <h6><a href="http://www.siteduzero.com/membres-315.html">Cours</a></h6>
                                                <ul>
                                                    <li style="font-style:italic;">Pour rédiger et participer à la rédaction d'un tutoriel, <a style="display:inline; font-style:normal" href="http://www.siteduzero.com/membres-315.html">rejoignez-nous !</a></li>
                                                </ul>
                                            
                                        </div>

                                        <div class="menuh_list_category">
                                            
                                                <div class="ico"><a href="http://www.siteduzero.com/membres-315.html"><img src="./cpp_files/defaut_thb.png" alt=""></a></div>
                                                <h6><a href="http://www.siteduzero.com/membres-315.html">News</a></h6>
                                                <ul>
                                                    <li style="font-style:italic;">Pour partager ou participer à la rédaction d'une news, <a style="display:inline; font-style:normal" href="http://www.siteduzero.com/membres-315.html"> rejoignez-nous !</a></li>
                                                </ul>
                                            
                                        </div>

                                        <div class="menuh_list_category">
                                            <div class="ico"><a href="http://www.siteduzero.com/concours.html"><img src="./cpp_files/cup_thb.png" alt=""></a></div>
                                            <h6><a href="http://www.siteduzero.com/concours.html">Concours</a></h6>
                                            <ul>
                                                
                                                            <li><a href="http://www.siteduzero.com/forum-81-435-innov-game-2011-a-la-gloire-de.html">Innov'Game 2011 : A la gloire de</a></li>
                                                        
                                                            <li><a href="http://www.siteduzero.com/forum-81-447-atelier-de-noel-faites-votre-jeu.html">Atelier de noël : "Faites votre jeu"</a></li>
                                                        
                                            </ul>
                                        </div>
                                        <div class="clear"></div>
                                    </div>


                                    <div id="menuh_job" style="display: none; ">
                                        <div class="menu_princi">
                                            <div class="menuh_princi_col">
                                                <div class="menuh_list_category">
                                                    <h6>Dernières annonces</h6>
                                                    <div class="menuh_list_category_job">
                                                        
                                                            <a title="Consulter le poste : Formateur sur les technologi…" href="http://www.siteduzero.com/emploi/34/formateur-sur-les-technologies-du-web" class="corpsmenu">
                                                                <span class="last_jobs">
                                                                    <span title="CDD" class="job_type jobtypes2">CDD</span>
                                                                </span>
                                                                <span>
                                                                    <span class="job_title">Formateur sur les technologi…</span>
                                                                    <span style="color:#000000;">Simple IT</span>
                                                                </span>
                                                            </a>
                                                        
                                                            <a title="Consulter le poste : Ingénieur d’études et de…" href="http://www.siteduzero.com/emploi/31/ingenieur-d-etudes-et-de-developpement-c" class="corpsmenu">
                                                                <span class="last_jobs">
                                                                    <span title="CDI" class="job_type jobtypes1">CDI</span>
                                                                </span>
                                                                <span>
                                                                    <span class="job_title">Ingénieur d’études et de…</span>
                                                                    <span style="color:#000000;">INVIVOO</span>
                                                                </span>
                                                            </a>
                                                        
                                                            <a title="Consulter le poste : Ingénieur d’études et de…" href="http://www.siteduzero.com/emploi/30/ingenieur-d-etudes-et-de-developpement-c" class="corpsmenu">
                                                                <span class="last_jobs">
                                                                    <span title="CDI" class="job_type jobtypes1">CDI</span>
                                                                </span>
                                                                <span>
                                                                    <span class="job_title">Ingénieur d’études et de…</span>
                                                                    <span style="color:#000000;">INVIVOO</span>
                                                                </span>
                                                            </a>
                                                        
                                                    </div>
                                                </div>
                                            </div>
                                                
                                                <div class="menuh_princi_col">
                                                    <div class="menuh_list_category">
                                                        <h6>Annonces à la une</h6>
                                                        <div class="menuh_list_category_job">
                                                            
                                                                <a title="Consulter le poste : Chargé(e) de clientèle for…" href="http://www.siteduzero.com/emploi/10/charge-e-de-clientele-formations-professionnelles" class="corpsmenu">

                                                                    <span class="last_jobs">
                                                                        <span title="Stage" class="job_type jobtypes3">Stage</span>
                                                                    </span>
                                                                    <span>
                                                                        <span class="job_title">Chargé(e) de clientèle for…</span>
                                                                        <span style="color:#000000;">Simple IT</span>
                                                                    </span>
                                                                </a>
                                                            
                                                                <a title="Consulter le poste : Ingénieur Etudes et Dévelo…" href="http://www.siteduzero.com/emploi/5/ingenieur-etudes-et-developpements-java-j2ee-finance-de-marche" class="corpsmenu">

                                                                    <span class="last_jobs">
                                                                        <span title="CDI" class="job_type jobtypes1">CDI</span>
                                                                    </span>
                                                                    <span>
                                                                        <span class="job_title">Ingénieur Etudes et Dévelo…</span>
                                                                        <span style="color:#000000;">TEAM TRADE GROUPE</span>
                                                                    </span>
                                                                </a>
                                                            
                                                        </div>
                                                    </div>
                                                    <div class="menuh_list_category">
                                                        <div>
                                                            <div><a href="http://www.siteduzero.com/emploi.html"><img src="./cpp_files/speed_barre_btn_recherche_emploi.png" alt=""></a></div>
                                                        </div>
                                                    </div>
                                                </div>

                                                <div class="menuh_more2">
                                                        <a href="http://www.siteduzero.com/emploi/liste.html">Toutes les annonces<img src="./cpp_files/fleche_droite.png" alt="►"></a>
                                                </div>
                                            </div>
                                        <div class="clear"></div>
                                    </div>

                                    <div id="menuh_study" style="padding-left: 15px; display: none; ">
                                        <div class="menu_princi">
                                            <div class="ico_study"><img src="./cpp_files/ico_etude.png" width="50" alt="icon etude"></div>
                                            <div class="menuh_princi_col">
                                                <div class="menuh_list_category">
                                                    <h6>Recrutement à Bac / Bac +1</h6>
                                                    <ul>
                                                        <li><a href="http://www.siteduzero.com/etudes-550-280-bts.html">BTS</a></li>
                                                        <li><a href="http://www.siteduzero.com/etudes-550-269-ecoles-d-ing%C3%A9nieurs-en-informatique.html">Ecoles d'ingénieurs en informatique</a></li>
                                                        <li><a href="http://www.siteduzero.com/etudes-550-274-ecoles-d-ing%C3%A9nieurs-generalistes.html">Ecoles d'ingénieurs généralistes</a></li>
                                                        <li><a href="http://www.siteduzero.com/etudes-550-283-iut.html">IUT</a></li>
                                                        <li><a href="http://www.siteduzero.com/etudes-550-300-universites.html">Universités</a></li>
                                                        <li><a href="http://www.siteduzero.com/etudes-550-287-autre-formation-diplomantes.html">Autres formations diplômantes</a></li>
                                                        <li><a href="http://www.siteduzero.com/etudes-550-448-cpge.html">CPGE</a></li>
                                                    </ul>
                                                </div>

                                                <div class="menuh_list_category">
                                                    <h6>Recrutement à Bac +2</h6>
                                                    <ul>
                                                       <li><a href="http://www.siteduzero.com/etudes-550-270-ecoles-d-ing%C3%A9nieurs-en-informatique.html">Ecoles d'ingénieurs en informatique</a></li>
                                                       <li><a href="http://www.siteduzero.com/etudes-550-273-ecoles-d-ing%C3%A9nieurs-generalistes.html">Ecoles d'ingénieurs généralistes</a></li>
                                                       <li><a href="http://www.siteduzero.com/etudes-550-289-autre-formation-diplomantes.html">Autres formations diplômantes</a></li>
                                                    </ul>
                                                </div>
                                            </div>

                                            <div class="menuh_princi_col">
                                                <div class="menuh_list_category">
                                                    <h6>Recrutement à Bac +3 / Bac +4</h6>
                                                    <ul>
                                                        <li><a href="http://www.siteduzero.com/etudes-550-388-ecoles-d-ing%C3%A9nieurs-en-informatique.html">Ecoles d'ingénieurs en informatique</a></li>
                                                        <li><a href="http://www.siteduzero.com/etudes-550-389-ecoles-d-ing%C3%A9nieurs-generalistes.html">Ecoles d'ingénieurs généralistes</a></li>
                                                        <li><a href="http://www.siteduzero.com/etudes-550-390-autre-formation-diplomantes.html">Autres formations diplômantes</a></li>
                                                    </ul>
                                                </div>

                                                <div class="menuh_list_category">
                                                    <h6>Recrutement à Bac +5</h6>
                                                    <ul>
                                                       <li><a href="http://www.siteduzero.com/etudes-550-299-doctorats.html">Doctorats</a></li>
                                                       <li><a href="http://www.siteduzero.com/etudes-550-391-autre-formation-diplomantes.html">Autres formations diplômantes</a></li>
                                                    </ul>
                                                    <div class="menuh_list_category">
                                                        <div id="find_training">
                                                            <div><a href="http://www.siteduzero.com/etudes.html"><img src="./cpp_files/ico_recherche_cours.png" alt=""><strong>Trouvez une formation</strong></a></div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="clear"></div>
                                    </div>

                                    <div id="menuh_shop" style="display: none; ">
                                        <div style="float: left; background-image:url(&#39;/images/designs/2/boutique/soldes/soldes_speed.png&#39;); width:296px; height:362px;">
                                            <a href="http://www.siteduzero.com/boutique-614-188-cle-usb-du-site-du-zero-8-go.html" style="display:block; height:240px;"></a>
                                            <div class="discount_product_high">
                                                <h5 style="font-size:16px; font-weight: bold">4 Go</h5>
                                                <span class="min_price" style="font-size:14px; background: transparent url(&#39;/images/designs/2/boutique/soldes/old.png&#39;) no-repeat center center;">15,20 €</span>
                                                <span class="price" style="color:#008000; font-size:18px;">9,90 €</span>
                                                <span><a class="link_contextual buy" href="http://www.siteduzero.com/boutique-614-184-cle-usb-du-site-du-zero-4-go.html">Acheter</a></span>
                                            </div>

                                            <div class="discount_product_high">
                                                <h5 style="font-size:16px; font-weight: bold">8 Go</h5>
                                                <span class="min_price" style="font-size:14px; background: transparent url(&#39;/images/designs/2/boutique/soldes/old.png&#39;) no-repeat center center;">23,20 €</span>
                                                <span class="price" style="color:#008000; font-size:18px;">14,90 €</span>
                                                <span><a class="link_contextual buy" href="http://www.siteduzero.com/boutique-614-188-cle-usb-du-site-du-zero-8-go.html">Acheter</a></span>
                                            </div>

                                            <div class="discount_product_high">
                                                <h5 style="font-size:16px; font-weight: bold">16 Go</h5>
                                                <span class="min_price" style="font-size:14px; background: transparent url(&#39;/images/designs/2/boutique/soldes/old.png&#39;) no-repeat center center;">39,20 €</span>
                                                <span class="price" style="color:#008000; font-size:18px;">24,90 €</span>
                                                <span><a class="link_contextual buy" href="http://www.siteduzero.com/boutique-614-191-cle-usb-du-site-du-zero-16-go.html">Acheter</a></span>
                                            </div>
                                        </div>

                                    <div class="other_products">
                                        <span>Concevez votre site web avec PHP et MySQL<br>
                                        <a href="http://www.siteduzero.com/boutique-614-107-concevez-votre-site-web-avec-php-et-mysql.html">En savoir plus ►</a></span>
                                        <a href="http://www.siteduzero.com/boutique-614-107-concevez-votre-site-web-avec-php-et-mysql.html">
                                        <img style="margin:13px 0 0 22px" alt="Concevez votre site web avec php et mysql" src="./cpp_files/livre_cours_php_2d.png"></a>
                                    </div>

                                    <div class="other_products">
                                        <span>Apprenez à programmer en C <br>
                                        <a href="http://www.siteduzero.com/boutique-614-65-apprenez-a-programmer-en-c.html">En savoir plus ►</a></span>
                                        <a href="http://www.siteduzero.com/boutique-614-65-apprenez-a-programmer-en-c.html">
                                        <img style="margin:13px 0 0 22px" alt="Apprenez à programmer en C" src="./cpp_files/livre_cours_c_2d.png"></a>
                                    </div>
                                    <div class="other_products">
                                        <span>Reprenez le contrôle à l'aide de Linux <br>
                                        <a href="http://www.siteduzero.com/boutique-614-171-reprenez-le-controle-a-l-aide-de-linux.html">En savoir plus ►</a></span>
                                        <a href="http://www.siteduzero.com/boutique-614-171-reprenez-le-controle-a-l-aide-de-linux.html">
                                        <img style="margin:13px 0 0 22px" alt="Reprenez le contrôle à l&#39;aide de Linux" src="./cpp_files/livre_cours_linux_2d.png"></a>
                                    </div>

                                    <div class="other_products">
                                        <span>Rédigez des documents de qualité avec LaTeX<br>
                                        <a href="http://www.siteduzero.com/boutique-614-207-redigez-des-documents-de-qualite-avec-latex.html">En savoir plus ►</a></span>
                                        <a href="http://www.siteduzero.com/boutique-614-207-redigez-des-documents-de-qualite-avec-latex.html">
                                        <img style="margin:13px 0 0 22px" alt="Rédigez des documents de qualité avec LaTeX" src="./cpp_files/livre_cours_latex_2d.png"></a>
                                    </div>
                                      
                                    <div class="menuh_more">
                                        <a href="http://www.siteduzero.com/boutique.html">Tous les produits <img src="./cpp_files/fleche_droite(1).png" alt="►"></a>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="search_bar">
                        <div class="ard"></div>
                        <form method="get" action="http://www.siteduzero.com/recherche.html" id="recherche">
                            <p>
                                <input type="text" name="src" id="champ_recherche" accesskey="4" value="Rechercher">
                                <select name="c" id="section_recherche">
                                    <option value="3" selected="selected">Cours</option>
                                    <option value="6">Forums</option>
                                    <option value="4">News</option>
                                    <option value="mbr">Membres</option>
                                    <option value="formation">Études</option>
                                    <option value="codeweb">Code web</option>
                                    <option value="mp">MP</option>
                                </select>
                                <input class="button_go_search" value="Go" type="submit">
                                <a class="button_more_search" href="http://www.siteduzero.com/recherche.html">+</a>
                            </p>
                        </form>
                        </div>

                    </div>

<script type="text/javascript">

    
        //On Hover

    var keyCodeEscape = 27;
    $(document).keyup(function(f) {
        if (f.keyCode == keyCodeEscape)
        {
            hideBlocMenu();
        }
    });


    /* Var for speedbar*/
    showDelay = 300;
    hiddenDelay = 367;
    fadeInDelay = 100
    fadeOutDelay = 100
    timer = null;
    hideTimeOut = null
    // speedbar function
    function speedShowDelay(){
        if($('.menuh_content > div').is(':visible'))
        {
            showDelay = null;
        }
        else
        {
            showDelay = 300;
        }
    }
    
    $("body").mouseleave(function(){
        $('.menuh_content > div').hide();
        $('#speedbarre .smenu>li a').removeClass("smenu_hover");
    });
    
    function showMenu(id, id2){

        $(id2).click(function(){
            clearInterval(timer);
            hideBlocMenu();
            return;
        });

        speedShowDelay();

        $("body").unbind('click');

        clearInterval(timer);
        if(!$(id).is(':visible'))
        {
            $('.menuh_content > div').hide();

            $('#speedbarre .smenu>li a').removeClass("smenu_hover");
            $('#speedbarre .smenu > li > .speedbarre_arrow').hide();

            timer=setInterval(function(){
                $(id+' ,#speedbar_expand').fadeIn(fadeInDelay);
                $(id2+' a').addClass('smenu_hover')
                clearInterval(timer);

                // Discount
                if(id == '#menuh_shop')
                {
                    $.get('http://www.siteduzero.com/soldes/affichage');
                    $('#discount_teaser').remove();
                }

                },showDelay);
        }
    }

    function hideMenu(id, id2){

        clearInterval(timer);
        clearTimeout(hideTimeOut);

        $("body").bind('click',function(){
            hideBlocMenu();
        });

        timer=setInterval(function(){
            $(id).fadeOut(fadeOutDelay,function(){
                $('#speedbar_expand').hide();
                $(id2+' a').removeClass("smenu_hover");
            });
            clearInterval(timer);
        },hiddenDelay)
    }

    function hideBlocMenu(){
        $('.menuh_content > div').fadeOut(fadeOutDelay, function(){
            $('#speedbar_expand').hide();
            $('#speedbarre .smenu>li a').removeClass("smenu_hover");})
    }

        /* speedbar */


    $("#speed_cours").addClass('hideOnLoad');
    $("#speed_forum").addClass('hideOnLoad');
    $("#speed_concours").addClass('hideOnLoad');
    $("#speed_job").addClass('hideOnLoad');
    $("#speed_etudes").addClass('hideOnLoad');
    $("#speed_boutique").addClass('hideOnLoad');



    $(document).mousemove(function(){
        $("#speed_cours").removeClass('hideOnLoad');
        $("#speed_forum").removeClass('hideOnLoad');
        $("#speed_concours").removeClass('hideOnLoad');
        $("#speed_job").removeClass('hideOnLoad');
        $("#speed_etudes").removeClass('hideOnLoad');
        $("#speed_boutique").removeClass('hideOnLoad');
    })


    //TUTORIALS
    $("#speed_cours, #menuh_tutorials").hover(function(){
        clearTimeout(hideTimeOut);
        id = '#menuh_tutorials';
        id2 = '#speed_cours';
        if(!$(id2).hasClass('hideOnLoad'))
        {
            hideTimeOut = setTimeout(function(){
                showMenu(id, id2);
            },100);
        }

    ;},function(){

        id = '#menuh_tutorials';
        id2 = '#speed_cours';
        hideMenu(id, id2);
    });
    //FORUMS
    $("#speed_forum, #menuh_forum").hover(function(){
        clearTimeout(hideTimeOut);
        id = '#menuh_forum';
        id2 = '#speed_forum';

        if(!$(id2).hasClass('hideOnLoad'))
        {
            hideTimeOut = setTimeout(function(){
                showMenu(id, id2);
            },100);
        }

    ;},function(){

        id = '#menuh_forum';
        id2 = '#speed_forum';
        hideMenu(id, id2);
    });

    //COLLABORATE
    $("#speed_concours, #menuh_collaborate").hover(function(){
        clearTimeout(hideTimeOut);
        id = '#menuh_collaborate';
        id2 = '#speed_concours';
        if(!$(id2).hasClass('hideOnLoad'))
        {
            hideTimeOut = setTimeout(function(){
                showMenu(id, id2);
            },100);
        }

    ;},function(){

        id = '#menuh_collaborate';
        id2 = '#speed_concours';
        hideMenu(id, id2);
    });

    //JOB
    $("#speed_job, #menuh_job").hover(function(){
        clearTimeout(hideTimeOut);
        id = '#menuh_job';
        id2 = '#speed_job';
        if(!$(id2).hasClass('hideOnLoad'))
        {
            hideTimeOut = setTimeout(function(){
                showMenu(id, id2);
            },100);
        }

    ;},function(){

        id = '#menuh_job';
        id2 = '#speed_job';
        hideMenu(id, id2);
    });

    //STUDY
    $("#speed_etudes, #menuh_study").hover(function(){
        clearTimeout(hideTimeOut);
        id = '#menuh_study';
        id2 = '#speed_etudes';
        if(!$(id2).hasClass('hideOnLoad'))
        {
            hideTimeOut = setTimeout(function(){
                showMenu(id, id2);
            },100);
        }

    ;},function(){

        id = '#menuh_study';
        id2 = '#speed_etudes';
        hideMenu(id, id2);
    });

    //SHOP
    $("#speed_boutique, #menuh_shop").hover(function(){
        clearTimeout(hideTimeOut);
        id = '#menuh_shop';
        id2 = '#speed_boutique';
        if(!$(id2).hasClass('hideOnLoad'))
        {
            hideTimeOut = setTimeout(function(){
                showMenu(id, id2);
            },100);
        }

    ;},function(){

        id = '#menuh_shop';
        id2 = '#speed_boutique';
        hideMenu(id, id2);
    });

    

</script>
            
            <div class="contenu">
                <div id="menu">
                    

                    <div class="box_menu">
                        <h5>Cours</h5>

                        <div class="corpsmenu">
                            <ul>
                                
                                    <li style="border-bottom: 0 none; padding: 0 0 2px 0; background-color: #e2f0ff">
                                        <a href="http://www.siteduzero.com/tutoriel-3-361996-par-ou-commencer.html"><img style="padding-left:5px;" src="./cpp_files/compass.png" class="fl" alt=""></a>
                                        <span class="liste_cours_menu" style="margin-left: 43px;">
                                            <a href="http://www.siteduzero.com/tutoriel-3-361996-par-ou-commencer.html"><strong class="menu_cours_section">Nouveau ?</strong></a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-361996-par-ou-commencer.html">Suivez le guide !</a><br>
                                        </span>
                                    </li>
                                    <li>
                                        <a href="http://www.siteduzero.com/tutoriel-1-67-site-web.html"><img src="./cpp_files/67.png" class="fl" alt=""></a>
                                        <span class="liste_cours_menu">
                                            <a href="http://www.siteduzero.com/tutoriel-1-67-site-web.html"><strong class="menu_cours_section">Site Web</strong></a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-13666-apprenez-a-creer-votre-site-web.html">XHTML / CSS</a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-309961-dynamisez-vos-sites-web-avec-javascript.html">Javascript</a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-14668-concevez-votre-site-web-avec-php-et-mysql.html">PHP / MySQL</a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-112219-apprenez-a-creer-des-applications-web-dynamiques-avec-jee.html">Java EE (J2EE)</a>
                                        </span>
                                    </li>
                                    <li>
                                        <a href="http://www.siteduzero.com/tutoriel-1-57-programmation.html"><img src="./cpp_files/57.png" class="fl" alt=""></a>
                                        <span class="liste_cours_menu">
                                            <a href="http://www.siteduzero.com/tutoriel-1-57-programmation.html"><strong class="menu_cours_section">Programmation</strong></a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-14189-apprenez-a-programmer-en-c.html">Langage C</a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-11406-apprenez-a-programmer-en-c.html">Langage C++</a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-10601-programmation-en-java.html">Java</a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-119239-programmation-en-java-api.html">Java (API)</a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-223267-apprendre-python.html">Python </a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-134798-visual_basic_net.html">VB .NET</a>
                                        </span>
                                    </li>
                                    <li>                                        
                                        <a href="http://www.siteduzero.com/tutoriel-1-60-systemes-d-exploitation.html"><img src="./cpp_files/60.png" class="fl" alt=""></a>
                                        <span class="liste_cours_menu">
                                            <a href="http://www.siteduzero.com/tutoriel-1-60-systemes-d-exploitation.html"><strong class="menu_cours_section">Systèmes d'exploitation</strong></a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-12827-reprenez-le-controle-a-l-aide-de-linux.html">Linux</a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-273305-freebsd-et-l-envers-du-decor.html">FreeBSD</a>
                                        </span>
                                    </li>
                                    <li>
                                        <a href="http://www.siteduzero.com/tutoriel-1-56-graphisme.html"><img src="./cpp_files/56.png" class="fl" alt=""></a>
                                        <span class="liste_cours_menu">
                                            <a href="http://www.siteduzero.com/tutoriel-1-56-graphisme.html"><strong class="menu_cours_section">Graphisme</strong></a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-351765-debuter-sur-adobe-photoshop.html">Photoshop</a><br>
                                        </span>
                                    </li>
                                    <li>
                                        <a href="http://www.siteduzero.com/tutoriel-1-58-infographie-3d.html"><img src="./cpp_files/58.png" class="fl" alt=""></a>
                                        <span class="liste_cours_menu">
                                            <a href="http://www.siteduzero.com/tutoriel-1-58-infographie-3d.html"><strong class="menu_cours_section">Infographie 3D</strong></a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-11714-debutez-dans-la-3d-avec-blender.html">Blender</a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-228998-apprenez-a-modeliser-en-3d-avec-autodesk-maya.html">Maya</a>
                                        </span>
                                    </li>

                                    <li>
                                        <a href="http://www.siteduzero.com/tutoriel-1-55-bureautique.html"><img src="./cpp_files/55.png" class="fl" alt=""></a>
                                        <span class="liste_cours_menu">
                                            <a href="http://www.siteduzero.com/tutoriel-1-55-bureautique.html"><strong class="menu_cours_section">Bureautique</strong></a><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-258577-redigez-des-documents-de-qualite-professionnelle-avec-latex.html">LaTeX </a>
                                        </span>
                                        
                                    </li>
                                    
                                    
                                    <li class="last_idem_liste">
                                        <img src="./cpp_files/die.png" class="fl" alt="">
                                        <span class="liste_cours_menu">
                                            <strong class="menu_cours_section">Tutoriel du jour</strong><br>
                                            <a href="http://www.siteduzero.com/tutoriel-3-38890-la-cross-compilation-d-applications-qt-depuis-linux.html">La cross compilation d'applications Qt depuis Linux</a><br>
                                        </span>
                                        <div id="menu_ajout_cours">
                                            
                                                <a href="http://www.siteduzero.com/tutoriel-3-256867-devenez-auteur-de-cours-sur-le-site-du-zero-et-le-livre-du-zero.html">
                                            
                                            Rédigez un cours <img src="./cpp_files/add.png" alt="">&nbsp;</a>
                                        </div>
                                        <a href="http://www.siteduzero.com/tutoriel.html" class="fr">Tous les cours  <img src="./cpp_files/fleche_droite.png" alt="">&nbsp;</a><br>
                                    </li>
                                
                            </ul>
                        </div>
                    </div>
                </div>

                <div id="corps">
                    <div id="zozor_position">
                        <div id="zozor">
                            <div class="centre"><img src="./cpp_files/zozor6.png" alt=" Zozor" title=" Zozor"></div>
                       </div>
                    </div>

                    <div id="container_bulle_zozor">
                        
                    </div>

                    <div id="arbre">
                        
			&gt;  <a href="http://www.siteduzero.com/">Le Site du Zéro</a>
		
			&gt;  <a href="http://www.siteduzero.com/tutoriel.html">Cours</a>
			 &gt;  <a href="http://www.siteduzero.com/tutoriel-1-352-tutoriels.html">Tutoriels</a>
		 &gt;  <a href="http://www.siteduzero.com/tutoriel-1-57-programmation.html">Programmation</a>
		 &gt;  <a href="http://www.siteduzero.com/tutoriel-2-261-c.html">C++</a>
		&gt;  <a href="http://www.siteduzero.com/tutoriel-3-11406-apprenez-a-programmer-en-c.html">Apprenez à programmer en C++ !</a> 

&gt; Lecture du tutoriel

                    </div>

                    


<h1>Apprenez à programmer en C++ !</h1>


<div id="onglets_tutos" class="onglets_tutos">
  <ul>
    
      <li class="selected">
      <a href="http://www.siteduzero.com/tutoriel-3-11406-apprenez-a-programmer-en-c.html">Tutoriel</a></li>
    
      <li>
      <a href="http://www.siteduzero.com/tutoriel-50-11406-p7-apprenez-a-programmer-en-c.html#r69571">202 commentaires</a></li>
    
      <li>
      <a href="http://www.siteduzero.com/tutoriel-21-11406-apprenez-a-programmer-en-c.html">Historique</a></li>
    
  </ul>
</div>
<hr class="bas_onglets">





<div class="cadre_auteur_date">
  <form action="http://www.siteduzero.com/tutoriel-54-11406.html" method="post">
    <div class="dnone"><input type="hidden" value="ed76eab401a049a91b67ae7f6cc351d083c1edd5" name="challenge"></div>

    <div class="infobox">
<h3 class="special">Informations sur le tutoriel</h3>
<div class="conteneur_infobox">
<table>
  <tbody><tr>
    <td>
    <div class="boite_avatar_100px">
      <a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/genius.wav"><img src="./cpp_files/155400.png" style="width:73px; height:93px; display: block;" alt="Avatar" class="avatar" id="avatar3"></a><img src="./cpp_files/92161.png" style="width:100px; height:100px;" alt="Avatar" class="avatar" id="avatar49110">  
     </div>
    </td>
    <td>
     
      <strong>Auteurs</strong> :
      
    
	    <a class="auteur_tut" href="http://www.siteduzero.com/membres-294-3.html">M@teo21</a> et 
	    <a class="auteur_tut" href="http://www.siteduzero.com/membres-294-49110.html">Nanoc</a>
    
      <br>
    
      
		  <strong>Difficulté</strong> :
		  
			<img src="./cpp_files/niveau_3.png" alt="Difficile">
		  
		  <br>
	  
		<strong>Temps d'étude estimé</strong> : 
		
			3 mois
		<br>
	<strong>Licence</strong> : <a href="http://creativecommons.org/licenses/by-nc-sa/2.0/fr/"><img src="./cpp_files/6.png" alt="Creative Commons BY-NC-SA" title="Creative Commons BY-NC-SA"></a><br><br>
      <br>
      <a href="#tuto_details" onclick="toggle(&#39;infos_detaillees&#39;); return false;">Plus d'informations <img src="./cpp_files/fleche_bas.png" alt="Plus d&#39;informations" title="Plus d&#39;informations" id="image_detail"></a>

      <div style="display: none;" id="infos_detaillees">
	<br>			
<strong>Créé</strong> : Le 18/09/2007 à 17:13:58<br>
<strong>Modifié</strong> : Hier à 15:51:57<br>

<strong>Avancement</strong> : 100%<br>

<br>


<a href="http://www.siteduzero.com/tutoriel-50-11406-69571-apprenez-a-programmer-en-c.html#r69571">202 commentaires</a><br>

  <a href="http://www.siteduzero.com/tutoriel-3-11406-apprenez-a-programmer-en-c.html">Revenir au sommaire du tutoriel</a><br>


      </div>

    </td>
  </tr>
</tbody></table>
</div>
</div>


    <div class="infobox">
        <h3 class="special">Popularité</h3>
        <div class="conteneur_infobox">
            <strong>Visualisations</strong> : 2&nbsp;141&nbsp;055&nbsp;398<br><br>
            <div style="padding-top: 1px; float: left;"><strong>Appréciation<br>des lecteurs</strong> : </div>
            <div class="tut_appreciation">
                <div class="tut_appreciation_smiley" id="smiley-1-90--644019" style="background-position: -19px 50%;"><img src="./cpp_files/empty.gif" alt=""></div>
                <span id="eval_nb-1">19</span>
            </div>
            <div class="tut_appreciation">
                <div class="tut_appreciation_smiley" id="smiley-2-90--644019" style="background-position: -57px 50%;"><img src="./cpp_files/empty.gif" alt=""></div>
                <span id="eval_nb-2">15</span>
            </div>
            <div class="tut_appreciation">
                <div class="tut_appreciation_smiley" id="smiley-3-90--644019" style="background-position: -95px 50%;"><img src="./cpp_files/empty.gif" alt=""></div>
                <span id="eval_nb-3">64</span>
            </div>
            <div class="tut_appreciation">
                <div class="tut_appreciation_smiley eval_always_color" id="smiley-4-90--644019" style="background-position: -114px 50%;"><img src="./cpp_files/empty.gif" alt=""></div>
                <span id="eval_nb-4">741</span>
            </div>
            
            <div style="clear: both;"></div>
                
                    <p id="tut_vot_ldz" style="text-align:center;"><img src="./cpp_files/thb_livre_cours_c.png" id="tut_vot_ldz_img" alt="">
                    
                                <b>2866 personnes</b> souhaitent voir ce tutoriel publié en livre ! <br> <a href="http://www.siteduzero.com/vote/ldz/90.html" id="tut_vot_ldz_link">Vous aussi ?</a>
                            
            </p>
        </div>
    </div>


<div class="infobox" id="pave_pub_tuto" style="display: block; ">
<h3 class="special">Publicité</h3>
<div class="conteneur_infobox">
<table style="width: 100%;">
  <tbody><tr>
    <td colspan="2" id="menu_pub_tuto">
    <script type="text/javascript">
            <!--
            ord=Math.random();
            ord=ord*10000000000000000000;
            var test = true;
            document.write('<scr'+'ipt type="text/javascript" src="pub.js.php?cb='+ord+'&amp;l=300&amp;h=250&amp;age=0&amp;afficher_bloc_pub=pave_pub_tuto&amp;cid=261&amp;pays=0"><\/scr'+'ipt>');
            -->
    </script><script type="text/javascript" src="./cpp_files/pub.js(1).php"></script><iframe src="./cpp_files/cm.htm" marginwidth="0" marginheight="0" width="300" height="250" border="0" frameborder="0" style="border:none;" scrolling="no"></iframe>
    </td>
  </tr>
</tbody></table>
</div>
</div>

    
	<div class="infobox">
		<h3 class="special">Historique des mises à jour</h3>
		<div class="conteneur_infobox">
			<ul>
				
					<li>
						<em>Hier à 23:52:19</em><br>
						Correction des alertes #3807 et #3809
					</li>
			  
					<li>
						<em>Hier à 19:44:16</em><br>
						Correction alerte #3806
					</li>
			  
					<li>
						<em>Hier à 19:34:25</em><br>
						Correction des alertes #3795, #3797, #3800, #3801 et #3805
					</li>
			  
			</ul>
		</div>
	</div>


    
  </form>
</div>

<div id="btuto_intro">
	<div class="centre"><span class="gros">La programmation C++ vous intéresse mais ça vous paraît trop compliqué ?</span><br>
Ce cours de C++ est fait pour des débutants comme vous qui n'ont jamais programmé !</div><br>
<br>
Le langage C++ est un des langages les plus célèbres au monde. Très utilisé, notamment dans le secteur des jeux vidéo qui apprécie ses performances et ses possibilités, le C++ est désormais incontournable pour les développeurs.<br>
<br>
Le C++ est le descendant du <a href="http://www.siteduzero.com/tutoriel-3-14189-apprenez-a-programmer-en-c.html">langage C</a>. Ces deux langages, bien que semblables au premier abord, sont néanmoins <span class="italique">différents</span>. Le C++ propose de nouvelles fonctionnalités, comme la programmation orientée objet (POO). Elles en font un langage très puissant qui permet de programmer avec une approche différente du langage C.<br>
<br>
Dans ce cours, nous découvrirons aussi une bibliothèque appelée Qt. Elle ajoute un très large éventail de possibilités au C++ : elle va nous permettre de créer des fenêtres et menus, mais aussi d'utiliser les fonctionnalités réseau de votre ordinateur ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<div class="centre"><a href="./cpp_files/116941(1).png"><img src="./cpp_files/116941.png" alt="ZeroClassGenerator"></a> <a href="./cpp_files/121737(1).png"><img src="./cpp_files/121737.png" alt="zNavigo"></a> <a href="./cpp_files/124121(1).png"><img src="./cpp_files/124121.png" alt="Chat côté client"></a><br>
<span class="italique">Quelques programmes C++ que nous réaliserons</span></div>
</div>

<hr>



<div id="pre_liste_parties">
	Ce cours est composé des parties suivantes :
</div>

<ul id="liste_parties">
	
		<li><a href="#part_420452">[Théorie] Découverte de la programmation en C++</a></li>
	
		<li><a href="#part_11409">[Théorie] La Programmation Orientée Objet</a></li>
	
		<li><a href="#part_11407">[Pratique] Créez vos propres fenêtres avec Qt</a></li>
	
		<li><a href="#part_11408">Annexes</a></li>
	
</ul>
		<ul class="liste_parties_btut">
		
		<li>
		<hr class="separateur_parties">
		<h2 id="part_420452">Partie 1 : [Théorie] Découverte de la programmation en C++</h2>
		<div>
			Vous souhaitez découvrir le C++ mais vous n'avez jamais fait de programmation avant ? Commencez par là !<br>
Vous découvrirez comment fonctionne la programmation, quels logiciels il faut installer et quelles sont les techniques de base à connaître.
		</div>
			
				<ul class="liste_chapitres_btut">
				
					<li>
						<br><br><a href="#chap_420473">1) Qu'est-ce que le C++ ?</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/405105.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_420468">Les programmes</a></li>
								
									<li><a href="#ss_part_420469">Les langages de programmation</a></li>
								
									<li><a href="#ss_part_420421">Le C++ face aux autres langages</a></li>
								
									<li><a href="#ss_part_420426">La petite histoire du C++</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_420447">2) Les logiciels nécessaires pour programmer</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/393131.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_420438">Les outils nécessaires au programmeur</a></li>
								
									<li><a href="#ss_part_420425">Code::Blocks (Windows, Mac OS, Linux)</a></li>
								
									<li><a href="#ss_part_420437">Visual C++ (Windows seulement)</a></li>
								
									<li><a href="#ss_part_420451">Xcode (Mac OS seulement)</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_420424">3) Votre premier programme</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/403591.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_420456">Le monde merveilleux de la console</a></li>
								
									<li><a href="#ss_part_420430">Création et lancement d'un premier projet</a></li>
								
									<li><a href="#ss_part_420435">Explications du premier code source</a></li>
								
									<li><a href="#ss_part_420462">Commentez vos programmes !</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_420457">4) Utiliser la mémoire</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/403539.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_420449">Qu'est-ce qu'une variable ?</a></li>
								
									<li><a href="#ss_part_420418">Déclarer une variable</a></li>
								
									<li><a href="./cpp_files/">Déclarer sans initialiser</a></li>
								
									<li><a href="#ss_part_420446">Afficher la valeur d'une variable</a></li>
								
									<li><a href="#ss_part_420465">Les références</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_420467">5) Une vraie calculatrice</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/403550.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_420429">Demander des informations à l'utilisateur</a></li>
								
									<li><a href="#ss_part_420442">Modifier des variables</a></li>
								
									<li><a href="#ss_part_420428">Les constantes</a></li>
								
									<li><a href="#ss_part_420461">Un premier exercice</a></li>
								
									<li><a href="#ss_part_420470">Les raccourcis</a></li>
								
									<li><a href="#ss_part_420436">Encore plus de maths !</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_420444">6) Les structures de contrôle</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/402845.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_420454">Les conditions</a></li>
								
									<li><a href="#ss_part_420463">Booléens et combinaisons de conditions</a></li>
								
									<li><a href="#ss_part_420472">Les boucles</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_420464">7) Découper son programme en fonctions</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/402738.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_420423">Créer et utiliser une fonction</a></li>
								
									<li><a href="#ss_part_420460">Quelques exemples</a></li>
								
									<li><a href="#ss_part_420417">Passage par valeur et passage par référence</a></li>
								
									<li><a href="#ss_part_420427">Utiliser plusieurs fichiers</a></li>
								
									<li><a href="#ss_part_420453">Des valeurs par défaut pour les arguments</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_420445">8) Les tableaux</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/401910.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_420432">Les tableaux statiques</a></li>
								
									<li><a href="#ss_part_420433">Les tableaux dynamiques</a></li>
								
									<li><a href="#ss_part_420419">Les tableaux multi-dimensionnels</a></li>
								
									<li><a href="#ss_part_420431">Les strings comme tableaux</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_420466">9) Lire et écrire des fichiers</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/411412.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_420443">Écrire dans un fichier</a></li>
								
									<li><a href="#ss_part_420434">Lire un fichier</a></li>
								
									<li><a href="#ss_part_420441">Quelques astuces</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_420459">10) [TP] Le mot mystère</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/408486.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_420474">Préparatifs et conseils</a></li>
								
									<li><a href="#ss_part_420422">Correction</a></li>
								
									<li><a href="#ss_part_420458">Aller plus loin</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_420420">11) Les pointeurs</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/412840.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_420448">Une question d'adresse</a></li>
								
									<li><a href="#ss_part_420471">Les pointeurs</a></li>
								
									<li><a href="#ss_part_420439">L'allocation dynamique</a></li>
								
									<li><a href="#ss_part_420455">Quand utiliser des pointeurs</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
				</ul>
				<div>
					<br>
					
				</div>
			
		</li>
		
		<li>
		<hr class="separateur_parties">
		<h2 id="part_11409">Partie 2 : [Théorie] La Programmation Orientée Objet</h2>
		<div>
			Maintenant que vous connaissez les bases de la programmation C++, attaquons le coeur du sujet : la programmation orientée objet (POO) !<br>
Soyez attentifs car les choses deviennent un peu plus complexes à partir d'ici. Prenez bien le temps de tout lire, car vous ne pouvez pas faire de C++ sans bien connaître la POO. <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
			
				<ul class="liste_chapitres_btut">
				
					<li>
						<br><br><a href="#chap_11159">1) Introduction : la vérité sur les strings enfin dévoilée</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11152.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11158">Des objets... pour quoi faire ?</a></li>
								
									<li><a href="#ss_part_420450">L'horrible secret du type string</a></li>
								
									<li><a href="#ss_part_11157">Créer et utiliser des objets string</a></li>
								
									<li><a href="#ss_part_11156">Opérations sur les string</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11131">2) Premier programme C++ avec cout et cin</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11122.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11130">Configurer l'IDE pour le C++</a></li>
								
									<li><a href="#ss_part_11129">Analyse du premier code source C++</a></li>
								
									<li><a href="#ss_part_11128">Le flux de sortie cout</a></li>
								
									<li><a href="#ss_part_11127">Le flux d'entrée cin</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11141">3) Nouveautés pour les variables</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11132.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11140">Le type bool</a></li>
								
									<li><a href="#ss_part_11139">Les déclarations de variables</a></li>
								
									<li><a href="#ss_part_11138">Les allocations dynamiques</a></li>
								
									<li><a href="#ss_part_11143">Le typedef automatique</a></li>
								
									<li><a href="#ss_part_11142">Les références</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11151">4) Nouveautés pour les fonctions</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11144.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11150">Des valeurs par défaut pour les paramètres</a></li>
								
									<li><a href="#ss_part_11149">La surcharge des fonctions</a></li>
								
									<li><a href="#ss_part_11148">Les fonctions inline</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11167">5) Les classes (Partie 1/2)</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11160.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11166">Créer une classe</a></li>
								
									<li><a href="#ss_part_11165">Droits d'accès et encapsulation</a></li>
								
									<li><a href="#ss_part_11164">Séparer prototypes et définitions</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11177">6) Les classes (Partie 2/2)</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11168.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11176">Constructeur et destructeur</a></li>
								
									<li><a href="#ss_part_11175">Associer des classes entre elles</a></li>
								
									<li><a href="#ss_part_11174">Action !</a></li>
								
									<li><a href="#ss_part_11173">Méga schéma résumé</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11187">7) Classes et pointeurs</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11178.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11186">Pointeur d'une classe vers une autre classe</a></li>
								
									<li><a href="#ss_part_11185">Gestion de l'allocation dynamique</a></li>
								
									<li><a href="#ss_part_11184">Le constructeur de copie</a></li>
								
									<li><a href="#ss_part_11183">Le pointeur this</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11199">8) La surcharge d'opérateurs</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11188.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11198">Petits préparatifs</a></li>
								
									<li><a href="#ss_part_11197">Les opérateurs arithmétiques (+, -, *, /, %)</a></li>
								
									<li><a href="#ss_part_11196">Les opérateurs de comparaison (==, &gt;, &lt;, ...)</a></li>
								
									<li><a href="#ss_part_11195">L'opérateur d'affectation (=)</a></li>
								
									<li><a href="#ss_part_11194">Les opérateurs de flux (&lt;&lt;, &gt;&gt;)</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11213">9) TP : La POO en pratique avec ZString</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11200.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11212">Notre objectif</a></li>
								
									<li><a href="#ss_part_11211">Quelques préparatifs</a></li>
								
									<li><a href="#ss_part_11210">Constructeurs et destructeur</a></li>
								
									<li><a href="#ss_part_11209">La surcharge des opérateurs</a></li>
								
									<li><a href="#ss_part_11208">Récapitulatif</a></li>
								
									<li><a href="#ss_part_11207">Aller (encore) plus loin</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11223">10) L'héritage</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11214.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11222">Exemple d'héritage simple</a></li>
								
									<li><a href="#ss_part_11221">La dérivation de type</a></li>
								
									<li><a href="#ss_part_11220">Héritage et constructeurs</a></li>
								
									<li><a href="#ss_part_11219">La portée protected</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11231">11) Eléments statiques et constants</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11224.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11230">Les méthodes constantes</a></li>
								
									<li><a href="#ss_part_11229">Les méthodes statiques</a></li>
								
									<li><a href="#ss_part_11228">Les attributs statiques</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
				</ul>
				<div>
					<br>
					
				</div>
			
		</li>
		
		<li>
		<hr class="separateur_parties">
		<h2 id="part_11407">Partie 3 : [Pratique] Créez vos propres fenêtres avec Qt</h2>
		<div>
			<div class="flot_droite"><img src="./cpp_files/86863.png" alt="Image utilisateur"></div>Vous l'avez compris en lisant la partie I : la POO, ce n'est pas évident à maîtriser au début, mais ça apporte un nombre important d'avantages : le code est plus facile à réutiliser, à améliorer, et... quand on utilise une bibliothèque là c'est carrément le pied <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Le but de la partie II est entièrement de pratiquer, pratiquer, pratiquer. Vous n'apprendrez pas de nouvelles notions théoriques ici, mais par contre vous allez apprendre à maîtriser le C++ par la pratique, et ça c'est important.<br>
<br>
Qt est une bibliothèque C++ très complète qui vous permet notamment de créer vos propres fenêtres, que vous soyez sous Windows, Linux ou Mac OS. Tout ce que nous allons faire sera très concret : ouverture de fenêtres, ajout de boutons, création de menus, de listes déroulantes... bref que des choses motivantes ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies">
		</div>
			
				<ul class="liste_chapitres_btut">
				
					<li>
						<br><br><a href="#chap_11240">1) Introduction à Qt</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11233.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11239">Dis papa, comment on fait des fenêtres ?</a></li>
								
									<li><a href="#ss_part_11238">Présentation de Qt</a></li>
								
									<li><a href="#ss_part_11237">Installation de Qt</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11250">2) Compiler votre première fenêtre Qt</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11241.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11249">Codons notre première fenêtre !</a></li>
								
									<li><a href="#ss_part_11248">Compiler un projet Qt : la théorie</a></li>
								
									<li><a href="#ss_part_11247">Compiler un projet Qt : la pratique</a></li>
								
									<li><a href="#ss_part_11246">Exécuter le programme</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11260">3) Personnaliser les widgets</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11251.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11259">Modifier les propriétés d'un widget</a></li>
								
									<li><a href="#ss_part_11258">Qt et l'héritage</a></li>
								
									<li><a href="#ss_part_11257">Un widget peut en contenir un autre</a></li>
								
									<li><a href="#ss_part_11256">Hériter un widget</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11268">4) Les signaux et les slots</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11261.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11267">Le principe des signaux et slots</a></li>
								
									<li><a href="#ss_part_11266">Connexion d'un signal à un slot simple</a></li>
								
									<li><a href="#ss_part_11270">Des paramètres dans les signaux et slots</a></li>
								
									<li><a href="#ss_part_11269">Créer ses propres signaux et slots</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11282">5) Les boîtes de dialogue usuelles</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11271.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11281">Afficher un message</a></li>
								
									<li><a href="#ss_part_11280">Saisir une information</a></li>
								
									<li><a href="#ss_part_11279">Sélectionner une police</a></li>
								
									<li><a href="#ss_part_11278">Sélectionner une couleur</a></li>
								
									<li><a href="#ss_part_11277">Sélection d'un fichier ou d'un dossier</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11290">6) Apprendre à lire la documentation de Qt</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11283.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11289">Où trouver la doc ?</a></li>
								
									<li><a href="#ss_part_11288">Les différentes sections de la doc</a></li>
								
									<li><a href="#ss_part_11287">Comprendre la documentation d'une classe</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11302">7) Positionner ses widgets avec les layouts</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11291.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11301">Le positionnement absolu et ses défauts</a></li>
								
									<li><a href="#ss_part_11300">L'architecture des classes de layout</a></li>
								
									<li><a href="#ss_part_11299">Les layouts horizontaux et verticaux</a></li>
								
									<li><a href="#ss_part_11298">Le layout de grille</a></li>
								
									<li><a href="#ss_part_11304">Le layout de formulaire</a></li>
								
									<li><a href="#ss_part_11303">Combiner les layouts</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11316">8) Les principaux widgets</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11305.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11315">Les fenêtres</a></li>
								
									<li><a href="#ss_part_11314">Les boutons</a></li>
								
									<li><a href="#ss_part_11313">Les afficheurs</a></li>
								
									<li><a href="#ss_part_11312">Les champs</a></li>
								
									<li><a href="#ss_part_11311">Les conteneurs</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11324">9) TP : ZeroClassGenerator</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11317.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11323">Notre objectif</a></li>
								
									<li><a href="#ss_part_11322">Correction</a></li>
								
									<li><a href="#ss_part_11321">Des idées d'améliorations</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11334">10) La fenêtre principale</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11325.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11333">Présentation de QMainWindow</a></li>
								
									<li><a href="#ss_part_11332">La zone centrale (SDI et MDI)</a></li>
								
									<li><a href="#ss_part_11338">Les menus</a></li>
								
									<li><a href="#ss_part_11337">La barre d'outils</a></li>
								
									<li><a href="#ss_part_11336">Les docks</a></li>
								
									<li><a href="#ss_part_11335">La barre d'état</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11350">11) Traduire son programme avec Qt Linguist</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11339.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11349">Les étapes de la traduction</a></li>
								
									<li><a href="#ss_part_11348">Préparer son code à une traduction</a></li>
								
									<li><a href="#ss_part_11347">Créer les fichiers de traduction .ts</a></li>
								
									<li><a href="#ss_part_11346">Traduire l'application sous Qt Linguist</a></li>
								
									<li><a href="#ss_part_11345">Lancer l'application traduite</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11360">12) Modéliser ses fenêtres avec Qt Designer</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11351.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11359">Présentation de Qt Designer</a></li>
								
									<li><a href="#ss_part_11358">Placer des widgets sur la fenêtre</a></li>
								
									<li><a href="#ss_part_11357">Configurer les signaux et les slots</a></li>
								
									<li><a href="#ss_part_11356">Utiliser la fenêtre dans votre application</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11372">13) TP : zNavigo, le navigateur web des Zéros !</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/32238.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11371">Les navigateurs et les moteurs web</a></li>
								
									<li><a href="#ss_part_11370">Organisation du projet</a></li>
								
									<li><a href="#ss_part_11369">Génération de la fenêtre principale</a></li>
								
									<li><a href="#ss_part_11368">Les slots personnalisés</a></li>
								
									<li><a href="#ss_part_11367">Conclusion et améliorations possibles</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11384">14) L'architecture MVC avec les widgets complexes</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11373.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11383">Présentation de l'architecture MVC</a></li>
								
									<li><a href="#ss_part_11382">L'architecture simplifiée modèle/vue de Qt</a></li>
								
									<li><a href="#ss_part_11381">Utilisation d'un modèle simple</a></li>
								
									<li><a href="#ss_part_11380">Utilisation de modèles personnalisables</a></li>
								
									<li><a href="#ss_part_11379">Gestion des sélections</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
					<li>
						<br><br><a href="#chap_11396">15) Communiquer en réseau avec son programme</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11385.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11395">Comment communique-t-on en réseau ?</a></li>
								
									<li><a href="#ss_part_11394">L'architecture du projet de Chat avec Qt</a></li>
								
									<li><a href="#ss_part_11393">Réalisation du serveur</a></li>
								
									<li><a href="#ss_part_11392">Réalisation du client</a></li>
								
									<li><a href="#ss_part_11391">Test du Chat et améliorations</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
				</ul>
				<div>
					<br>
					
				</div>
			
		</li>
		
		<li>
		<hr class="separateur_parties">
		<h2 id="part_11408">Partie 4 : Annexes</h2>
		<div>
			Besoin d'aller encore plus loin ?<br>
Lisez donc les annexes !
		</div>
			
				<ul class="liste_chapitres_btut">
				
					<li>
						<br><br><a href="#chap_11405">1) Ce que vous pouvez encore apprendre</a>
						<div class="icone_chap">
							
								<img src="./cpp_files/11398.png" alt="Icône du chapitre" class="icone_chapitre">
							
						</div>
						<div class="droite_chapitre">
						<ul class="liste_btuto_chap">
							
									<li><a href="#ss_part_11404">... sur le langage C++</a></li>
								
									<li><a href="#ss_part_11403">... sur la bibliothèque standard</a></li>
								
									<li><a href="#ss_part_11402">... sur la bibliothèque Qt</a></li>
								
						</ul>
						</div>
						<div class="clearer"> </div>
					</li>
				
				</ul>
				<div>
					<br>
					
				</div>
			
		</li>
		
		</ul>

<hr>
<h2>Partie 1 : [Théorie] Découverte de la programmation en C++</h2>
<div>
Vous souhaitez découvrir le C++ mais vous n'avez jamais fait de programmation avant ? Commencez par là !<br>
Vous découvrirez comment fonctionne la programmation, quels logiciels il faut installer et quelles sont les techniques de base à connaître.
</div>
	
	<hr>
	<h1 id="chap_420473">Qu'est-ce que le C++ ?</h1>
	<div id="chap_intro">
	L'informatique vous passionne et vous aimeriez apprendre à programmer ? Et pourquoi pas après tout ! La programmation peut sembler difficile au premier abord, mais c'est un univers beaucoup plus accessible qu'il n'y paraît !<br>
<br>
Vous vous demandez sûrement par où commencer, si le C++ est fait pour vous, s'il n'est pas préférable de démarrer avec un autre langage... Vous vous demandez si vous allez pouvoir faire tout ce que vous voulez, quelles sont les forces et les faiblesses du C++...<br>
<br>
Dans ce chapitre, je vais tenter de répondre à toutes ces questions. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
N'oubliez pas : c'est un <strong>cours pour débutants</strong>. <span class="souligne">Aucune connaissance préalable n'est requise.</span> Même si vous n'avez jamais programmé de votre vie, tout ce que vous avez besoin de faire c'est de lire ce cours progressivement, sans brûler les étapes et en pratiquant régulièrement en même temps que moi !
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420468">Les programmes</h2>
		<div class="ss_part_texte">
		Les programmes sont à la base de l'informatique. Ce sont eux qui vous permettent d'exécuter des actions sur votre ordinateur.<br>
<br>
Prenons par exemple cette capture d'écran de mon ordinateur :<br>
<br>
<div class="centre"><a href="http://uploads.siteduzero.com/files/280001_281000/280227.png"><img src="./cpp_files/280227.png" alt="Des programmes"></a></div><br>
<br>
On y distingue 3 fenêtres correspondant à 3 programmes différents. Du premier plan à l'arrière-plan :<br>
<ul>	
<li>Le navigateur web Google Chrome, qui permet de consulter des sites web.</li>	
<li>L'explorateur de fichiers, qui permet de gérer les fichiers sur son ordinateur.</li>	
<li>Le traitement de texte Microsoft Word, qui permet de rédiger lettres et documents.</li>
</ul><br>
Comme vous le voyez, chacun de ces programmes est conçu dans un but précis. On pourrait aussi citer les jeux, par exemple, qui sont prévus pour s'amuser : Starcraft II, World of Warcraft, Worms, Team Fortress 2, etc. Chacun d'eux correspond à un programme différent.<br>
<br>
<div class="rmq information">Tous les programmes ne sont pas forcément visibles. C'est le cas de certains programmes qui surveillent les mises à jour disponibles pour votre ordinateur, ou, dans une moindre mesure, de votre antivirus. Ils tournent tous en "tâche de fond", ils n'affichent pas toujours une fenêtre mais ça ne les empêche pas d'être actifs et de travailler !</div><br>
<br>
<div class="centre"><img src="./cpp_files/280229.jpg" alt="Starcraft 2"><br>
<span class="italique">Les jeux vidéo (ici Starcraft II) sont le plus souvent développés en C++</span><br>
</div><br>
<br>
<div class="rmq question">Moi aussi je veux créer des programmes ! Comment dois-je m'y prendre ?</div><br>
<br>
Tout d'abord, commencez par mesurer vos ambitions. Un jeu tel que Starcraft II nécessite des dizaines de développeurs à plein temps pendant plusieurs années. Ne vous mettez donc pas en tête des objectifs trop difficiles à atteindre. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
En revanche, si vous suivez ce cours, vous aurez de solides bases pour développer des programmes. Nous réaliserons même notre propre navigateur web (simplifié) comme Mozilla Firefox et Google Chrome au cours d'un TP ! Vous saurez créer des programmes constitués de fenêtres. Avec un peu de travail supplémentaire, vous pourrez même créer des jeux 2D et 3D si vous le désirez. Bref, avec le temps et à force de persévérance, vous pourrez aller loin. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Alors oui, je n'oublie pas votre question : vous vous demandez comment réaliser des programmes. La programmation est un univers très riche. On utilise des <strong>langages de programmation</strong> qui nous permettent d'expliquer à l'ordinateur ce qu'il doit faire. Voyons voir plus en détail ce que sont les langages de programmation.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420469">Les langages de programmation</h2>
		<div class="ss_part_texte">
		Votre ordinateur est une machine étonnante et complexe. A la base, il ne comprend qu'un langage très simple constitué de 0 et de 1. Ainsi, un message tel que celui-ci :<br>
<br>
<span class="courrier"><span class="gros">1010010010100011010101001010111010100011010010</span></span><br>
<br>
... peut signifier quelque chose comme "Affiche une fenêtre à l'écran".<br>
<br>
<div class="rmq question">Ouah ! <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> Mais c'est super compliqué !<br>
On va être obligé d'apprendre ce langage ?</div><br>
<br>
Heureusement non. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
S'il fallait écrire dans ce langage (qu'on appelle<span class="italique"> langage binaire</span>), il ne faudrait pas des années pour concevoir un jeu comme Starcraft II mais plutôt des millénaires (sans rire !).<br>
<br>
Pour se simplifier la vie, les informaticiens ont créé des langages intermédiaires, plus simples que le binaire. Il existe aujourd'hui des centaines de langages de programmation. Vous pouvez retrouver une <a href="http://fr.wikipedia.org/wiki/Liste_des_langages_de_programmation">liste des langages de programmation sur Wikipédia</a> pour vous faire une idée. Chacun de ces langages a des spécificités, nous y reviendrons.<br>
<br>
Tous les langages de programmation ont un seul but : vous permettre de parler à l'ordinateur plus simplement qu'en binaire. Voici comment ça fonctionne :<br>
<br>
<ol class="liste_1">	
<li>Vous écrivez des instructions pour l'ordinateur dans un langage de programmation (par exemple le C++ <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ).</li>	
<li>Les instructions sont traduites en binaire grâce à un programme de "traduction".</li>	
<li>L'ordinateur peut alors lire le binaire et faire ce que vous avez demandé !</li></ol><br>
Résumons ces étapes dans un schéma :<br>
<br>
<div class="centre"><img src="./cpp_files/280235.png" alt="Compilation"></div><br>
<br>
Le fameux "programme de traduction" s'appelle en réalité le <strong>compilateur</strong>. C'est un outil indispensable. Il vous permet de transformer votre code, écrit dans un langage de programmation, en un vrai programme exécutable.<br>
<br>
Reprenons le schéma précédent et utilisons un vrai vocabulaire d'informaticien. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<div class="centre"><img src="./cpp_files/280236.png" alt="Compilation détaillée"></div><br>
<br>
Voilà ce que je vous demande de retenir pour le moment, ce n'est pas bien compliqué mais c'est la base à connaître absolument !<br>
<br>
<div class="rmq question">Mais justement, comment dois-je faire pour choisir le langage de programmation que je vais utiliser ? Tu as toi-même dit qu'il en existait <a href="http://fr.wikipedia.org/wiki/Liste_des_langages_de_programmation">des centaines</a> !<br>
Lequel est le meilleur ? Est-ce que le C++ est un bon choix ?</div><br>
<br>
Les programmeurs (aussi appelés <span class="italique">développeurs</span>) connaissent en général plusieurs langages de programmation et non pas un seul. On se concentre rarement sur un seul langage de programmation.<br>
<br>
Bien entendu, il faut bien commencer par l'un d'eux. La bonne nouvelle, c'est que vous pouvez commencer par celui que vous voulez ! Les principes des langages sont souvent les mêmes, vous ne serez pas trop dépaysés d'un langage à l'autre.<br>
<br>
Néanmoins, voyons voir plus en détail ce qui caractérise le C++ par rapport aux autres langages de programmation... Ben oui, c'est un cours de C++ ne l'oubliez pas ! <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Que vaut le C++ par rapport aux autres langages ?
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420421">Le C++ face aux autres langages</h2>
		<div class="ss_part_texte">
		<h3>Le C++ : langage de haut ou de bas niveau ?</h3><br>
<br>
Parmi les centaines de langages de programmation qui existent, certains d'entre eux sont plus populaires que d'autres. Sans aucun doute, le C++ est un langage <strong>très populaire</strong>. Des sites comme <a href="http://langpop.com/">langpop.com</a> tiennent à jour un classement des langages les plus couramment utilisés si cette information vous intéresse. Comme vous pourrez le constater, le C, le Java et le C++ tiennent régulièrement le haut du classement.<br>
<br>
La question est : faut-il choisir un langage parce qu'il est populaire ? Il existe des langages très intéressants mais peu utilisés. Le souci avec les langages peu utilisés, c'est qu'il est difficile de trouver des gens pour vous aider et vous conseiller quand vous avez un problème. Voilà entre autres pourquoi le C++ est un bon choix pour qui veut débuter : il y a suffisamment de gens qui développent en C++ pour que vous n'ayez pas à craindre de vous retrouver tout seuls !<br>
<br>
Bien entendu, il y a d'autres critères que la popularité. Le plus important à mes yeux est le niveau du langage. Il existe des langages de <strong>haut niveau</strong> et d'autres de plus <strong>bas niveau</strong>.<br>
<br>
<div class="rmq question">Qu'est-ce qu'un langage de haut niveau ? <img src="./cpp_files/huh.png" alt=":o" class="smilies"></div><br>
<br>
C'est un langage assez éloigné du binaire (et donc du fonctionnement de la machine), qui vous permet généralement de développer de façon plus souple et rapide.<br>
Par opposition, un langage de bas niveau est plus proche du fonctionnement de la machine : il demande en général un peu plus d'efforts mais vous donne aussi plus de contrôle sur ce que vous faites. C'est à double tranchant.<br>
<br>
Le C++ ? On considère qu'il fait partie de la seconde catégorie : c'est un langage dit "de bas niveau". Mais que cela ne vous fasse pas peur ! Si programmer en C++ peut s'avérer assez complexe, vous aurez entre les mains un langage très puissant et particulièrement rapide. En effet, si l'immense majorité des jeux sont développés en C++, c'est parce qu'il s'agit du langage qui allie le mieux puissance et rapidité. Voilà ce qui en fait un langage incontournable.<br>
<br>
Le schéma ci-dessous représente quelques langages de programmation, classés par "niveau" :<br>
<br>
<div class="centre"><img src="./cpp_files/273556.png" alt="Image utilisateur"></div><br>
<br>
<br>
Vous constaterez qu'il est en fait possible de programmer en binaire grâce à un outil très basique appelé l'assembleur. Etant donné qu'il faut déployer des efforts surhumains pour coder ne serait-ce qu'une calculatrice, on préfère le plus souvent utiliser un langage de programmation. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="rmq information">La notion de "niveau" est relative en programmation. Globalement, on peut dire que le C++ est "bas niveau" par rapport au Python, mais il est plus "haut niveau" que l'assembleur. Tout dépend de quel point de vue on se place. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
<h3>Résumé des forces du C++</h3><br>
<br>
<ul>	
<li>Il est <strong>très répandu</strong>. Comme nous l'avons vu, il fait partie des langages de programmation les plus utilisés sur la planète. On trouve donc beaucoup de documentation sur Internet et on peut facilement avoir de l'aide sur les forums. Il paraît même qu'il y a des gens sympas qui écrivent des tutos pour débutants dessus. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"></li>	
<li>Il est <strong>rapide</strong>, très rapide même, ce qui en fait un langage de choix pour les applications critiques qui ont besoin de performances. C'est en particulier le cas des jeux vidéo, mais aussi des outils financiers ou de certains programmes militaires qui doivent fonctionner en temps réel.</li>	
<li>Il existe de <strong>nombreuses bibliothèques</strong> pour le C++. Les bibliothèques sont des extensions pour le langage, un peu comme des plug-ins. De base, le C++ ne sait pas faire grand chose, mais en le combinant avec de bonnes bibliothèques on peut créer des programmes 3D, réseau, audio, fenêtrés, etc.</li>	
<li>Il est <strong>multi-paradigme</strong> (outch !). Ce mot barbare signifie qu'on peut programmer de plusieurs façons différentes en C++. Vous êtes encore un peu trop débutants pour que je vous présente tout de suite ces techniques de programmation, mais l'une des plus célèbres est la Programmation Orientée Objet (POO). C'est une technique qui permet de simplifier l'organisation du code dans nos programmes et de rendre facilement certains morceaux de codes réutilisables. La partie II de ce cours sera toute entière dédiée à la POO !</li>
</ul><br>
<br>
<h3>Petit aperçu du C++</h3><br>
<br>
Pour vous donner une idée, voici un programme très simple affichant le message "Hello world!" à l'écran. Ce sera l'un des premiers codes source que nous étudierons dans les chapitres suivants.<br>
<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
 
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>

		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420426">La petite histoire du C++</h2>
		<div class="ss_part_texte">
		La programmation a déjà une longue histoire derrière elle. Au début, il n'existait même pas le clavier pour programmer ! On utilisait des cartes perforées comme celle ci-dessous pour donner des instructions à l'ordinateur :<br>
<br>
<div class="centre"><img src="./cpp_files/280249.png" alt="Carte perforée"></div><br>
<br>
Autant vous dire que c'était long et fastidieux !<br>
<br>
<h3>De l'Algol au C++</h3><br>
<br>
Les choses ont ensuite évolué, heureusement. Le clavier et les premiers langages de programmation sont apparus :<br>
<br>
<ol class="liste_1">
<li>1958 : il y a longtemps, à l'époque où les ordinateurs pesaient des tonnes et faisaient la taille de votre maison, on a commencé à inventer un langage de programmation appelé <strong>l'Algol</strong>.</li>
<li>1960-1970 : ensuite, les choses évoluant, on a créé un nouveau langage appelé le <strong>CPL</strong>, qui évolua lui-même en <strong>BCPL</strong>, puis qui pris le nom de <strong>langage B</strong> (vous n'êtes pas obligés de retenir tout ça par coeur hein <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).</li>
<li>1970 : puis, un beau jour, on en est arrivé à créer encore un autre langage qu'on a appelé... le <strong>langage C</strong>. Ce langage, s'il a subi quelques modifications, reste encore un des langages les plus utilisés aujourd'hui.</li>
<li>1983 : un peu plus tard, on a proposé d'ajouter des choses au langage C, de le faire évoluer. Ce nouveau langage, que l'on a appelé "C++", est entièrement basé sur le C. <strong>Le langage C++</strong> n'est en fait rien d'autre que le langage C avec plusieurs nouveautés. Il s'agit de concepts de programmation poussés comme la programmation orientée objet, le polymorphisme, les flux... Bref, des choses bien compliquées pour nous pour le moment, mais dont nous aurons l'occasion de reparler par la suite !</li></ol><br>
<div class="rmq question">Une minute... Si le C++ est en fait une amélioration du C, pourquoi y a-t-il encore tant de gens qui développent en C ?</div><br>
<br>
Tout le monde n'a pas besoin des améliorations apportées par le langage C++. Le C est à lui seul suffisamment puissant pour être à la base des systèmes d'exploitation comme Linux, Mac OS X et Windows.<br>
Ceux qui n'ont pas besoin des améliorations (mais aussi de la complexité !) apportées par le langage C++ se contentent donc très bien du langage C, et ce malgré son âge. Comme quoi, un langage peut être vieux et rester d'actualité. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<h3>Le concepteur</h3><br>
<div class="flot_gauche"><a href="http://uploads.siteduzero.com/files/280001_281000/280255.jpg"><img src="./cpp_files/280255.jpg" alt="Bjarne Stroustrup"></a></div><br>
C'est Bjarne Stroustrup, un informaticien originaire du Danemark, qui a conçu le langage C++. Insatisfait des possibilités offertes par le C, il a créé en 1983 le C++ en y ajoutant les possibilités qui manquaient selon lui.<br>
<br>
<strong>Bjarne Stroustrup</strong> est aujourd'hui professeur d'informatique à l'université du Texas, aux Etats-Unis. Il s'agit d'une importante figure de l'univers informatique qu'il faut connaître, au moins de nom (du moins si vous arrivez à retenir le sien <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).<br>
<br>
De nombreux langages de programmation se sont par la suite inspirés du C++. C'est notamment le cas du langage Java.<br>
<br>
Le langage C++, bien que relativement ancien, continue à être amélioré. Une nouvelle version, appelée <span class="courrier">C++1x</span>, est d'ailleurs en cours de préparation. Il ne s'agit pas d'un nouveau langage mais d'une mise à jour du C++. Les nouveautés qu'elle apporte sont cependant trop complexes pour nous, nous n'en parlerons donc pas ici !
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Cette petite introduction avait pour but de vous faire découvrir les langages de programmation et de vous expliquer dans les grandes lignes comment tout ceci fonctionne.<br>
<br>
Résumons :<br>
<br>
<ul>
<li>Les programmes sont à la base de l'informatique. Ils demandent à votre ordinateur d'exécuter des actions.</li>
<li>Pour écrire des programmes, on utilise un langage de programmation. Il en existe des centaines.</li>
<li>Le C++ est un des langages de programmation les plus utilisés dans le monde.</li>
<li>Le C++ est un descendant du C. Il le complète en rajoutant un certain nombre de possibilités.</li>	
<li>Le C++ est un langage de bas niveau : il est plus proche du langage machine (le binaire) et peut parfois être assez complexe.</li>	
<li>Le C++ est un langage extrêmement rapide, ce qui en fait le langage de prédilection de la plupart des jeux vidéo avides de performances.</li>
</ul><br>
<br>
Nous n'avons encore rien manipulé sur votre ordinateur, mais nous commencerons dès le prochain chapitre en installant les logiciels nécessaires pour programmer ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_420447">Les logiciels nécessaires pour programmer</h1>
	<div id="chap_intro">
	Maintenant que l'on en sait un peu plus sur le C++, si on commençait à pratiquer ?<br>
<br>
Ah mais oui, c'est vrai : vous ne pouvez pas programmer tant que vous n'avez pas installé les bons logiciels ! En effet, il faut installer certains logiciels spécifiques pour programmer en C++. Dans ce chapitre, nous allons les installer et les découvrir ensemble.<br>
<br>
Un peu de patience : dès le prochain chapitre nous pourrons enfin commencer à véritablement programmer ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies">
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420438">Les outils nécessaires au programmeur</h2>
		<div class="ss_part_texte">
		Alors à votre avis, de quels outils un programmeur a-t-il besoin ?<br>
Si vous avez attentivement suivi le chapitre précédent, vous devez en connaître au moins un !<br>
<br>
Vous voyez de quoi je parle ?<br>
?<br>
?<br>
?<br>
Vraiment pas ? <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Eh oui, il s'agit du <strong>compilateur</strong>, ce fameux programme qui permet de traduire votre langage C++ en langage binaire !<br>
<br>
Comme je vous l'avais un peu déjà dit dans le premier chapitre, il existe plusieurs compilateurs pour le langage C++. Nous allons voir que le choix du compilateur ne sera pas très compliqué dans notre cas.<br>
<br>
Bon, de quoi d'autre a-t-on besoin ?<br>
Je ne vais pas vous laisser deviner plus longtemps. Voici le strict minimum pour un programmeur :<br>
<br>
<ul>
<li><strong>Un éditeur de texte</strong> pour écrire le code source du programme en C++. En théorie un logiciel comme le Bloc-Notes sous Windows, ou "<span class="italique">vi</span>" sous Linux fait l'affaire. L'idéal, c'est d'avoir un éditeur de texte intelligent qui colore tout seul le code, ce qui vous permet de vous repérer dedans bien plus facilement. Voilà pourquoi aucun programmeur sain d'esprit n'utilise Bloc-Notes. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></li>
<li><strong>Un compilateur</strong> pour transformer ("compiler") votre source en binaire.</li>
<li><strong>Un débugger</strong> pour vous aider à traquer les erreurs dans votre programme (on n'a malheureusement pas encore inventé le "correcteur", un truc qui corrigerait tout seul nos erreurs <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies"> )</li>
</ul><br>
A priori, si vous êtes un casse-cou de l'extrême, vous pourriez vous passer de débugger. Mais bon, je sais pertinemment que dans moins de 5 minutes vous reviendrez en pleurnichant me demander où on peut trouver un débugger qui marche bien. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
A partir de maintenant on a 2 possibilités :<br>
<ul>
<li>Soit on récupère chacun de ces 3 programmes <strong>séparément</strong>. C'est la méthode la plus compliquée, mais elle fonctionne. Sous Linux en particulier, bon nombre de programmeurs préfèrent utiliser ces 3 programmes séparément. Je ne détaillerai pas cette méthode ici, je vais plutôt vous parler de la méthode simple.</li>
<li>Soit on utilise un programme "3-en-1" (comme les liquides vaisselle, oui oui) qui combine éditeur de texte, compilateur et débugger. Ces programmes "3-en-1" sont appelés <strong>IDE</strong> (ou en français "EDI" pour "Environnement de développement intégré").</li>
</ul><br>
Il existe plusieurs environnements de développement. Vous aurez peut-être un peu de mal à choisir celui qui vous plaît au début. Une chose est sûre en tout cas: <span class="souligne">vous pouvez faire n'importe quel type de programme, quel que soit l'IDE que vous choisissez</span>.<br>
<br>
<h3>Les projets</h3><br>
<br>
Quand vous réalisez un programme, on dit que vous travaillez sur un <strong>projet</strong>. Un projet est constitué de plusieurs fichiers de code source : des fichiers .cpp, .h, les images du programme, etc.<br>
<br>
Le rôle d'un IDE est de rassembler tous ces fichiers d'un projet au sein d'une même interface. Comme ça, vous avez accès à tous les éléments de votre programme à portée de clic.<br>
Voilà pourquoi, quand vous voudrez créer un nouveau programme, il faudra demander à l'IDE de vous préparer un "<span class="italique">nouveau projet</span>".<br>
<br>
<h3>Choisissez votre IDE</h3><br>
<br>
Il m'a semblé intéressant de vous montrer quelques IDE parmi les plus connus. Tous sont disponibles gratuitement. Personnellement, je navigue un peu entre tous ceux-là et j'utilise l'IDE qui me plaît selon l'humeur du jour. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<ul>
<li>Un des IDE que je préfère s'appelle <strong>Code::Blocks</strong>. Il est gratuit et fonctionne sur la plupart des systèmes d'exploitation. <span class="souligne">Je conseille d'utiliser celui-ci pour débuter</span> (et même pour la suite s'il vous plaît bien !).<br>
<span class="marron">Fonctionne sous Windows, Mac et Linux.</span></li>
<li>Le plus célèbre IDE sous Windows, c'est celui de Microsoft : <strong>Visual C++</strong>. Il existe à la base en version payante (chère !), mais heureusement il existe une version gratuite intitulée <strong>Visual C++ Express</strong> qui est vraiment très bien (il y a peu de différences avec la version payante). Il est très complet et possède un puissant module de correction des erreurs (débuggage).<br>
<span class="marron">Fonctionne sous Windows uniquement.</span></li>
<li>Sur Mac OS X, vous pouvez aussi utiliser XCode, généralement fourni sur le CD d'installation de Mac OS X. C'est un IDE très apprécié par tous ceux qui font de la programmation sur Mac.<br>
<span class="marron">Fonctionne sous Mac OS X uniquement.</span></li>
</ul><br>
<br>
<div class="rmq information">Note pour les utilisateurs de Linux : il existe de nombreux IDE sous Linux, mais les programmeurs expérimentés préfèrent parfois se passer d'IDE et compiler "à la main", ce qui est un peu plus difficile. Vous aurez le temps d'apprendre à faire cela plus tard. En ce qui nous concerne nous allons commencer par utiliser un IDE. Je vous conseille d'installer Code::Blocks si vous êtes sous Linux pour suivre mes explications.<br>
Vous pouvez aussi jeter un oeil du côté d'<a href="http://www.eclipse.org/downloads/moreinfo/c.php">Eclipse pour les développeurs C/C++</a>, un IDE très puissant qui ne sert pas qu'à programmer en Java contrairement à l'idée répandue !</div><br>
<br>
<div class="rmq question">Quel est le meilleur de tous ces IDE ?</div><br>
<br>
Tous ces IDE vous permettront de programmer et de suivre le reste de ce cours sans problème. Certains sont plus complets au niveau des options, d'autres un peu plus intuitifs à utiliser, mais dans tous les cas les programmes que vous créerez seront les mêmes quel que soit l'IDE que vous utilisez. Ce choix n'est donc pas si crucial qu'on pourrait le croire.<br>
<br>
Durant tout ce cours, j'utiliserai Code::Blocks. Si vous voulez avoir exactement les mêmes écrans que moi, surtout pour ne pas être perdu au début, je vous recommande donc de commencer par installer Code::Blocks.<br>

		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420425">Code::Blocks (Windows, Mac OS, Linux)</h2>
		<div class="ss_part_texte">
		Code::Blocks est un IDE libre et gratuit, disponible <strong>pour Windows, Mac et Linux</strong>.<br>
<br>
Code::Blocks n'est disponible pour le moment qu'en anglais. <span class="souligne">Ca ne devrait PAS vous repousser à l'utiliser</span>. Nous utiliserons très peu les menus en fait. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Sachez toutefois que quand vous programmerez vous serez de toute façon confronté bien souvent à des documentations en anglais. Voilà donc une raison de plus pour s'entraîner à utiliser cette langue.<br>
<br>
<h3>Télécharger Code::Blocks</h3><br>
<br>
Rendez-vous <a href="http://www.codeblocks.org/downloads/binaries">sur la page de téléchargements de Code::Blocks</a>.<br>
<br>
<ul>
<li>Si vous êtes sous Windows, repérez la section "Windows" un peu plus bas sur cette page. Téléchargez le logiciel <span class="souligne">en prenant le programme qui contient <span class="courrier">mingw </span>dans le nom</span> (ex. : <span class="courrier">codeblocks-10.05mingw-setup.exe</span>). L'autre version étant sans compilateur, vous auriez eu du mal à compiler vos programmes. <img src="./cpp_files/langue.png" alt=":p" class="smilies"></li>
<li>Si vous êtes sous Linux, le mieux est encore d'installer Code::Blocks via les dépôts (avec la commande <span class="code2 console">apt-get</span> sous Ubuntu par exemple).</li>
<li>Enfin, sous Mac, choisissez le fichier le plus récent de la liste (ex. : <span class="courrier">codeblocks-10.05-p2-mac.zip</span>).</li>
</ul><br>
<div class="rmq erreur">J'insiste là-dessus : si vous êtes sous Windows, <strong>téléchargez la version incluant <span class="code2">mingw</span></strong> dans le nom du programme d'installation. Si vous prenez la mauvaise version, vous ne pourrez pas compiler vos programmes par la suite !</div><br>
<div class="centre"><img src="./cpp_files/271893.png" alt="CodeBlocks avec mingw"></div><br>
<br>
<br>
L'installation est très simple et rapide. Laissez toutes les options par défaut et lancez le programme.<br>
<br>
<div class="centre"><img src="./cpp_files/285317.png" alt="Code Blocks"></div><br>
<br>
On distingue 4 grandes sections dans la fenêtre, numérotées sur l'image :<br>
<br>
<ol class="liste_1">
<li><strong>La barre d'outils</strong> : elle comprend de nombreux boutons, mais seuls quelques-uns d'entre eux nous seront régulièrement utiles. J'y reviendrai plus loin.</li>
<li><strong>La liste des fichiers du projet</strong> : c'est à gauche que s'affiche la liste de tous les fichiers source de votre programme. Notez que sur cette capture aucun projet n'a été créé donc on ne voit pas encore de fichiers à l'intérieur de la liste. Vous verrez cette section se remplir dans cinq minutes en lisant la suite du cours.</li>
<li><strong>La zone principale</strong> : c'est là que vous pourrez écrire votre code en langage C++ !</li>
<li><strong>La zone de notification</strong> : aussi appelée la "Zone de la mort", c'est ici que vous verrez les erreurs de compilation s'afficher si votre code comporte des erreurs. Cela arrive très régulièrement !</li></ol><br>
<br>
<div class="flot_droite"><img src="./cpp_files/285322.png" alt="Icônes de compilation"></div>Intéressons-nous maintenant à une section particulière de la barre d'outils. Vous trouverez les boutons suivants (dans l'ordre) "Compiler", "Exécuter", "Compiler &amp; Exécuter" et "Tout recompiler". Retenez-les, nous les utiliserons régulièrement.<br>
<br>
<ul>
<li><strong>Compiler </strong>: tous les fichiers source de votre projet sont envoyés au compilateur qui va se charger de créer un exécutable. S’il y a des erreurs (ce qui a de fortes chances d’arriver <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ), l’exécutable ne sera pas créé et on vous indiquera les erreurs en bas de Code::Blocks.</li>
<li><strong>Exécuter </strong>: cette icône lance juste le dernier exécutable que vous avez compilé. Cela vous permettra donc de tester votre programme et voir ainsi ce qu’il donne. Dans l’ordre, si vous avez bien suivi, on doit d’abord compiler, puis exécuter pour tester ce que ça donne. On peut aussi utiliser le 3ème bouton…</li>
<li><strong>Compiler &amp; Exécuter</strong> : pas besoin d’être un génie pour comprendre que c’est la combinaison des 2 boutons précédents. C’est d’ailleurs ce bouton que vous utiliserez le plus souvent. Notez que s’il y a des erreurs pendant la compilation (pendant la génération de l’exécutable), le programme ne sera pas exécuté. A la place, vous aurez droit à une beeelle liste d’erreurs à corriger. <img src="./cpp_files/langue.png" alt=":p" class="smilies"></li>
<li><strong>Tout reconstruire</strong> : quand vous faites " Compiler ", Code::Blocks ne recompile en fait que les fichiers que vous avez modifiés et pas les autres. Parfois, je dis bien parfois, vous aurez besoin de demander à Code::Blocks de vous recompiler tous les fichiers. On verra plus tard quand on a besoin de ce bouton, et vous verrez plus en détail le fonctionnement de la compilation dans un chapitre futur. Pour l’instant, on se contente de savoir le minimum nécessaire pour pas tout mélanger.<br>
Ce bouton ne nous sera donc pas utile de suite.</li>
</ul><br>
<br>
<div class="rmq information">Je vous conseille d’utiliser les raccourcis plutôt que de cliquer sur les boutons, parce que c’est quelque chose qu’on fait vraiment très très souvent. Retenez en particulier qu'il faut taper sur <span class="keyboard_shortcut">F9</span> pour faire " Compiler &amp; Exécuter ".</div><br>
<br>
<h3>Créer un nouveau projet</h3><br>
<br>
Pour créer un nouveau projet c'est très simple : allez dans le menu File / New / Project.<br>
Dans la fenêtre qui s'ouvre, choisissez "Console application" :<br>
<br>
<div class="centre"><img src="./cpp_files/115550.png" alt="Nouveau projet"></div><br>
<br>
<div class="rmq information">Comme vous pouvez le voir, Code::Blocks propose de réaliser pas mal de types de programmes différents qui utilisent des bibliothèques connues comme la SDL (2D), OpenGL (3D), Qt et wxWidgets (Fenêtres) etc etc... Pour l'instant, ces icônes servent plutôt à faire joli car <span class="souligne">les bibliothèques ne sont pas installées sur votre ordinateur</span>, vous ne pourrez donc pas les faire marcher.<br>
Nous nous intéresserons à ces autres types de programmes bien plus tard. En attendant il faudra vous contenter de "Console", car vous n'avez pas encore le niveau nécessaire pour créer les autres types de programmes.</div><br>
<br>
Cliquez sur "Go" pour créer le projet. Un assistant s'ouvre.<br>
<br>
Faites "Next", la première page ne servant à rien.<br>
On vous demande ensuite si vous allez faire du C ou du C++ : répondez C++.<br>
<br>
<div class="centre"><img src="./cpp_files/285318.png" alt="Nouveau projet C++"></div><br>
<br>
On vous demande le nom de votre projet, et dans quel dossier les fichiers source seront enregistrés :<br>
<br>
<div class="centre"><img src="./cpp_files/115552.png" alt="Nouveau projet"></div><br>
<br>
Enfin, la dernière page vous permet de choisir de quelle façon le programme doit être compilé. Vous pouvez laisser les options par défaut, ça n'aura pas d'incidence pour ce que nous allons faire dans l'immédiat (veillez à ce que "Debug" ou "Release" au moins soit coché).<br>
<br>
<div class="centre"><img src="./cpp_files/115553.png" alt="Nouveau projet"></div><br>
<br>
Cliquez sur "Finish", c'est bon !<br>
Code::Blocks vous créera un premier projet avec déjà un tout petit peu de code source dedans. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Dans le cadre de gauche "Projects", développez l'arborescence en cliquant sur le petit "+" pour afficher la liste des fichiers du projet. Vous devriez avoir au moins un main.cpp que vous pourrez ouvrir en double-cliquant dessus.<br>
<br>
<br>
Et voilà !
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420437">Visual C++ (Windows seulement)</h2>
		<div class="ss_part_texte">
		Quelques petits rappels sur Visual C++ :<br>
<br>
<ul>
<li>C'est l'IDE de Microsoft</li>
<li>Il est à la base payant, mais Microsoft a sorti une version gratuite intitulée Visual C++ Express.</li>
</ul><br>
<br>
Nous allons bien entendu voir ici la version gratuite, Visual C++ Express. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="centre"><img src="./cpp_files/285351.png" alt="Visual C++"><br>
<span class="italique">Aperçu de Visual C++ Express</span></div><br>
<br>
<br>
<div class="rmq question">Quelles sont les différences avec le "vrai" Visual ?</div><br>
Il n'y a pas d'éditeur de ressources (vous permettant de dessiner des images, des icônes, ou des fenêtres). Mais bon, ça entre nous on s'en fout parce qu'on n'aura pas besoin de s'en servir dans ce tutoriel. <img src="./cpp_files/clin.png" alt=";)" class="smilies"> Ce ne sont pas des fonctionnalités indispensables bien au contraire.<br>
<br>
Vous trouverez les instructions pour télécharger Visual C++ Express à cette adresse :<br>
<br>
<br>
<div class="centre"><a href="http://msdn.microsoft.com/fr-fr/express/aa975050.aspx"><span class="gros">Site de Visual C++ Express Edition</span></a></div><br>
<br>
Sélectionnez Visual C++ Express Français un peu plus bas sur la page.<br>
<br>
Visual C++ Express <span class="souligne">est en français et est totalement gratuit</span>. Ce n'est donc pas une version d'essai limitée dans le temps.<br>
<br>
C'est une chance d'avoir un IDE aussi puissant que celui de Microsoft disponible gratuitement, donc ne la laissez pas passer. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Installation</h3><br>
<br>
L'installation devrait normalement se passer sans encombre. Le programme d'installation va télécharger la dernière version de Visual sur Internet.<br>
Je vous conseille de laisser les options par défaut.<br>
<br>
A la fin, on vous dit qu'il faut vous enregistrer dans les 30 jours. Pas de panique, c'est gratuit et rapide mais il faut le faire.<br>
Cliquez sur le lien qui vous est donné : vous arrivez sur le site de Microsoft. Connectez-vous avec votre compte Windows Live ID (équivalent du compte hotmail ou msn) ou créez-en un si vous n'en avez pas, puis répondez au petit questionnaire.<br>
<br>
On vous donnera à la fin une clé d'enregistrement. Vous devrez recopier cette clé dans le menu "?" / "Inscrire le produit".<br>
<br>
<br>
<h3>Créer un nouveau projet</h3><br>
<br>
Pour créer un nouveau projet sous Visual, allez dans le menu Fichier / Nouveau / Projet.<br>
Sélectionnez "Win32" dans la colonne de gauche, puis "Application console Win32" à droite.<br>
<br>
Entrez un nom pour votre projet, par exemple "test" :<br>
<br>
<div class="centre"><img src="./cpp_files/285353.png" alt="Ajout d&#39;un projet"></div><br>
<br>
Validez. Une nouvelle fenêtre s'ouvre :<br>
<br>
<div class="centre"><img src="./cpp_files/129227.png" alt="Visual C++ Express"></div><br>
<br>
Cette fenêtre ne sert à rien. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Par contre, cliquez sur "Paramètres de l'application" dans la colonne de gauche :<br>
<br>
<div class="centre"><img src="./cpp_files/129228.png" alt="Visual C++ Express"></div><br>
<br>
Veillez à ce que "Projet vide" soit coché comme sur ma capture d'écran.<br>
Puis, cliquez sur "Terminer".<br>
<br>
<br>
<h3>Ajouter un nouveau fichier source</h3><br>
<br>
Votre projet est pour l'instant bien vide. Faites un clic droit sur le dossier "Fichiers sources" situé sur votre gauche, puis allez dans Ajouter / Nouvel élément :<br>
<br>
<div class="centre"><img src="./cpp_files/129231.png" alt="Visual C++ Express"></div><br>
<br>
Une fenêtre s'ouvre.<br>
Sélectionnez "Fichier C++ (.cpp)". Entrez le nom "main.cpp" pour votre fichier :<br>
<br>
<div class="centre"><img src="./cpp_files/285355.png" alt="Ajout d&#39;un fichier"></div><br>
<br>
Cliquez sur "Ajouter". C'est bon, vous allez pouvoir commencer à écrire du code !<br>
<br>
<br>
<h3>La fenêtre principale de Visual</h3><br>
<br>
Voyons ensemble le contenu de la fenêtre principale de Visual C++ Express :<br>
<br>
<div class="centre"><img src="./cpp_files/285354.png" alt="Fenêtre de Visual C++"></div><br>
<br>
On va rapidement (re)voir quand même ce que signifient chacune des parties :<br>
<br>
<ol class="liste_1">
<li>La barre d'outils, tout ce qu'il y a de plus standard. Ouvrir, enregistrer, enregistrer tout, couper, copier, coller etc. Par défaut, il semble qu'il n'y ait pas de bouton de barre d'outils pour compiler. Vous pouvez les rajouter en faisant un clic droit sur la barre d'outils, puis en choisissant "Déboguer" et "Générer" dans la liste.<br>
Toutes ces icônes de compilation ont leur équivalent dans les menus "Générer" et "Déboguer". Si vous faites "Générer", cela créera l'exécutable (ça signifie "Compiler" pour Visual). Si vous faites "Déboguer / Exécuter", on devrait vous proposer de compiler avant d'exécuter le programme. F7 permet de générer le projet, et F5 de l'exécuter.<br>
<br>
</li>
<li>Dans cette zone très importante vous voyez normalement la liste des fichiers de votre projet. Cliquez sur l'onglet "Explorateur de solutions" en bas si ce n'est déjà fait. Vous devriez voir que Visual crée déjà des dossiers pour séparer les différents types de fichiers de votre projet (sources, en-têtes et ressources). Nous verrons un peu plus tard quels sont les différents types de fichiers qui constituent un projet. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
</li>
<li>La partie principale. C'est là qu'on modifie les fichiers source.<br>
<br>
</li>
<li>C'est là encore la "zone de la mort", celle où on voit apparaître toutes les erreurs de compilation. C'est dans le bas de l'écran aussi que Visual affiche les informations de débuggage quand vous essayez de corriger un programme buggé. Je vous ai d'ailleurs dit tout à l'heure que j'aimais beaucoup le débugger de Visual, et je pense que je ne suis pas le seul. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"></li></ol><br>
<br>
Voilà, on a fait le tour de Visual C++.<br>
Vous pouvez aller jeter un œil dans les options (Outils / Options) si ça vous chante, mais n'y passez pas 3 heures. Il faut dire qu'il y a tellement de cases à cocher de partout qu'on ne sait plus trop où donner de la tête. <img src="./cpp_files/rire.gif" alt=":lol:" class="smilies"> <br>

		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420451">Xcode (Mac OS seulement)</h2>
		<div class="ss_part_texte">
		Il existe plusieurs IDE compatibles Mac. Il y a Code::Blocks bien sûr, mais ce n'est pas le seul.<br>
Je vais vous présenter ici l'IDE le plus célèbre sous Mac : Xcode.<br>
<br>
<div class="rmq information">Merci à <a href="http://www.siteduzero.com/membres-294-72901.html">prs513rosewood</a> pour les captures d'écran et ses judicieux conseils pour réaliser cette section.</div><br>
<br>
<h3>Xcode, où es-tu ?</h3><br>
<br>
<div class="flot_gauche"><img src="./cpp_files/3870.jpg" alt="Image utilisateur"></div>Tous les utilisateurs de Mac OS ne sont pas des programmeurs. Apple l'a bien compris et n'installe pas par défaut d'IDE avec Mac OS.<br>
Heureusement, pour ceux qui voudraient programmer, tout est prévu. En effet, Xcode est présent sur le CD d'installation de Mac OS.<br>
<br>
Insérez donc le CD dans le lecteur. Pour installer Xcode, il faut ouvrir le paquet "Xcode Tools" dans le répertoire "Installation facultative" du disque d'installation. L'installeur démarre :<br>
<br>
<div class="centre"><img src="./cpp_files/289604.png" alt="Installation Xcode"></div><br>
<br>
Par ailleurs, je vous conseille de mettre en favoris la <a href="http://developer.apple.com/fr/">page dédiée aux développeurs</a> sur le site d'Apple. Vous y trouverez une foule d'informations utiles pour le développement sous Mac. Vous pourrez notamment y télécharger plusieurs logiciels pour développer.<br>
N'hésitez pas à vous inscrire à l'ADC (Apple Development Connection), c'est gratuit et vous serez ainsi tenu au courant des nouveautés.<br>
<br>
<h3>Lancement</h3><br>
<br>
Une fois l'installation terminée, l'application Xcode se trouve dans le répertoire /Developer/Applications/ :<br>
<br>
<div class="centre"><img src="./cpp_files/289605.png" alt="Lancement Xcode"></div><br>
<br>
<h3>Nouveau projet</h3><br>
<br>
Pour créer un nouveau projet, on clique sur "Create a new Xcode project", ou "File &gt; New Project". Il faut choisir le type "Command Line Tool", et sélectionner "C++ sdtc++" dans le petit menu déroulant.<br>
<br>
<div class="centre"><img src="./cpp_files/289606.png" alt="Xcode nouveau projet"></div><br>
<br>
Une fois le projet créé, la fenêtre principale de Xcode apparaît :<br>
<br>
<div class="centre"><img src="./cpp_files/289612.png" alt="Xcode fenêtre principale"></div><br>
<br>
Le fichier sdz-test (icône noire) est l'exécutable, et le fichier sdz-test.1 est un fichier de documentation.<br>
Le fichier main.cpp contient le code source du programme. Vous pouvez double-cliquer pour l'ouvrir.<br>
<br>
Vous pouvez ajouter de nouveaux fichiers C++ au projet via le menu File &gt; New File.<br>
<br>
<h3>Compilation</h3><br>
<br>
Avant de compiler, il faut changer un réglage dans les préférences de Xcode. Pour ouvrir les préférences, il faut cliquer sur "Preferences" dans le menu "Xcode". Dans le panneau debugging, il faut sélectionner "Show console" dans le menu déroulant en face de "On start". C'est une manipulation qui est nécessaire pour voir la sortie d'un programme en console.<br>
<br>
<div class="centre"><img src="./cpp_files/289614.png" alt="Options Xcode"></div><br>
<br>
<div class="rmq information">Cette manipulation n'a besoin d'être faite qu'une seule fois en tout.</div><br>
<br>
Pour compiler, on clique sur le bouton "Build and Run" (en forme de marteau avec une petite icône verte devant) dans la fenêtre du projet. Voici donc la console qui s'affiche :<br>
<br>
<div class="centre"><img src="./cpp_files/289616.png" alt="Compilation Xcode"></div><br>
<br>
Voilà ! Vous connaissez désormais l'essentiel pour créer un nouveau projet C++ et le compiler avec Xcode. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Maintenant que nous avons installé un IDE, nous avons tous les outils en main pour programmer.<br>
<br>
...<br>
<br>
Qu'attendez-vous ? Rendez-vous au prochain chapitre, on commence à coder ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_420424">Votre premier programme</h1>
	<div id="chap_intro">
	Vous avez appris en quoi consistait la programmation et ce qu'était le C++, vous avez installé un IDE (ce logiciel qui va vous permettre de programmer) et maintenant vous vous demandez :<br>
<br>
<div class="rmq question">Bon, c'est quand qu'on commence ? <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies"> </div><br>
<br>
Bonne nouvelle : c'est maintenant ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Alors bien sûr, ne vous mettez pas à vous imaginer que vous allez faire des choses folles tout d'un coup. La 3D temps réel en réseau n'est pas trop au programme pour le moment ! A la place, votre objectif du chapitre sera d'arriver à afficher un message à l'écran et à récupérer le texte saisi par l'utilisateur.<br>
<br>
Vous allez voir... c'est déjà du travail ! <img src="./cpp_files/clin.png" alt=";)" class="smilies">
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420456">Le monde merveilleux de la console</h2>
		<div class="ss_part_texte">
		Quand je vous annonce que nous allons commencer à programmer, vous vous dites sûrement "<span class="italique">Chouette, je vais pouvoir faire ça, ça et ça, et j'ai toujours rêvé de faire ça aussi !</span>". Il est de mon devoir de calmer un peu le jeu et de vous expliquer comment ça va se passer. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Nous allons commencer doucement. Nous n'avons de toute façon pas le choix, car les programmes complexes 3D en réseau que vous imaginez peut-être nécessitent de connaître <strong>les bases</strong>.<br>
<br>
Il faut savoir qu'il existe 2 types de programmes : les programmes graphiques et les programmes console.<br>
<br>
<h3>Les programmes graphiques</h3><br>
<br>
Ce sont des programmes qui affichent des fenêtres. Ce sont ceux que vous connaissez sûrement le mieux. Ils affichent des fenêtres à l'écran que l'on peut ouvrir, réduire, fermer, agrandir...<br>
Les programmeurs parlent de GUI (Graphical User Interface - Interface Utilisateur Graphique).<br>
<br>
<div class="centre"><img src="./cpp_files/288054.png" alt="Word (GUI)"><br>
<span class="italique">Un programme GUI (graphique) : Word</span></div><br>
<br>
<h3>Les programmes console</h3><br>
<br>
Les programmes en console sont plus fréquents sous Linux que sous Windows et Mac OS X. Ils sont constitués de simples textes qui s'affichent à l'écran, le plus souvent en blanc sur fond noir.<br>
<br>
<div class="centre"><img src="./cpp_files/288055.png" alt="Programme console"><br>
<span class="italique">Un programme en console</span></div><br>
<br>
Ces programmes fonctionnent au clavier. La souris n'est pas utilisée.<br>
Ils s'exécutent généralement linéairement : les messages s'affichent au fur et à mesure de haut en bas.<br>
<br>
<h3>Notre première cible : les programmes console</h3><br>
<br>
Eh oui, j'imagine que vous l'avez vue venir celle-là ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Je vous annonce que nous allons commencer par réaliser des programmes console. En effet, bien qu'un peu austères a priori, ces programmes sont beaucoup plus simples à créer que les programmes graphiques. Pour les débutants que nous sommes, il faudra donc d'abord en passer par là !<br>
<br>
Bien entendu, je sais que vous ne voudrez pas en rester là. Rassurez-vous sur ce point : je m'en voudrais de m'arrêter aux programmes console car je sais que beaucoup d'entre vous préféreraient créer des programmes graphiques. Ca tombe bien : une partie toute entière de ce cours sera dédiée à la création de GUI avec Qt, une sorte d'extension du C++ qui permet de réaliser ce type de programmes !<br>
<br>
Mais avant ça, il va falloir retrousser ses manches et se mettre au travail. Au boulot ! <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420430">Création et lancement d'un premier projet</h2>
		<div class="ss_part_texte">
		Dans le chapitre précédent, vous avez installé un IDE, ce fameux logiciel qui contient tout ce qu'il faut pour programmer.<br>
Nous avons découvert qu'il existait plusieurs IDE (Code::Blocks, Visual C++, Xcode...). Je ne vous en ai cité que quelques-uns parmi les plus connus mais il y en a bien d'autres !<br>
<br>
Comme je vous l'avais annoncé, je travaille essentiellement sous Code::Blocks. Mes explications s'attarderont donc le plus souvent sur cet IDE, mais je reviendrai sur ses concurrents si nécessaire. Heureusement, ces logiciels se ressemblent beaucoup et emploient le même vocabulaire, donc vous ne serez pas perdus dans tous les cas. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<h3>Création d'un projet</h3><br>
<br>
Pour commencer à programmer, la première étape consiste à demander à son IDE de créer un nouveau projet. C'est un peu comme si vous demandiez à Word de vous créer un nouveau document. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Pour cela, vous allez dans le menu <span class="courrier">File / New / Project</span> :<br>
<br>
<div class="centre"><img src="./cpp_files/288063.png" alt="Nouveau projet Code Blocks"></div><br>
<br>
Un assistant s'ouvre, nous l'avons vu dans le chapitre précédent. Créez un nouveau programme console C++ comme nous avons appris à le faire.<br>
<br>
A la fin des étapes de l'assistant, le projet est créé avec un premier fichier. Déroulez l'arborescence à gauche pour voir le fichier main.cpp apparaître et double-cliquez dessus pour l'ouvrir. Ce fichier est notre premier code source et il est déjà un peu rempli !<br>
<br>
<div class="centre"><img src="./cpp_files/288064.png" alt="Premier programme dans Code Blocks"></div><br>
<br>
Code::Blocks vous a créé un premier programme très simple qui affiche le message "Hello world!" à l'écran (ça signifie quelque chose comme "Bonjour tout le monde !").<br>
<br>
<div class="rmq question">Il y a déjà une dizaine de lignes de code source C++ et je n'y comprends rien ! <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"></div><br>
<br>
Oui, ça peut paraître un peu difficile la première fois, mais nous allons voir ensemble ce que signifie ce code un peu plus loin. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<h3>Lancement du programme</h3><br>
<br>
Pour le moment, j'aimerais que vous fassiez une chose simple : essayez de compiler et de lancer ce premier programme. Vous vous souvenez comment faire ? Il y a un bouton "Compiler et exécuter" (Build and run). Ce bouton se trouve dans la barre d'outils, dans cette section : <img src="./cpp_files/285322.png" alt="Image utilisateur"> (c'est l'image de la roue dentée avec la flèche verte).<br>
<br>
La compilation va alors se lancer. Vous allez voir quelques messages s'afficher en bas de l'IDE (dans la section <span class="italique">Build log</span>).<br>
<br>
<div class="rmq erreur">Si la compilation ne fonctionne pas et que vous avez une erreur de ce type :<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>"My-program&nbsp;-&nbsp;Release"&nbsp;uses&nbsp;an&nbsp;invalid&nbsp;compiler.&nbsp;Skipping...
Nothing&nbsp;to&nbsp;be&nbsp;done.</pre></div></td></tr></tbody></table></div><br>
... Cela signifie que vous avez téléchargé la version de Code::Blocks sans mingw (le compilateur). Retournez sur le site de <a href="http://www.codeblocks.org/">Code::Blocks</a> pour télécharger la version avec mingw.</div><br>
<br>
Si tout va bien, une console va apparaître avec notre programme :<br>
<br>
<div class="centre"><img src="./cpp_files/288066.png" alt="Premier programme en console"></div><br>
<br>
Vous voyez que le programme affiche bel et bien "Hello world!" dans la console !<br>
Ce n'est pas beau !? Vous venez de compiler votre tout premier programme ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<div class="rmq question">Au fait, que signifie le message à la fin de la console : <span class="code2 console">Process&nbsp;returned&nbsp;0&nbsp;(0x0)&nbsp;&nbsp;&nbsp;execution&nbsp;time&nbsp;:&nbsp;0.004&nbsp;s&nbsp;&nbsp;Press&nbsp;any&nbsp;key&nbsp;to&nbsp;continue.</span> ?</div><br>
<br>
Ah bonne question ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Ce message n'a pas été écrit par votre programme mais par votre IDE. En l’occurrence, c'est Code::Blocks qui affiche un message pour signaler que le programme s'est bien déroulé et le temps que son exécution a duré.<br>
<br>
Le but de Code::Blocks est ici surtout de "maintenir" la console ouverte. En effet, sous Windows en particulier, dès qu'un programme console est terminé la fenêtre de la console se ferme. Or, le programme s'étant exécuté en 0.004s ici, vous n'auriez pas eu le temps de voir le message s'afficher à l'écran !<br>
<br>
Code::Blocks vous invite donc à "appuyer sur n'importe quelle touche pour continuer", ce qui aura pour effet de fermer la console.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420435">Explications du premier code source</h2>
		<div class="ss_part_texte">
		Lorsque Code::Blocks a créé un nouveau projet, il a créé un fichier main.cpp contenant ce code :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<div class="rmq information">Tous les IDE proposent en général de démarrer avec un code similaire. Cela permet de commencer à programmer plus vite.<br>
Vous retrouverez les 3 premières lignes (include, using namespace et int main) dans quasiment tous vos programmes C++. Vous pouvez considérer que tous vos programmes commenceront avec ces lignes.</div><br>
<br>
Sans trop rentrer dans les détails (car cela pourrait devenir compliqué pour un début !), je vais vous présenter à quoi servent chacune de ces lignes. Vous les retrouverez dans la plupart de vos programmes.<br>
<br>
<h3>include</h3><br>
<br>
La toute première ligne est :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est ce qu'on appelle une <span class="italique">directive de préprocesseur</span>. Son rôle est de "charger" des fonctionnalités du C++ pour que nous puissions effectuer certaines actions.<br>
<br>
En effet, <span class="italique">le C++ est un langage très modulaire</span>. De base, il ne sait pas faire grand-chose (pas même afficher un message à l'écran !). On doit charger des extensions que l'on appelle <strong>bibliothèques</strong> et qui nous donnent de nouvelles possibilités.<br>
<br>
Ici, la bibliothèque iostream que l'on charge permet... d'afficher des messages à l'écran dans une console ! Quelque chose de vraiment très basique, comme vous le voyez, mais qui nécessite quand même le chargement d'une bibliothèque.<br>
<br>
<div class="rmq information">iostream permet en fait de faire un peu plus que d'afficher des messages à l'écran : cette bibliothèque peut aussi récupérer ce que saisit l'utilisateur au clavier comme nous le verrons plus tard.<br>
Son nom correspond à "Input Output Stream", ce qui signifie "Flux d'entrée-sortie". Dans un ordinateur, l'entrée correspond en général au clavier (ou la souris), et la sortie à l'écran. Cette bibliothèque gère donc en quelque sorte tout ce qu'il faut pour échanger des informations avec l'utilisateur.</div><br>
<br>
Plus tard, nous découvrirons de nouvelles bibliothèques et il faudra les inclure en haut des codes source comme ici. Par exemple, lorsque nous étudierons Qt qui permet de réaliser des programmes graphiques (GUI), on insérera une ligne comme celle-ci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;Qt&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notez qu'on peut charger autant de bibliothèques que l'on veut à la fois.<br>
<br>
<h3>using namespace</h3><br>
<br>
La ligne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... permet en quelque sorte d'indiquer dans quel lot de fonctionnalités notre fichier source va aller piocher.<br>
<br>
Si vous chargez plusieurs bibliothèques, chacune va proposer de nombreuses fonctionnalités. Parfois, certaines fonctionnalités ont le même nom. Imaginez une commande "AfficherMessage" qui s'appelle ainsi pour iostream mais aussi pour Qt ! Si vous chargez les deux bibliothèques en même temps et que vous appelez "AfficherMessage", l'ordinateur ne saura pas s'il doit afficher un message en console avec iostream ou dans une fenêtre avec Qt !<br>
<br>
Pour éviter ce genre de problèmes, on a créé des namespaces (espaces de noms) qui sont des sortes de dossiers à noms. La ligne <span class="code2 cpp"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span></span> indique que vous allez utiliser l'espace de noms std dans la suite de votre fichier de code. Cet espace de noms est un des plus connus car il correspond à la bibliothèque standard (std), une bibliothèque livrée par défaut avec le langage C++ et dont iostream fait partie.<br>
<br>
<h3>int main()</h3><br>
<br>
C'est ici que commence vraiment le coeur du programme. Les programmes, vous le verrez, sont essentiellement constitués de fonctions. Chaque fonction a un rôle et peut en appeler d'autres pour effectuer certains actions.<br>
<br>
Tous les programmes ont au moins une fonction qui s'appelle "main" (prononcez en anglais "mèïne"), ce qui signifie "principale". C'est donc la fonction principale. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Une fonction a cette forme :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les accolades déterminent le début et la fin de la fonction. Comme vous le voyez dans le code source qui nous a été généré par Code::Blocks, il n'y a rien après la fonction main. C'est normal : à la fin de la fonction main le programme s'arrête ! Tout programme commence au début de la fonction main et termine à la fin de celle-ci.<br>
<br>
<div class="rmq question">Cela veut dire qu'on va écrire tout notre programme dans la fonction main ? <img src="./cpp_files/huh.png" alt=":o" class="smilies"></div><br>
<br>
Non ! Bien que ce soit possible, ce serait très délicat à gérer surtout pour de gros programmes. A la place, la fonction main appelle d'autres fonctions qui à leur tour appellent d'autres fonctions. Bref, elle délègue le travail.<br>
Dans un premier temps cependant, nous allons surtout travailler dans la fonction main car nos programmes seront assez simples pour commencer.<br>
<br>
<h3>cout</h3><br>
<br>
Voici enfin la première ligne qui fait quelque chose de concret ! C'est la première ligne du main, donc la première action qui sera exécutée par l'ordinateur (ce que nous avons vu précédemment ne sont en fait que des préparatifs pour le programme).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le rôle de cout (prononcez "ci aoute") est d'afficher un message à l'écran. C'est ce qu'on appelle une <strong>instruction</strong>. Tous nos programmes seront constitués d'instructions qui donnent des ordres à l'ordinateur.<br>
<br>
Notez que cout est fourni par iostream. Si vous n'incluez pas iostream au début de votre programme, le compilateur dira qu'il ne connaît pas cout et vous ne pourrez pas générer votre programme !<br>
<br>
<div class="rmq attention">Notez bien : chaque instruction se termine par un point-virgule ! C'est d'ailleurs ce qui vous permet de différencier les instructions du reste. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Si vous oubliez le point-virgule, la compilation ne fonctionnera pas et votre programme ne pourra pas être créé !</div><br>
<br>
Il y a 3 éléments sur cette ligne :<br>
<br>
<ul>	
<li>cout : commande l'affichage d'un message à l'écran</li>	
<li>"Hello world!" : indique le message à afficher</li>	
<li>endl : crée un retour à la ligne dans la console</li>
</ul><br>
<br>
Il est possible de combiner plusieurs messages en une instruction. Par exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bonjour tout le monde !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">"Comment allez-vous ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... affichera ces deux phrases sur 2 lignes différentes. Essayez ce code, vous verrez !<br>
<br>
<div class="rmq information">Sous Windows, les caractères accentués s'affichent mal (essayez d'afficher "Bonjour Gérard" pour voir !). C'est un problème de la console de Windows (problème qu'on peut retrouver plus rarement sous Mac OS X et Linux). Il existe des moyens de le régler mais aucun n'est vraiment satisfaisant. A la place, je vous recommande plutôt d'éviter les accents dans les programmes console sous Windows.<br>
Rassurez-vous : les GUI que nous créerons plus tard avec Qt n'auront pas ce problème !</div><br>
<br>
<h3>return</h3><br>
<br>
La dernière ligne est :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce type d'instruction clôt généralement les fonctions. En fait, la plupart des fonctions renvoient une valeur (un nombre par exemple). Ici, la fonction main renvoie 0 pour indiquer que tout s'est bien passé (toute valeur différente de 0 aurait indiqué un problème).<br>
<br>
Vous n'avez pas besoin de modifier cette ligne, laissez-la telle quelle. Nous aurons l'occasion d'utiliser return d'autres fois pour d'autres fonctions, nous en reparlerons !
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420462">Commentez vos programmes !</h2>
		<div class="ss_part_texte">
		En plus du code qui donne des instructions à l'ordinateur, vous pouvez écrire des commentaires pour expliquer le fonctionnement de votre programme.<br>
<br>
Les commentaires n'ont aucun impact sur le fonctionnement de votre logiciel : en fait, le compilateur ne les lit même pas et ils n'apparaissent pas dans le programme généré. Pourtant, ces commentaires sont indispensables pour les développeurs : ils leur permettent d'expliquer ce qu'ils font dans leur code !<br>
<br>
Dès que vos programmes vont devenir un petit peu complexes (et croyez-moi, ça ne tardera pas <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ), vous risquez d'avoir du mal à vous souvenir de leur fonctionnement quelque temps après avoir écrit le code source. De plus, si vous envoyez votre code à un ami, il aura des difficultés à comprendre ce que vous avez essayé de faire juste en lisant le code source. C'est là que les commentaires entrent en jeu !<br>
<br>
<h3>Les différents types de commentaires</h3><br>
<br>
Il y a 2 façons d'écrire des commentaires, selon leur longueur. Je vais vous les présenter toutes les deux.<br>
<br>
<h4>Les commentaires courts</h4><br>
<br>
Pour écrire un commentaire court, sur une seule ligne, il suffit de commencer par // puis d'écrire votre commentaire. Cela donne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="c1">// Ceci est un commentaire</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Mieux, vous pouvez aussi ajouter le commentaire à la fin d'une ligne pour expliquer ce qu'elle fait :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// Affiche un message à l'écran</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Les commentaires longs</h4><br>
<br>
Si votre commentaire tient sur plusieurs lignes, ouvrez la zone de commentaire avec /* et fermez-la avec */ :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="cm">/* Le code qui suit est un peu complexe</span>
<span class="cm">alors je prends mon temps pour l'expliquer</span>
<span class="cm">parce que je sais que sinon dans quelques semaines</span>
<span class="cm">j'aurai tout oublié et je serai perdu pour le modifier */</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
En général, on n'écrit pas un roman dans les commentaires non plus... sauf si la situation le justifie vraiment.<br>
<br>
<h3>Commentons notre code source !</h3><br>
<br>
Reprenons le code source que nous avons étudié dans ce chapitre et complétons-le de quelques commentaires pour nous souvenir de ce qu'il fait.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt; </span><span class="c1">// Inclut la bibliothèque iostream (affichage de texte)</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> <span class="c1">// Indique quel espace de noms on va utiliser</span>

<span class="cm">/*</span>
<span class="cm">Fonction principale "main"</span>
<span class="cm">Tous les programmes commencent par la fonction main</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// Affiche un message</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Termine la fonction main et donc le programme</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si vous lancez ce programme, vous ne verrez aucune nouveauté. Les commentaires sont, comme je vous le disais, purement ignorés par le compilateur.<br>
<br>
<div class="rmq attention">J'ai volontairement commenté chaque ligne de code ici, mais dans la pratique il ne faut pas commenter à tout-va non plus. Si une ligne de code fait quelque chose de vraiment évident, inutile de la commenter.<br>
En fait, les commentaires sont plus utiles pour expliquer le fonctionnement d'une série d'instructions, plutôt que chaque instruction une à une.</div>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Vous avez mis en place votre tout premier programme : bravo !<br>
<br>
Pour le moment, vous savez seulement afficher un message à l'écran, mais vous allez pouvoir aller de plus en plus loin au fur et à mesure des chapitres qui vont venir. Dans le prochain chapitre, nous allons commencer à manipuler la mémoire ! <img src="./cpp_files/smile.png" alt=":)" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_420457">Utiliser la mémoire</h1>
	<div id="chap_intro">
	Jusqu'à présent, vous avez découvert comment créer vos premiers programmes en mode console. Vous avez aussi appris à les compiler, ce qui n'a pas été une mince affaire. Pour l'instant les programmes que vous avez réalisés sont très simples. Ils affichent des messages à l'écran et c'est un peut tout.  <img src="./cpp_files/triste.png" alt=":(" class="smilies"> <br>
Je suis d'accord avec vous, ce n'est pas assez pour faire quelque chose d'intéressant. Cela est principalement dû au fait que vos programmes ne savent pas interagir avec leurs utilisateurs. C'est ce que nous allons apprendre à faire dans ce chapitre, puisque je vais vous montrer comment demander des informations à l'utilisateur. Nous pourrons ainsi écrire notre premier programme interactif.<br>
<br>
Mais avant ça, il va nous falloir travailler dur, puisque je vais vous présenter une notion fondamentale en informatique. Nous allons parler des <strong>variables</strong>.<br>
<br>
<div class="flot_droite"><a href="http://uploads.siteduzero.com/files/277001_278000/277577.jpg"><img src="./cpp_files/277577.jpg" alt="Calculatrice basique"></a></div>L'idée de base qui se cache derrière la notion de variable c'est de mettre quelque chose dans la mémoire de l'ordinateur afin de le ré-utiliser plus tard. J'imagine que vous avez tous déjà eu une calculatrice entre les mains. Sur ces outils, il y a généralement des touches <span class="keyboard_shortcut">M+</span>, <span class="keyboard_shortcut">M-</span>, <span class="keyboard_shortcut">MC</span>, etc. qui permettent de stocker un résultat intermédiaire d'un calcul dans la mémoire de la calculatrice et de reprendre ce nombre plus tard. <br>
Nous allons apprendre à faire la même chose avec votre ordinateur, qui n'est après tout qu'une grosse machine à calculer.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Une fois que nous aurons appris à déclarer des variables, nous pourrons les utiliser pour interagir avec les utilisateurs de nos programmes et leur demander par exemple, leur nom ou leur âge.
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420449">Qu'est-ce qu'une variable ?</h2>
		<div class="ss_part_texte">
		Je vous ai donné l'exemple de la mémoire de la calculatrice avant parce que dans le monde de l'informatique le principe de base est le même. Il y a quelque part, dans votre ordinateur, des composants électroniques qui sont capables de contenir une valeur et de la conserver pendant un certain temps. La manière dont tout cela fonctionne exactement est très complexe.  <img src="./cpp_files/triste.png" alt=":(" class="smilies"> <br>
<br>
Je vous rassure tout de suite, on n'a absolument pas besoin de comprendre comment ça marche pour pouvoir, nous aussi, mettre des valeurs dans la mémoire du PC. Toute la partie compliquée sera gérée par le compilateur et le système d'exploitation. Elle est pas belle la vie ?<br>
<br>
<br>
<div class="flot_droite"><img src="./cpp_files/286436.jpg" alt="La mémoire d&#39;un ordinateur fonctionne comme une grosse armoire avec beaucoup de tiroirs"></div><br>
La seule et unique chose que vous avez besoin de savoir, c'est qu'une <strong>variable</strong> est une partie de la mémoire que l'ordinateur nous prête pour y mettre des valeurs. Imaginez que l'ordinateur possède dans ses entrailles une grande armoire. Cette armoire possède des milliers (des milliards) de petits tiroirs, ce sont des endroits que nous allons pouvoir utiliser pour mettre nos variables.<br>
<br>
<br>
Dans le cas d'une calculatrice toute simple, on ne peut généralement stocker qu'un seul nombre à la fois. Vous vous doutez bien que dans le cas d'un programme, il va falloir conserver plus d'une chose simultanément. Il faut donc un moyen de différencier les variables pour pouvoir par la suite y accéder. Chaque variable possède donc un <strong>nom</strong>. C'est en quelque sorte l'étiquette qui est collée sur le tiroir.<br>
<br>
L'autre chose qui distingue la calculatrice de l'ordinateur, c'est que nous aimerions pouvoir stocker des tas de choses différentes, des nombres, des lettres, des phrases, des images, etc. C'est ce qu'on appelle le <strong>type</strong> d'une variable. Vous pouvez vous imaginez cela comme étant la forme du tiroir. On utilise en effet pas les mêmes tiroirs pour stocker des bouteilles ou des livres.<br>
<br>
<h3>Les noms de variables</h3><br>
<br>
Commençons par la question du nom des variables. En C++, il y a quelques règles qui régissent les différents noms autorisés ou interdits. <br>
<ul>
<li> Les noms de variables sont constitués de lettres, de chiffres et du tiret-bas _ uniquement. </li>
<li> Le premier caractère doit être une lettre (majuscule ou minuscule).</li>
<li> On ne peut pas utiliser d'accents.</li>
<li> On ne peut pas utiliser d'espaces dans le nom. </li>
</ul><br>
Le mieux est encore de vous donner quelques exemples. Les noms <span class="code2 cpp"><span class="n">ageZero</span></span>, <span class="code2 cpp"><span class="n">nom_du_zero</span></span> ou encore <span class="code2 cpp"><span class="n">NOMBRE_ZEROS</span></span> sont tous des noms valides. <span class="code2 cpp"><span class="n">AgeZ</span>é<span class="n">ro</span></span>, <span class="code2 cpp"><span class="n">_nomzero</span></span> ne le sont par contre pas.<br>
<br>
A cela s'ajoute une règle supplémentaire qui est valable pour tout ce que l'on écrit en C++ et pas seulement pour les variables. Le langage fait la différence entre les majuscules et les minuscules. En termes techniques, on dit que C++ est <span class="italique">sensible à la casse</span>. Donc, <span class="code2 cpp"><span class="n">nomZero</span></span>, <span class="code2 cpp"><span class="n">nomzero</span></span>, <span class="code2 cpp"><span class="n">NOMZERO</span></span> et <span class="code2 cpp"><span class="n">NomZeRo</span></span> sont tous des noms de variables différents.<br>
<br>
<div class="rmq attention">Pour des questions de lisibilité, il est important d'utiliser des noms de variables qui décrivent bien ce qu'elles contiennent. On préfèrera donc choisir <span class="code2 cpp"><span class="n">ageUtilisateur</span></span> comme nom plutôt que <span class="code2 cpp"><span class="n">maVar</span></span> ou  <span class="code2 cpp"><span class="n">variable1</span></span>. <br>
Pour le compilateur, cela ne joue aucun rôle. Mais pour vous et pour les gens qui travailleront avec vous sur le même programme, c'est très important.</div><br>
<br>
Personnellement, j'utilise une "convention" partagée par beaucoup de programmeurs. Dans tous les gros projets regroupant des milliers de programmeurs on trouve des règles très strictes et parfois difficiles à suivre. Celles que je vous propose ici permettent de garder une bonne lisibilité et surtout vous permettront de bien comprendre tous les exemples dans la suite de ce cours.<br>
<ul>	
<li>Les noms de variables commencent par une minuscule.</li>	
<li>Si le nom se décompose en plusieurs mots, ceux-ci sont collés les uns aux autres.</li>	
<li>Chaque nouveau mot (excepté le premier) commence par une majuscule.</li>
</ul><br>
<br>
Voyons ça avec des exemples. Prenons le cas d'une variable censée contenir l'âge de l'utilisateur du programme. <br>
<ul>	
<li><span class="rouge"><span class="code2 cpp"><span class="n">AgeUtilisateur</span></span>: Non, car la première lettre est une majuscule.</span></li>	
<li><span class="rouge"><span class="code2 cpp"><span class="n">age_utilisateur</span></span>: Non, car les mots ne sont pas collés</span></li>	
<li><span class="rouge"><span class="code2 cpp"><span class="n">ageutilisateur</span></span>: Non, car le deuxième mot ne commence pas par une majuscule.</span></li>	
<li><span class="rouge"><span class="code2 cpp"><span class="n">maVar</span></span>: Non, car la nom ne décrit pas ce que contient la variable.</span></li>	
<li><span class="vertf"><span class="code2 cpp"><span class="n">ageUtilisateur</span></span>: Ok.</span></li>
</ul><br>
<br>
Je vous conseille fortement d'utiliser la même convention. Rendre son code lisible et facilement compréhensible par d'autres programmeurs est très important. <br>
<br>
<h3>Les types de variables</h3><br>
<br>
Reprenons. Nous avons appris qu'une variable a un nom et un type. Nous savons comment nommer nos variables, voyons maintenant leurs différents types. L'ordinateur aime savoir ce qu'il a dans sa mémoire, il faut donc indiquer quel type d'élément va contenir la variable que nous aimerions utiliser. Est-ce un nombre, une mot, une lettre ? Il faut le spécifier. <br>
<br>
Voici donc la liste des types de variables que l'on peut utiliser en C++.<br>
<br>
<table class="tab_user">







<thead><tr><th>Nom du type</th><th>Ce qu'il peut contenir</th></tr></thead><tbody><tr>
<td><span class="code2 cpp"><span class="kt">bool</span></span></td>
<td>Peut contenir deux valeurs "vrai" (<span class="code2 cpp"><span class="kc">true</span></span>) ou "faux" (<span class="code2 cpp"><span class="kc">false</span></span>).</td>
</tr><tr>
<td><span class="code2 cpp"><span class="kt">char</span></span></td>
<td>Une lettre.</td>
</tr><tr>
<td><span class="code2 cpp"><span class="kt">int</span></span></td>
<td>Un nombre entier entre <img src="./cpp_files/mimetex.cgi" alt="-2~147~483~648"> et <img src="./cpp_files/mimetex(1).cgi" alt="2~147~483~647">. </td>
</tr><tr>
<td><span class="code2 cpp"><span class="kt">unsigned</span> <span class="kt">int</span></span></td>
<td>Un nombre entier <span class="italique">positif</span> entre <img src="./cpp_files/mimetex(2).cgi" alt="0"> et <img src="./cpp_files/mimetex(3).cgi" alt="4~294~967~295">. </td>
</tr><tr>
<td><span class="code2 cpp"><span class="kt">double</span></span></td>
<td>Un nombre à virgule entre <img src="./cpp_files/mimetex(4).cgi" alt="-1.7\cdot 10^{308}"> et <img src="./cpp_files/mimetex(5).cgi" alt="1.7\cdot 10^{308}"></td>
</tr><tr>
<td><span class="code2 cpp"><span class="n">string</span></span></td>
<td>Une chaîne de caractères. C'est-à-dire une suite de lettres, un mot, une phrase.</td>
</tr></tbody></table><br>
<br>
Si vous tapez un de ces noms de type dans votre IDE, vous devriez voir le mot se colorer. L'IDE l'a reconnu, c'est bien la preuve que je ne vous raconte pas des salades. Le cas de string est différent; nous verrons plus loin pourquoi. Je peux vous assurer qu'on va beaucoup en reparler.  <img src="./cpp_files/langue.png" alt=":p" class="smilies"> <br>
<br>
<div class="rmq information">Il existe d'autres types de variables plus spécifiques. Par exemple des nombres entiers avec d'autres limites minimales et maximales. Ils sont plus rarement utilisés.</div><br>
<br>
Quand on a besoin d'une variable, il faut donc se poser la question du genre de choses qu'elle va contenir. Si vous avez besoin d'une variable pour stocker le nombre de personnes qui utilisent votre programme, alors utilisez un <span class="code2 cpp"><span class="kt">int</span></span> ou <span class="code2 cpp"><span class="kt">unsigned</span> <span class="kt">int</span></span>, pour stocker le poids d'un gigot, on utilisera un <span class="code2 cpp"><span class="kt">double</span></span> et pour conserver en mémoire le nom de votre meilleur ami, on choisira une chaîne de caractères <span class="code2 cpp"><span class="n">string</span></span>.<br>
<br>
<div class="rmq question">Mais, à quoi sert le type <span class="code2 cpp"><span class="kt">bool</span></span> ? J'en ai jamais entendu parler.</div><br>
<br>
C'est ce qu'on appelle un booléen. C'est-à-dire une variable qui ne peut prendre que deux valeurs, vrai (<span class="code2 cpp"><span class="kc">true</span></span> en anglais) ou faux (<span class="code2 cpp"><span class="kc">false</span></span> en anglais). On les utilise par exemple pour stocker des informations comme, la lumière est-elle allumée ? L'utilisateur a-t-il le droit d'utiliser cette fonctionnalité ? Le mot de passe est-il correct? <br>
Si vous avez besoin de conserver le résultat d'une question de ce genre, alors pensez à ce type de variable.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420418">Déclarer une variable</h2>
		<div class="ss_part_texte">
		Assez parlé, il est temps d'entrer dans le vif du sujet et de demander à l'ordinateur de nous prêter un de ses tiroirs. En terme technique, on parle de <strong>déclaration de variable</strong>.<br>
<br>
Il nous faut indiquer à l'ordinateur, le type de la variable que l'on veut, son nom et enfin sa valeur. Pour se faire, c'est très simple. On indique les choses exactement dans cet ordre.<br>
<br>
<img src="./cpp_files/277950.png" alt="Syntaxe d&#39;initialisation d&#39;une variable en C++"><br>
<br>
On peut aussi utiliser la même syntaxe que dans le langage C:<br>
<br>
<img src="./cpp_files/277951.png" alt="Syntaxe d&#39;initialisation d&#39;une variable héritée du C."><br>
<br>
Les deux versions sont <span class="italique">strictement équivalentes</span>. Je vous conseille cependant d'utiliser la première pour des raisons qui deviendront claires plus tard. La deuxième version ne sera pas utilisée dans la suite du cours, je vous l'ai mise pour que vous puissiez comprendre les nombreux exemples que l'on peut trouver sur le web et qui utilisent cette version de la déclaration d'une variable.<br>
<br>
<div class="rmq erreur">N'oubliez pas le point-virgule (<strong>;</strong>) à la fin de la ligne ! C'est le genre de choses que l'on oublie très facilement et le compilateur n'aime pas ça du tout.  <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies"> </div><br>
<br>
Reprenons le morceau de code minimal et ajoutons-y une variable pour stocker l'âge de l'utilisateur. <br>
<br>
<span class="code">Code : C++ - Déclaration d'une variable - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="ln-xtra">    <span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span></span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Que se passe-t-il à la ligne 6 de ce programme ? <br>
L'ordinateur voit que l'on aimerait lui emprunter un tiroir dans sa mémoire avec les propriétés suivantes :<br>
<ul>	
<li>Il peut contenir des nombres entiers.</li>	
<li>Il a une étiquette indiquant qu'il s'appelle <span class="code2 cpp"><span class="n">ageUtilisateur</span></span>.</li>	
<li>Il contient la valeur <img src="./cpp_files/mimetex(6).cgi" alt="16">.</li>
</ul><br>
A partir de cette ligne, vous êtes donc l'heureux possesseur d'un tiroir dans la mémoire de l'ordinateur.  <img src="./cpp_files/smile.png" alt=":)" class="smilies">  <br>
<br>
<div class="centre"><img src="./cpp_files/286445.png" alt="Un tiroir dans la mémoire de l&#39;ordinateur contenant le chiffre 16"></div><br>
<br>
Comme nous allons avoir besoin de beaucoup de tiroirs dans la suite du cours, je vous propose d'utiliser des schémas un peu plus simple. On va beaucoup les utiliser par la suite, il est donc bien de s'y habituer tôt.<br>
<br>
<div class="centre"><img src="./cpp_files/280302.png" alt="Schéma de l&#39;état de la mémoire après la déclaration d&#39;une variable"><br>
</div><br>
<br>
Je vais vous décrire un peu ce qu'on voit sur le schéma. Le gros rectangle bleu représente la mémoire de l'ordinateur. Pour l'instant, elle est presque vide. Le carré jaune est la zone de mémoire que l'ordinateur vous a prêtée. C'est l'équivalent de notre tiroir. Il contient, comme avant, le nombre <img src="./cpp_files/mimetex(6).cgi" alt="16"> et on peut lire le nom <span class="code2 cpp"><span class="n">ageUtilisateur</span></span> sur l'étiquette qui y est accrochée.<br>
Je ne suis pas bon en dessin, donc il faut un peu imaginer hein.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Ne nous arrêtons pas en si bon chemin. Déclarons d'autres variables. <br>
<br>
<span class="code">Code : C++ - Un amour de déclaration - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">nombreAmis</span><span class="p">(</span><span class="mi">432</span><span class="p">);</span>      <span class="c1">//Le nombre d'amis de l'utilisateur</span>

    <span class="kt">double</span> <span class="n">pi</span><span class="p">(</span><span class="mf">3.14159</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="n">estMonAmi</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>    <span class="c1">//Cet utilisateur est-il mon ami ?</span>

    <span class="kt">char</span> <span class="n">lettre</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Il y a deux choses importantes à remarquer ici, la première est que les variables de type <span class="code2 cpp"><span class="kt">bool</span></span> ne peuvent avoir pour valeur que <span class="code2 cpp"><span class="kc">true</span></span> ou <span class="code2 cpp"><span class="kc">false</span></span>. C'est donc une de ces deux valeurs qu'il faut mettre entre les parenthèses. L'autre chose dont il faut se souvenir, c'est que pour le type <span class="code2 cpp"><span class="kt">char</span></span>, il faut mettre la lettre que l'on veut entre apostrophes. Il faut écrire <span class="code2 cpp"><span class="kt">char</span> <span class="n">lettre</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span></span> et pas <span class="code2 cpp"><span class="kt">char</span> <span class="n">lettre</span><span class="p">(</span><span class="n">a</span><span class="p">);</span></span>. C'est une erreur que tout le monde fait, moi le premier.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
<div class="rmq information">Il est toujours bien de mettre un commentaire pour expliquer à quoi va servir la variable.</div><br>
<br>
Je peux donc compléter mon schéma en lui ajoutant nos nouvelles variables.<br>
<br>
<div class="centre"><img src="./cpp_files/293281.png" alt="Schéma de l&#39;état de la mémoire après plusieurs déclarations"></div><br>
<br>
Vous pouvez évidemment compiler et tester le programme ci-dessus. Vous constaterez qu'il ne fait strictement rien. J'espère que vous n'êtes pas trop déçu. Il se passe en réalité énormément de choses mais comme je vous l'ai dit au début, ces opérations sont cachées et ne nous intéressent pas vraiment. En voici quand même un résumé chronologique.<br>
<br>
<ol class="liste_1">	
<li>Votre programme demande au système d'exploitation de lui fournir un peu de mémoire</li>	
<li>L'OS a regardé s'il en avait encore à disposition et a indiqué au programme quel tiroir utiliser.</li>	
<li>Le programme a écrit la valeur <img src="./cpp_files/mimetex(6).cgi" alt="16"> dans la case mémoire.</li>        
<li>Il a ensuite recommencé pour les quatre autres variables.</li>        
<li>En arrivant à la dernière ligne, le programme a vidé ses tiroirs et les a rendus à l'ordinateur.</li></ol><br>
Et tout ça sans que rien ne se passe du tout à l'écran ! C'est normal, on a nulle part indiquer qu'on voulait afficher quelque chose.<br>
<br>
<h3>Le cas des strings</h3><br>
<br>
Les chaînes de caractères sont un petit peu plus complexes à déclarer, mais rien d'insurmontable, je vous rassure. La première chose à faire est d'ajouter une petite ligne au début de votre programme. Il faut, en effet, indiquer au compilateur que nous souhaitons utiliser des strings. Sans ça, il n'inclurait pas les outils nécessaires à leur gestion. La ligne à ajouter est <span class="code2 cpp"><span class="cp">#include &lt;string&gt;</span></span>. <br>
<br>
Voici ce que ça donne.<br>
<br>
<span class="code">Code : C++ - Votre premier string - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="ln-xtra"><span class="cp">#include &lt;string&gt;</span></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">nomUtilisateur</span><span class="p">(</span><span class="s">"Albert Einstein"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
L'autre différence se situe au niveau de la déclaration elle-même. Comme vous l'avez certainement constaté, j'ai utilisé des guillemets autour de la valeur. Un peu comme pour les lettres, mais cette fois ce sont des guillemets doubles (") et pas juste des apostrophes ('). D'ailleurs votre IDE devrait colorier les mots <span class="code2 cpp"><span class="s">"Albert Einstein"</span></span> d'une couleur différente du <span class="code2 cpp"><span class="sc">'a'</span></span> de l'exemple précédent, même si ce n'est pas le cas sur le site du zéro. Confondre ' et " est une erreur à nouveau très courante qui fera hurler de douleur votre compilateur. Mais ne vous en faites pas pour lui, il en a vu d'autres.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
<h3>Une astuce pour gagner de la place</h3><br>
<br>
Avant de passer à la suite, il faut que je vous présente une petite astuce qui vous fera gagner des lignes dans vos programmes.<br>
Si vous avez plusieurs variables du <strong>même type</strong> à déclarer, vous pouvez le faire sur une seule ligne en les séparant par une virgule (<span class="code2 cpp"><span class="p">,</span></span>). Voici comment:<br>
<br>
<span class="code">Code : C++ - Déclarer plusieurs variables sur une seule ligne - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">b</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span><span class="n">c</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">//On declare trois cases memoires nommees a,b et c et qui contiennent les valeurs 2,4 et -1 respectivement.</span>

<span class="n">string</span> <span class="n">prenom</span><span class="p">(</span><span class="s">"Albert"</span><span class="p">),</span> <span class="n">nom</span><span class="p">(</span><span class="s">"Einstein"</span><span class="p">);</span> <span class="c1">//On declare deux cases pouvant contenir des chaines de caracteres</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ça peut être pratique quand on a besoin de beaucoup de variables d'un coup. On économise l'écriture du type à chaque fois. Vous le verrez encore par la suite, la fainéantise est une qualité importante du programmeur.  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420440">Déclarer sans initialiser</h2>
		<div class="ss_part_texte">
		Maintenant que nous avons vu le principe général, il est temps de plonger un petit peu plus dans les détails. <br>
<br>
Lors de la déclaration d'une variable, votre programme effectue en réalité deux opérations successives.<br>
<ol class="liste_1">	
<li>Il demande à l'ordinateur de lui fournir une zone dans la mémoire. En termes techniques, on parle d'<strong>allocation</strong> de la mémoire.</li>	
<li>Il remplit cette case avec la valeur fournie. On parle alors d'<strong>initialisation</strong> de la variable.</li></ol><br>
Ces deux étapes s'effectuent automatiquement et sans que l'on ait besoin de rien faire. Voilà pour la partie vocabulaire de ce chapitre.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Il arrive parfois que l'on ne sache pas quelle valeur donner à une variable lors de sa déclaration. Il est alors possible d'effectuer uniquement l'allocation sans l'initialisation. <br>
Il suffit d'indiquer le <strong>type</strong> et le <strong>nom</strong> de la variable sans spécifier de valeur. <br>
<br>
<img src="./cpp_files/286691.png" alt="Déclaration d&#39;une variable sans initialisation"><br>
<br>
Et sous forme de code C++ complet, voilà ce que ça donne :<br>
<br>
<span class="code">Code : C++ - Déclaration sans initialisation - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">nomJoueur</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">nombreJoueurs</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">aGagne</span><span class="p">;</span>         <span class="c1">//Le joueur a-t-il gagné ?</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Simple non ?   <img src="./cpp_files/langue.png" alt=":p" class="smilies">  Je savais que ça allait vous plaire. Et je vous offre même un schéma en bonus !<br>
<br>
<div class="centre"><img src="./cpp_files/286721.png" alt="La mémoire après avoir allouer 3 variables sans les initialiser"></div><br>
<br>
On a bien trois cases dans la mémoire et les trois étiquettes correspondantes. La chose nouvelle est que l'on ne sait pas ce que contiennent ces trois cases. Nous verrons dans le chapitre suivant comment modifier le contenu d'une variable et donc remplacer ces points d'interrogation par d'autres valeurs plus intéressantes.<br>
<br>
<div class="rmq attention">Je viens de vous montrer comment déclarer des variables sans leur donner de valeur initiale. Je vous conseille par contre de <strong>toujours initialiser</strong> vos variables. Ce que je vous ai montré là, n'est à utiliser que dans les cas où l'on ne sait vraiment pas quoi mettre comme valeur. Ce qui est très rare. </div><br>
<br>
Il est temps d'apprendre à effectuer quelques opérations avec nos variables. Parce que vous en conviendrez, pour l'instant, on n'a pas appris grand chose d'utile. Notre écran est resté désespérément vide. <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420446">Afficher la valeur d'une variable</h2>
		<div class="ss_part_texte">
		Dans le chapitre précédent, vous avez appris à afficher du texte à l'écran. J'espère que vous vous souvenez encore de ce qu'il faut faire. <br>
<br>
Oui, c'est bien ça. Il faut utiliser <span class="code2 cpp"><span class="n">cout</span></span> et les chevrons (<span class="code2 cpp"><span class="o">&lt;&lt;</span></span>). Parfait. Parce que pour afficher le contenu d'une variable, c'est la même chose. A la place du texte à afficher, on met simplement le nom de la variable. <br>
<br>
<span class="code">Code : C++ - Afficher le contenu d'une variable - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ageUtilisateur</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Facile non ? <br>
<br>
Prenons un exemple complet pour essayer.<br>
<br>
<span class="code">Code : C++ - Exemple d'affichage - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Votre age est : "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ageUtilisateur</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Une fois compilé, ce code affiche ceci à l'écran:<br>
<br>
<span class="code">Code : Console - Résultat du code précédent - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Votre&nbsp;age&nbsp;est&nbsp;:&nbsp;16</pre></div></td></tr></tbody></table></div><br>
<br>
Exactement ce que l'on voulait !  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> On peut même faire encore plus simple. Tout mettre sur une seule ligne ! Et on peut même ajouter un retour à la ligne à la fin.<br>
<br>
<div class="rmq information">Pensez à mettre une espace à la fin du texte. Comme ça la valeur de votre variable sera détachée du texte lors de l'affichage.</div><br>
<br>
<span class="code">Code : C++ - Exemple d'affichage - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Votre age est : "</span> <span class="o">&lt;&lt;</span> <span class="n">ageUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Et on peut même afficher le contenu de plusieurs variables à la fois.<br>
<br>
<span class="code">Code : C++ - Plusieurs variables d'un coup ! - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">qiUtilisateur</span><span class="p">(</span><span class="mi">150</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">nomUtilisateur</span><span class="p">(</span><span class="s">"Albert Einstein"</span><span class="p">);</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous vous appelez "</span> <span class="o">&lt;&lt;</span> <span class="n">nomUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="s">" et votre QI vaut "</span> <span class="o">&lt;&lt;</span> <span class="n">qiUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce qui affiche le résultat escompté. <br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Vous&nbsp;vous&nbsp;appelez&nbsp;Albert&nbsp;Einstein&nbsp;et&nbsp;votre&nbsp;QI&nbsp;vaut&nbsp;150</pre></div></td></tr></tbody></table></div><br>
<br>
Mais je pense que vous n'en doutiez pas vraiment.  Nous verrons dans le chapitre suivant comment faire le contraire, récupérer la saisie d'un utilisateur et la stocker dans une variable.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420465">Les références</h2>
		<div class="ss_part_texte">
		Avant de terminer ce chapitre, il nous reste une notion importante à voir. Il s'agit des <strong>références</strong>. Je vous ai expliqué au tout début de ce chapitre qu'une variable pouvait être considérée comme étant une case mémoire avec une étiquette portant son nom. Dans la vraie vie, on peut très bien mettre plusieurs étiquettes sur un objet donné, en C++ c'est la même chose, on peut coller une deuxième (troisième, ..., dixième, etc.) étiquette à une case mémoire. <br>
On obtient alors un deuxième moyen d'accéder à la <strong>même</strong> case mémoire. Un petit peu comme si on donnait un surnom à une variable en plus de son nom normal. On parle parfois d'<strong>alias</strong>, mais le mot correct en C++ est <strong>référence</strong>.<br>
<br>
Schématiquement, on peut se représenter une référence comme ceci:<br>
<br>
<div class="centre"><img src="./cpp_files/281579.png" alt="Une variable et une référence sur cette variable"></div><br>
<br>
On a une seule case mémoire mais deux étiquettes qui y sont accrochées. <br>
<br>
Au niveau du code, on utilise une esperluette (<strong>&amp;</strong>) pour déclarer une référence sur une variable. Voyons ça avec un petit exemple.<br>
<br>
<span class="code">Code : C++ - Déclaration d'une référence - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>  <span class="c1">//Declaration d'une variable.</span>

<span class="kt">int</span><span class="o">&amp;</span> <span class="n">maVariable</span><span class="p">(</span><span class="n">ageUtilisateur</span><span class="p">);</span> <span class="c1">//Declaration d'une reference nommee 'maVariable' qui est accrochee a la variable 'ageUtilisateur'.</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
A la ligne 1, on déclare une case mémoire nommée <span class="courrier">ageUtilisateur</span> dans laquelle on met le nombre <img src="./cpp_files/mimetex(6).cgi" alt="16">. Et à la ligne 3, on accroche une deuxième étiquette à cette case mémoire. On a donc dorénavant deux moyens d'accéder au même espace dans la mémoire de notre ordinateur.  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies"> <br>
<br>
On dit que <span class="courrier">maVariable</span> <strong>fait référence</strong> à <span class="courrier">ageUtilisateur</span>. <br>
<br>
<div class="rmq attention">La référence doit impérativement être du même type que la variable à laquelle elle est accrochée ! Un <span class="code2 cpp"><span class="kt">int</span><span class="o">&amp;</span></span> ne peut faire référence qu'à un <span class="code2 cpp"><span class="kt">int</span></span>, de même qu'un <span class="code2 cpp"><span class="n">string</span><span class="o">&amp;</span></span> ne peut être associé qu'à une variable de type <span class="code2 cpp"><span class="n">string</span></span>.</div><br>
<br>
Essayons pour voir. On peut afficher l'âge de l'utilisateur comme d'habitude et via une référence. <br>
<br>
<span class="code">Code : C++ - Exemple d'utilisation d'une référence - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">18</span><span class="p">);</span>   <span class="c1">//Une variable pour contenir l'âge de l'utilisateur</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">maReference</span><span class="p">(</span><span class="n">ageUtilisateur</span><span class="p">);</span> <span class="c1">//Et une référence sur la variable ageUtilisateur</span>

    <span class="c1">//On peut, a partir d'ici, utiliser 'ageUtilisateur' ou 'maReference' indistinctement.</span>
    <span class="c1">//puisque ce sont deux étiquettes de la même case en mémoire</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous avez "</span> <span class="o">&lt;&lt;</span> <span class="n">ageUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="s">"  ans. (via variable)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//On affiche comme toujours</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous avez "</span> <span class="o">&lt;&lt;</span> <span class="n">maReference</span> <span class="o">&lt;&lt;</span> <span class="s">" ans. (via reference)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>    <span class="c1">//Et on affiche en utilisant la référence</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce qui donne évidemment le résultat escompté.<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Vous&nbsp;avez&nbsp;18&nbsp;ans.&nbsp;(via&nbsp;variable)
Vous&nbsp;avez&nbsp;18&nbsp;ans.&nbsp;(via&nbsp;reference)</pre></div></td></tr></tbody></table></div><br>
<br>
Une fois qu'elle a été déclarée, on peut manipuler la référence comme si on manipulait la variable elle-même. Il n'y a <strong>aucune différence</strong> entre les deux.<br>
<br>
<div class="rmq question">Euh... Mais à quoi est-ce que ça peut bien servir ?</div><br>
<br>
Bonne question !  <img src="./cpp_files/smile.png" alt=":)" class="smilies">  C'est vrai que dans l'exemple que je vous ai donné, on peut très bien s'en passer. Mais imaginez que l'on ait besoin de cette variable dans deux parties très différentes du programme, des parties créées par différents programmeurs. Dans une des parties, un des programmeurs va s'occuper de la déclaration de la variable alors que l'autre programmeur va juste l'afficher. Ce deuxième programmeur aura juste besoin d'un accès à la variable et un alias sera donc suffisant. <br>
Pour l'instant, ça vous paraît très abstrait et inutile ? Il faut juste savoir que c'est un des éléments importants du C++ qui apparaîtra à de très nombreuses reprises dans ce cours. Il est donc important de se familiariser avec la notion avant de devoir l'utiliser dans des cas plus compliqués.
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Bon ! <br>
<br>
Récapitulons ce que nous avons appris. A la fin de ce chapitre, vous savez :<br>
<ul>
<li> Déclarer une variable, c'est-à-dire demander à l'ordinateur de nous prêter un peu de sa mémoire pour y stocker des informations. </li>
<li> Afficher le contenu d'une variable à l'écran.</li>
<li> Définir une référence (un alias) sur une autre variable.</li>
</ul><br>
Moi je trouve que c'est pas mal pour un seul chapitre. Il est donc temps de faire une pause avant de continuer avec des choses bien plus intéressantes : recevoir des informations de l'utilisateur et effectuer des opérations. Comme une calculatrice en fait. <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Assurez-vous que vous avez bien compris le tout parce que des variables vous allez en manger tout le restant de votre vie et notamment dans le chapitre suivant.  <img src="./cpp_files/hihi.png" alt="^^" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_420467">Une vraie calculatrice</h1>
	<div id="chap_intro">
	J'ai commencé à vous parler de variables dans le chapitre précédent en vous présentant la mémoire d'une calculatrice. Notre ordinateur étant une super-super-super-calculatrice, on doit pouvoir lui faire faire des calculs et pas juste sauvegarder des données. J'espère que ça vous intéresse, parce que c'est ce que je vais vous apprendre à faire. <br>
<br>
Nous allons commencer en douceur avec la première tâche qu'on effectue sur une calculette. Vous voyez de quoi je veux parler ? Oui c'est ça, écrire des nombres pour les mettre dans la machine. Nous allons donc voir comment demander des informations à l'utilisateur et comment les stocker dans la mémoire. Nous aurons donc besoin de .... variables ! <br>
<br>
Dans un deuxième temps, je vais vous présenter comment effectuer de petits calculs. Finalement, comme vous savez déjà comment afficher un résultat, vous pourrez mettre tout votre savoir en action avec un petit exercice.
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420429">Demander des informations à l'utilisateur</h2>
		<div class="ss_part_texte">
		Dans le chapitre précédent, je vous ai expliqué comment afficher des variables dans la console. Voyons maintenant comment faire le contraire, c'est-à-dire demander des informations à l'utilisateur pour les stocker dans la mémoire.<br>
<br>
<h3>Lecture depuis la console</h3><br>
<br>
Vous l'aurez remarqué, le C++ utilise pas mal de mots tirés de l'anglais. C'est notamment le cas pour le flux sortant <span class="code2">cout</span>, qui doit se lire "c-out". Ce qui est bien, c'est qu'on peut immédiatement en déduire le nom du flux entrant. Avec <span class="code2">cout</span>, les données sortent du programme, d'où le <span class="courrier">out</span>. Le contraire de <span class="courrier">out</span> en anglais étant <span class="courrier">in</span>, qui signifie "vers l'intérieur", on utilise <span class="code2">cin</span> pour faire entrer des informations dans le programme. <span class="code2">cin</span> se décompose aussi sous la forme "c-in" et se prononce "si-inne". C'est important pour les soirées entre programmeurs.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Ce n'est pas tout ! Associés à <span class="code2">cout</span>, il y avait les chevrons (<span class="code2">&lt;&lt;</span>). Dans le cas de <span class="code2">cin</span>, il y en a aussi, mais <strong>dans l'autre sens</strong> (<span class="code2">&gt;&gt;</span>). <br>
<br>
Voyons ce que ça donne avec un premier exemple.<br>
<br>
<span class="code">Code : C++ - Premier exemple de cin - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Quel age avez-vous ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>      <span class="c1">//On prepare une case memoire pour stocker un entier.</span>

<span class="ln-xtra">    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">ageUtilisateur</span><span class="p">;</span>   <span class="c1">//On fait entrer un nombre dans cette case.</span></span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous avez "</span> <span class="o">&lt;&lt;</span> <span class="n">ageUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="s">" ans !"</span> <span class="o">&lt;&lt;</span>  <span class="n">endl</span><span class="p">;</span> <span class="c1">//Et on l'affiche.</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je vous invite à tester ce programme. Voici ce que ça donne avec mon âge  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> :<br>
<br>
<span class="code">Code : Console - Quel âge avez-vous ? - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Quel&nbsp;age&nbsp;avez-vous&nbsp;?
22
Vous&nbsp;avez&nbsp;22&nbsp;ans&nbsp;!</pre></div></td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Que s'est-il passé exactement ?</div><br>
<br>
Le programme a affiché le texte <span class="code2 bash">Quel age avez-vous ?</span>. Jusque-là, rien de bien sorcier. Puis, comme on l'a vu précédemment, à la ligne 8, le programme demande une case mémoire pour stocker un <span class="code2">int</span> à l'ordinateur et il baptise cette case <span class="code2">ageUtilisateur</span>.<br>
Ensuite, ça devient vraiment intéressant. L'ordinateur affiche un curseur blanc clignotant et attend que l'utilisateur écrive quelque chose. Quand celui-ci a terminé et appuyé sur <span class="keyboard_shortcut">Entrée</span>, le programme prend ce qui a été écrit et met le contenu dans la case mémoire <span class="code2">ageUtilisateur</span> <span class="italique">à la place</span> du 0 qui s'y trouvait.<br>
Finalement, on retombe sur quelque chose de connu, puisque le programme affiche une petite phrase et le contenu de la variable. <br>
<br>
<h3>Une astuce pour les chevrons</h3><br>
<br>
Il arrive souvent que l'on se trompe dans le sens des chevrons.  Vous ne seriez pas le premier à écrire <span class="code2 cpp"><span class="n">cout</span> <span class="o">&gt;&gt;</span></span> ou <span class="code2 cpp"><span class="n">cin</span> <span class="o">&lt;&lt;</span></span>, ce qui est faux.<br>
Pour se souvenir du sens correct, je vous conseille de considérer les chevrons comme si c'étaient des flèches indiquant la direction dans laquelle les données se déplacent. Depuis la variable vers <span class="code2 cpp"><span class="n">cout</span></span> ou depuis <span class="code2 cpp"><span class="n">cin</span></span> vers votre variable. <br>
<br>
Le mieux est de prendre un petit schéma magique.  <img src="./cpp_files/magicien.png" alt=":magicien:" class="smilies"> <br>
<br>
<div class="centre"><img src="./cpp_files/286723.png" alt="Schéma mnémotechnique indiquant le sens des chevrons à utiliser"></div><br>
<br>
Quand on affiche la valeur d'une variable, les données sortent du programme, on utilise donc une flèche allant de la variable vers <span class="code2 cpp"><span class="n">cout</span></span>. Quand on demande une information à l'utilisateur, c'est le contraire, la valeur vient de <span class="code2 cpp"><span class="n">cin</span></span> et va dans la variable.<br>
<br>
Avec ça, plus moyen de se tromper !<br>
<br>
<h3>D'autres variables</h3><br>
<br>
Évidemment, ce que je vous ai présenté marche aussi avec d'autres types de variables. Voyons ça avec un petit exemple.<br>
<br>
<span class="code">Code : C++ - Lecture d'autres types de variables - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Quel est votre prenom ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">nomUtilisateur</span><span class="p">(</span><span class="s">"Sans nom"</span><span class="p">);</span>           <span class="c1">//On crée une case mémoire pour contenir une chaine de caractères</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">nomUtilisateur</span><span class="p">;</span>                       <span class="c1">//On remplit cette case avec ce qu'écrit l'utilisateur</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Combien vaut pi ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">piUtilisateur</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>                  <span class="c1">//On crée une case mémoire pour stocker un nombre réel</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">piUtilisateur</span><span class="p">;</span>                        <span class="c1">//Et on remplit cette case avec ce qu'écrit l'utilisateur</span>
     
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous vous appelez "</span> <span class="o">&lt;&lt;</span> <span class="n">nomUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="s">" et vous pensez que pi vaut "</span> <span class="o">&lt;&lt;</span> <span class="n">piUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="s">"."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je crois que je n'ai même pas besoin de donner d'explications. Je vous invite néanmoins à tester pour bien comprendre en détail ce qui se passe.<br>
<br>
<h3>Le problème des espaces</h3><br>
<br>
Avez-vous testé le code précédent en mettant votre nom et prénom ? Regardons ce que ça donne.<br>
<br>
<span class="code">Code : Console - Les soucis d'Albert - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Quel&nbsp;est&nbsp;votre&nbsp;prenom&nbsp;?
Albert&nbsp;Einstein
Combien&nbsp;vaut&nbsp;pi&nbsp;?
3.14
Vous&nbsp;vous&nbsp;appelez&nbsp;Albert&nbsp;et&nbsp;vous&nbsp;pensez&nbsp;que&nbsp;pi&nbsp;vaut&nbsp;3.14.</pre></div></td></tr></tbody></table></div><br>
<br>
 <img src="./cpp_files/blink.gif" alt="o_O" class="smilies">  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> Le nom de famille a disparu ! Que s'est-il passé ? <br>
<br>
C'est un problème d'espaces. Quand on appuie sur <span class="keyboard_shortcut">Entrée</span>, l'ordinateur copie ce qui a été écrit par l'utilisateur dans la case mémoire. Mais, il s'arrête à la première <span class="italique">espace</span> ou au premier <span class="italique">retour à la ligne</span>. Quand il s'agit d'un nombre, cela ne pose pas de problèmes puisqu'il n'y a pas d'espaces dans les nombres.<br>
Pour les <span class="code2 cpp"><span class="n">string</span></span>, le problème se pose. Il peut très bien y avoir une espace dans une chaîne de caractère. Et donc l'ordinateur va couper au mauvais endroit, c'est-à-dire après le premier mot.<br>
<br>
Il faudrait en fait pouvoir récupérer toute la ligne plutôt que juste le premier mot. Et si je vous le propose, c'est qu'il y a une solution pour le faire ! <br>
Il faut utiliser la <strong>fonction</strong> <span class="code2 cpp"><span class="n">getline</span><span class="p">()</span></span>. Nous verrons plus loin ce que sont exactement les fonctions, mais pour l'instant voyons comment faire dans ce cas particulier.<br>
<br>
Il faut remplacer la ligne <span class="code2 cpp"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">nomUtilisateur</span><span class="p">;</span></span> par un <span class="code2 cpp"><span class="n">getline</span><span class="p">()</span></span>.<br>
<br>
<span class="code">Code : C++ - Lecture d'une ligne complète - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Quel est votre nom ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">nomUtilisateur</span><span class="p">(</span><span class="s">"Sans nom"</span><span class="p">);</span>           <span class="c1">//On crée une case mémoire pour contenir une chaine de caractères</span>
<span class="ln-xtra">    <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">nomUtilisateur</span><span class="p">);</span>                <span class="c1">//On remplit cette case avec toute la ligne que l'utilisateur a écrite</span></span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Combien vaut pi ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">piUtilisateur</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>                  <span class="c1">//On crée une case mémoire pour stocker un nombre réel</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">piUtilisateur</span><span class="p">;</span>                        <span class="c1">//Et on remplit cette case avec ce qu'écrit l'utilisateur</span>
     
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous vous appelez "</span> <span class="o">&lt;&lt;</span> <span class="n">nomUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="s">" et vous pensez que pi vaut "</span> <span class="o">&lt;&lt;</span> <span class="n">piUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="s">"."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On retrouve les mêmes éléments qu'auparavant. Il y a <span class="code2 cpp"><span class="n">cin</span></span> et il y a le nom de la variable (<span class="code2 cpp"><span class="n">nomUtilisateur</span></span>), sauf que cette fois, le tout se trouve entre des parenthèses et séparé par une virgule et pas par des chevrons.<br>
<br>
<div class="rmq attention">L'ordre des éléments entre les parenthèses est très important. Il faut absolument mettre le <span class="code2 cpp"><span class="n">cin</span></span> en premier !</div><br>
<br>
Cette fois le nom ne sera pas tronqué lors de la lecture et notre ami Albert pourra utiliser notre programme sans soucis.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
<span class="code">Code : Console - Plus de soucis pour Albert - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Quel&nbsp;est&nbsp;votre&nbsp;nom&nbsp;?
Albert&nbsp;Einstein
Combien&nbsp;vaut&nbsp;pi&nbsp;?
3.14
Vous&nbsp;vous&nbsp;appelez&nbsp;Albert&nbsp;Einstein&nbsp;et&nbsp;vous&nbsp;pensez&nbsp;que&nbsp;pi&nbsp;vaut&nbsp;3.14.</pre></div></td></tr></tbody></table></div><br>
<br>
Voyons maintenant ce que l'on peut faire avec des variables. Par exemple, additionner deux nombres.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420442">Modifier des variables</h2>
		<div class="ss_part_texte">
		<h3>Changer le contenu d'une variable</h3><br>
<br>
Je vous ai expliqué dans l'introduction de ce chapitre que la mémoire de l'ordinateur ressemblait dans sa manière de fonctionner à celle d'une calculatrice. Ce n'est pas la seule similitude. On peut évidemment effectuer des opérations sur un ordinateur. Et cela se fait en utilisant des variables.<br>
<br>
Commençons par voir comment changer le contenu d'une variable. On utilise le symbole <strong>=</strong> pour effectuer un changement de valeur. Si j'ai une variable de type <span class="code2 cpp"><span class="kt">int</span></span> dont je veux modifier le contenu, j'écris le nom de ma variable, suivi d'un <strong>=</strong> et finalement la nouvelle valeur. C'est ce qu'on appelle l'<strong>assignation d'une variable</strong>.<br>
<br>
<span class="code">Code : C++ - Assignation d'une valeur - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">unNombre</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">//Je crée une case mémoire nommée 'unNombre' et qui contient le nombre 0.</span>

<span class="n">unNombre</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>   <span class="c1">//Je mets 5 dans la case mémoire 'unNombre'.</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On peut aussi directement assigner le contenu d'une variable à une autre.<br>
<br>
<span class="code">Code : C++ - Assignation d'une valeur - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//Déclaration de deux variables.</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//Assignation de la valeur de 'b' à 'a'.</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Que se passe-t-il exactement ?</div><br>
<br>
Quand il arrive à la ligne 3 du code précédent, l'ordinateur va lire le contenu de la case mémoire nommée <span class="code2 cpp"><span class="n">b</span></span>, soit le nombre <img src="./cpp_files/mimetex(7).cgi" alt="5">. Il va ensuite ouvrir la case dont le nom est <span class="code2 cpp"><span class="n">a</span></span> et il y écrit la valeur <img src="./cpp_files/mimetex(7).cgi" alt="5"> en remplaçant le <img src="./cpp_files/mimetex(8).cgi" alt="4"> qui s'y trouvait. Voyons ça avec un schéma.<br>
<br>
<div class="centre"><img src="./cpp_files/280311.png" alt="Assignation d&#39;une variable à une autre"></div><br>
<br>
On peut d'ailleurs afficher le contenu des deux variables pour vérifier.<br>
<br>
<span class="code">Code : C++ - Assignation d'une valeur - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//Déclaration de deux variables.</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a vaut : "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" et b vaut : "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Assignation !"</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//Assignation de la valeur de 'b' à 'a'.</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a vaut : "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" et b vaut : "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Avez-vous testé ? Non ? N'oubliez pas qu'il est important de tester les codes proposés pour bien comprendre. Bon, comme je suis gentil, je vous donne le résultat.<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>a&nbsp;vaut&nbsp;:&nbsp;4&nbsp;et&nbsp;b&nbsp;vaut&nbsp;:&nbsp;5&nbsp;
Assignation&nbsp;!
a&nbsp;vaut&nbsp;:&nbsp;5&nbsp;et&nbsp;b&nbsp;vaut&nbsp;:&nbsp;5</pre></div></td></tr></tbody></table></div><br>
<br>
Exactement ce que je vous avais prédit.<br>
<br>
<div class="rmq attention">La valeur de <span class="code2 cpp"><span class="n">b</span></span> n'a pas changé ! Il est important de se rappeler que lors d'une affectation, seule la variable <strong>à gauche</strong> du symbole = est modifiée. <br>
Cela ne veut pas dire que les deux variables sont égales ! Juste que le contenu de celle de droite est copié dans celle de gauche.</div><br>
<br>
C'est un bon début, mais on est encore loin d'une calculatrice. Il nous manque ... <br>
<br>
... les opérations ! <br>
<br>
<h3>Une vraie calculatrice de base !</h3><br>
Commençons avec l'opération la plus simple, l'addition bien sûr. Et je pense que je ne vais pas trop vous surprendre en vous disant qu'on utilise le symbole <strong>+</strong>. <br>
<br>
C'est vraiment très simple à faire :<br>
<br>
<span class="code">Code : C++ - Votre première addition - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">resultat</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="ln-xtra"><span class="n">resultat</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">//Et hop une addition pour la route!</span></span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Comme c'est votre première opération, je vous décris ce qui se passe précisément. A la ligne 1, le programme crée trois cases dans la mémoire, nommées <span class="courrier">a</span>, <span class="courrier">b</span> et <span class="courrier">resultat</span>. Il remplit également ces cases avec les valeurs <img src="./cpp_files/mimetex(7).cgi" alt="5">, <img src="./cpp_files/mimetex(9).cgi" alt="8"> et <img src="./cpp_files/mimetex(2).cgi" alt="0"> respectivement. Tout ça, on commence à connaître.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
On arrive ensuite à la ligne 3. L'ordinateur voit qu'il va devoir modifier le contenu de la variable <span class="courrier">resultat</span>. Il regarde alors ce qu'il y a de l'autre côté du <strong>=</strong> et il trouve qu'il va devoir faire la somme du contenu de ce qui se trouve dans les cases mémoire <span class="courrier">a</span> et <span class="courrier">b</span>. Il regarde alors le contenu de <span class="courrier">a</span> et de <span class="courrier">b</span> <strong>sans le modifier</strong>, effectue le calcul et écrit la somme dans la variable <span class="courrier">resultat</span>. Tout ça en un éclair. Pour calculer, l'ordinateur est un vrai champion. <br>
<br>
On peut même vérifier que ça fonctionne si vous voulez.<br>
<br>
<span class="code">Code : C++ - Vérification - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>  
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">resultat</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">a</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

  <span class="n">resultat</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"5 + 8 = "</span> <span class="o">&lt;&lt;</span> <span class="n">resultat</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Et sur votre écran vous devriez voir :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>5&nbsp;+&nbsp;8&nbsp;=&nbsp;13</pre></div></td></tr></tbody></table></div><br>
<br>
Et ce n'est pas tout, il existe encore quatre autres opérations. Je vous ai mis un résumé des possibilités dans un petit tableau récapitulatif.<br>
<br>
<table class="tab_user">






<thead><tr><th>Opération</th><th>Symbole</th><th>Exemple</th></tr></thead><tbody><tr>
<td>Addition</td>
<td><div class="centre"><strong>+</strong></div></td>
<td><span class="code2">resultat&nbsp;=&nbsp;a&nbsp;+&nbsp;b;</span></td>
</tr><tr>
<td>Soustraction</td>
<td><div class="centre"><strong>-</strong></div></td>
<td><span class="code2">resultat&nbsp;=&nbsp;a&nbsp;-&nbsp;b;</span></td>
</tr><tr>
<td>Multiplication</td>
<td><div class="centre"><strong>*</strong></div></td>
<td><span class="code2">resultat&nbsp;=&nbsp;a&nbsp;*&nbsp;b;</span></td>
</tr><tr>
<td>Division</td>
<td><div class="centre"><strong>/</strong></div></td>
<td><span class="code2">resultat&nbsp;=&nbsp;a&nbsp;/&nbsp;b;</span></td>
</tr><tr>
<td>Modulo</td>
<td><div class="centre"><strong>%</strong></div></td>
<td><span class="code2">resultat&nbsp;=&nbsp;a&nbsp;%&nbsp;b;</span></td>
</tr></tbody></table><br>
<br>
<div class="rmq question">Mais, qu'est-ce que le modulo ? Je n'ai pas vu ça à l'école.</div><br>
Je suis sûr que si, mais pas forcément sous ce nom là. Il s'agit en fait du reste de la division entière. Par exemple, si vous ressortez vos cahiers d'école vous devriez retrouver des calculs tels que <img src="./cpp_files/mimetex(10).cgi" alt="13"> divisé par <img src="./cpp_files/mimetex(11).cgi" alt="3">. <br>
Comme <img src="./cpp_files/mimetex(10).cgi" alt="13"> n'est pas un multiple de <img src="./cpp_files/mimetex(11).cgi" alt="3">, il faut déduire quelque chose pour en obtenir un. C'est ce "quelque chose" qu'on appelle le reste de la division. Avec notre exemple, on peut écrire <img src="./cpp_files/mimetex(12).cgi" alt="13 = 4*3+1">. L'opérateur modulo calcule ce reste de la division. Peut-être que vous en aurez besoin un jour.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
<div class="rmq attention">Cet opérateur n'existe que pour les nombres entiers (<span class="code2 cpp"><span class="kt">int</span></span> et <span class="code2 cpp"><span class="kt">unsigned</span> <span class="kt">int</span></span>) !</div><br>
<br>
A partir des opérations de base, on peut tout à fait écrire des expressions mathématiques plus complexes qui nécessitent plusieurs variables. On peut également utiliser des parenthèses si nécessaire. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">d</span><span class="p">;</span> <span class="c1">//Quelques variables</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span> <span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span> <span class="c1">//Un calcul complique !</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La seule limite est votre imagination. Toute expression valide en math, l'est aussi en C++.  <img src="./cpp_files/magicien.png" alt=":magicien:" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420428">Les constantes</h2>
		<div class="ss_part_texte">
		Je vous ai présenté comment modifier des variables. J'espère que vous avez bien compris ! Parce qu'on va faire le contraire, en quelque sorte. Je vais vous montrer comment déclarer des variables non modifiables.  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> <br>
<br>
En termes techniques, on parle de <strong>constantes</strong>. Ça fait beaucoup de termes techniques pour un seul chapitre, mais je vous promet que dans la suite, ça va se calmer. <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
<div class="rmq question">Euh, mais à quoi ça peut bien servir des variables non modifiables ?</div><br>
<br>
Ah, je savais que vous alliez poser cette question. Je vous ai donc préparé une réponse aux petits oignons. <br>
<br>
Prenons le futur jeu vidéo révolutionnaire que vous allez créer. Comme vous êtes très fort, je pense qu'il y aura plusieurs niveaux, disons 10. Et bien ce nombre de niveaux ne va jamais changer durant l'exécution du programme. Entre le moment où l'utilisateur a lancé le jeu et le moment où il l'a quitté, il y a eu en permanence 10 niveaux dans votre jeu. Ce nombre est constant. En C++, on pourrait donc créer une variable <span class="code2 cpp"><span class="n">nombreNiveaux</span></span> qui serait une constante. <br>
<br>
Ce n'est bien sûr pas le seul exemple. Pensez à une calculatrice, elle aura besoin de la constante <img src="./cpp_files/mimetex(13).cgi" alt="\pi"> ou bien à un jeu où les personnages tombent, il faudra utiliser la constante d'accélération de la pesanteur <img src="./cpp_files/mimetex(14).cgi" alt="g=9.81">, etc. <br>
Ces valeurs ne vont jamais changer. <img src="./cpp_files/mimetex(13).cgi" alt="\pi"> vaudra toujours <img src="./cpp_files/mimetex(15).cgi" alt="3.14"> et l'accélération sur Terre est partout identique. Ce sont des constantes.  <img src="./cpp_files/smile.png" alt=":)" class="smilies"> <br>
<br>
Voyons donc comment déclarer une telle variable.<br>
<br>
<h3>Déclarer une constante</h3><br>
<br>
C'est très simple. On déclare une variable normale et on ajoute le mot-clé <span class="code2 cpp"><span class="k">const</span></span> entre le type et le nom. <br>
<br>
<span class="code">Code : C++ - Une constante - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="k">const</span> <span class="n">nombreNiveaux</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Et ça marche bien sûr avec tous les types de variables. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">string</span> <span class="k">const</span> <span class="n">motDePasse</span><span class="p">(</span><span class="s">"wAsTZsaswQ"</span><span class="p">);</span>  <span class="c1">//Le mot de passe secret</span>
<span class="kt">double</span> <span class="k">const</span> <span class="n">pi</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">pointsDeVieMaximum</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="c1">//Le nombre maximal de points de vie</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je pourrais encore continuer longtemps, mais je pense que vous avez saisi le principe. Vous n'êtes pas des futurs génies de l'informatique pour rien.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Vous verrez, on reparlera des constantes dans les chapitres suivants. En attendant, préparez-vous pour votre premier exercice.  <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420461">Un premier exercice</h2>
		<div class="ss_part_texte">
		Je crois qu'on a enfin toutes les clés en main pour réaliser votre premier vrai programme. Dans l'exemple précédent, le programme effectuait l'addition de deux nombres fixés à l'avance. Il serait bien mieux de demander à l'utilisateur quels nombres il veut additionner ! Voilà donc le sujet de notre premier exercice. Demander deux nombres à l'utilisateur, calculer la somme de ces deux nombres et finalement afficher le résultat.  <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> <br>
Rassurez-vous, je vais vous aider, mais je vous invite à essayer par vous-même avant de regarder la solution. C'est le meilleur moyen d'apprendre.<br>
<br>
Dans un premier temps, il faut toujours réfléchir aux variables qu'il va falloir utiliser dans le code. <br>
<div class="rmq question">De quoi avons-nous besoin ici ?</div><br>
Il nous faut une variable pour stocker le premier nombre entré par l'utilisateur et une autre pour stocker le deuxième. En se basant sur l'exemple précédent, on peut simplement appeler ces deux cases mémoires <span class="courrier">a</span> et <span class="courrier">b</span>. <br>
Il nous faut aussi une troisième case pour stocker le résultat du calcul. Appelons cette variable <span class="courrier">resultat</span> tout simplement. <br>
Finalement, il faut se poser la question du <strong>type</strong> de nos variables. Nous voulons faire des calculs, il nous faut donc prendre <span class="code2 cpp"><span class="kt">int</span></span>, <span class="code2 cpp"><span class="kt">unsigned</span> <span class="kt">int</span></span> ou <span class="code2 cpp"><span class="kt">double</span></span> selon les nombres que l'on veut utiliser. Je vote pour <span class="code2 cpp"><span class="kt">double</span></span>, afin de pouvoir utiliser des nombres à virgule. <br>
<br>
On peut donc déjà écrire un bout de notre programme, c'est-à-dire la structure de base et la déclaration des variables.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">double</span> <span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">resultat</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//Declaration des variables utiles</span>

   <span class="c1">//...</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La prochaine étape consiste à demander des nombres à l'utilisateur. Je pense que vous vous en souvenez encore, cela se fait grâce à <span class="code2 cpp"><span class="n">cin</span> <span class="o">&gt;&gt;</span></span>. On peut donc aller plus loin et écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">double</span> <span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">resultat</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//Declaration des variables utiles</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bienvenue dans le programme d'addition a+b !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Donnez une valeur pour a : "</span><span class="p">;</span>    <span class="c1">//Demande du premier nombre</span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Donnez une valeur pour b : "</span><span class="p">;</span>    <span class="c1">//Demande du deuxieme nombre</span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>

   <span class="c1">//...</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Il ne nous reste plus qu'à effectuer l'addition et afficher le résultat. Pour changer la valeur de <span class="courrier">resultat</span>, il va falloir utiliser le symbole <strong>=</strong> et pour effectuer l'addition, c'est bien sûr le <strong>+</strong> qu'il va falloir écrire. <br>
<br>
<span class="code">Code : C++ - Correction du premier exercice - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">double</span> <span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">resultat</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//Declaration des variables utiles</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bienvenue dans le programme d'addition a+b !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Donnez une valeur pour a : "</span><span class="p">;</span>    <span class="c1">//Demande du premier nombre</span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Donnez une valeur pour b : "</span><span class="p">;</span>    <span class="c1">//Demande du deuxieme nombre</span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>

   <span class="n">resultat</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">//On effectue l'operation</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" + "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">resultat</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//On affiche le resultat</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Mmmh, ça a l'air rudement bien tout ça ! Compilons et testons pour voir.<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Bienvenue&nbsp;dans&nbsp;le&nbsp;programme&nbsp;d'addition&nbsp;a+b&nbsp;!
Donnez&nbsp;une&nbsp;valeur&nbsp;pour&nbsp;a&nbsp;:&nbsp;123.784
Donnez&nbsp;une&nbsp;valeur&nbsp;pour&nbsp;b&nbsp;:&nbsp;51.765
123.784&nbsp;+&nbsp;51.765&nbsp;=&nbsp;175.549</pre></div></td></tr></tbody></table></div><br>
<br>
Magnifique ! Exactement ce qui était prévu ! <br>
<br>
Bon, j'ai assez travaillé. A vous maintenant de programmer. Je vous propose de vous entrainer en modifiant cet exercice. Voici quelques idées:<br>
<ul>	
<li>Calculer le produit de <span class="courrier">a</span> et <span class="courrier">b</span> plutôt que leur somme.</li>	
<li>Faire une opération plus complexe comme <img src="./cpp_files/mimetex(16).cgi" alt="a*b + c">.</li>	
<li>Demander deux nombres entiers et calculer leur quotient et le reste de la division.</li>
</ul><br>
Bon courage et amusez-vous bien !
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420470">Les raccourcis</h2>
		<div class="ss_part_texte">
		Après cet exercice, vous savez manipuler toutes les opérations de base. C'est peut-être surprenant pour vous, mais il n'en existe pas d'autres !  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> Avec ces 5 opérations, on peut tout faire, même des jeux vidéo comme ceux présentés dans le chapitre d'introduction. <br>
<br>
Il existe quand même quelques variantes qui, j'en suis sûr, vont vous plaire.<br>
<br>
<h3>L'incrémentation</h3><br>
<br>
Une des opérations les plus courantes en informatique c'est ajouter 1 à une variable. Pensez par exemple aux cas suivants :<br>
<ul>	
<li>Passer du niveau 4 au niveau 5 de votre jeu.</li>	
<li>Augmenter le nombre de vie du personnage.</li>	
<li>Ajouter un joueur à la partie.</li>	
<li>etc.</li>
</ul><br>
Cette opération est tellement courante qu'elle a un nom spécial. On parle d'<strong>incrémentation</strong>. Avec vos connaissances actuelles, vous savez déjà comment incrémenter une variable. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreJoueur</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">//Il y a 4 joueurs dans la partie</span>
<span class="n">nombreJoueur</span> <span class="o">=</span> <span class="n">nombreJoueur</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//On en ajoute un</span>
<span class="c1">//A partir d'ici, il y a 5 joueurs</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Bien ! Mais comme je vous l'ai dit, les informaticiens sont des fainéants et la 2<sup>e</sup> ligne de ce code est un peu trop longue à écrire. Les créateurs du C++ ont donc inventé une notation spéciale pour ajouter 1 à une variable. Voici comment.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreJoueur</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">//Il y a 4 joueurs dans la partie</span>
<span class="n">nombreJoueur</span><span class="o">++</span><span class="p">;</span>
<span class="c1">//A partir d'ici, il y a 5 joueurs</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On utilise le symbole <strong>++</strong>. On écrit le nom de la variable, suivi de <strong>++</strong> et finalement on met le point-virgule habituel. Ce code a <strong>exactement le même effet</strong> que le précédent. Il est juste plus court à écrire. <br>
<br>
Vous trouvez peut-être ça ridicule, mais je suis sûr que vous allez rapidement adorer ce genre de choses !  <img src="./cpp_files/smile.png" alt=":)" class="smilies"> <br>
<br>
<div class="rmq information">Cette astuce est tellement utilisée qu'elle est même présente dans le nom du langage ! Oui, oui, C++ veut en quelque sorte dire "C incrémenté", ou en meilleur français, "C amélioré". Ils sont fous ces informaticiens.  <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> </div><br>
<br>
<h3>La décrémentation</h3><br>
<br>
La <strong>décrémentation</strong> est l'opération inverse. Soustraire 1 à une variable. <br>
<br>
La version sans raccourci s'écrit comme ceci.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreJoueur</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">//Il y a 4 joueurs dans la partie</span>
<span class="n">nombreJoueur</span> <span class="o">=</span> <span class="n">nombreJoueur</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//On en enleve un</span>
<span class="c1">//A partir d'ici, il y a 3 joueurs</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je suis presque sûr que vous connaissez la version courte. On utilise <strong>++</strong> pour ajouter 1, c'est donc <strong>--</strong> qu'il faut utiliser pour soustraire 1.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreJoueur</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">//Il y a 4 joueurs dans la partie</span>
<span class="n">nombreJoueur</span><span class="o">--</span><span class="p">;</span> <span class="c1">//On en enleve un</span>
<span class="c1">//A partir d'ici, il y a 3 joueurs</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Simple, non ?  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies"> <br>
<br>
<h3>Les autres opérations</h3><br>
<br>
Bon. Ajouter ou enlever 1, c'est bien, mais c'est pas non plus suffisant pour tout faire. Il existe des raccourcis pour toutes les opérations de base. <br>
<br>
Si l'on souhaite diviser une variable par 3, on devrait écrire en version longue :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">double</span> <span class="n">nombre</span><span class="p">(</span><span class="mi">456</span><span class="p">);</span> 
<span class="n">nombre</span> <span class="o">=</span> <span class="n">nombre</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
<span class="c1">//A partir d'ici, nombre vaut 456/3 = 152</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La version courte utilise le symbole <strong>/=</strong> pour obtenir <strong>exactement le même</strong> résultat.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">double</span> <span class="n">nombre</span><span class="p">(</span><span class="mi">456</span><span class="p">);</span> 
<span class="n">nombre</span> <span class="o">/=</span> <span class="mi">3</span><span class="p">;</span>
<span class="c1">//A partir d'ici, nombre vaut 456/3 = 152</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Il existe des raccourcis pour les 5 opérations de base, c'est-à-dire, <strong>+=</strong>, <strong>-=</strong>, <strong>*=</strong>, <strong>/=</strong> et <strong>%=</strong>. <br>
Je suis sûr que vous n'allez plus pouvoir vous en passer. Les essayer, c'est les adopter.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Je vous propose un petit exemple pour la route.<br>
<br>
<span class="code">Code : C++ - Utilisation des versions raccourcies des opérateurs - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">double</span> <span class="n">nombre</span><span class="p">(</span><span class="mf">5.3</span><span class="p">);</span>
   <span class="n">nombre</span> <span class="o">+=</span> <span class="mf">4.2</span><span class="p">;</span>       <span class="c1">//nombre vaut maintenant 9.5</span>
   <span class="n">nombre</span> <span class="o">*=</span> <span class="mf">2.</span><span class="p">;</span>        <span class="c1">//nombre vaut maintenant 19</span>
   <span class="n">nombre</span> <span class="o">-=</span> <span class="mf">1.</span><span class="p">;</span>        <span class="c1">//nombre vaut maintenant 18</span>
   <span class="n">nombre</span> <span class="o">/=</span> <span class="mf">3.</span><span class="p">;</span>        <span class="c1">//nombre vaut maintenant 6</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ces opérations sont utiles quand il faut ajouter ou soustraire autre chose que 1.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420436">Encore plus de maths !</h2>
		<div class="ss_part_texte">
		Vous en voulez encore ? Ah je vois, vous n'êtes pas satisfait de votre calculatrice. C'est vrai qu'elle est encore un peu pauvre, elle ne connaît que les opérations de base. Pas vraiment génial pour la super-super-calculatrice qu'est votre ordinateur. <br>
<br>
Ne partez pas ! J'ai mieux à vous proposer.<br>
<br>
<h3>L'en-tête cmath</h3><br>
<br>
Pour avoir accès à plus de fonctions mathématiques, il faut ajouter une ligne en haut de votre programme, comme lorsque l'on désire utiliser des variables de type <span class="code2 cpp"><span class="n">string</span></span>. Il faut ajouter <br>
<br>
<span class="code">Code : C++ - Ligne à ajouter pour les fonctions mathématiques - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;cmath&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Jusque là, c'est très simple. Et dans <span class="courrier">cmath</span> il y a "math", ce qui devrait vous réjouir. On est sur la bonne voie.  <img src="./cpp_files/smile.png" alt=":)" class="smilies"> <br>
<br>
<div class="rmq information">Je vais vous présenter comment utiliser quelques fonctions mathématiques en C++. Il se peut très bien que vous ne sachiez pas ce que sont ces fonctions. Ce n'est pas grave, elles ne vous seront pas utiles dans la suite du cours. Vous saurez ce qu'elles représentent quand vous aurez fait un peu plus de maths. </div><br>
 <br>
Commençons avec une fonction très souvent utilisée, la racine carrée. En anglais, racine carrée se dit <span class="italique">square root</span> et en abrégé on écrit parfois <strong>sqrt</strong>.  <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies">  Comme le C++ utilise l'anglais, c'est ce mot là qu'il va falloir retenir et utiliser. <br>
<br>
Pour utiliser une fonction mathématique, on écrit le nom de la fonction, suivi de la valeur à calculer entre parenthèses. On utilise alors l'affectation pour stocker le résultat dans une variable.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">resultat</span> <span class="o">=</span> <span class="n">fonction</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est comme en math quand on écrit <img src="./cpp_files/mimetex(17).cgi" alt="y = f(x)">. Il faut juste se souvenir du nom compliqué des fonctions. Pour la racine carrée, cela donnerait <span class="code2 cpp"><span class="n">resultat</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span></span>.<br>
<br>
<div class="rmq erreur">N'oubliez pas le point-virgule à la fin de la ligne !</div><br>
<br>
Prenons un exemple complet, je pense que vous allez comprendre rapidement le principe.<br>
<br>
<span class="code">Code : C++ - La racine carrée - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;cmath&gt;  </span><span class="c1">//Ne pas oublier cette ligne </span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">nombre</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>       <span class="c1">//Le nombre dont on veut la racine</span>
    <span class="kt">double</span> <span class="n">resultat</span><span class="p">;</span>         <span class="c1">//Une case mémoire pour stocker le résultat</span>

    <span class="n">resultat</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">nombre</span><span class="p">);</span>  <span class="c1">//On effectue le calcul !</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"La racine de "</span> <span class="o">&lt;&lt;</span> <span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" est "</span> <span class="o">&lt;&lt;</span> <span class="n">resultat</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voyons ce que ça donne.<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>La&nbsp;racine&nbsp;de&nbsp;16&nbsp;est&nbsp;4</pre></div></td></tr></tbody></table></div><br>
<br>
Wow ! Votre ordinateur calcule correctement. Mais je ne pense pas que vous en doutiez.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Voyons s'il y a d'autres fonctions à disposition.<br>
<br>
<h3>Quelques autres fonctions présentes dans cmath</h3><br>
<br>
Comme il y a beaucoup de fonctions, je vous propose de tout mettre dans un tableau. <br>
<br>
<table class="tab_user">











<thead><tr><th>Nom de la fonction</th><th>Symbole mathématique</th><th>Nom de la fonction en C++</th><th>Mini-exemple</th></tr></thead><tbody><tr>
<td>Racine carrée</td>
<td><img src="./cpp_files/mimetex(18).cgi" alt="\sqrt{x}"></td>
<td><span class="code2 cpp"><span class="n">sqrt</span><span class="p">()</span></span></td>
<td><span class="code2 cpp"><span class="n">resultat</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span></span></td>
</tr><tr>
<td>Sinus</td>
<td><img src="./cpp_files/mimetex(19).cgi" alt="\sin(x)"></td>
<td><span class="code2 cpp"><span class="n">sin</span><span class="p">()</span></span></td>
<td><span class="code2 cpp"><span class="n">resultat</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span></span></td>
</tr><tr>
<td>Cosinus</td>
<td><img src="./cpp_files/mimetex(20).cgi" alt="\cos(x)"></td>
<td><span class="code2 cpp"><span class="n">cos</span><span class="p">()</span></span></td>
<td><span class="code2 cpp"><span class="n">resultat</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span></span></td>
</tr><tr>
<td>Tangente</td>
<td><img src="./cpp_files/mimetex(21).cgi" alt="\tan(x)"></td>
<td><span class="code2 cpp"><span class="n">tan</span><span class="p">()</span></span></td>
<td><span class="code2 cpp"><span class="n">resultat</span> <span class="o">=</span> <span class="n">tan</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span></span></td>
</tr><tr>
<td>Exponentielle</td>
<td><img src="./cpp_files/mimetex(22).cgi" alt="e^x"></td>
<td><span class="code2 cpp"><span class="n">exp</span><span class="p">()</span></span></td>
<td><span class="code2 cpp"><span class="n">resultat</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span></span></td>
</tr><tr>
<td>Logarithme népérien</td>
<td><img src="./cpp_files/mimetex(23).cgi" alt="\ln{x}"></td>
<td><span class="code2 cpp"><span class="n">log</span><span class="p">()</span></span></td>
<td><span class="code2 cpp"><span class="n">resultat</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span></span></td>
</tr><tr>
<td>Logarithme en base 10</td>
<td><img src="./cpp_files/mimetex(24).cgi" alt="\log_{10}{x}"></td>
<td><span class="code2 cpp"><span class="n">log10</span><span class="p">()</span></span></td>
<td><span class="code2 cpp"><span class="n">resultat</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span></span></td>
</tr><tr>
<td>Valeur absolue</td>
<td><img src="./cpp_files/mimetex(25).cgi" alt="|x|"></td>
<td><span class="code2 cpp"><span class="n">fabs</span><span class="p">()</span></span></td>
<td><span class="code2 cpp"><span class="n">resultat</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span></span></td>
</tr><tr>
<td>Arrondi vers le bas</td>
<td><img src="./cpp_files/mimetex(26).cgi" alt="\lfloor x \rfloor"></td>
<td><span class="code2 cpp"><span class="n">floor</span><span class="p">()</span></span></td>
<td><span class="code2 cpp"><span class="n">resultat</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span></span></td>
</tr><tr>
<td>Arrondi vers le haut</td>
<td><img src="./cpp_files/mimetex(27).cgi" alt="\lceil x \rceil"></td>
<td><span class="code2 cpp"><span class="n">ceil</span><span class="p">()</span></span></td>
<td><span class="code2 cpp"><span class="n">resultat</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">valeur</span><span class="p">);</span></span></td>
</tr></tbody></table><br>
<br>
Et il y en a encore beaucoup d'autres ! Je ne vous ai mis que les principales pour pas qu'on se perde.<br>
<br>
<div class="rmq information">On parle de mathématiques, ces fonctions ne sont donc utilisables qu'avec des variables qui représentent des nombres (<span class="code2 cpp"><span class="kt">double</span></span>, <span class="code2 cpp"><span class="kt">int</span></span> et <span class="code2 cpp"><span class="kt">unsigned</span> <span class="kt">int</span></span>). Prendre la racine carrée d'une lettre ou calculer le cosinus d'une phrase n'ont de tout façon pas de sens.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> </div><br>
<br>
<h3>Le cas de la fonction puissance</h3><br>
<br>
Comme toujours, il y a un cas particulier : la fonction puissance. Comment calculer <img src="./cpp_files/mimetex(28).cgi" alt="4^5"> ? Il faut utiliser la fonction <span class="code2 cpp"><span class="n">pow</span><span class="p">()</span></span> qui est un peu spéciale. Elle prend <strong>deux arguments</strong>, c'est-à-dire qu'il faut lui mettre deux valeurs entre les parenthèses. Comme pour la fonction <span class="code2 cpp"><span class="n">getline</span><span class="p">()</span></span> dont je vous ai parlé avant.<br>
<br>
Si je veux calculer <img src="./cpp_files/mimetex(28).cgi" alt="4^5">, je vais devoir faire comme ceci.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">double</span> <span class="n">a</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">b</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">resultat</span><span class="p">;</span>
<span class="n">resultat</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je déclare une variable pour mettre le <img src="./cpp_files/mimetex(8).cgi" alt="4">, une autre pour mettre le <img src="./cpp_files/mimetex(7).cgi" alt="5"> et finalement une dernière pour le résultat. Rien de nouveau jusque là. J'utilise la fonction <span class="code2 cpp"><span class="n">pow</span><span class="p">()</span></span> pour effectuer le calcul et j'utilise le symbole <strong>=</strong> pour stocker la valeur obtenue dans la variable <span class="code2 cpp"><span class="n">resultat</span></span>.<br>
<br>
Nous pouvons donc reprendre l'exercice précédent et remplacer l'addition par notre nouvelle amie, la fonction puissance.  <img src="./cpp_files/clin.png" alt=";)" class="smilies">  Je vous laisse essayer. <br>
<br>
Voici ma version:<br>
<br>
<span class="code">Code : C++ - La puissance de pow() - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;cmath&gt;  </span><span class="c1">//Ne pas oublier !</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">double</span> <span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">resultat</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//Déclaration des variables utiles</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bienvenue dans le programme de calcul de a^b !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Donnez une valeur pour a : "</span><span class="p">;</span>    <span class="c1">//Demande du premier nombre</span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Donnez une valeur pour b : "</span><span class="p">;</span>    <span class="c1">//Demande du deuxième nombre</span>
   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">;</span>

   <span class="n">resultat</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>   <span class="c1">//On effectue l'opération</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" ^ "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">resultat</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//On affiche le résultat</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous avez fait la même chose ? Parfait !  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> Vous êtes un futur champion du C++ ! Voyons quand même ce que ça donne.<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Bienvenue&nbsp;dans&nbsp;le&nbsp;programme&nbsp;de&nbsp;calcul&nbsp;de&nbsp;a^b&nbsp;!
Donnez&nbsp;une&nbsp;valeur&nbsp;pour&nbsp;a&nbsp;:&nbsp;4
Donnez&nbsp;une&nbsp;valeur&nbsp;pour&nbsp;b&nbsp;:&nbsp;5
4&nbsp;^&nbsp;5&nbsp;=&nbsp;1024</pre></div></td></tr></tbody></table></div><br>
<br>
J'espère que vous êtes satisfaits avec toutes ces fonctions mathématiques. Je ne sais pas si vous en aurez besoin un jour. Si c'est le cas, vous saurez où en trouver une description.  <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Nous voilà au terme de deux gros chapitres sur la mémoire. Dans cette deuxième partie, vous avez appris à modifier les variables grâce au symbole <strong>=</strong> et à effectuer des opérations mathématiques. <br>
<br>
Dans le chapitre suivant, nous allons laisser un peu la mémoire de côté pour nous intéresser à des moyens de modifier le déroulement d'un programme. Une vraie aventure !
	</div>
	
	<hr>
	<h1 id="chap_420444">Les structures de contrôle</h1>
	<div id="chap_intro">
	Les programmes doivent être capables de prendre des décisions. Pour y parvenir, les développeurs utilisent ce qu'on appelle des <strong>structures de contrôle</strong>. Ce nom un peu barbare cache en fait deux éléments que nous verrons dans ce chapitre :<br>
<br>
<ul>
<li>Les conditions : elles permettent d'écrire dans le programme des règles comme "Si ceci arrive, alors fais cela".</li>
<li>Les boucles : elles permettent de répéter une série d'instructions plusieurs fois.</li>
</ul><br>
<br>
Savoir manier les structures de contrôle est fondamental ! Bien que ce chapitre ne soit pas réellement difficile, il faut faire attention à bien comprendre ces notions de base. Elles vous serviront durant toute votre vie de développeurs C++... mais aussi dans d'autres langages, car le principe y est le même !<br>
<br>
<div class="rmq information">Ces outils sont en fait exactement les mêmes en C++ qu'en C. Si vous avez déjà programmé en C, vous ne devriez donc pas être dépaysés.<br>
Et si vous n'avez jamais fait de C de votre vie, ce n'est pas grave, nous allons tout apprendre dans ce chapitre. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div>
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420454">Les conditions</h2>
		<div class="ss_part_texte">
		Pour qu'un programme soit capable de prendre des décisions, on utilise des conditions dans le code source (on parle aussi de "structures conditionnelles"). Le principe est simple : vous voulez que votre programme réagisse différemment en fonction des circonstances. Nous allons découvrir ici comment utiliser ces fameuses conditions dans nos programmes C++. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Pour commencer, il faut savoir que les conditions permettent de tester des variables. Vous vous souvenez de ces variables stockées en mémoire que nous avons découvertes ? Eh bien nous allons maintenant apprendre à les analyser : "Est-ce que cette variable est supérieure à 10 ?", "Est-ce que cette variable contient bien le mot de passe secret ?"...<br>
<br>
Pour effectuer ces tests, nous utilisons des symboles. Voici le tableau des symboles à connaître <span class="souligne">par coeur</span> :<br>
<br>
<table class="tab_user">







<thead><tr><th>Symbole</th><th>Signification</th></tr></thead><tbody><tr>
<td>==</td>
<td>Est égal à</td>
</tr><tr>
<td>&gt;</td>
<td>Est supérieur à</td>
</tr><tr>
<td>&lt;</td>
<td>Est inférieur à</td>
</tr><tr>
<td>&gt;=</td>
<td>Est supérieur ou égal à</td>
</tr><tr>
<td>&lt;=</td>
<td>Est inférieur ou égal à</td>
</tr><tr>
<td>!=</td>
<td>Est différent de</td>
</tr></tbody></table><br>
<br>
<div class="rmq erreur">Faites très attention, il y a bien 2 symboles "=" pour tester l'égalité. Les débutants oublient souvent cela et n'écrivent qu'un seul "=", ce qui n'a pas la même signification en C++.</div><br>
<br>
Nous allons utiliser ces symboles pour effectuer des comparaisons dans nos conditions.<br>
<br>
Il faut savoir qu'il existe plusieurs types de conditions en C++ pour faire des tests, mais la plus importante qu'il faut impérativement connaître est sans aucun doute la condition <span class="code2">if</span>.<br>
<br>
<h3>La condition <span class="code2">if</span></h3><br>
<br>
Comme je vous le disais, les conditions permettent de tester des variables. Je vous propose donc de créer un petit programme en même temps que moi et de faire des tests pour vérifier que vous avez bien compris le principe.<br>
<br>
On va commencer avec ce code :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nbEnfants</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce code-là ne fait rien pour le moment. Il se contente de déclarer une variable nbEnfants (qui indique un nombre d'enfants donc), puis il s'arrête.<br>
<br>
<h4>Une première condition if</h4><br>
<br>
Imaginons qu'on souhaite afficher un message de félicitations si la personne a des enfants. On va ajouter une condition qui regarde si le nombre d'enfants est supérieur à 0 et qui affiche un message dans ce cas.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nbEnfants</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous avez des enfants, bravo !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fin du programme"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce code affiche :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Vous&nbsp;avez&nbsp;des&nbsp;enfants,&nbsp;bravo&nbsp;!
Fin&nbsp;du&nbsp;programme</pre></div></td></tr></tbody></table></div><br>
<br>
Regardez bien la ligne suivante :<br>
<span class="code2 cpp"><span class="k">if</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span></span><br>
<br>
Elle effectue le test : "<span class="italique">Si le nombre d'enfants est supérieur à 0</span>" (if, en anglais, veut dire "si").<br>
Si ce test est vérifié (donc si la personne a bien des enfants), alors l'ordinateur va lire les lignes qui se trouvent entre les accolades : il va donc afficher le message "Vous avez des enfants, bravo !".<br>
<br>
<div class="rmq question">Et si la personne n'a pas d'enfants, qu'est-ce qui se passe ?</div><br>
<br>
Dans le cas où le test n'est pas vérifié, l'ordinateur ne lit pas les instructions qui se trouvent entre accolades. Il saute donc à la ligne qui suit la fermeture des accolades.<br>
<br>
Dans notre cas, si la personne n'a aucun enfant, on verra seulement ce message apparaître :<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Fin&nbsp;du&nbsp;programme</pre></div></td></tr></tbody></table></div><br>
<br>
<strong>Faites le test !</strong> Changez la valeur de la variable <span class="code2 cpp"><span class="n">nbEnfants</span></span>, mettez-la à 0, et regardez ce qui se passe. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<h4>else : ce qu'il faut faire si la condition n'est pas vérifiée</h4><br>
<br>
Vous souhaitez que votre programme fasse quelque chose de précis si la condition n'est pas vérifiée ? C'est vrai que pour le moment, le programme est plutôt silencieux si vous n'avez pas d'enfants !<br>
<br>
Heureusement, vous pouvez utiliser le mot-clé <span class="code2 cpp"><span class="k">else</span></span> qui signifie "sinon". On va par exemple afficher un autre message si la personne n'a pas d'enfants :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nbEnfants</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous avez des enfants, bravo !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Eh bien alors, vous n'avez pas d'enfants ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fin du programme"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce code affiche :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Eh&nbsp;bien&nbsp;alors,&nbsp;vous&nbsp;n'avez&nbsp;pas&nbsp;d'enfants&nbsp;?
Fin&nbsp;du&nbsp;programme</pre></div></td></tr></tbody></table></div><br>
<br>
... car j'ai changé la valeur de la variable nbEnfants au début, regardez bien. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Si vous mettez une valeur supérieure à 0, le message redeviendra celui que nous avons vu avant !<br>
<br>
Bien, comment ça fonctionne ? C'est très simple en fait : l'ordinateur lit d'abord la condition du <span class="code2 cpp"><span class="k">if</span></span> et se rend compte que la condition est fausse. On vérifie si la personne a au moins 1 enfant et ce n'est pas le cas.<br>
L'ordinateur "saute" tout ce qui se trouve entre les premières accolades et tombe sur la ligne du <span class="code2 cpp"><span class="k">else</span></span> qui signifie "sinon". Il effectue donc les actions indiquées après le <span class="code2 cpp"><span class="k">else</span></span>.<br>
<br>
<div class="centre"><img src="./cpp_files/287595.png" alt="Condition if else"></div><br>
<br>
<h4>else if : effectuer un autre test</h4><br>
<br>
Il est possible de faire plusieurs tests à la suite. Imaginez qu'on souhaite faire le test suivant :<br>
<br>
<ul>	
<li>Si le nombre d'enfants est égal à 0, afficher ce message "[...]"</li>	
<li>Sinon si le nombre d'enfants est égal à 1, afficher ce message "[...]"</li>	
<li>Sinon si le nombre d'enfants est égal à 2, afficher ce message "[...]"</li>	
<li>Sinon, afficher ce message "[...]"</li>
</ul><br>
Pour faire tous ces tests un à un dans l'ordre, on va avoir recours à la condition "else if" qui signifie "sinon si". Les tests vont être lus dans l'ordre jusqu'à ce que l'un d'entre eux soit vérifié.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nbEnfants</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Eh bien alors, vous n'avez pas d'enfants ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Alors, c'est pour quand le deuxieme ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Quels beaux enfants vous avez la !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bon, il faut arreter de faire des gosses maintenant !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Fin du programme"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
Ca se complique ? Pas tant que ça. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Dans notre cas, nous avons 2 enfants :<br>
<ol class="liste_1">	
<li>L'ordinateur teste d'abord si on en a 0.</li>	
<li>Comme ce n'est pas le cas, il passe au premier else if : est-ce qu'on a 1 enfant ? Non plus !</li>	
<li>L'ordinateur teste donc le second else if : est-ce qu'on a 2 enfants ? Oui ! Donc on affiche le message "<span class="italique">Quels beaux enfants vous avez la !</span>".</li></ol><br>
Si aucune des conditions n'avait été vérifiée, c'est le message du else "Bon, il faut arreter de faire des gosses maintenant !" qui se serait affiché.<br>
<br>
<div class="centre"><img src="./cpp_files/287602.png" alt="Conditions if else if else"></div><br>
<br>
<h3>La condition switch</h3><br>
<br>
En théorie, la condition if permet de faire tous les tests que l'on veut. En pratique, il existe d'autres façons de faire des tests. La condition switch, par exemple, permet de simplifier l'écriture de conditions qui testent plusieurs valeurs différentes pour une même variable.<br>
<br>
Prenez par exemple le test qu'on vient de faire sur le nombre d'enfants :<br>
<br>
A-t-il 0 enfants ?<br>
A-t-il 1 enfant ?<br>
A-t-il 2 enfants ?<br>
...<br>
<br>
On peut faire ce genre de tests avec des if... else if... else, mais on peut faire la même chose avec une condition switch qui a tendance à rendre le code plus lisible dans ce genre de cas. Voici ce que donnerait la condition précédente avec un switch :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nbEnfants</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">nbEnfants</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Eh bien alors, vous n'avez pas d'enfants ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Alors, c'est pour quand le deuxieme ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Quels beaux enfants vous avez la !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">default</span><span class="o">:</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bon, il faut arreter de faire des gosses maintenant !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cela affiche :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Quels&nbsp;beaux&nbsp;enfants&nbsp;vous&nbsp;avez&nbsp;la&nbsp;!</pre></div></td></tr></tbody></table></div><br>
<br>
La forme est un peu différente : on indique d'abord qu'on va analyser la variable <span class="code2 cpp"><span class="n">nbEnfants</span></span>(ligne 9). Ensuite, on teste tous les cas (<span class="code2 cpp"><span class="k">case</span></span>) possibles : si ça vaut 0, si ça vaut 1, si ça vaut 2...<br>
<br>
Les <span class="code2 cpp"><span class="k">break</span></span> sont obligatoires si on veut que l'ordinateur ne continue pas d'autres tests une fois qu'il en a vérifié un. En pratique, je vous conseille d'en mettre toujours comme moi à la fin de chaque <span class="code2 cpp"><span class="k">case</span></span>.<br>
<br>
Enfin, le <span class="code2 cpp"><span class="k">default</span></span> à la fin correspond au <span class="code2 cpp"><span class="k">else</span></span> ("sinon") et s'exécute si aucun test précédent n'est vérifié.<br>
<br>
<div class="rmq information">Le <span class="code2 cpp"><span class="k">switch</span></span> ne permet de tester que l'égalité. Vous ne pouvez pas tester "Si le nombre d'enfants est supérieur à 2" avec un <span class="code2 cpp"><span class="k">switch</span></span> : il faut utiliser un <span class="code2 cpp"><span class="k">if</span></span> dans ce cas.<br>
De plus, le <span class="code2 cpp"><span class="k">switch</span></span> ne peut tester que des nombres entiers (<span class="code2 cpp"><span class="kt">int</span></span>, <span class="code2 cpp"><span class="kt">unsigned</span> <span class="kt">int</span></span>, <span class="code2 cpp"><span class="kt">char</span></span>). Il est impossible de tester des nombreux décimaux (<span class="code2 cpp"><span class="kt">double</span></span>) avec un <span class="code2 cpp"><span class="k">switch</span></span>.<br>
<br>
Le <span class="code2 cpp"><span class="k">switch</span></span> est donc limité en terme de possibilités mais il permet d'utiliser une écriture alternative qui peut être parfois pratique dans des cas simples.</div><br>
<br>
<h3>Les ternaires</h3><br>
<br>
Les ternaires sont un autre type de condition très... condensée. On les utilise peu, mais vous en verrez probablement un jour donc il vaut mieux vous les présenter. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Prenez ce code :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nbEnfants</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">parent</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Son fonctionnement est simple :<br>
<br>
<ol class="liste_1">	
<li>Si le nombre d'enfants est supérieur à 0, on met la variable booléenne "parent" à true (vrai).</li>	
<li>Sinon, on met "parent" à false (faux).</li></ol><br>
<br>
Dans un cas comme celui-ci où on fait un test et où on change la valeur d'une variable, on pourrait utiliser une forme ternaire.<br>
Voici le même code qui précédemment... mais en beaucoup beaucoup plus court !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nbEnfants</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">parent</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

<span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La ligne se lit à partir de "nbEnfants" : est-ce que le nombre d'enfants est supérieur à 0 ? Si oui, on met true dans la variable parent (tout à gauche), si non on met false. <br>
<br>
<div class="rmq question">Ouah c'est compliqué ! Est-ce que je dois vraiment connaître ça ? <img src="./cpp_files/huh.png" alt=":o" class="smilies"></div><br>
<br>
Non, rassurez-vous, je vous présente cette méthode mais nous n'allons pas vraiment l'utiliser... d'autant plus qu'on peut faire la même chose avec <span class="code2 cpp"><span class="k">if</span></span> ! Sachez juste que ça existe au cas où vous en rencontriez un jour dans un code. <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420463">Booléens et combinaisons de conditions</h2>
		<div class="ss_part_texte">
		Allons un peu plus loin avec les conditions. Nous allons découvrir deux notions un peu plus avancées mais néanmoins essentielles : les booléens et les combinaisons de conditions.<br>
<br>
<h3>Les booléens</h3><br>
<br>
Vous vous souvenez du type <span class="code2 cpp"><span class="kt">bool</span></span> ? Ce type de données peut stocker deux valeurs :<br>
<br>
<ul>	
<li><span class="code2 cpp"><span class="kc">true</span></span>(vrai)</li>	
<li><span class="code2 cpp"><span class="kc">false</span></span> (faux)</li>
</ul><br>
Ce type est souvent utilisé avec les conditions. Quand on y pense c'est logique : une condition est soit vraie, soit fausse. Une variable booléenne aussi. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Si je vous parle du type <span class="code2 cpp"><span class="kt">bool</span></span>, c'est parce qu'on peut l'utiliser d'une façon un peu particulière dans les conditions. Regardez ce code pour commencer :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">bool</span> <span class="n">adulte</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">adulte</span> <span class="o">==</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous etes un adulte !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cette condition, qui vérifie la variable <span class="code2 cpp"><span class="n">adulte</span></span>, affiche un message si celle-ci vaut vrai (true).<br>
<br>
Où je veux en venir ? En fait, il est possible d'omettre la partie "<span class="code2 cpp"><span class="o">==</span> <span class="kc">true</span></span>" dans la condition, cela revient au même ! Regardez ce code, qui est équivalent :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">bool</span> <span class="n">adulte</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

<span class="ln-xtra"><span class="k">if</span> <span class="p">(</span><span class="n">adulte</span><span class="p">)</span></span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous etes un adulte !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
L'ordinateur <span class="italique">comprend</span> que vous voulez vérifier si la variable booléenne vaut <span class="code2 cpp"><span class="kc">true</span></span>. Il n'est pas nécessaire de rajouter "<span class="code2 cpp"><span class="o">==</span> <span class="kc">true</span></span>".<br>
<br>
<div class="rmq question">Ca ne rend pas le code plus difficile à lire ça ? <img src="./cpp_files/huh.png" alt=":o" class="smilies"></div><br>
<br>
Non, au contraire le code est plus court et plus facile à lire !<br>
<span class="code2 cpp"><span class="k">if</span> <span class="p">(</span><span class="n">adulte</span><span class="p">)</span></span> se lit tout simplement "S'il est adulte".<br>
<br>
Je vous invite à utiliser cette notation raccourcie quand vous testerez des variables booléennes. Cela vous aidera à clarifier votre code et à rendre certaines conditions plus "digestes" à lire. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Combiner des conditions</h3><br>
<br>
Pour les conditions les plus complexes, sachez que vous pouvez faire plusieurs tests au sein d'un seul et même <span class="code2 cpp"><span class="k">if</span></span>. Pour cela, il va falloir utiliser de nouveaux symboles :<br>
<br>
<table class="tab_user">



<tbody><tr>
<td>&amp;&amp;</td>
<td>ET</td>
</tr><tr>
<td>||</td>
<td>OU</td>
</tr><tr>
<td>!</td>
<td>NON</td>
</tr></tbody></table><br>
<br>
<h4>Test ET</h4><br>
<br>
Imaginons : on veut faire tester si la personne est adulte ET si elle a 1 enfant au moins. On va écrire :<br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">if</span> <span class="p">(</span><span class="n">adulte</span> <span class="o">&amp;&amp;</span> <span class="n">nbEnfants</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les deux symboles "&amp;&amp;" signifient ET. Notre condition se dirait en français : "<span class="italique">Si la personne est adulte ET que le nombre d'enfants est supérieur ou égal à 1</span>"<br>
<br>
<div class="rmq information">Notez que j'aurais aussi pu écrire cette condition comme ceci : <span class="code2 cpp"><span class="k">if</span> <span class="p">(</span><span class="n">adulte</span> <span class="o">==</span> <span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="n">nbEnfants</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span></span><br>
Cependant, comme je vous l'ai expliqué un peu plus tôt, il est facultatif de préciser "<span class="code2 cpp"><span class="o">==</span> <span class="kc">true</span></span>" sur les booléens et c'est une habitude que je vous invite à prendre.</div><br>
<br>
<br>
<h4>Test OU</h4><br>
<br>
Pour faire un OU, on utilise les 2 signes ||. Je dois avouer que ce signe n'est pas facilement accessible sur nos claviers. Pour le taper sur un clavier AZERTY français, il faudra faire <span class="keyboard_shortcut">Alt Gr</span> + <span class="keyboard_shortcut">6</span>. Sur un clavier belge, il faudra faire <span class="keyboard_shortcut">Alt Gr</span> + <span class="keyboard_shortcut">&amp;</span> et finalement, pour les Suisses, c'est la combinaison <span class="keyboard_shortcut">Alt Gr</span> + <span class="keyboard_shortcut">7</span> qu'il faut utiliser.<br>
<br>
On peut par exemple tester si le nombre d'enfants est égal à 1 OU 2 :<br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">if</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">nbEnfants</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
<h4>Test NON</h4><br>
<br>
Il faut maintenant que je vous présente un dernier symbole : le point d'exclamation. En informatique, le point d'exclamation signifie "Non".<br>
Vous devez mettre ce signe <span class="souligne">avant</span> votre condition pour pouvoir dire "<span class="italique">Si cela n'est pas vrai</span>" :<br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adulte</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cela pourrait se traduire par "<span class="italique">Si la personne n'est pas adulte</span>".<br>

		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420472">Les boucles</h2>
		<div class="ss_part_texte">
		Les boucles vous permettent de répéter les mêmes instructions plusieurs fois dans votre programme. Le principe est le suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/7855.gif" alt="Image utilisateur"></div><br>
<br>
<ol class="liste_1">
<li><span class="rouge">L'ordinateur lit les instructions de haut en bas (comme d'habitude)</span></li>
<li><span class="vertf">Puis, une fois arrivé à la fin de la boucle, il repart à la première instruction</span></li>
<li><span class="rouge">Il recommence alors à lire les instructions de haut en bas...</span></li>
<li><span class="vertf">... Et il repart au début de la boucle.</span><br>
</li></ol><br>
Les boucles sont répétées tant qu'une condition est vraie. Par exemple on peut faire une boucle qui dit : "Tant que l'utilisateur donne un nombre d'enfants inférieur à 0, redemander le nombre d'enfants"...<br>
<br>
Il existe 3 types de boucles à connaître :<br>
<br>
<ul>	
<li>while</li>	
<li>do ... while</li>	
<li>for</li>
</ul><br>
Contrairement aux conditions, les 3 sont assez fréquemment utilisées (le for étant sensiblement plus utilisé).<br>
<br>
<h3>La boucle while</h3><br>
<br>
Cette boucle s'utilise comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Conditions à répéter */</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Tout ce qui est entre accolades sera répété tant que la condition est vérifiée.<br>
<br>
Essayons de faire ce que j'ai dit plus tôt : on redemande le nombre d'enfants à l'utilisateur tant que celui-ci est inférieur à 0. Ce genre de boucle permet de s'assurer que l'utilisateur rentre un nombre correct.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nbEnfants</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Nombre négatif pour pouvoir rentrer dans la boucle</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Combien d'enfants avez-vous ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">nbEnfants</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Merci d'avoir indique un nombre d'enfants correct. Vous en avez "</span> <span class="o">&lt;&lt;</span> <span class="n">nbEnfants</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voici un exemple d'utilisation de ce programme :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Combien&nbsp;d'enfants&nbsp;avez-vous&nbsp;?
-3
Combien&nbsp;d'enfants&nbsp;avez-vous&nbsp;?
-5
Combien&nbsp;d'enfants&nbsp;avez-vous&nbsp;?
2
Merci&nbsp;d'avoir&nbsp;indique&nbsp;un&nbsp;nombre&nbsp;d'enfants&nbsp;correct.&nbsp;Vous&nbsp;en&nbsp;avez&nbsp;2</pre></div></td></tr></tbody></table></div><br>
<br>
Tant que vous mettrez un nombre négatif, la boucle recommencera. En effet, elle teste <span class="code2 cpp"><span class="k">while</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span></span> c'est-à-dire "Tant que le nombre d'enfants est inférieur à 0". Dès que le nombre devient supérieur ou égal à 0, la boucle s'arrête et le programme continue après l'accolade fermante.<br>
<br>
<div class="rmq information">Vous noterez que j'ai initialisé la variable <span class="code2 cpp"><span class="n">nbEnfants</span></span> à -1. En effet, pour que l'ordinateur veuille bien rentrer une première fois dans la boucle, il faut faire en sorte que la condition soit vraie la première fois. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
<h3>La boucle do ... while</h3><br>
<br>
Cette boucle est très similaire à la précédente... si ce n'est que la condition n'est analysée qu'à la fin. Cela signifie que le contenu de la boucle sera toujours lu <strong>au moins une première fois</strong>.<br>
<br>
Cette boucle a cette forme :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">do</span>
<span class="p">{</span>
    <span class="cm">/* Instructions */</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notez bien la présence du point-virgule tout à la fin !<br>
<br>
Reprenons le code précédent et utilisons cette fois un do ... while :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nbEnfants</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Combien d'enfants avez-vous ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">nbEnfants</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nbEnfants</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Merci d'avoir indique un nombre d'enfants correct. Vous en avez "</span> <span class="o">&lt;&lt;</span> <span class="n">nbEnfants</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le principe est le même, le programme a le même comportement. Le gros intérêt du do ... while est qu'on s'assure que la boucle sera lue au moins une fois.<br>
D'ailleurs, du coup, il n'est pas nécessaire d'initialiser nbEnfants à -1 (c'est le principal avantage que procure cette solution). En effet, ici le nombre d'enfants est initialisé à 0 (comme on a l'habitude de faire), et comme la condition n'est testée qu'après le premier passage de la boucle, les instructions sont bien lues au moins une fois.<br>
<br>
<h3>La boucle for</h3><br>
<br>
Ce type de boucle, que l'on retrouve fréquemment, permet de condenser :<br>
<br>
<ul>	
<li>Une initialisation</li>	
<li>Une condition</li>	
<li>Une incrémentation</li>
</ul><br>
<br>
Voici sa forme :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">for</span> <span class="p">(</span><span class="n">initialisation</span> <span class="p">;</span> <span class="n">condition</span> <span class="p">;</span> <span class="n">incrementation</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Regardons un exemple concret qui affiche des nombres de 0 à 10 :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">compteur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">compteur</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">compteur</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="p">;</span> <span class="n">compteur</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compteur</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce code affiche :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>0
1
2
3
4
5
6
7
8
9
10</pre></div></td></tr></tbody></table></div><br>
<br>
On retrouve sur la ligne du for les 3 instructions que je vous ai indiquées :<br>
<br>
<ul>	
<li>Une initialisation (<span class="code2 cpp"><span class="n">compteur</span> <span class="o">=</span> <span class="mi">0</span></span>) : la variable compteur est mise à 0 au tout début de la boucle. Notez que ça avait été fait juste la ligne au-dessus donc ce n'était pas vraiment nécessaire ici.</li>	
<li>Une condition (<span class="code2 cpp"><span class="n">compteur</span> <span class="o">&lt;=</span> <span class="mi">10</span></span>) : on vérifie que la variable compteur ne dépasse pas 10 à chaque nouveau tour de boucle.</li>	
<li>Une incrémentation (<span class="code2 cpp"><span class="n">compteur</span><span class="o">++</span></span>) : à chaque tour de boucle, on ajoute 1 à la variable compteur ! Voilà pourquoi on voit s'afficher à l'écran des nombres de 0 à 10. <img src="./cpp_files/smile.png" alt=":)" class="smilies"></li>
</ul><br>
<div class="rmq information">Vous pouvez faire autre chose qu'une incrémentation si vous le désirez. La dernière section du <span class="code2 cpp"><span class="k">for</span></span> est réservée à la modification de la variable et vous pouvez donc y faire une décrémentation (<span class="code2 cpp"><span class="n">compteur</span><span class="o">--</span></span>) ou avancer de 2 en 2 (<span class="code2 cpp"><span class="n">compteur</span> <span class="o">+=</span> <span class="mi">2</span></span>), etc.</div><br>
<br>
Notez qu'il est courant d'initialiser la variable directement à l'intérieur du for, comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">compteur</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span> <span class="n">compteur</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="p">;</span> <span class="n">compteur</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compteur</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La variable n'existe alors que pendant la durée de la boucle for.<br>
<br>
<br>
<div class="rmq information">Quand utiliser un for et quand utiliser un while ?<br>
On utilise la boucle for quand on connaît le nombre de fois que l'on souhaite boucler, et on utilise le plus souvent la boucle while quand on ne sait pas combien de fois la boucle va être effectuée.</div>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Vous savez maintenant manier les structures de contrôle, ces éléments indispensables à tous les programmes informatiques ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Prenez le temps de vous approprier les codes présentés dans ce chapitre car nous allons utiliser des conditions et des boucles tout au long de ce cours !
	</div>
	
	<hr>
	<h1 id="chap_420464">Découper son programme en fonctions</h1>
	<div id="chap_intro">
	Nous venons de voir comment faire varier le déroulement d'un programme en utilisant des boucles et des branchements. Avant ça, je vous ai parlé des variables. Ce sont des éléments qui se retrouvent dans tous les langages de programmation. C'est aussi le cas de la notion que nous allons aborder dans ce chapitre :  les <strong>fonctions</strong>.<br>
<br>
Tous les programmes C++ utilisent des fonctions et vous en avez aussi utilisé plusieurs sans le savoir.  <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> <br>
Le but des fonctions est de découper son programme en petits éléments réutilisables, un peu comme des briques. On peut les assembler d'une certaine manière pour créer un mur, ou d'une autre manière pour faire un cabanon ou même un gratte-ciel. Une fois que les briques sont créées, la tâche du programmeur ne consiste "plus qu'à" les assembler. <br>
<br>
Commençons par créer des briques. Nous apprendrons à les utiliser dans un deuxième temps.
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420423">Créer et utiliser une fonction</h2>
		<div class="ss_part_texte">
		Dès le début de ce cours, nous avons utilisé des fonctions, toujours la même en fait. La fonction <span class="code2 cpp"><span class="n">main</span><span class="p">()</span></span>. C'est le point d'entrée de tous les programmes C++, c'est par là que tout commence. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="ln-xtra"><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="c1">//Debut de la fonction main() et donc du programme</span></span>
<span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bonjour tout le monde !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln-xtra"><span class="p">}</span> <span class="c1">//Fin de la fonction main() et donc du programme</span></span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le programme commence réellement à la ligne 4 et se termine à la ligne 8 après l'accolade fermante. C'est-à-dire que tout se déroule dans une seule et unique fonction. On n'en sort pas. Il n'y a qu'une seule portion de code qui est exécutée dans l'ordre sans jamais sauter ailleurs.<br>
<br>
Alors, si je vous dit tout ça, c'est vous vous en doutez, que l'on peut écrire d'autres fonctions. Et donc avoir un programme découpé en plusieurs modules indépendants. <br>
<br>
<div class="rmq question">Pourquoi vouloir faire ça ?</div><br>
<br>
C'est vrai après tout, mettre l'entièreté du code dans la fonction <span class="code2 cpp"><span class="n">main</span><span class="p">()</span></span> est tout à fait possible. Ce n'est cependant pas une bonne pratique.<br>
<br>
Imaginons que nous voulions créer un jeu vidéo 3D. Comme c'est quand même assez complexe, le code source va nécessiter plusieurs dizaines de milliers de lignes !  <img src="./cpp_files/triste.png" alt=":(" class="smilies"> Si l'on garde tout dans une seule fonction, il va être très difficile de s'y retrouver. Il serait certainement plus simple d'avoir un morceau de code dans un coin qui fait bouger un personnage et un autre bout de code ailleurs qui charge les niveaux, etc. Découper son programme en fonctions permet de s'<strong>organiser</strong>.<br>
En plus, si vous êtes plusieurs programmeurs à travailler sur le même programme, vous pourrez vous partager plus facilement le travail. Chacun travaille sur une fonction différente.<br>
<br>
Mais ce n'est pas tout ! <br>
Prenons par exemple le calcul de la racine carrée. Si vous créez un programme de maths, il est bien possible que vous ayez besoin à plusieurs endroits d'effectuer des calculs de racine. Avoir une fonction <img src="./cpp_files/mimetex(29).cgi" alt="sqrt()"> va nous permettre de faire plusieurs de ces calculs sans avoir à recopier le même code à plusieurs endroits. On peut <strong>utiliser plusieurs fois la même fonction</strong> et c'est une des raisons principales d'en écrire.<br>
<br>
<h3>Présentation des fonctions</h3><br>
<br>
Une fonction est un morceau de code qui accomplit une tâche particulière. Elle reçoit des données à traiter, effectue des actions avec et finalement renvoie une valeur.<br>
<br>
Les données entrantes s'appellent les <strong>arguments</strong> et on utilise l'expression <strong>valeur retournée</strong> pour les éléments qui sortent de la fonction.<br>
<br>
<div class="centre"><img src="./cpp_files/288117.png" alt="Une fonction traîte des arguments et produit une valeur de retour"></div><br>
<br>
Vous vous souvenez de <img src="./cpp_files/mimetex(30).cgi" alt="pow()"> ? La fonction qui permet de calculer des puissances ? En utilisant le nouveau vocabulaire, on peut dire que cette fonction :<br>
<ol class="liste_1">
<li> reçoit deux arguments.</li>
<li> effectue un calcul mathématique.</li>
<li> renvoie le résultat du calcul.</li></ol><br>
En utilisant un schéma comme le précédent, on peut imaginer <img src="./cpp_files/mimetex(30).cgi" alt="pow()"> comme ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/288118.png" alt="Schéma de la fonction pow()"></div><br>
<br>
Vous en avez déjà fait l'expérience, on peut utiliser cette fonction plusieurs fois. Ce qui implique que nous ne sommes pas obligés de copier le code (compliqué) qui se trouve à l'intérieur de <img src="./cpp_files/mimetex(30).cgi" alt="pow()"> à chaque fois que l'on souhaite effectuer un calcul de puissance.<br>
<br>
<h3>Définir une fonction</h3><br>
<br>
Bon bon, il est temps d'attaquer le concret. Il faut que je vous montre comment définir une fonction. Je pourrais vous dire de regarder comment <span class="code2 cpp"><span class="n">main</span><span class="p">()</span></span> est fait et vous laisser patauger, mais je suis sympa.  Je vais vous guider <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Vous êtes prêt ? Alors allons-y !<br>
<br>
Toutes les fonctions ont la forme suivante :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">type</span> <span class="n">nomFonction</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//Instructions effectuées par la fonction</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On retrouve les trois éléments dont je vous ai déjà parlé auquels s'ajoute le nom de la fonction.<br>
<br>
<ul>
<li>Le premier élément est le <strong>type de retour</strong>. Il permet d'indiquer le type de variable renvoyé par la fonction. Si votre fonction doit renvoyer du texte, alors ce sera <span class="code2 cpp"><span class="n">string</span></span>, si votre fonction effectue un calcul, alors ce sera <span class="code2 cpp"><span class="kt">int</span></span> ou <span class="code2 cpp"><span class="kt">double</span></span>.<br>
</li>
<li>Le deuxième élément est le <strong>nom de la fonction</strong>. Vous connaissez déjà <span class="code2 cpp"><span class="n">main</span><span class="p">()</span></span>, <span class="code2 cpp"><span class="n">pow</span><span class="p">()</span></span> ou <span class="code2 cpp"><span class="n">sqrt</span><span class="p">()</span></span>. L'important est de choisir un nom de fonction qui décrit bien ce que fait la fonction. Comme pour les variables en fait.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
</li>
<li>Entre les parenthèses, on trouve la <strong>liste des arguments</strong> de la fonction. Ce sont les données avec lesquelles la fonction va travailler. Il peut y avoir un argument (comme pour <span class="code2 cpp"><span class="n">sqrt</span><span class="p">()</span></span>), plusieurs arguments (comme pour <span class="code2 cpp"><span class="n">pow</span><span class="p">()</span></span>) ou aucun argument (comme pour <span class="code2 cpp"><span class="n">main</span><span class="p">()</span></span>).<br>
</li>
<li>Finalement, il y a des <strong>accolades</strong> qui délimitent le contenu de la fonction. Toutes les opérations qui seront effectuées se trouvent entre les deux accolades.<br>
</li>
</ul><br>
<br>
<div class="rmq information">Il est possible de créer <strong>plusieurs fonctions ayant le même nom.</strong> Il faut alors que la liste des arguments des deux fonctions soit différente. C'est ce qu'on appelle la <strong>surcharge </strong>d'une fonction.<br>
<br>
Dans un même programme, il peut par exemple y avoir la fonction <span class="code2 cpp"><span class="kt">int</span> <span class="n">addition</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span></span> et la fonction <span class="code2 cpp"><span class="kt">double</span> <span class="n">addition</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span></span>. Les deux fonctions ont le même nom mais une travaille avec des entiers et l'autre avec des nombres réels.</div><br>
<br>
Créons donc des fonctions ! <br>
<br>
<h3>Une fonction toute simple</h3><br>
<br>
Commençons par une fonction basique. Une fonction qui reçoit un nombre entier, ajoute 2 à ce nombre et le renvoie. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="kt">int</span> <span class="n">nombreRecu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">valeur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>           <span class="c1">//On cree une case en memoire.</span>
    <span class="n">valeur</span> <span class="o">=</span> <span class="n">nombreRecu</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//On prend le nombre recu en argument, on y ajoute 2.</span>
                             <span class="c1">//Et on met tout ça dans la memoire.</span>

    <span class="k">return</span> <span class="n">valeur</span><span class="p">;</span>           <span class="c1">//On indique que la valeur qui sort de la fonction</span>
                             <span class="c1">//est la valeur de la variable 'valeur'</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq attention">Il n'y a pas de point-virgule ! Ni après la déclaration, ni après l'accolade fermante.</div><br>
<br>
Analysons ce code en détail. Il y a deux lignes vraiment nouvelles pour vous.<br>
<br>
Avec ce que je vous ai expliqué, vous devriez comprendre la première ligne. On déclare une fonction nommée <span class="code2 cpp"><span class="n">ajouteDeux</span></span> qui va recevoir un nombre entier en argument et qui, une fois qu'elle aura terminé, va recracher un autre nombre entier.<br>
<br>
<div class="centre"><img src="./cpp_files/290751.png" alt="Image utilisateur"></div><br>
<br>
Toutes les lignes suivantes utilisent des choses déjà connues sauf l'avant-dernière. Si vous vous posez des questions sur ces lignes, je vous invite à relire le chapitre sur l'<a href="http://www.siteduzero.com/tutoriel-3-403539-1-utiliser-la-memoire.html">utilisation de la mémoire</a>.<br>
<br>
Le <span class="code2 cpp"><span class="k">return</span></span> de l'avant-dernière ligne indique quelle valeur va ressortir de la fonction. En l'occurrence, c'est la valeur de la variable <span class="code2 cpp"><span class="n">valeur</span></span> qui va être renvoyée.<br>
<br>
<h3>Appeler une fonction</h3><br>
<br>
Bon, c'est bien joli tout ça, mais il faut encore apprendre à l'utiliser cette fonction. C'est vrai, mais vous savez déjà le faire. Souvenez-vous des fonctions mathématiques ! <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="kt">int</span> <span class="n">nombreRecu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">valeur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">valeur</span> <span class="o">=</span> <span class="n">nombreRecu</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">valeur</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">b</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Valeur de a : "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Valeur de b : "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>                     <span class="c1">//Appel de la fonction</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Valeur de a : "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Valeur de b : "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h3>Plusieurs paramètres</h3><br>
<br>
On n'est pas encore au bout de nos peines. Il y a des fonctions qui prennent plusieurs paramètres, comme <span class="code2 cpp"><span class="n">pow</span><span class="p">()</span></span> et <span class="code2 cpp"><span class="n">getline</span><span class="p">()</span></span> par exemple.<br>
<br>
Pour passer plusieurs paramètres à une fonction, il faut les séparer par des virgules.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">addition</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="n">multiplication</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La première de ces fonctions calcule la somme des deux nombres qui lui sont fournis alors que la deuxième calcule le produit des trois nombres reçus.<br>
<br>
<div class="rmq information">Vous pouvez bien sûr écrire des fonctions qui prennent des arguments de type différent.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> </div><br>
<br>
<h3>Pas d'arguments</h3><br>
<br>
A l'inverse, il est aussi possible de créer des fonctions sans arguments.  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> Il faut simplement ne rien écrire entre les parenthèses !<br>
<br>
<div class="rmq question">Mais à quoi ça sert ?</div><br>
<br>
On peut imaginer plusieurs scénarios, mais pensez par exemple à une fonction qui demande à l'utilisateur d'entrer son nom. Elle n'a pas besoin de paramètres.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">string</span> <span class="n">demanderNom</span><span class="p">()</span>
<span class="p">{</span>    
     <span class="n">string</span> <span class="n">nom</span><span class="p">;</span>
     <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Entrez votre nom : "</span><span class="p">;</span>
     <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">nom</span><span class="p">;</span>
     <span class="k">return</span> <span class="n">nom</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je suis sûr que vous trouverez plein d'exemples par la suite ! Même si c'est vrai que ce type de fonctions est plus rare.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
<h3>Des fonctions qui ne renvoient rien</h3><br>
<br>
Tous les exemples que je vous ai donnés jusque-là prenaient des arguments et renvoyaient une valeur. Mais il est aussi possible d'écrire des fonctions qui ne renvoient rien. Enfin presque. <br>
Rien ne ressort de la fonction, mais quand on la déclare, il faut quand même indiquer un type. On utilise le "type" <span class="code2 cpp"><span class="kt">void</span></span>, ce qui signifie <span class="italique">néant</span> en anglais. Ça veut tout dire, il n'y a réellement rien qui ressort de la fonction.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
<span class="code">Code : C++ - Une fonction ne renvoyant rien - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">direBonjour</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bonjour !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Comme rien ne ressort, il n'y a pas de return !</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">direBonjour</span><span class="p">();</span>    <span class="c1">//Comme la fonction ne renvoie rien, on l'appelle</span>
                      <span class="c1">//sans mettre la valeur de retour dans une variable</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Avec ce dernier point, nous avons fait le tour de la théorie. Dans la suite du chapitre, je vous propose quelques exemples et un super schéma récapitulatif. Ce n'est pas le moment de partir.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420460">Quelques exemples</h2>
		<div class="ss_part_texte">
		<h3>Le carré</h3><br>
<br>
Commençons de manière simple. Calculer le carré d'un nombre. Cette fonction reçoit un nombre <img src="./cpp_files/mimetex(31).cgi" alt="x"> en argument et calcule la valeur de <img src="./cpp_files/mimetex(32).cgi" alt="x^2">. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">double</span> <span class="n">carre</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">resultat</span><span class="p">;</span>
    <span class="n">resultat</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">resultat</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">nombre</span><span class="p">,</span> <span class="n">carreNombre</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Entrez un nombre : "</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">nombre</span><span class="p">;</span>

    <span class="n">carreNombre</span> <span class="o">=</span> <span class="n">carre</span><span class="p">(</span><span class="n">nombre</span><span class="p">);</span> <span class="c1">//On utilise la fonction</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Le carre de "</span> <span class="o">&lt;&lt;</span> <span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="s">" est "</span> <span class="o">&lt;&lt;</span> <span class="n">carreNombre</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je vous avais promis un schéma, le voilà. Voyons ce qui se passe dans ce programme et dans quel ordre les lignes sont exécutées.<br>
<br>
<div class="centre"><img src="./cpp_files/290707.png" alt="Déroulement d&#39;un programme appelant une fonction."></div><br>
<br>
Il y a une chose dont il faut absolument se rappeler. Les valeurs des variables transmises aux fonctions sont <strong>copiées dans de nouvelles cases mémoires</strong>. La fonction <span class="code2 cpp"><span class="n">carre</span><span class="p">()</span></span> n'agit donc pas sur les variables déclarées dans la fonction <span class="code2 cpp"><span class="n">main</span><span class="p">()</span></span>. Elle travaille uniquement avec ses propres cases mémoires. <br>
Ce n'est que lors du <span class="code2 cpp"><span class="k">return</span></span> que les variables de <span class="code2 cpp"><span class="n">main</span><span class="p">()</span></span> sont modifiées. Ici la variable <span class="code2 cpp"><span class="n">carreNombre</span></span>. La variable <span class="code2 cpp"><span class="n">nombre</span></span> reste <strong>inchangée </strong>lors de l'appel à la fonction.<br>
<br>
<h3>Réutiliser la même fonction</h3><br>
<br>
L'intérêt d'utiliser une fonction ici est bien sûr de pouvoir calculer facilement le carré de différents nombres. Par exemple de tous les nombres entre 1 et 20 :<br>
<br>
<span class="code">Code : C++ - Calcul des carrés des nombres entre 1 et 20 - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">double</span> <span class="n">carre</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">resultat</span><span class="p">;</span>
    <span class="n">resultat</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">resultat</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">20</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Le carre de "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" est : "</span> <span class="o">&lt;&lt;</span> <span class="n">carre</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On écrit une seule fois la "formule" du calcul du carré et ensuite on utilise cette "brique" vingt fois. Ici, le calcul est simple, mais dans bien des cas, utiliser une fonction raccourcit beaucoup le code !<br>
<br>
<h3>Une fonction à deux arguments</h3><br>
<br>
Avant de terminer cette partie, voici un dernier exemple. Cette fois, je vous propose une fonction utilisant deux arguments. Nous allons dessiner un rectangle d'étoiles <strong>*</strong> dans la console. La fonction a besoin de deux arguments : la largeur et la hauteur du rectangle.<br>
<br>
<span class="code">Code : C++ - Dessin d'un rectangle d'étoiles - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">dessineRectangle</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">ligne</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">ligne</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">;</span> <span class="n">ligne</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">colonne</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">colonne</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">colonne</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*"</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">largeur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hauteur</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Largeur du rectangle : "</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">largeur</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">"Hauteur du rectangle : "</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">hauteur</span><span class="p">;</span>
    
    <span class="n">dessineRectangle</span><span class="p">(</span><span class="n">largeur</span><span class="p">,</span> <span class="n">hauteur</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Une fois compilé ce programme s'exécute et donnera par exemple :<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Largeur&nbsp;du&nbsp;rectangle&nbsp;:&nbsp;16
Hauteur&nbsp;du&nbsp;rectangle&nbsp;:&nbsp;3
****************
****************
****************</pre></div></td></tr></tbody></table></div><br>
<br>
Voilà la première version d'un logiciel de dessin révolutionnaire !<br>
<br>
Cette fonction ne fait qu'afficher du texte. Elle n'a donc pas besoin de renvoyer quelque chose. C'est pour ça, qu'elle est déclarée avec le "type" <span class="code2 cpp"><span class="kt">void</span></span>. <br>
On peut facilement modifier la fonction pour qu'elle renvoie la surface du rectangle. A ce moment-là, il faudra qu'elle renvoie un <span class="code2 cpp"><span class="kt">int</span></span>. <br>
<br>
Essayez de modifier cette fonction !  <img src="./cpp_files/diable.png" alt=":diable:" class="smilies">  Voici deux idées :<br>
<br>
<ul>	
<li>Afficher un message d'erreur si la hauteur ou la largeur est négative.</li>	
<li>Ajouter un argument pour le symbole à utiliser lors du dessin.</li>
</ul><br>
<br>
Amusez-vous bien. C'est important de bien maîtriser tous ces concepts. <br>
<br>
La fin de ce chapitre est consacrée à trois notions un peu plus avancées. Vous pourrez toujours y revenir plus tard si nécessaire. Mais n'oubliez pas le QCM ! <img src="./cpp_files/clin.png" alt=";)" class="smilies"> 
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420417">Passage par valeur et passage par référence</h2>
		<div class="ss_part_texte">
		La première des choses avancées dont il faut que je vous parle c'est la manière dont l'ordinateur gère la mémoire avec les fonctions.<br>
<br>
<h3>Passage par valeur</h3><br>
<br>
Prenons une fonction simple qui ajoute simplement deux à son argument. Vous commencez à bien la connaître. Je l'ai donc modifiée un poil.  <img src="./cpp_files/langue.png" alt=":p" class="smilies"> <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">a</span><span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Utiliser <strong>+=</strong> ici est volontairement bizarre ! Vous verrez tout de suite pourquoi.</div><br>
<br>
Testons donc cette fonction. Je pense ne rien vous apprendre en vous proposant le code suivant.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">a</span><span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nombre</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">resultat</span><span class="p">;</span>
    <span class="n">resultat</span> <span class="o">=</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="n">nombre</span><span class="p">);</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Le nombre original vaut : "</span> <span class="o">&lt;&lt;</span> <span class="n">nombre</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Le resultat vaut : "</span> <span class="o">&lt;&lt;</span> <span class="n">resultat</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce qui donne sans surprise :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Le&nbsp;nombre&nbsp;original&nbsp;vaut&nbsp;:&nbsp;4
Le&nbsp;resultat&nbsp;vaut&nbsp;:&nbsp;6</pre></div></td></tr></tbody></table></div><br>
<br>
L'étape intéressante est bien sûr ce qui se passe à la ligne 13. Vous vous rappelez des schémas de la mémoire ? Il est temps de les ressortir. <br>
<br>
Lors de l'appel à la fonction, il se passe énormément de choses :<br>
<ol class="liste_1">
<li>Le programme évalue la valeur de <span class="code2 cpp"><span class="n">nombre</span></span>. Il trouve <img src="./cpp_files/mimetex(8).cgi" alt="4">.</li>
<li>Le programme <strong>alloue un nouvel espace</strong> dans la mémoire et y écrit la valeur <img src="./cpp_files/mimetex(8).cgi" alt="4">. Cet espace mémoire possède l'étiquette <span class="code2 cpp"><span class="n">a</span></span>, le nom de la variable dans la fonction.</li>
<li>Le programme entre dans la fonction.</li>
<li>Le programme ajoute <img src="./cpp_files/mimetex(33).cgi" alt="2"> à la variable <span class="code2 cpp"><span class="n">a</span></span>.</li>
<li>La valeur de <span class="code2 cpp"><span class="n">a</span></span> est ensuite copiée et assignée à la variable <span class="code2 cpp"><span class="n">resultat</span></span>, qui vaut donc maintenant <img src="./cpp_files/mimetex(34).cgi" alt="6">.</li>
<li>On sort alors de la fonction.</li></ol><br>
<br>
Ce qui est important, c'est que la variable <span class="code2 cpp"><span class="n">nombre</span></span> est copiée dans une nouvelle case mémoire. On dit que <span class="code2 cpp"><span class="n">a</span></span> est <strong>passé par valeur</strong>. Lorsque le programme se situe dans la fonction, la mémoire ressemble donc à ce qui se trouve sur ce schéma :<br>
<br>
<div class="centre"><img src="./cpp_files/289598.png" alt="Etat de la mémoire lors du passage dans la fonction."></div><br>
<br>
On se retrouve donc avec trois cases dans la mémoire. L'autre élément important est que la variable <span class="code2 cpp"><span class="n">nombre</span></span> va rester inchangée. <br>
<br>
Si j'insiste sur ces points, c'est bien sûr que l'on peut faire autrement.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
<h3>Passage par référence</h3><br>
<br>
Vous vous rappelez des références ?  <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies">  Oui, oui, ces choses bizarres dont je vous ai parlé il y a quelques chapitres. Si vous n'êtes pas sûr de vous, n'hésitez-pas à vous <a href="http://www.siteduzero.com/tutoriel-3-403539-1-utiliser-la-memoire.html#ss_part_5">rafraichir la mémoire</a>. C'est le moment de voir à quoi servent ces drôles de bêtes.<br>
<br>
Plutôt que de copier la valeur de <span class="code2 cpp"><span class="n">nombre</span></span> dans la variable <span class="code2 cpp"><span class="n">a</span></span>, il est possible d'ajouter une "deuxième étiquette" à la variable <span class="code2 cpp"><span class="n">nombre</span></span> à l'intérieur de la fonction. Et c'est bien sûr une référence qu'il faut utiliser comme argument de la fonction.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="c1">//Notez le petit &amp; !!</span>
<span class="p">{</span>
    <span class="n">a</span><span class="o">+=</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Lorsque l'on appelle la fonction, il n'y a plus de copie. Le programme donne juste un alias à la variable <span class="code2 cpp"><span class="n">nombre</span></span>. Jetons un œil à la mémoire dans ce cas.<br>
<br>
<div class="centre"><img src="./cpp_files/289607.png" alt="État de la mémoire après un passage par référence"></div><br>
<br>
Cette fois, la variable <span class="code2 cpp"><span class="n">a</span></span> et la variable <span class="code2 cpp"><span class="n">nombre</span></span> sont confondues. On dit que l'argument <span class="code2 cpp"><span class="n">a</span></span> est <strong>passé par référence</strong>.<br>
<br>
<div class="rmq question">Quel intérêt y a-t-il à faire un passage par référence ?</div><br>
<br>
Cela va permettre à la fonction <span class="code2 cpp"><span class="n">ajouteDeux</span><span class="p">()</span></span> de modifier ses arguments ! Elle va ainsi pouvoir avoir une influence durable sur le reste du programme. Essayons pour voir. Reprenons le programme précédent, mais avec une référence comme argument. On obtient cette fois :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Le&nbsp;nombre&nbsp;original&nbsp;vaut&nbsp;:&nbsp;6
Le&nbsp;resultat&nbsp;vaut&nbsp;:&nbsp;6</pre></div></td></tr></tbody></table></div><br>
<br>
Que s'est-il passé ? C'est à la fois simple et compliqué.  <img src="./cpp_files/triste.png" alt=":(" class="smilies"> <br>
Comme <span class="code2 cpp"><span class="n">a</span></span> et la variable <span class="code2 cpp"><span class="n">nombre</span></span> correspondent à la même case mémoire, faire <span class="code2 cpp"><span class="n">a</span><span class="o">+=</span><span class="mi">2</span></span> a modifié la valeur de <span class="code2 cpp"><span class="n">nombre</span></span> ! <br>
Utiliser des références peut donc être très dangereux. C'est pour cela qu'on ne les utilise que quand on en a réellement besoin.<br>
<br>
<div class="rmq question">Justement, est-ce qu'on pourrait avoir un exemple utile ?</div><br>
<br>
J'y viens, j'y viens. Ne soyez pas trop pressés.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
L'exemple classique est la fonction <span class="code2 cpp"><span class="n">swap</span><span class="p">()</span></span>. C'est une fonction qui échange les valeurs des deux arguments qu'on lui fournit :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="kt">double</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">temporaire</span><span class="p">;</span>
    <span class="n">temporaire</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>     <span class="c1">//On sauvegarde la valeur de 'a'</span>
    <span class="n">a</span><span class="o">=</span><span class="n">b</span><span class="p">;</span>                <span class="c1">//On remplace la valeur de 'a' par celle de 'b'</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">temporaire</span><span class="p">;</span>     <span class="c1">//Et on utilise la valeur sauvegardee pour mettre la valeur de 'a' dans 'b'</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si l'on n'utilisait pas un passage par référence, alors ce seraient des copies des arguments qui seraient échangées. Et pas les vrais arguments. Cette fonction serait donc inutile. <br>
Je vous invite à tester cette fonction avec et sans les références. Vous verrez ainsi précisément ce qui se passe.<br>
<br>
A priori, le passage par référence peut vous sembler obscur et compliqué. Vous verrez par la suite qu'il est souvent utilisé. Vous pourrez toujours revenir lire cette partie plus tard si ce n'est pas vraiment clair dans votre esprit. <br>
Je vous rassure, il m'a fallu un moment pour vraiment saisir tout ça.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> 
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420427">Utiliser plusieurs fichiers</h2>
		<div class="ss_part_texte">
		Dans l'introduction, je vous ai dit que le but des fonctions était de pouvoir réutiliser les briques créées dans plusieurs programmes. <br>
Pour le moment, les fonctions que vous savez créer se situent à côté de la fonction <span class="code2 cpp"><span class="n">main</span><span class="p">()</span></span>. On ne peut donc pas vraiment les réutiliser. <br>
<br>
Le C++ permet de découper son programme en plusieurs fichiers sources. Chaque fichier contient une ou plusieurs fonctions. On peut alors inclure les fichiers, et donc les fonctions, dont on a besoin dans différents projets. On a ainsi réellement des briques séparées utilisables pour construire différents programmes.<br>
<br>
<h3>Les fichiers nécessaires</h3><br>
<br>
Pour faire les choses proprement, il ne faut pas un mais, deux fichiers  <img src="./cpp_files/smile.png" alt=":)" class="smilies"> :<br>
<ul>
<li> Un fichier source dont l'extension est <span class="italique">.cpp</span>. Ce fichier contient le code source de la fonction.</li>
<li> Un fichier d'en-tête dont l'extension est <span class="italique">.h</span>. Ce deuxième fichier contient uniquement la description de la fonction. Ce qu'on appelle le <strong>prototype </strong> de la fonction.</li>
</ul><br>
<br>
Créons donc ces deux fichiers pour notre célèbre fonction <span class="code2 cpp"><span class="n">ajouteDeux</span><span class="p">()</span></span> :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="kt">int</span> <span class="n">nombreRecu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">valeur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">valeur</span> <span class="o">=</span> <span class="n">nombreRecu</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">valeur</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Le fichier source</h4><br>
<br>
C'est le plus simple des deux. Allez dans le menu File / New /File. Choisissez ensuite C/C++ source. <br>
<br>
<div class="centre"><img src="./cpp_files/290628.png" alt="Créer un nouveau fichier source"></div><br>
<br>
Cliquez ensuite sur "Go". Comme lors de la création du projet, le programme vous demande ensuite si vous faites du C ou du C++. Choisissez "C++" bien sûr !  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Finalement, on vous demande le nom du fichier à créer. Comme pour tout, il vaut mieux choisir un nom intelligent pour ses fichiers. On peut ainsi mieux s'y retrouver. Pour la fonction <span class="code2 cpp"><span class="n">ajouteDeux</span><span class="p">()</span></span>, je choisis le nom <span class="italique">math.cpp</span> et je place le fichier dans le même dossier que mon fichier <span class="italique">main.cpp</span>. <br>
<br>
Cochez ensuite toutes les options.<br>
<br>
<div class="centre"><img src="./cpp_files/290630.png" alt="Sélection des options pour le fichier source"></div><br>
<br>
Cliquez sur "Finish". Votre fichier source est maintenant créé. Passons au fichier d'en-tête. <br>
<br>
<h4>Le fichier d'en-tête</h4><br>
<br>
Le début est quasiment identique. Ouvrez le menu File / new / File. Sélectionnez ensuite "C/C++ header". <br>
<div class="centre"><br>
<img src="./cpp_files/290633.png" alt="Création d&#39;un fichier d&#39;en-tête"></div><br>
<br>
Dans la fenêtre suivante, indiquez le nom du fichier à créer. Il est conseillé d'utiliser le <strong>même nom</strong> que pour le fichier source mais avec une extension <span class="italique">.h</span> au lieu de <span class="italique">.cpp</span>. Dans notre cas, ce sera <span class="italique">math.h</span>. Placez le fichier dans le même dossier que les deux autres.<br>
<br>
Ne touchez pas le champ juste en-dessous et n'oubliez pas de cocher toutes les options.<br>
<br>
<div class="centre"><img src="./cpp_files/290634.png" alt="Sélection des options pour le fichier d&#39;en-tête"></div><br>
<br>
Cliquez sur "Finish". Et voilà.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Une fois que les deux fichiers sont créés, vous devriez les voir apparaître dans la colonne de gauche de Code::Blocks :<br>
<br>
<div class="centre"><img src="./cpp_files/290636.png" alt="Les nouveaux fichiers du projet"></div><br>
<br>
<div class="rmq information">Le nom du projet sera certainement différent dans votre cas.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> </div><br>
<br>
<h3>Déclarer la fonction dans les fichiers</h3><br>
<br>
Maintenant que nous avons nos fichiers, il ne reste qu'à les remplir. <br>
<br>
<h4>Le fichier source</h4><br>
Je vous ai dit que le fichier source contenait la déclaration de la fonction. C'est un des éléments. <br>
L'autre est plus compliqué à comprendre. Le compilateur a besoin de savoir que les fichiers <span class="italique">.cpp</span> et <span class="italique">.h</span> ont un lien entre eux. Il faut donc commencer le fichier par la ligne suivante :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "math.h"</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous reconnaissez certainement cette ligne. Elle indique que l'on va utiliser ce qui se trouve dans le fichier <span class="italique">math.h</span>. <br>
<br>
<div class="rmq attention">Il faut utiliser des guillemets <strong>"</strong> ici et pas des chevrons <strong>&lt;</strong> et <strong>&gt;</strong> comme vous en aviez l'habitude jusque là.</div><br>
<br>
Le fichier <span class="italique">math.cpp</span> au complet est donc :<br>
<br>
<span class="code">Code : C++ - Le fichier math.cpp - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "math.h"</span>

<span class="kt">int</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="kt">int</span> <span class="n">nombreRecu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">valeur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">valeur</span> <span class="o">=</span> <span class="n">nombreRecu</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">valeur</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Le fichier d'en-tête</h4><br>
<br>
Si vous regardez le fichier qui a été créé, il n'est pas vide !  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> Il contient trois lignes mystérieuses :<br>
<br>
<span class="code">Code : C++ - Les gardes anti-inclusions multiples - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef MATH_H_INCLUDED</span>
<span class="cp">#define MATH_H_INCLUDED</span>


<span class="cp">#endif </span><span class="c1">// MATH_H_INCLUDED</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ces lignes sont là pour empêcher le compilateur d'inclure plusieurs fois ce fichier. Le compilateur n'est parfois pas très malin et risque de tourner en rond. Cette astuce évite de se retrouver dans cette situation. Il ne faut donc pas toucher ces lignes et surtout, écrire tout le code <strong>entre la deuxième et la troisième</strong>.<br>
<br>
<div class="rmq information">Le texte en majuscule sera différent pour chaque fichier. C'est le texte qui apparaît dans le champ que nous n'avons pas modifié lors de la création du fichier.</div><br>
<br>
Dans ce fichier, il faut mettre ce qu'on appelle le <strong>prototype</strong> de la fonction. C'est la première ligne de la fonction. Celle qui vient avant les accolades. On prend cette ligne et on ajoute un point-virgule à la fin.<br>
<br>
C'est donc très court. Voici ce que l'on obtient pour notre fonction :<br>
<br>
<span class="code">Code : C++ - Contenu du fichier d'en-tête - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef MATH_H_INCLUDED</span>
<span class="cp">#define MATH_H_INCLUDED</span>

<span class="kt">int</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="kt">int</span> <span class="n">nombreRecu</span><span class="p">);</span>

<span class="cp">#endif </span><span class="c1">// MATH_H_INCLUDED</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq erreur">N'oubliez pas le point-virgule ici !</div><br>
<br>
Et c'est tout.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> Il ne nous reste qu'une seule chose à faire : inclure tout ça dans le fichier <span class="italique">main.cpp</span>. Si on ne le fait pas, le compilateur ne saura pas où trouver la fonction <span class="code2 cpp"><span class="n">ajouteDeux</span><span class="p">()</span></span> lorsqu'on essaiera de l'utiliser. Il faut donc ajouter la ligne<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "math.h"</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
au début de notre programme. Ce qui donne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include "math.h"</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="n">b</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Valeur de a : "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Valeur de b : "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>                     <span class="c1">//Appel de la fonction</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Valeur de a : "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Valeur de b : "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Et voilà ! Nous avons maintenant réellement des briques séparées utilisables dans plusieurs programmes. Si vous voulez utiliser la fonction <span class="code2 cpp"><span class="n">ajouteDeux</span><span class="p">()</span></span> dans un autre projet, il vous suffira de copier les fichiers <span class="italique">math.cpp</span> et <span class="italique">math.h</span>.  <img src="./cpp_files/magicien.png" alt=":magicien:" class="smilies"> <br>
<br>
<div class="rmq information">On peut bien sûr mettre plusieurs fonctions par fichier. On les regroupe généralement par catégorie. Les fonctions mathématiques d'un côté, les fonctions pour l'affichage d'un menu dans un autre fichier et celle pour faire se déplacer un personnage de jeu vidéo dans un troisième. Programmer, c'est aussi être organisé.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> </div><br>
<br>
<h3>Documenter son code</h3><br>
<br>
Avant de terminer ce chapitre, je veux juste vous présenter un point qui peut sembler futile. On vous l'a dit dès le début, il est important de mettre des commentaires dans son programme pour comprendre ce qu'il fait. <br>
C'est particulièrement vrai pour les fonctions puisque vous allez peut-être utiliser des fonctions écrites par d'autres programmeurs. Il est donc important de savoir ce que font ces fonctions sans avoir besoin de lire tout le code ! (Rappelez-vous, le programmeur est fainéant...)<br>
<br>
Comme il y a de la place dans les fichiers d'en-tête, on en profite généralement pour décrire ce que font les fonctions. Il y a généralement trois choses décrites :<br>
<ol class="liste_1">
<li>Ce que fait la fonction.</li>
<li>La liste des ses arguments.</li>
<li>La valeur retournée.</li></ol><br>
<br>
Plutôt qu'un long discours, voici ce qu'on pourrait écrire pour notre fonction <span class="code2 cpp"><span class="n">ajouteDeux</span><span class="p">()</span></span> :<br>
<br>
<span class="code">Code : C++ - Le fichier math.h avec des commentaires - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef MATH_H_INCLUDED</span>
<span class="cp">#define MATH_H_INCLUDED</span>

<span class="cm">/**</span>
<span class="cm"> * Fonction qui ajoute 2 au nombre reçu en argument</span>
<span class="cm"> * - nombreRecu : Le nombre auquel la fonction ajoute 2</span>
<span class="cm"> * Valeur retournée : nombreRecu + 2</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">ajouteDeux</span><span class="p">(</span><span class="kt">int</span> <span class="n">nombreRecu</span><span class="p">);</span>

<span class="cp">#endif </span><span class="c1">// MATH_H_INCLUDED</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Bien sûr, dans ce cas, le descriptif est très simple. Mais c'est une habitude qu'il faut prendre. C'est d'ailleurs tellement courant de mettre des commentaires dans les fichiers <span class="italique">.h</span> qu'il existe des systèmes quasi-automatiques qui génèrent des sites web ou des livres à partir de ces commentaires.  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> 
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420453">Des valeurs par défaut pour les arguments</h2>
		<div class="ss_part_texte">
		Les arguments de fonctions, vous commencez à connaître. Je vous en parle depuis le début du chapitre. Lorsque une fonction a trois arguments, il faut lui fournir trois valeurs pour qu'elle puisse fonctionner. <br>
Et bien, je vais vous montrer que ce n'est pas toujours le cas. <br>
<br>
Voyons tout ça avec la fonction suivante :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">total</span> <span class="o">=</span> <span class="n">heures</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">minutes</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">secondes</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cette fonction calcule le nombre de secondes en additionnant les heures, minutes et secondes qu'on lui envoie. Rien de bien compliqué ! <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Les variables <span class="code2 cpp"><span class="n">heures</span></span>, <span class="code2 cpp"><span class="n">minutes</span></span> et <span class="code2 cpp"><span class="n">secondes</span></span> sont les <strong>paramètres </strong>de la fonction <span class="code2 cpp"><span class="n">nombreDeSecondes</span><span class="p">()</span></span>. Ce sont des valeurs qu'elle reçoit, celles avec lesquelles elle va travailler.<br>
Mais ça, vous le savez déjà.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
<h3>Les valeurs par défaut</h3><br>
<br>
La nouveauté, c'est qu'on peut donner des valeurs par défaut à certains paramètres de nos fonctions. Ainsi, on ne sera pas obligé d'indiquer à chaque fois tous les paramètres lorsqu'on appelle une fonction !<br>
<br>
Pour bien voir comment on doit procéder, on va regarder le code complet. J'aimerais que vous le copiez dans votre IDE pour faire les tests en même temps que moi :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// Prototype de la fonction</span>
<span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">);</span>

<span class="c1">// Main</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Définition de la fonction</span>
<span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">total</span> <span class="o">=</span> <span class="n">heures</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">minutes</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">secondes</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce code donne le résultat suivant :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>4225</pre></div></td></tr></tbody></table></div><br>
<br>
Sachant qu'1 heure = 3600s, 10 minutes = 600s, 25 secondes =... 25s, le résultat est logique car <img src="./cpp_files/mimetex(35).cgi" alt="3600 + 600 + 25 = 4225">. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Bref, tout va bien.<br>
<br>
Maintenant supposons que l'on veuille rendre certains paramètres facultatifs, par exemple parce qu'on utilise en pratique plus souvent les heures que le reste.<br>
On va devoir modifier le prototype de la fonction (et non sa définition, attention).<br>
<br>
Indiquez la valeur par défaut que vous voulez donner aux paramètres si on ne les a pas renseignés lors de l'appel de la fonction :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Dans cet exemple, seul le paramètre heures sera obligatoire, les deux autres étant désormais facultatifs. Si on ne renseigne pas les minutes et les secondes, les variables vaudront alors 0 dans la fonction.<br>
<br>
Voici le code complet que vous devriez avoir sous les yeux :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// Prototype avec les valeurs par défaut</span>
<span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// Main</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Définition de la fonction, SANS les valeurs par défaut</span>
<span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">total</span> <span class="o">=</span> <span class="n">heures</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">minutes</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">secondes</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq erreur">Si vous avez lu attentivement ce code, vous avez dû vous rendre compte de quelque chose : <span class="souligne">les valeurs par défaut sont spécifiées uniquement dans le prototype</span>, PAS dans la définition de la fonction ! Si votre code est découpé en plusieurs fichiers, alors il ne faut spécifier les valeurs par défaut uniquement dans le fichier d'en-tête <span class="italique">.h</span>. On se fait souvent avoir, je vous préviens... <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Si vous vous trompez, le compilateur vous indiquera une erreur à la ligne de la définition de la fonction.</div><br>
<br>
Bon, ce code ne change pas beaucoup du précédent. A part les valeurs par défaut dans le prototype, rien n'a été modifié (et le résultat à l'écran sera toujours le même).<br>
La nouveauté maintenant, c'est qu'on peut supprimer des paramètres lors de l'appel de la fonction (ici dans le <span class="code2 cpp"><span class="n">main</span><span class="p">()</span></span>). On peut par exemple écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le compilateur lit les paramètres de gauche à droite. Comme il n'y en a qu'un et que seules les heures sont obligatoires, il devine que la valeur "1" correspond à un nombre d'heures.<br>
<br>
Le résultat à l'écran sera le suivant :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>3600</pre></div></td></tr></tbody></table></div><br>
<br>
Mieux encore, vous pouvez indiquer juste les heures et les minutes si vous le désirez :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>4200</pre></div></td></tr></tbody></table></div><br>
<br>
Tant que vous indiquez au moins les paramètres obligatoires, il n'y a pas de problème. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Cas particuliers, attention danger</h3><br>
<br>
Bon, mine de rien il y a quand même quelques pièges, ce n'est pas si simple que ça ! <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
On va voir ces pièges sous la forme de questions / réponses :<br>
<br>
<div class="rmq question">Et si je veux envoyer à la fonction juste les heures et les secondes, mais pas les minutes ?</div><br>
<br>
Tel quel, c'est impossible. En effet, je vous l'ai dit plus haut, le compilateur va analyser les paramètres de gauche à droite. Le premier correspondra forcément aux heures, le second aux minutes et le troisième aux secondes.<br>
<br>
<strong>Vous ne pouvez PAS écrire :</strong><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">,,</span><span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est interdit. Si vous le faites, le compilateur vous fera comprendre qu'il n'apprécie guère vos manœuvres. C'est comme ça : en C++, on ne peut pas "sauter" des paramètres, même s'ils sont facultatifs. Si vous voulez indiquer le premier et le dernier paramètre, il vous faudra obligatoirement spécifier ceux du milieu. On devra donc écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Est-ce que je peux rendre juste les heures facultatives, et rendre les minutes et secondes obligatoires ?</div><br>
<br>
Si le prototype est défini dans le même ordre que tout à l'heure : non.<br>
<strong>Les paramètres facultatifs doivent obligatoirement se trouver à la fin</strong> (à droite).<br>
<br>
Ce code ne compilera donc pas :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">);</span>
                                  <span class="c1">// Erreur, les paramètres par défaut doivent être à droite</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La solution, pour régler ce problème, consiste à placer le paramètre <span class="italique">heures </span>à la fin :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">secondes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">heures</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
                                                <span class="c1">// OK</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Est-ce que je peux rendre tous mes paramètres facultatifs ?</div><br>
<br>
Oui, ça ne pose pas de problème :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Dans ce cas, l'appel de la fonction pourra être fait comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le résultat retourné sera bien entendu 0 dans notre cas. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<h3>Règles à retenir</h3><br>
<br>
En résumé, il y a 2 règles que vous devez retenir pour les valeurs par défaut :<br>
<br>
<ul>
<li>Seul le prototype doit contenir les valeurs par défaut (pas la définition de la fonction).</li>
<li>Les valeurs par défaut doivent se trouver à la fin de la liste des paramètres ("à droite").</li>
</ul>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Souvenez-vous qu'il est très important de découper son programme en fonctions. Dans certaines entreprises, on oblige les gens à faire des fonctions dès qu'un morceau de code dépasse une hauteur d'écran ! C'est peut-être un peu extrême, mais force les programmeurs à avoir la bonne attitude, découper, découper et découper encore.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Au terme de ce chapitre, vous connaissez les variables, les branchements et les fonctions. Vous connaissez donc presque tous les concepts de base.  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> Dans le chapitre suivant, nous allons découvrir un nouveau type de variables.
	</div>
	
	<hr>
	<h1 id="chap_420445">Les tableaux</h1>
	<div id="chap_intro">
	Vous êtes encore là ?<br>
<br>
Bien ! Vous êtes maintenant familiers avec la notion de variable et vous avez pu voir à quel point les utiliser est important. Il est temps maintenant d'aborder des types de variables un petit peu plus complexes : les tableaux. <br>
<br>
Dans de très nombreux programmes, on a besoin d'avoir plusieurs variables du même type et qui jouent quasiment le même rôle. Pensez par exemple à la liste des utilisateurs d'un site web. Cela représente une grande quantité de variables de type <span class="code2 cpp"><span class="n">string</span></span>. Ou les dix meilleurs scores de votre jeu que l'on stockera dans différentes cases mémoires, toutes de type <span class="code2 cpp"><span class="kt">int</span></span>. <br>
Le C++, comme presque tous les langages de programmation, propose un moyen simple de regrouper des données identiques en un seul paquet. Et comme l'indique le titre du chapitre, on appelle ces regroupements de variables <strong>des tableaux</strong>.<br>
<br>
Dans ce chapitre, je vais vous apprendre à manipuler deux sortes de tableaux. Ceux dont la taille est connue à l'avance, comme pour la liste des dix meilleurs scores. Et ceux dont la taille peut varier en permanence comme la liste des visiteurs d'un site web qui, généralement, ne cesse de grandir. <br>
Vous vous en doutez certainement, les tableaux dont la taille est fixée à l'avance sont plus faciles à utiliser et c'est donc par eux que nous allons commencer.
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420432">Les tableaux statiques</h2>
		<div class="ss_part_texte">
		Je vous ai parlé dans l'introduction de l'intérêt des tableaux dans le cas où l'on a plusieurs variables du même type à stocker. Voyons cela avec un exemple bien connu, la liste des meilleurs scores du jeu révolutionnaire que vous allez créer un jour.  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies"> <br>
<br>
<h3>Un exemple d'utilisation</h3><br>
<br>
Si vous voulez afficher la liste des 5 meilleurs scores des joueurs, il va vous falloir en réalité deux listes. La liste des noms de joueurs et la liste des scores qu'ils ont obtenus. Il va donc falloir déclarer 10 variables pour mettre toutes ces informations dans la mémoire de l'ordinateur. On aura par exemple :<br>
<br>
<span class="code">Code : C++ - Les variables du 'Hall of fame' - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">string</span> <span class="n">nomMeilleurJoueur1</span><span class="p">(</span><span class="s">"Nanoc"</span><span class="p">);</span>
<span class="n">string</span> <span class="n">nomMeilleurJoueur2</span><span class="p">(</span><span class="s">"M@teo21"</span><span class="p">);</span>
<span class="n">string</span> <span class="n">nomMeilleurJoueur3</span><span class="p">(</span><span class="s">"Albert Einstein"</span><span class="p">);</span>
<span class="n">string</span> <span class="n">nomMeilleurJoueur4</span><span class="p">(</span><span class="s">"Isaac Newton"</span><span class="p">);</span>
<span class="n">string</span> <span class="n">nomMeilleurJoueur5</span><span class="p">(</span><span class="s">"Archimede"</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">meilleurScore1</span><span class="p">(</span><span class="mi">118218</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">meilleurScore2</span><span class="p">(</span><span class="mi">100432</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">meilleurScore3</span><span class="p">(</span><span class="mi">87347</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">meilleurScore4</span><span class="p">(</span><span class="mi">64523</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">meilleurScore5</span><span class="p">(</span><span class="mi">31415</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Et pour afficher tout ça, il va aussi falloir pas mal de travail.<br>
<br>
<span class="code">Code : C++ - Affichage du 'Hall of fame' - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"1) "</span> <span class="o">&lt;&lt;</span> <span class="n">nomMeilleurJoueur1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">meilleurScore1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2) "</span> <span class="o">&lt;&lt;</span> <span class="n">nomMeilleurJoueur2</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">meilleurScore2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"3) "</span> <span class="o">&lt;&lt;</span> <span class="n">nomMeilleurJoueur3</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">meilleurScore3</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"4) "</span> <span class="o">&lt;&lt;</span> <span class="n">nomMeilleurJoueur4</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">meilleurScore4</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"5) "</span> <span class="o">&lt;&lt;</span> <span class="n">nomMeilleurJoueur5</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">meilleurScore5</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce qui fait énormément de lignes ! Imaginez maintenant que vous vouliez afficher les 100 meilleurs scores et pas seulement les 5 meilleurs. Ça serait terrible. Il vous faudrait déclarer 200 variables et écrire 100 lignes quasiment identiques pour l'affichage ! Autant arrêter tout de suite, c'est beaucoup trop de travail. <img src="./cpp_files/rire.gif" alt=":lol:" class="smilies"> <br>
<br>
C'est là qu'interviennent les tableaux. Nous allons pouvoir déclarer les 100 meilleures scores et les noms des 100 meilleurs joueurs d'un seul coup. On va créer <strong>une seule</strong> case dans la mémoire qui aura de la place pour contenir les 100 <span class="code2 cpp"><span class="kt">int</span></span> qu'il nous faut et une deuxième pour contenir les 100 <span class="code2 cpp"><span class="n">string</span></span>. Magique non ?<br>
<br>
<div class="rmq attention">Il faut quand même que les variables aient un lien entre elles pour que l'utilisation d'un tableau soit justifiée. Mettre dans un même tableau l'âge de votre chien et le nombre d'internautes connectés n'est pas correct. Même si ces deux variables sont des <span class="code2 cpp"><span class="kt">int</span></span>.</div><br>
<br>
Dans cet exemple, nous avons besoin de 100 variables. C'est-à-dire 100 places dans le tableau. C'est ce qu'on appelle, en termes techniques, la <strong>taille</strong> du tableau. Si la taille du tableau reste inchangée et est fixée dans le code source, alors on parle d'un <strong>tableau statique</strong>. Parfait ! C'est ce dont nous avons besoin pour notre liste des 100 meilleurs scores.<br>
<br>
<h3>Déclarer un tableau statique</h3><br>
<br>
Comme toujours en C++, une variable est composée d'un nom et d'un type. Comme les tableaux sont des variables, cette règle reste valable. Il faut juste ajouter une propriété supplémentaire, la taille du tableau. Autrement dit, le nombre de compartiments que notre case mémoire va pouvoir contenir. <br>
<br>
La déclaration d'un tableau est très similaire à celle d'une variable :<br>
<br>
<img src="./cpp_files/287407.png" alt="Déclaration d&#39;un tableau statique"><br>
<br>
On indique le type, puis le nom choisi et enfin la taille du tableau entre crochets. Voyons ça avec un exemple.<br>
<br>
<span class="code">Code : C++ - Votre premier tableau - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">meilleurScore</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>   <span class="c1">//Declare un tableau de 5 entiers </span>

   <span class="kt">double</span> <span class="n">anglesTriangle</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>   <span class="c1">//Declare un tableau de 3 double</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voyons à quoi ressemble la mémoire avec un de nos schémas habituels.<br>
<br>
<div class="centre"><img src="./cpp_files/287234.png" alt="La mémoire de l&#39;ordinateur après avoir déclaré deux tableaux"></div><br>
<br>
On retrouve nos deux zones mémoires avec leurs étiquettes, mais cette fois, chaque zone est découpée en cases. Trois cases pour le tableau <span class="code2 cpp"><span class="n">anglesTriangle</span></span> et cinq cases pour le tableau <span class="code2 cpp"><span class="n">meilleurScore</span></span>. Pour l'instant toutes ces cases ne sont pas initialisées. Leur contenu est donc quelconque. <br>
<br>
Il est également possible de déclarer un tableau en utilisant comme taille une <strong>constante</strong> de type <span class="code2 cpp"><span class="kt">int</span></span> ou <span class="code2 cpp"><span class="kt">unsigned</span> <span class="kt">int</span></span>. On indique simplement le nom de la constante entre les crochets plutôt qu'un nombre.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="k">const</span> <span class="n">tailleTableau</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>  <span class="c1">//La taille du tableau</span>
<span class="kt">double</span> <span class="n">anglesIcosagone</span><span class="p">[</span><span class="n">tailleTableau</span><span class="p">];</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq attention">Il faut <strong>impérativement</strong> utiliser une <strong>constante</strong> comme taille du tableau.</div><br>
<br>
Je vous conseille de toujours utiliser des constantes comme taille de vos tableaux plutôt que d'indiquer directement la taille entre les crochets. C'est une bonne habitude à prendre.<br>
<br>
Bon. On a de la place dans la mémoire. Il ne nous reste plus qu'à l'utiliser.  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies"> <br>
<br>
<h3>Accéder aux éléments d'un tableau</h3><br>
<br>
Chaque case d'un tableau peut être utilisée comme n'importe quelle autre variable. Il n'y a aucune différence. Il faut juste y accéder d'une manière un peu spéciale. Il faut indiquer le nom du tableau et le numéro de la case. Dans le tableau <span class="code2 cpp"><span class="n">meilleurScore</span></span>, on a accès à cinq variables. La première case de <span class="code2 cpp"><span class="n">meilleurScore</span></span>, la deuxième, etc, jusqu'à la cinquième. <br>
<br>
Pour accéder à une case on utilise la syntaxe <span class="code2 cpp"><span class="n">nomDuTableau</span><span class="p">[</span><span class="n">numeroDeLaCase</span><span class="p">]</span></span>. Il y a juste une petite subtilité, la première case possède le numéro 0 et pas 1. Tout est en quelque sorte décalé de 1. Pour accéder à la 3<sup>e</sup> case de <span class="code2 cpp"><span class="n">meilleurScore</span></span> et y écrire une valeur, il faudra donc écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">meilleurScore</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
En effet, <img src="./cpp_files/mimetex(36).cgi" alt="3-1=2">, la 3<sup>e</sup> case possède le numéro 2. Si je veux remplir mon tableau des meilleurs scores comme dans l'exemple initial, je peux donc écrire :<br>
<br>
<span class="code">Code : C++ - Remplissage d'un tableau - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="k">const</span> <span class="n">nombreMeilleursScores</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">//La taille du tableau</span>

<span class="kt">int</span> <span class="n">meilleursScores</span><span class="p">[</span><span class="n">nombreMeilleursScores</span><span class="p">];</span>  <span class="c1">//Declaration du tableau</span>

<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">118218</span><span class="p">;</span> <span class="c1">//Remplissage de la premiere case</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100432</span><span class="p">;</span> <span class="c1">//Remplissage de la deuxiemecase</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">87347</span><span class="p">;</span> <span class="c1">//Remplissage de la troisieme case</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">64523</span><span class="p">;</span> <span class="c1">//Remplissage de la quatrieme case</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">31415</span><span class="p">;</span> <span class="c1">//Remplissage de la cinquieme case</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq attention">Comme tous les numéros de cases sont décalés, la dernière case a le numéro 4 et pas 5 !</div><br>
<br>
<h3>Parcourir un tableau</h3><br>
<br>
Le gros point fort des tableaux, c'est qu'on peut les parcourir en utilisant une boucle. On peut ainsi effectuer une action sur chacune des cases d'un tableau l'une après l'autre. Par exemple afficher le contenu des cases. <br>
<br>
On connaît à priori le nombre de cases du tableau, on peut donc utiliser une boucle <span class="code2 cpp"><span class="k">for</span></span>. Nous allons pouvoir utiliser la variable <span class="code2 cpp"><span class="n">i</span></span> de la boucle pour accéder au <span class="italique">i</span>ème élément du tableau. C'est fou, on dirait que c'est fait pour !<br>
<br>
<span class="code">Code : C++ - Parcourir un tableau - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="k">const</span> <span class="n">nombreMeilleursScores</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">//La taille du tableau</span>
<span class="kt">int</span> <span class="n">meilleursScores</span><span class="p">[</span><span class="n">nombreMeilleursScores</span><span class="p">];</span>  <span class="c1">//Declaration du tableau</span>

<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">118218</span><span class="p">;</span> <span class="c1">//Remplissage de la premiere case</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100432</span><span class="p">;</span> <span class="c1">//Remplissage de la deuxiemecase</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">87347</span><span class="p">;</span> <span class="c1">//Remplissage de la troisieme case</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">64523</span><span class="p">;</span> <span class="c1">//Remplissage de la quatrieme case</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">31415</span><span class="p">;</span> <span class="c1">//Remplissage de la cinquieme case</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nombreMeilleursScores</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">meilleursScores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La variable <span class="code2 cpp"><span class="n">i</span></span> va prendre succécivement les valeurs 0,1,2,3 et 4. Ce qui veut dire que ce seront les valeurs de <span class="code2 cpp"><span class="n">meilleursScores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></span> puis <span class="code2 cpp"><span class="n">meilleursScores</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></span> etc. qui seront envoyées dans <span class="code2 cpp"><span class="n">cout</span></span>.<br>
<br>
<div class="rmq erreur">Il faut faire très attention à ne pas dépasser la taille du tableau dans la boucle. Sinon, vous aurez droit à un plantage de votre programme. La dernière case dans cet exemple a le numéro <span class="code2 cpp"><span class="n">nombreMeilleursScores</span></span> <strong>moins un</strong>. Les valeurs autorisées de <span class="code2 cpp"><span class="n">i</span></span> sont tous les entiers entre 0 et <span class="code2 cpp"><span class="n">nombreMeilleursScores</span></span> <strong>moins un</strong> compris.</div><br>
<br>
Vous allez voir, le couple tableau - boucle <span class="code2 cpp"><span class="k">for</span></span> va devenir votre nouveau meilleur ami. En tout cas je l'espère. <img src="./cpp_files/clin.png" alt=";)" class="smilies"> C'est un outil très puissant.<br>
<br>
<h3>Un petit exemple</h3><br>
<br>
Allez, je vous propose un petit exemple un petit peu plus complexe. Nous allons utiliser le C++ pour calculer la moyenne de vos notes de l'année. Je vous propose de mettre toutes vos notes dans un tableau et d'utiliser une boucle <span class="code2 cpp"><span class="k">for</span></span> pour le calcul de la moyenne. <br>
<br>
Vous voyez comment faire ?  Parfait !  Je vous regarde.  <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies"> <br>
<br>
Bon. Ok. J'accepte de vous aider. Voyons donc tout ça étape par étape. Premièrement, il nous faut un tableau pour stocker les notes. Comme ce sont des nombres à virgule, il nous faut des <span class="code2 cpp"><span class="kt">double</span></span>. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="k">const</span> <span class="n">nombreNotes</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">notes</span><span class="p">[</span><span class="n">nombreNotes</span><span class="p">];</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La deuxième étape consiste à remplir ce tableau avec vos notes. J'espère que vous savez encore comment faire !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="k">const</span> <span class="n">nombreNotes</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">notes</span><span class="p">[</span><span class="n">nombreNotes</span><span class="p">];</span>

<span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">12.5</span><span class="p">;</span>
<span class="n">notes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">19.5</span><span class="p">;</span>  <span class="c1">//Bieeeen !</span>
<span class="n">notes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">6.</span><span class="p">;</span>    <span class="c1">//Pas bien !</span>
<span class="n">notes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="n">notes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">14.5</span><span class="p">;</span>
<span class="n">notes</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq attention">Je me répète, mais c'est important. La première case du tableau a le numéro 0. La deuxième a le numéro 1 et ainsi de suite.</div><br>
<br>
Pour calculer la moyenne, il nous faut additionner toutes les notes et ensuite diviser par le nombre de notes. Nous connaissons déjà le nombre de notes, puisque nous avons la constante <span class="code2 cpp"><span class="n">nombreNotes</span></span>. Il ne reste donc qu'à déclarer une variable pour contenir la moyenne.<br>
<br>
Le calcul de la somme s'effectue dans une boucle <span class="code2 cpp"><span class="k">for</span></span> qui va parcourir toutes les cases du tableau. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">double</span> <span class="n">moyenne</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nombreNotes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">moyenne</span> <span class="o">+=</span> <span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>   <span class="c1">//On additionne toutes les notes</span>
<span class="p">}</span>
<span class="c1">//En arrivant ici, la variable moyenne contient la somme des notes (79.5)</span>
<span class="c1">//Il ne reste donc qu'a diviser par le nombre de notes</span>
<span class="n">moyenne</span> <span class="o">/=</span> <span class="n">nombreNotes</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Avec une petite ligne pour l'affichage de la valeur, on obtient le résultat voulu. Un programme qui calcule la moyenne de vos notes.<br>
<br>
<span class="code">Code : C++ - Calcul de la moyenne des notes - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="k">const</span> <span class="n">nombreNotes</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
   <span class="kt">double</span> <span class="n">notes</span><span class="p">[</span><span class="n">nombreNotes</span><span class="p">];</span>

   <span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">12.5</span><span class="p">;</span>
   <span class="n">notes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">19.5</span><span class="p">;</span>  <span class="c1">//Bieeeen !</span>
   <span class="n">notes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">6.</span><span class="p">;</span>    <span class="c1">//Pas bien !</span>
   <span class="n">notes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
   <span class="n">notes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">14.5</span><span class="p">;</span>
   <span class="n">notes</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
   
   <span class="kt">double</span> <span class="n">moyenne</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nombreNotes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">moyenne</span> <span class="o">+=</span> <span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>   <span class="c1">//On additionne toutes les notes</span>
   <span class="p">}</span>
   <span class="c1">//En arrivant ici, la variable moyenne contient la somme des notes (79.5)</span>
   <span class="c1">//Il ne reste donc qu'a diviser par le nombre de notes</span>
   <span class="n">moyenne</span> <span class="o">/=</span> <span class="n">nombreNotes</span><span class="p">;</span>
   
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Votre moyenne est : "</span> <span class="o">&lt;&lt;</span> <span class="n">moyenne</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
Voyons ce que ça donne quand on l'exécute. <br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Votre&nbsp;moyenne&nbsp;est&nbsp;:&nbsp;13.25</pre></div></td></tr></tbody></table></div><br>
<br>
Et ça marche ! Vous n'en doutiez pas j'espère. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<h3>Les tableaux et les fonctions</h3><br>
<br>
Ah ! les fonctions. Vous n'avez pas oublié ce que c'est j'espère. Il faut quand même que je vous en reparle un peu. Comme vous allez le voir, les tableaux et les fonctions ne sont pas les meilleurs amis du monde. <br>
<br>
La première restriction est qu'<strong>on ne peut pas écrire une fonction qui renvoie un tableau</strong>. C'est impossible.  <img src="./cpp_files/triste.png" alt=":(" class="smilies"> <br>
<br>
La deuxième restriction est qu'un tableau statique est <strong>toujours passé par référence</strong>. Et il n'y a pas besoin d'utiliser l'esperluette (<strong>&amp;</strong>). C'est fait automatiquement. Cela veut dire que lorsqu'on passe un tableau à une fonction, cette dernière peut le modifier.<br>
<br>
Voici donc une fonction qui reçoit un tableau en argument.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">fontion</span><span class="p">(</span><span class="kt">double</span> <span class="n">tableau</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Il ne faut rien mettre entre les crochets.</div><br>
<br>
Mais ce n'est pas tout ! Très souvent, on va vouloir parcourir le tableau, avec une boucle <span class="code2 cpp"><span class="k">for</span></span> par exemple. Il nous manque une information cruciale. Vous voyez laquelle ?<br>
<br>
La taille ! A l'intérieur de la fonction précédente, il n'y a aucun moyen de connaître la taille du tableau ! Il faut donc <strong>impérativement ajouter un deuxième argument contenant la taille</strong>. Ce qui donne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">fontion</span><span class="p">(</span><span class="kt">double</span> <span class="n">tableau</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">tailleTableau</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Oui, je sais c'est ennuyeux. Mais il ne faut pas vous en prendre à moi. Je n'ai pas créé le langage.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Pour vous entraîner, je vous propose d'écrire une fonction <span class="code2 cpp"><span class="n">moyenne</span><span class="p">()</span></span> qui calcule la moyenne des valeurs d'un tableau. <br>
<br>
Voici ma version :<br>
<br>
<span class="spoiler_hidden">Secret <a href="#" onclick="switch_spoiler_hidden(this); return false;">(cliquez pour afficher)</a></span><div class="spoiler2_hidden"><div class="spoiler3_hidden"><span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="syntax"><pre><span class="cm">/*</span>
<span class="cm"> *  Fonction qui calcule la moyenne des éléments d'un tableau</span>
<span class="cm"> *  - tableau: Le tableau dont on veut la moyenne</span>
<span class="cm"> *  - tailleTableau: La taille du tableau</span>
<span class="cm"> */</span>
<span class="kt">double</span> <span class="n">moyenne</span><span class="p">(</span><span class="kt">double</span> <span class="n">tableau</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">tailleTableau</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">double</span> <span class="n">moyenne</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">tailleTableau</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">moyenne</span> <span class="o">+=</span> <span class="n">tableau</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>   <span class="c1">//On additionne toutes les valeurs</span>
   <span class="p">}</span>
   <span class="n">moyenne</span> <span class="o">/=</span> <span class="n">tailleTableau</span><span class="p">;</span>

   <span class="k">return</span> <span class="n">moyenne</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div></div></div><br>
<br>
Bon bon, assez parlé de ces tableaux. Passons à la suite.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420433">Les tableaux dynamiques</h2>
		<div class="ss_part_texte">
		Je vous avais dit que nous allions parler de deux sortes de tableaux différents. Ceux dont la taille est fixée et ceux dont la taille peut varier, les <strong>tableaux dynamiques</strong>. Certaines choses sont identiques, ce qui va nous permettre de ne pas tout répéter.<br>
<br>
<h3>Déclarer un tableau dynamique</h3><br>
<br>
La première différence se situe au tout début de votre programme. Il faut ajouter la ligne <span class="code2 cpp"><span class="cp">#include &lt;vector&gt;</span></span> pour utiliser ces tableaux.<br>
<br>
<div class="rmq information">A cause de cette ligne, on parle souvent de <span class="code2 cpp"><span class="n">vector</span></span> à la place de tableau dynamique. J'utiliserai ce terme parfois dans la suite.</div><br>
<br>
La deuxième grosse différence se situe dans la manière de déclarer un tableau. On utilise la syntaxe<br>
<br>
<img src="./cpp_files/287408.png" alt="Déclaration d&#39;un vector"><br>
<br>
Par exemple pour un tableau de 5 entiers, on écrit :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;vector&gt; </span><span class="c1">//Ne pas oublier !</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tableau</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Il faut remarquer trois choses.<br>
<ol class="liste_1">
<li>Le type n'est pas le premier mot de la ligne comme pour toutes les autres variables.</li>
<li>On utilise une notation bizarre avec un chevron ouvrant et un chevron fermant.</li>
<li>On écrit la taille entre des parenthèses et pas entre crochets.</li></ol><br>
<br>
Ce qui veut dire que ça ne ressemble pas vraiment aux tableaux statiques.  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies">  Mais vous allez voir, pour parcourir le tableau, le principe est similaire. <br>
Mais avant cela, il y a deux astuces bien pratiques à savoir. <br>
<br>
On peut directement remplir toutes les cases du tableau en ajoutant un deuxième argument entre les parenthèses. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tableau</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">//Cree un tableau de 5 entiers valant tous 3</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">listeNoms</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="s">"Sans nom"</span><span class="p">);</span> <span class="c1">//Cree un tableau de 12 strings valant toutes "Sans nom"</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On peut déclarer un tableau sans cases en ne mettant pas de parenthèses du tout.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">tableau</span><span class="p">;</span> <span class="c1">//Cree un tableau de 0 nombres à virgules</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Euh... A quoi ça sert un tableau vide ?</div><br>
<br>
Hehe, rappelez-vous que ce sont des tableaux dont la taille peut varier. On peut donc ajouter des cases par la suite. Attendez un peu et vous saurez tout. <img src="./cpp_files/smile.png" alt=":)" class="smilies"> <br>
<br>
<h3>Accéder aux éléments d'un tableau</h3><br>
<br>
La déclaration était très différente des tableaux statiques. Par contre là, c'est exactement identique. On utilise à nouveau les crochets et la première case possède aussi le numéro 0. <br>
<br>
On peut donc récrire encore une fois l'exemple de la sous-partie précédente avec un vector.<br>
<br>
<span class="code">Code : C++ - Remplissage d'un tableau - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="k">const</span> <span class="n">nombreMeilleursScores</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">//La taille du tableau</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">meilleursScores</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">//Declaration du tableau</span>

<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">118218</span><span class="p">;</span> <span class="c1">//Remplissage de la premiere case</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100432</span><span class="p">;</span> <span class="c1">//Remplissage de la deuxiemecase</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">87347</span><span class="p">;</span> <span class="c1">//Remplissage de la troisieme case</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">64523</span><span class="p">;</span> <span class="c1">//Remplissage de la quatrieme case</span>
<span class="n">meilleursScores</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">31415</span><span class="p">;</span> <span class="c1">//Remplissage de la cinquieme case</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Là, je crois qu'on ne peut pas faire plus facile.  <img src="./cpp_files/magicien.png" alt=":magicien:" class="smilies"> <br>
<br>
<br>
<h3>Changer la taille</h3><br>
<br>
Entrons maintenant dans le vif du sujet. Faire varier la taille d'un tableau. Commençons par ajouter des cases à la fin d'un tableau. <br>
<br>
Il faut utiliser <span class="code2 cpp"><span class="n">push_back</span><span class="p">()</span></span>. On écrit le nom du tableau, suivi d'un point et du mot <span class="code2 cpp"><span class="n">push_back</span></span> avec entre parenthèses la valeur qui va remplir la nouvelle case.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tableau</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//Un tableau de 3 entiers valant tous 2</span>
<span class="n">tableau</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>  <span class="c1">//On ajoute une 4eme case au tableau. Cette case contient la valeur 8</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voyons ce qui se passe dans la mémoire de plus près. <br>
<br>
<div class="centre"> <img src="./cpp_files/287255.png" alt="Effet d&#39;un push_back sur un vector"></div><br>
<br>
Une case supplémentaire a été ajoutée au bout du tableau. Tout se fait de manière automatique. C'est fou ce que ça peut être intelligent un ordinateur parfois.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
Et bien sûr on peut ajouter beaucoup de cases à la suite les unes des autres.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tableau</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//Un tableau de 3 entiers valant tous 2</span>
<span class="n">tableau</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>  <span class="c1">//On ajoute une 4eme case au tableau. Cette case contient la valeur 8</span>
<span class="n">tableau</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>  <span class="c1">//On ajoute une 5eme case qui contient le chiffre 7.</span>
<span class="n">tableau</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span> <span class="c1">//Et encore une avec le nombre 14 cette fois.</span>

<span class="c1">//Le tableau contient maintenant les nombres : 2 2 2 8 7 14</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Et ils ne peuvent que grandir les vectors ?</div><br>
<br>
Non ! Bien sûr que non. Les créateurs du C++ ont pensé à tout.  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies"> <br>
<br>
On peut supprimer la dernière case d'un tableau en utilisant la fonction <span class="code2 cpp"><span class="n">pop_back</span><span class="p">()</span></span> de la même manière que <span class="code2 cpp"><span class="n">push_back</span><span class="p">()</span></span>. Sauf qu'il n'y a rien à mettre entre les parenthèses.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tableau</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//Un tableau de 3 entiers valant tous 2</span>
<span class="n">tableau</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="c1">//Et hop ! Plus que 2 cases.</span>
<span class="n">tableau</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span> <span class="c1">//Et hop ! Plus qu'une case.</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq attention">Attention tout de même à ne pas trop supprimer de cases ! Un tableau ne peut pas contenir moins de 0 éléments.</div><br>
<br>
Je crois que je n'ai pas besoin d'en dire plus sur ce sujet. <br>
<br>
Il nous reste quand même un petit problème à régler. Comme la taille peut changer, on ne sait pas combien d'éléments un tableau contient de manière certaine. Heureusement, il y a une fonction pour ça. C'est la fonction <span class="code2 cpp"><span class="n">size</span><span class="p">()</span></span>. En faisant <span class="code2 cpp"><span class="n">tableau</span><span class="p">.</span><span class="n">size</span><span class="p">()</span></span>, on récupère un entier correspondant au nombre d'éléments de <span class="code2 cpp"><span class="n">tableau</span></span>. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tableau</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span> <span class="c1">//Un tableau de 5 entiers valant tous 4</span>
<span class="kt">int</span> <span class="n">taille</span><span class="p">;</span> <span class="c1">//Une variable pour contenir la taille du tableau</span>
<span class="n">taille</span> <span class="o">=</span> <span class="n">tableau</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">//Taille vaut maintenant 5</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h3>Retour sur l'exercice</h3><br>
<br>
Je crois que le mieux pour se mettre tout ça en tête, est de reprendre l'exercice du calcul des moyennes mais en le refaisant à la "sauce vector". <br>
<br>
Je vous laisse essayer. Si vous n'y arrivez pas, voici ma solution :<br>
<br>
<span class="code">Code : C++ - Calcul de moyenne en utilisant vector - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;vector&gt; </span><span class="c1">//Ne pas oublier !!</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">notes</span><span class="p">;</span> <span class="c1">//Un tableau vide</span>

   <span class="n">notes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">12.5</span><span class="p">);</span>  <span class="c1">//On ajoute des cases avec les notes</span>
   <span class="n">notes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">19.5</span><span class="p">);</span>
   <span class="n">notes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
   <span class="n">notes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
   <span class="n">notes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">14.5</span><span class="p">);</span>
   <span class="n">notes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
   
   <span class="kt">double</span> <span class="n">moyenne</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
   <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">notes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>  <span class="c1">//On utilise notes.size() pour la limite de notre boucle</span>
   <span class="p">{</span>
      <span class="n">moyenne</span> <span class="o">+=</span> <span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>   <span class="c1">//On additionne toutes les notes</span>
   <span class="p">}</span>

   <span class="n">moyenne</span> <span class="o">/=</span> <span class="n">notes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>  <span class="c1">//On utilise a nouveau notes.size() pour obtenir le nombre de notes</span>
   
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Votre moyenne est : "</span> <span class="o">&lt;&lt;</span> <span class="n">moyenne</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Wow ! C'est assez différent en fait.  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies"> <br>
<br>
On a écrit deux programmes qui font exactement la même chose de deux manières différentes. C'est très courant. Il y a presque toujours plusieurs manières de faire les choses. Chacun choisit celle qu'il préfère. 
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420419">Les tableaux multi-dimensionnels</h2>
		<div class="ss_part_texte">
		Je vous ai dit en début de chapitre que l'on pouvait créer des tableaux de n'importe quoi. Des tableaux d'entiers, des tableaux de strings, et ainsi de suite. On peut donc créer des tableaux de ... tableaux !  <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> <br>
<br>
Je vous vois d'ici froncer les sourcils et vous demander à quoi cela peut bien servir. Une fois n'est pas coutume, je vous propose de commencer par visualiser la mémoire. Vous verrez peut-être l'intérêt de ce concept pour le moins bizarre. <br>
<br>
<div class="centre"><img src="./cpp_files/287353.png" alt="Un tableau bi-dimensionnel dans la mémoire de l&#39;ordinateur"></div><br>
<br>
La grosse case jaune représente, comme à chaque fois, une variable. Cette fois, c'est un tableau de 5 éléments dont j'ai représenté les cases en utilisant des lignes épaisses. A l'intérieur de chacune des cases, on trouve un petit tableau de 4 éléments dont on ne connaît pas la valeur. Pffiou... <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> <br>
<br>
Mais si vous regardez attentivement les points d'interrogation, vous pouvez voir une grille régulière ! Un tableau de tableau est donc une grille de variables. Et là, je pense que vous trouvez ça tout de suite moins bizarre. <br>
<br>
<div class="rmq information">On parle parfois de <strong>tableaux multi-dimensionnels</strong> plutôt que de grilles. C'est pour souligner le fait que les variables sont arrangées selon des axes <img src="./cpp_files/mimetex(37).cgi" alt="X"> et <img src="./cpp_files/mimetex(38).cgi" alt="Y"> et pas juste selon un seul axe.</div><br>
<br>
<h3>Déclaration d'un tableau multi-dimensionnel</h3><br>
<br>
Pour déclarer un tel tableau, il faut indiquer les dimensions les unes après les autres entre crochets. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">type</span> <span class="n">nomTableau</span><span class="p">[</span><span class="n">tailleX</span><span class="p">][</span><span class="n">tailleY</span><span class="p">]</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Donc pour reproduire le tableau du schéma, on doit déclarer le tableau suivant.<br>
<br>
<span class="code">Code : C++ - Déclaration du tableau du schéma - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">tableau</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ou encore mieux, en déclarant des constantes.<br>
<br>
<span class="code">Code : C++ - Déclaration du tableau du schéma - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="k">const</span> <span class="n">tailleX</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="kt">int</span> <span class="k">const</span> <span class="n">tailleY</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">tableau</span><span class="p">[</span><span class="n">tailleX</span><span class="p">][</span><span class="n">tailleY</span><span class="p">];</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Et c'est tout ! C'est bien le C++ non ?<br>
<br>
<h3>Accéder aux éléments</h3><br>
<br>
Je suis sûr que je n'ai pas besoin de vous expliquer la suite. Vous avez sûrement deviné tout seul. Pour accéder à une case de notre grille, il faut indiquer la position en X et en Y de la case voulue.<br>
<br>
Par exemple <span class="code2 cpp"><span class="n">tableau</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></span> accède à la case en-bas à gauche de la grille. <span class="code2 cpp"><span class="n">tableau</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span></span> correspond à celle qui se trouve juste en-dessus, alors que <span class="code2 cpp"><span class="n">tableau</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></span> se situe directement à sa droite. <br>
<br>
<div class="rmq question">Comment accéder à la case située en-haut à droite ?  <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies"> </div><br>
<br>
Hehe. La question piège. C'est la dernière case dans la direction horizontale. Donc entre les premiers crochets, il faut mettre tailleX-1, c'est-à-dire 4. C'est également la dernière case selon l'axe vertical et donc il faut spécifier tailleY-1  entre les seconds crochets. Ce qui donne <span class="code2 cpp"><span class="n">tableau</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span></span>. <br>
<br>
<h3>Aller plus loin</h3><br>
<br>
On peut bien sûr aller encore plus loin et créer des grilles tri-dimensionnelles voire même plus. On peut tout à fait déclarer une variable comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">double</span> <span class="n">grilleExtreme</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">6</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">7</span><span class="p">];</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Mais là, il ne faudra pas me demander un dessin. <img src="./cpp_files/clin.png" alt=";)" class="smilies"> Je vous rassure quand même, il est rare de devoir utiliser des grilles à plus de 2 dimensions. Ou alors, c'est que vous prévoyez de faire des programmes vraiment compliqués.  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420431">Les strings comme tableaux</h2>
		<div class="ss_part_texte">
		Avant de terminer ce chapitre, il faut quand même que je vous fasse une petite révélation. Les chaînes de caractères sont en fait des tableaux !  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> <br>
<br>
On ne le voit pas lors de la déclaration, c'est bien caché. Mais il s'agit en fait d'un tableau de lettres. Il y a même beaucoup de points communs avec les <span class="code2 cpp"><span class="n">vector</span></span>.<br>
<br>
<h3>Accéder aux lettres</h3><br>
<br>
L'intérêt de voir une chaîne de caractères comme un tableau de lettres, c'est qu'on peut accéder à ces lettres et les modifier. Et je ne vais pas vous surprendre, on utilise aussi les crochets.  <img src="./cpp_files/smile.png" alt=":)" class="smilies"> <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">string</span> <span class="n">nomUtilisateur</span><span class="p">(</span><span class="s">"Julien"</span><span class="p">);</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous etes "</span> <span class="o">&lt;&lt;</span> <span class="n">nomUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="s">"."</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

   <span class="n">nomUtilisateur</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'L'</span><span class="p">;</span>  <span class="c1">//On modifie la premiere lettre</span>
   <span class="n">nomUtilisateur</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'c'</span><span class="p">;</span>  <span class="c1">//On modifie la troisieme lettre</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ah non, vous etes "</span> <span class="o">&lt;&lt;</span> <span class="n">nomUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="s">"!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Testons pour voir. <br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Vous&nbsp;etes&nbsp;Julien.
Ah&nbsp;non,&nbsp;vous&nbsp;etes&nbsp;Lucien!</pre></div></td></tr></tbody></table></div><br>
<br>
C'est fort ! Mais on peut faire encore mieux.<br>
<br>
<h3>Les fonctions</h3><br>
<br>
On peut également utiliser <span class="code2 cpp"><span class="n">size</span><span class="p">()</span></span> pour connaître le nombre de lettres et <span class="code2 cpp"><span class="n">push_back</span><span class="p">()</span></span> pour ajouter des lettres à la fin. A nouveau, c'est comme pour <span class="code2 cpp"><span class="n">vector</span></span>.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">string</span> <span class="n">texte</span><span class="p">(</span><span class="s">"Portez ce whisky au vieux juge qui fume."</span><span class="p">);</span>  <span class="c1">//40 lettres</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cette phrase contient "</span><span class="o">&lt;&lt;</span> <span class="n">texte</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" lettres."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Mais contrairement aux tableaux, on peut ajouter <strong>plusieurs lettres</strong> d'un coup. Et on utilise le <strong>+=</strong>. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">string</span> <span class="n">prenom</span><span class="p">(</span><span class="s">"Albert"</span><span class="p">);</span> 
   <span class="n">string</span> <span class="n">nom</span><span class="p">(</span><span class="s">"Einstein"</span><span class="p">);</span>
   
   <span class="n">string</span> <span class="n">total</span><span class="p">;</span>    <span class="c1">//Une chaine vide</span>
   <span class="n">total</span> <span class="o">+=</span> <span class="n">prenom</span><span class="p">;</span> <span class="c1">//On ajoute le prenom a la chaine vide</span>
   <span class="n">total</span> <span class="o">+=</span> <span class="s">" "</span><span class="p">;</span>    <span class="c1">//Puis un espace</span>
   <span class="n">total</span> <span class="o">+=</span> <span class="n">nom</span><span class="p">;</span>    <span class="c1">//Et finalement le nom de famille</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous vous appelez "</span> <span class="o">&lt;&lt;</span> <span class="n">total</span> <span class="o">&lt;&lt;</span> <span class="s">"."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce qui donne bien sûr :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Vous&nbsp;vous&nbsp;appelez&nbsp;Albert&nbsp;Einstein.</pre></div></td></tr></tbody></table></div><br>
<br>
C'est fou ce que c'est bien le C++ parfois.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> 
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Nous voici donc au terme de ce chapitre. J'espère que vous aimez déjà les tableaux. Vous verrez, ils vont vite devenir des éléments essentiels de vos programmes. <br>
<br>
Dans le chapitre suivant, nous allons voir comment lire et écrire des fichiers. Vous serrez ensuite livrés à vous-même pour le premier TP de ce cours.  <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_420466">Lire et écrire des fichiers</h1>
	<div id="chap_intro">
	Pour l'instant, les programmes que nous avons écrits étaient encore relativement simples. C'est normal, vous débutez. Mais avec un peu d'entrainement, vous seriez capable de créer de vraies applications. Vous commencez à connaître la base du C++. Il vous manque quand même un élément essentiel : l'interaction avec des fichiers.<br>
<br>
Jusqu'à maintenant, vous avez appris à écrire dans la console et à récupérer ce que l'utilisateur saisit. Vous serez certainement d'accord avec moi, ce n'est pas suffisant. Pensez à des logiciels comme le bloc-note, votre IDE ou encore un tableur, ce sont tous des programmes qui savent lire et écrire des fichiers. Et même dans le monde des jeux vidéo, on a besoin de ça. Il y a bien sûr les fichiers de sauvegarde, mais aussi les images d'un jeu, les cinématiques, les musiques, etc. En somme, un programme qui ne sait pas interagir avec des fichiers risque d'être très limité. <br>
<br>
Voyons donc comment faire ! Vous verrez, si vous maîtrisez l'utilisation de <span class="code2 cpp"><span class="n">cin</span></span> et de <span class="code2 cpp"><span class="n">cout</span></span>, alors vous savez déjà presque tout.
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420443">Écrire dans un fichier</h2>
		<div class="ss_part_texte">
		La première chose à faire quand on veut manipuler des fichiers, c'est de les ouvrir.  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies"> Et bien en C++, c'est la même chose. <br>
Une fois le fichier ouvert, tout se passe comme pour <span class="code2 cpp"><span class="n">cout</span></span> et <span class="code2 cpp"><span class="n">cin</span></span>. Nous allons, par exemple, retrouver les chevrons <strong>&lt;&lt; </strong>et <strong>&gt;&gt;</strong>. Faites-moi confiance, vous allez rapidement vous y retrouver.<br>
<br>
On parle de <strong>flux</strong> pour désigner les moyens de communication d'un programme avec l'extérieur. Dans ce chapitre, nous allons donc parler des <strong>flux vers les fichiers</strong>. Mais dites simplement "lire et écrire des fichiers" quand vous n'êtes pas dans une soirée de programmeurs.  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
<h3>L'en-tête <span class="code2 cpp"><span class="n">fstream</span></span></h3><br>
<br>
Comme d'habitude en C++, quand on a besoin d'une fonctionnalité, il faut commencer par inclure le bon fichier d'en-tête. Pour les fichiers, il faut spécifier <span class="code2 cpp"><span class="cp">#include &lt;fstream&gt;</span></span> en-haut de notre code source. <br>
<br>
<div class="rmq information">Vous connaissez déjà <span class="code2 cpp"><span class="n">iostream</span></span> qui contient les outils nécessaires aux entrées/sorties vers la console. <span class="code2 cpp"><span class="n">iostream</span></span> signifie en réalité "input/output stream", ce qui veut dire flux d'entrées/sorties en français. <span class="code2 cpp"><span class="n">fstream</span></span> correspond à "file stream", flux vers les fichiers en bon français.</div><br>
<br>
La principale différence est qu'il faut un <strong>flux par fichier</strong>. Voyons comment créer un flux sortant, c'est-à-dire un flux permettant d'écrire un fichier.<br>
<br>
<h3>Ouvrir un fichier en écriture</h3><br>
<br>
Les flux sont en réalité des <strong>objets</strong>. Souvenez-vous que le C++ est un langage <span class="italique">orienté objet</span>. Voici donc un de ces fameux objets. <img src="./cpp_files/pleure.png" alt=":&#39;(" class="smilies">  <br>
N'ayez pas peur, il y aura plusieurs chapitres pour en parler. Pour l'instant, prenez-ça comme étant des grosses variables améliorées. Ces objets contiennent beaucoup d'informations sur les fichiers ouverts et proposent quelques fonctionnalités comme fermer le fichier, retourner au début et bien d'autres encore.  <img src="./cpp_files/huh.png" alt=":o" class="smilies"> <br>
<br>
L'important pour nous est que l'on déclare un flux exactement de la même manière qu'une variable. Une variable dont le type serait <span class="code2 cpp"><span class="n">ofstream</span></span>.<br>
<br>
<span class="code">Code : C++ - Déclaration d'un flux sortant - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;fstream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ofstream</span> <span class="n">monFlux</span><span class="p">;</span>    <span class="c1">//Déclaration d'un flux permettant d'écrire un fichier. </span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
A partir de là, il faut utiliser la fonction <span class="code2 cpp"><span class="n">open</span><span class="p">()</span></span> de l'objet pour ouvrir un fichier.<br>
<br>
<span class="code">Code : C++ - Ouverture d'un fichier - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ofstream</span> <span class="n">monFlux</span><span class="p">;</span>    <span class="c1">//Déclaration d'un flux permettant d'écrire un fichier. </span>

<span class="n">monFlux</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"C:/Nanoc/scores.txt"</span><span class="p">);</span> <span class="c1">//Ouvre un fichier texte</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
J'ai indiqué le chemin d'accès du fichier entre guillemets. Ce chemin doit être d'une des deux formes suivantes :<br>
<br>
<ul>
<li>Un chemin absolu. C'est-à-dire montrer l'emplacement du fichier depuis la racine du disque. Par exemple : <span class="italique">C:/Nanoc/C++/Fichiers/scores.txt</span>.</li>
<li>Un chemin relatif. C'est-à-dire montrer l'emplacement du fichier depuis l'endroit où se situe le programme sur le disque. Par exemple : <span class="italique">Fichiers/scores.txt</span> si mon programme se situe dans le dossier <span class="italique">C:/Nanoc/C++/</span>.</li>
</ul><br>
<br>
A partir de là, on peut utiliser le flux pour écrire dans le fichier. <br>
<br>
<div class="rmq information">Si le fichier n'existait pas, le programme le créerait automatiquement !</div><br>
<br>
Le plus souvent, le nom du fichier est contenu dans une chaîne de caractères <span class="code2 cpp"><span class="n">string</span></span>. Dans ce cas, il faut utiliser la fonction <span class="code2 cpp"><span class="n">c_str</span><span class="p">()</span></span> lors de l'ouverture du fichier.<br>
<br>
<span class="code">Code : C++ - Ouverture d'un fichier - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ofstream</span> <span class="n">monFlux</span><span class="p">;</span>    <span class="c1">//Déclaration d'un flux permettant d'écrire un fichier. </span>

<span class="n">string</span> <span class="n">nomFichier</span><span class="p">(</span><span class="s">"C:/Nanoc/scores.txt"</span><span class="p">);</span>

<span class="ln-xtra"><span class="n">monFlux</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">nomFichier</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span></span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Des problèmes peuvent survenir lors de l'ouverture d'un fichier. Si le fichier ne vous appartient pas ou si le disque dur est plein par exemple. C'est pour ça qu'il faut <strong>toujours</strong> tester si tout c'est bien passé. Cela se fait en utilisant la syntaxe <span class="code2 cpp"><span class="k">if</span><span class="p">(</span><span class="n">monFlux</span><span class="p">)</span></span>. Si ce test n'est pas vrai, alors c'est qu'il y a eu un problème et que l'on ne peut pas utiliser le fichier.<br>
<br>
<span class="code">Code : C++ - Tester l'ouverture - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ofstream</span> <span class="n">monFlux</span><span class="p">;</span>
<span class="n">monFlux</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"C:/Nanoc/scores.txt"</span><span class="p">);</span> <span class="c1">//On essaye d'ouvrir le fichier</span>

<span class="k">if</span><span class="p">(</span><span class="n">monFlux</span><span class="p">)</span>    <span class="c1">//On teste si tout est OK.</span>
<span class="p">{</span>
    <span class="c1">//Tout est OK. On peut utiliser le fichier</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ERREUR: Impossible d'ouvrir le fichier."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Avant d'écrire, voyons quand même comment refermer un fichier. Et si vous parlez anglais, vous vous doutez peut-être que la fonction à utiliser se nomme simplement <span class="code2 cpp"><span class="n">close</span><span class="p">()</span></span>.<br>
<br>
<span class="code">Code : C++ - Ouverture et fermeture d'un fichier - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ofstream</span> <span class="n">monFlux</span><span class="p">;</span>
<span class="n">monFlux</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"C:/Nanoc/scores.txt"</span><span class="p">);</span>  <span class="c1">//On essaye d'ouvrir le fichier</span>

<span class="k">if</span><span class="p">(</span><span class="n">monFlux</span><span class="p">)</span>    
<span class="p">{</span>
    <span class="c1">//Tout est OK. On peut utiliser le fichier</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ERREUR: Impossible d'ouvrir le fichier."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">monFlux</span><span class="p">.</span><span class="n">close</span><span class="p">();</span> <span class="c1">//On finit par refermer le fichier</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voilà, vous savez tout ! Ah non, il manque encore l'écriture à proprement parler. <img src="./cpp_files/rire.gif" alt=":lol:" class="smilies"> <br>
<br>
<h3>Écrire dans un flux</h3><br>
<br>
Je vous avais dit que tout était comme pour <span class="code2 cpp"><span class="n">cout</span></span>. C'est donc sans surprise que je vous présente le moyen d'envoyer des informations dans un flux. C'est les chevrons (<strong>&lt;&lt;</strong>) qu'il faut utiliser.<br>
<br>
<span class="code">Code : C++ - Écriture dans un fichier - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;fstream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ofstream</span> <span class="n">monFlux</span><span class="p">;</span>
    <span class="n">string</span> <span class="k">const</span> <span class="n">nomFichier</span><span class="p">(</span><span class="s">"C:/Nanoc/scores.txt"</span><span class="p">);</span>
    <span class="n">monFlux</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">nomFichier</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>

    <span class="k">if</span><span class="p">(</span><span class="n">monFlux</span><span class="p">)</span>    
    <span class="p">{</span>
        <span class="n">monFlux</span> <span class="o">&lt;&lt;</span> <span class="s">"Bonjour, je suis une phrase écrite dans un fichier."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">monFlux</span> <span class="o">&lt;&lt;</span> <span class="mf">42.1337</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">age</span><span class="p">(</span><span class="mi">23</span><span class="p">);</span>
        <span class="n">monFlux</span> <span class="o">&lt;&lt;</span> <span class="s">"J'ai "</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">" ans."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ERREUR: Impossible d'ouvrir le fichier."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">monFlux</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si j'exécute ce programme, je retrouve ensuite sur mon disque un fichier <span class="courrier">score.txt</span> dont voici le contenu :<br>
<br>
<div class="centre"><img src="./cpp_files/289410.png" alt="Le fichier une fois qu&#39;il a été écrit"></div><br>
<br>
Essayez par vous-mêmes ! <br>
Vous pouvez par exemple écrire un programme qui demande son nom et son âge à l'utilisateur et qui écrit ces données dans un fichier. <br>
<br>
<h3>Les différents modes d'ouverture</h3><br>
<br>
Il ne nous reste plus qu'un petit point à régler. <br>
<br>
<div class="rmq question">Que se passe-t-il si le fichier existe déjà ? </div><br>
<br>
Il sera supprimé et remplacé par ce que vous écrivez, ce qui n'est pas bien si l'on souhaite ajouter des informations à la fin d'un fichier pré-existant. Pensez par exemple à un fichier qui contiendrait la liste des actions effectuées par l'utilisateur. On ne veut pas tout effacer à chaque fois. On veut juste y ajouter des lignes.<br>
<br>
Pour pouvoir écrire à la fin d'un fichier, il faut le spécifier lors de l'ouverture en ajoutant un deuxième paramètre lors de l'appel à la fonction <span class="code2 cpp"><span class="n">open</span><span class="p">()</span></span> :<br>
<br>
<span class="code2 cpp"><span class="n">monFlux</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"C:/Nanoc/scores.txt"</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">app</span><span class="p">);</span></span><br>
<br>
<div class="rmq information"><span class="code2 cpp"><span class="n">app</span></span> est un raccourci pour <span class="italique">append</span>, le verbe anglais qui signifie "ajouter à la fin". </div><br>
<br>
Avec ça, plus de problème d'écrasement des données. Tout ce qui sera écrit sera ajouté à la fin.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420434">Lire un fichier</h2>
		<div class="ss_part_texte">
		Nous avons appris à écrire dans un fichier, voyons maintenant comment fonctionne la lecture de fichier. Vous allez voir, ce n'est pas très différent de ce que vous connaissez déjà.<br>
<br>
<h3>Ouvrir un fichier en lecture...</h3><br>
<br>
Le principe est exactement le même. On va simplement utiliser un <span class="code2 cpp"><span class="n">ifstream</span></span> au lieu d'un <span class="code2 cpp"><span class="n">ofstream</span></span>. Il faut également tester l'ouverture et on retrouve le <span class="code2 cpp"><span class="n">close</span><span class="p">()</span></span> pour la fermeture. C'est bien le C++ quand même.  <img src="./cpp_files/rire.gif" alt=":lol:" class="smilies"> <br>
<br>
<span class="code">Code : C++ - Lecture d'un fichier - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ifstream</span> <span class="n">monFlux</span><span class="p">;</span>    <span class="c1">//Un flux permettant de lire un fichier</span>
<span class="n">monFlux</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"C:/Nanoc/C++/data.txt"</span><span class="p">);</span> <span class="c1">//Ouverture du fichier</span>

<span class="k">if</span><span class="p">(</span><span class="n">monFlux</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//Tout est prêt pour la lecture.</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ERREUR: Impossible d'ouvrir le fichier en lecture."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">monFlux</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Rien de bien nouveau. <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>
<br>
<h3>... et le lire</h3><br>
<br>
Il y a trois manières différentes de lire un fichier.<br>
<br>
<ol class="liste_1">
<li>Ligne par ligne en utilisant <span class="code2 cpp"><span class="n">getline</span><span class="p">()</span></span>.</li>
<li>Mot par mot en utilisant les chevrons <span class="code2 cpp"><span class="o">&gt;&gt;</span></span>.</li>
<li>Caractère par caractère en utilisant <span class="code2 cpp"><span class="n">get</span><span class="p">()</span></span>.</li></ol><br>
<br>
Voyons ces trois moyens en détail.<br>
<br>
<h4>Lire ligne par ligne</h4><br>
<br>
La première méthode permet de récupérer une ligne entière et de la stocker dans une chaîne de caractères. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">string</span> <span class="n">ligne</span><span class="p">;</span>
<span class="n">getline</span><span class="p">(</span><span class="n">monFlux</span><span class="p">,</span> <span class="n">ligne</span><span class="p">);</span> <span class="c1">//On lit une ligne complète</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le fonctionnement est exactement le même qu'avec <span class="code2 cpp"><span class="n">cin</span></span>. Vous savez donc déjà tout. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<h4>Lire mot par mot</h4><br>
<br>
La deuxième manière de faire, vous la connaissez aussi. Comme je suis gentil, je vous propose quand même un petit rappel.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">double</span> <span class="n">nombre</span><span class="p">;</span>
<span class="n">monFlux</span> <span class="o">&gt;&gt;</span> <span class="n">nombre</span><span class="p">;</span> <span class="c1">//Lit un nombre à virgule depuis le fichier</span>
<span class="n">string</span> <span class="n">mot</span><span class="p">;</span>
<span class="n">monFlux</span> <span class="o">&gt;&gt;</span> <span class="n">mot</span><span class="p">;</span> <span class="c1">//Lit un mot depuis le fichier</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cette méthode lit ce qui se trouve entre l'endroit où l'on se situe dans le fichier et le prochain espace. Ce qui est lu est alors traduit en <span class="code2 cpp"><span class="kt">double</span></span>, <span class="code2 cpp"><span class="kt">int</span></span> ou <span class="code2 cpp"><span class="n">string</span></span> selon le type de variable dans lequel on écrit.<br>
<br>
<h4>Lire caractère par caractère</h4><br>
<br>
Finalement, il nous reste la dernière méthode. La seule réellement nouvelle. Mais tout aussi simple, je vous rassure.<br>
<br>
<span class="code">Code : C++ - Lecture d'un caractère - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
<span class="n">monFlux</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce code lit une seule lettre et la stocke dans la variable <span class="code2 cpp"><span class="n">a</span></span>. <br>
<br>
<div class="rmq attention">Cette méthode lit réellement <strong>tous</strong> les caractères. Les espaces, retours à la ligne et tabulations sont, entre autres, lus par cette fonction. Bien que bizarres, ces caractères seront néanmoins stockées dans la variable.</div><br>
<br>
<h3>Lire un fichier en entier</h3><br>
<br>
On veut très souvent lire un fichier en entier. Je vous ai montré comment lire, mais pas comment s'arrêter quand on arrive à la fin ! <br>
<br>
Pour savoir si l'on peut continuer à lire, il faut utiliser <span class="code2 cpp"><span class="k">if</span><span class="p">(</span><span class="n">monFlux</span><span class="p">)</span></span>. Comme pour tester l'ouverture.<br>
Vous vous rappelez des boucles ? On cherche à lire le fichier <span class="italique">tant qu'</span>on n'a pas atteint la fin. La boucle <span class="code2 cpp"><span class="k">while</span></span> est donc le meilleur choix. Voici comment faire :<br>
<br>
<span class="code">Code : C++ - Lecture d'un fichier du début à la fin - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;fstream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> 

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ifstream</span> <span class="n">fichier</span><span class="p">;</span>
    <span class="n">fichier</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"C:/Nanoc/fichier.txt"</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">fichier</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="c1">//L'ouverture s'est bien passée. On peut donc lire</span>

        <span class="k">while</span><span class="p">(</span><span class="n">fichier</span><span class="p">)</span>    <span class="c1">//Tant qu'on n'est pas a la fin</span>
        <span class="p">{</span>
            <span class="n">string</span> <span class="n">ligne</span><span class="p">;</span>
            <span class="n">getline</span><span class="p">(</span><span class="n">fichier</span><span class="p">,</span> <span class="n">ligne</span><span class="p">);</span> <span class="c1">//On lit une ligne</span>
    
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ligne</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//Et on l'affiche dans la console</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ERREUR: Impossible d'ouvrir le fichier en lecture."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">fichier</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Une fois que l'on a lu les lignes, on peut les manipuler facilement. Ici, j'affiche simplement les lignes, mais dans un programme réel on les utiliserait autrement. La seule limite est votre imagination.  <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420441">Quelques astuces</h2>
		<div class="ss_part_texte">
		Il ne reste que quelques astuces à voir et vous saurez alors tout ce qu'il faut sur les fichiers. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<h3>Gagner de la place</h3><br>
<br>
Je vous l'ai souvent dit, la principale qualité du programmeur est la fainéantise. Voici donc deux petites astuces pour écrire moins de lignes.<br>
<br>
La première astuce permet de déclarer le flux et d'ouvrir le fichier en une seule ligne.<br>
<br>
Le morceau de code suivant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ofstream</span> <span class="n">flux</span><span class="p">;</span>
<span class="n">flux</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"C:/Nanoc/fichier.txt"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... peut être remplacé par son équivalent plus court :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ofstream</span> <span class="n">flux</span><span class="p">(</span><span class="s">"C:/Nanoc/fichier.txt"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On a gagné une ligne. Il n'y a aucune différence entre les deux variantes. La deuxième est juste plus courte.<br>
<br>
L'autre élément qui peut être supprimé est l'appel à la fonction <span class="code2 cpp"><span class="n">close</span><span class="p">()</span></span>. En effet, le fichier sera automatiquement fermé à la fin de la fonction où le flux est déclaré. Cela nous fait donc une deuxième ligne de gagnée. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="rmq information">Beaucoup de gens aiment bien garder le <span class="code2 cpp"><span class="n">open</span><span class="p">()</span></span> et le <span class="code2 cpp"><span class="n">close</span><span class="p">()</span></span>. On peut ainsi mieux voir où le fichier est ouvert et où il est refermé. C'est une question de goût. A vous de voir ce que vous préférez.</div><br>
<br>
<h3>Le curseur dans le fichier</h3><br>
<br>
Plongeons un petit peu plus dans les détails techniques. Voyons comment se déroule la lecture. Quand on ouvre un fichier dans le bloc-note, par exempe, il y a un curseur qui indique l'endroit où l'on va écrire. Sur l'image suivante, le curseur se situe après les deux "s" sur la 4<sup>e</sup> ligne.<br>
<br>
<div class="centre"><img src="./cpp_files/290290.png" alt="Image utilisateur"></div><br>
<br>
Si l'on tape sur une touche du clavier, une lettre sera ajoutée à cet endroit du fichier. J'imagine que je ne vous apprends rien en disant ça. <img src="./cpp_files/clin.png" alt=";)" class="smilies"> Ce qui est plus intéressant, c'est qu'en C++ il y a aussi en quelque sorte un curseur. <br>
<br>
Lorsque l'on écrit la ligne suivante :<br>
<br>
<span class="code">Code : C++ - Curseur au début du fichier - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ifstream</span> <span class="n">fichier</span><span class="p">(</span><span class="s">"C:/Nanoc/scores.txt"</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
le fichier <span class="italique">C:/Nanoc/scores.txt </span> est ouvert et le curseur est placé tout au début du fichier. Si on lit le premier mot du fichier, on obtient bien sûr la chaîne de caractères <span class="code2 cpp"><span class="s">"Nanoc"</span></span> puisque c'est le premier mot du fichier. En faisant ça, le "curseur C++" se déplace jusqu'au début du mot suivant. Comme sur l'image suivante :<br>
<br>
<div class="centre"><img src="./cpp_files/290293.png" alt="Image utilisateur"></div><br>
<br>
Le mot suivant qui pourra être lu sera donc <span class="code2 cpp"><span class="s">":"</span></span>, puis <span class="code2 cpp"><span class="mi">118218</span></span> et ainsi de suite jusqu'à la fin. On est donc obligés de lire un fichier <strong>dans l'ordre</strong>. Ce n'est pas très pratique. <img src="./cpp_files/triste.png" alt=":(" class="smilies"><br>
<br>
Heureusement, il existe des moyens de se déplacer dans un fichier. On peut par exemple dire "je veux placer le curseur 20 caractères après le début" ou "je veux avancer le curseur de 32 lettres". On peut ainsi lire que les parties qui nous intéressent réellement.<br>
<br>
La première chose à faire est de savoir où se situe le curseur. Dans un deuxième temps, on pourra le déplacer. Voici comment.<br>
<br>
<h3>Connaître sa position</h3><br>
<br>
Il existe une fonction permettant de savoir à quel octet du fichier on se trouve. Autrement dit, elle permet de savoir à quel caractère du fichier on se situe. Malheureusement, cette fonction n'a pas le même nom pour les flux entrants et sortants. Et en plus ce sont des noms bizarres.  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies">  Je vous ai mis les noms des deux fonctions dans un petit tableau<br>
<table class="tab_user">		


<thead><tr><th>Pour <span class="code2 cpp"><span class="n">ifstream</span></span></th><th>Pour <span class="code2 cpp"><span class="n">ofstream</span></span></th></tr></thead><tbody><tr>		
<td><span class="code2 cpp"><span class="n">tellp</span><span class="p">()</span></span></td>		
<td><span class="code2 cpp"><span class="n">tellg</span><span class="p">()</span></span></td>	
</tr></tbody></table><br>
<br>
Par contre, elles s'utilisent toutes les deux de la même manière.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ofstream</span> <span class="n">fichier</span><span class="p">;</span>
<span class="n">fichier</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">"C:/Nanoc/data.txt"</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">fichier</span><span class="p">.</span><span class="n">tellg</span><span class="p">();</span> <span class="c1">//On recupere la position</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Nous nous situons au "</span> <span class="o">&lt;&lt;</span> <span class="n">position</span> <span class="o">&lt;&lt;</span> <span class="s">"eme caractere du fichier. &lt;&lt; endl;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h3>Se déplacer</h3><br>
<br>
A nouveau, il existe deux fonctions. Une pour chaque type de flux.<br>
<br>
<table class="tab_user">		


<thead><tr><th>Pour <span class="code2 cpp"><span class="n">ifstream</span></span></th><th>Pour <span class="code2 cpp"><span class="n">ofstream</span></span></th></tr></thead><tbody><tr>		
<td><span class="code2 cpp"><span class="n">seekp</span><span class="p">()</span></span></td>		
<td><span class="code2 cpp"><span class="n">seekg</span><span class="p">()</span></span></td>	
</tr></tbody></table><br>
<br>
Elles s'utilisent à nouveau de la même manière, je ne vous présente donc qu'une des deux versions.  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies"> <br>
<br>
Ces fonctions reçoivent deux arguments. Une position dans le fichier et un nombre de caractères <strong>à ajouter</strong> à cette position : <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">flux</span><span class="p">.</span><span class="n">seekp</span><span class="p">(</span><span class="n">nombreCaracteres</span><span class="p">,</span> <span class="n">position</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les trois positions possibles sont :<br>
<br>
<ul>
<li>Le début du fichier : <span class="code2 cpp"><span class="n">ios</span><span class="o">::</span><span class="n">beg</span></span>.</li>
<li>La fin du fichier : <span class="code2 cpp"><span class="n">ios</span><span class="o">::</span><span class="n">end</span></span>.</li>
<li>La position actuelle : <span class="code2 cpp"><span class="n">ios</span><span class="o">::</span><span class="n">cur</span></span>.</li>
</ul><br>
<br>
Si par exemple, je souhaite me placer 10 caractères après le début du fichier, j'utilise <span class="code2 cpp"><span class="n">flux</span><span class="p">.</span><span class="n">seekp</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">beg</span><span class="p">);</span></span>. Si je souhaite aller 20 caractères plus loin que l'endroit où le curseur se situe, j'utilise <span class="code2 cpp"><span class="n">flux</span><span class="p">.</span><span class="n">seekp</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">cur</span><span class="p">);</span></span>. <br>
Je pense que vous avez compris. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Voilà donc notre problème de lecture résolu. <br>
<br>
<h3>Connaître la taille d'un fichier</h3><br>
<br>
Cette troisième astuce utilise en réalité les deux précédentes. Pour connaître la taille d'un fichier, on se déplace à la fin et on demande au flux de nous dire où il se trouve. Vous voyez comment faire ?  <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> <br>
Bon, je vous montre.<br>
<br>
<span class="code">Code : C++ - Taille d'un fichier - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;fstream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ifstream</span> <span class="n">fichier</span><span class="p">(</span><span class="s">"C:/Nanoc/meilleursScores.txt"</span><span class="p">);</span> <span class="c1">//On ouvre le fichier</span>
    <span class="n">fichier</span><span class="p">.</span><span class="n">seekp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">end</span><span class="p">);</span> <span class="c1">//On se deplace a la fin du fichier</span>

    <span class="kt">int</span> <span class="n">taille</span><span class="p">;</span>
    <span class="n">taille</span> <span class="o">=</span> <span class="n">fichier</span><span class="p">.</span><span class="n">tellp</span><span class="p">();</span>  <span class="c1">//On recupere la position qui correspond donc a la taille du fichier !</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Taille du fichier : "</span> <span class="o">&lt;&lt;</span> <span class="n">taille</span> <span class="o">&lt;&lt;</span> <span class="s">" octets."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">//Pas besoin d'appeler fichier.close().</span>
    <span class="c1">//Souvenez-vous de la premiere astuce !</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je suis sûr que vous le saviez ! <br>
<br>
Voilà, on a fait le tour des notions principales. Vous êtes prêt à vous lancer seul dans le vaste monde des fichiers.
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Avec ces nouvelles notions, vous êtes prêts pour entrer dans la cour des grands et réaliser de vrais programmes. Et ça tombe bien, puisque le prochain chapitre sera un TP dans lequel vous aurez besoin de tout ce que vous avez appris précédemment !<br>
<br>
Je vous conseille de bien réviser les parties qui vous semblaient compliquées ! <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_420459">[TP] Le mot mystère</h1>
	<div id="chap_intro">
	Depuis le début de ce cours sur le C++, vous avez découvert de nombreuses notions : le compilateur, l'IDE, les variables, les fonctions, les conditions, les boucles... Vous avez pu voir des exemples d'utilisation de ces notions au fur et à mesure, mais est-ce que vous avez pris le temps de créer un <strong>vrai programme</strong> pour vous entraîner ? Non ? Eh bien c'est le moment de s'y mettre !<br>
<br>
On trouve régulièrement des TP au milieu des cours du Site du Zéro. Celui-ci ne fait pas exception.<br>
Le but ? Vous forcer à vous lancer "pour de vrai" dans la programmation. Parce que je sais bien qu'il y en a beaucoup parmi vous qui ont à peine ouvert leur IDE pour le moment, ce TP est l'occasion de vous y mettre vraiment. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Le sujet de ce TP n'est pas <span class="italique">très </span>compliqué mais promet d'être amusant : nous allons mélanger les lettres d'un mot et demander à un joueur de retrouver le mot "mystère" qui se cache derrière ces lettres. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="centre"><img src="./cpp_files/289595.png" alt="Mot mystère"></div><br>

	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420474">Préparatifs et conseils</h2>
		<div class="ss_part_texte">
		Le jeu que nous voulons réaliser consiste à retrouver un mot dont les lettres ont été mélangées. C'est simple en apparence, mais il va nous falloir utiliser des notions que nous avons découvertes dans les chapitres précédents :<br>
<br>
<ul>	
<li>Les variables string</li>	
<li>Les fonctions</li>	
<li>Les structures de contrôle (boucles, conditions...)</li>
</ul><br>
<br>
N'hésitez pas à relire rapidement ces chapitres pour bien être dans le bain avant de commencer ce TP !<br>
<br>
<h3>Principe du jeu "Le mot mystère"</h3><br>
<br>
Nous voulons réaliser un jeu qui se déroule de la façon suivante :<br>
<br>
<ol class="liste_1">	
<li>Le joueur 1 saisit un mot au clavier</li>	
<li>L'ordinateur mélange les lettres du mot</li>	
<li>Le joueur 2 essaie de deviner le mot d'origine à partir des lettres mélangées</li></ol><br>
<br>
Voici un exemple de partie du jeu que nous allons réaliser :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Saisissez&nbsp;un&nbsp;mot
MYSTERE

Quel&nbsp;est&nbsp;ce&nbsp;mot&nbsp;?&nbsp;MSERETY
RESEMTY
Ce&nbsp;n'est&nbsp;pas&nbsp;le&nbsp;mot&nbsp;!

Quel&nbsp;est&nbsp;ce&nbsp;mot&nbsp;?&nbsp;MSERETY
MYRESTE
Ce&nbsp;n'est&nbsp;pas&nbsp;le&nbsp;mot&nbsp;!

Quel&nbsp;est&nbsp;ce&nbsp;mot&nbsp;?&nbsp;MSERETY
MYSTERE
Bravo&nbsp;!</pre></div></td></tr></tbody></table></div><br>
<br>
<ol class="liste_1">	
<li>Dans cette partie, le joueur 1 choisit "MYSTERE" comme mot à deviner.</li>	
<li>L'ordinateur mélange les lettres et demande au joueur 2 de retrouver le mot qui se cache derrière "MSERETY".</li>	
<li>Le joueur 2 essaie de trouver le mot. Ici, il y parvient au bout de 3 essais :<br>
<ol class="liste_1">	
<li>RESEMTY : on lui dit que ce n'est pas ça</li>	
<li>MYRESTE : là non plus</li>	
<li>MYSTERE : là on lui dit bravo car il a trouvé, et le programme s'arrête. <img src="./cpp_files/smile.png" alt=":)" class="smilies"></li></ol></li></ol><br>
Bien sûr, le joueur 2 peut actuellement facilement lire le mot saisi par le joueur 1. Nous verrons à la fin du TP comment nous pouvons améliorer ça.<br>
<br>
<h3>Quelques conseils pour bien démarrer</h3><br>
<br>
Quand on lâche un débutant dans la nature la première fois, avec comme seule instruction "Allez, code-moi ça", il est en général assez désemparé.<br>
<span class="italique">"Par quoi dois-je commencer ?"</span>, <span class="italique">"Qu'est-ce que je dois faire, qu'est-ce que je dois utiliser ?"</span>. Bref, il ne sait pas du tout s'y prendre, et c'est bien normal vu qu'il n'a jamais fait ça. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Mais moi, je n'ai pas envie que vous vous perdiez ! Je vais donc vous donner une série de conseils pour que vous soyez le mieux préparés possible. Bien entendu, ce sont juste des conseils, vous en faites ce que vous voulez. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
<h4>Repérez les étapes du programme</h4><br>
<br>
Je vous ai décrit les 3 étapes du programme un peu plus tôt :<br>
<br>
<ol class="liste_1">	
<li>Saisie du mot à deviner</li>	
<li>Mélange des lettres</li>	
<li>Boucle qui se répète tant que le mot mystère n'a pas été trouvé</li></ol><br>
Ces étapes sont en fait assez indépendantes. Plutôt que d'essayer de réaliser tout le programme d'un coup, pourquoi vous n'essayez pas de faire chaque étape indépendamment des autres ?<br>
<br>
<ol class="liste_1">	
<li>L'étape 1 est très simple : l'utilisateur doit saisir un mot qu'on va stocker en mémoire (dans une string, car c'est le type adapté). Si vous connaissez cout et cin, vous ne mettrez pas plus de quelques minutes à écrire le code correspondant.</li>	
<li>L'étape 2 est la plus complexe : vous avez une string qui contient un mot comme MYSTERE et vous voulez aléatoirement mélanger les lettres pour obtenir quelque chose comme MSERETY. Comment faire ? Je vais vous aider un peu pour ça car vous devez utiliser certaines choses que nous n'avons pas vues.</li>	
<li>L'étape 3 est de difficulté moyenne : vous devez créer une boucle qui demande de saisir un mot et qui le compare au mot mystère. La boucle s'arrête dès que le mot saisi est identique au mot mystère.</li></ol><br>
<h4>Créez un canevas de code avec les étapes</h4><br>
<br>
Comme vous le savez, tous les programmes contiennent une fonction main(). Ecrivez dès maintenant des commentaires pour séparer les principales étapes du programme. Ca devrait donner quelque chose comme ça :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>    
    <span class="c1">// 1 : On demande à saisir un mot</span>

    <span class="c1">// 2 : On mélange les lettres du mot</span>

    <span class="c1">// 3 : On demande à l'utilisateur quel est le mot mystère</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
A vous de réaliser les étapes ! Pour y aller en difficulté croissante, je vous conseille de faire d'abord l'étape 1, puis l'étape 3 et enfin l'étape 2.<br>
<br>
Lorsque vous aurez réalisé les étapes 1 et 3, le programme vous demandera un mot et vous devrez le ressaisir. Ce ne sera pas très amusant mais comme ça vous pourrez valider que vous avez réussi les premières étapes ! N'hésitez donc pas à y aller pas à pas !<br>
<br>
Ci-dessous un aperçu du programme "intermédiaire" avec seulement les étapes 1 et 3 réalisées :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Saisissez&nbsp;un&nbsp;mot
MYSTERE

Quel&nbsp;est&nbsp;ce&nbsp;mot&nbsp;?
RESEMTY
Ce&nbsp;n'est&nbsp;pas&nbsp;le&nbsp;mot&nbsp;!

Quel&nbsp;est&nbsp;ce&nbsp;mot&nbsp;?&nbsp;
MYRESTE
Ce&nbsp;n'est&nbsp;pas&nbsp;le&nbsp;mot&nbsp;!

Quel&nbsp;est&nbsp;ce&nbsp;mot&nbsp;?
MYSTERE
Bravo&nbsp;!</pre></div></td></tr></tbody></table></div><br>
Comme vous le voyez, le programme ne propose pas encore le mot avec les lettres mélangées, mais si vous arrivez déjà à faire ça vous avez fait 50% du travail ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<h3>Un peu d'aide pour mélanger les lettres</h3><br>
<br>
L'étape de mélange des lettres est la plus "difficile" (si je puis dire !) de ce TP. Je vous donne quelques informations et conseils pour réaliser cette fameuse étape n°2.<br>
<br>
<h4>Tirer un nombre au hasard</h4><br>
<br>
Pour que les lettres soient aléatoirement mélangées, vous allez devoir tirer un nombre au hasard. Nous n'avons pas appris à le faire auparavant, il faut donc que je vous explique comment ça fonctionne.<br>
<br>
<ul>
<li>Vous devez inclure ctime et cstdlib au début de votre code source pour obtenir les fonctionnalités de nombres aléatoires.</li>
<li>Vous devez appeler la fonction <span class="code2 cpp"><span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span></span> une seule fois au début de votre programme (au début du main) pour initialiser la génération des nombres aléatoires.</li>
<li>Et enfin, pour générer un nombre compris entre 0 et 4 (par exemple), vous écrirez : <span class="code2 cpp"><span class="n">nbAleatoire</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">5</span><span class="p">;</span></span> (on écrit 5 pour avoir un nombre entre 0 et 4, oui oui <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ).</li>
</ul><br>
Un exemple qui génère un nombre entre 0 et 4 :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;ctime&gt; </span><span class="c1">// Obligatoire</span>
<span class="cp">#include &lt;cstdlib&gt; </span><span class="c1">// Obligatoire</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">nbAleatoire</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

    <span class="n">nbAleatoire</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">5</span><span class="p">;</span>    

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Tirer une lettre au hasard</h4><br>
<br>
<div class="rmq question">Tirer un nombre au hasard c'est bien, mais pour ce programme j'ai besoin de tirer une lettre au hasard pour mélanger les lettres !</div><br>
<br>
Imaginons que vous ayez une string appelée motMystere qui contient le mot mystère. Vous avez appris que les string pouvaient être considérées comme des tableaux, souvenez-vous ! Ainsi, motMystere[0] correspond à la première lettre, motMystere[1] à la deuxième lettre, etc.<br>
<br>
Il suffit de générer un nombre aléatoire entre 0 et le nombre de lettres du mot (qui nous est donné par motMystere.size()) pour tirer une lettre au hasard ! Une petite idée de code pour récupérer une lettre au hasard :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;ctime&gt;</span>
<span class="cp">#include &lt;cstdlib&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">motMystere</span><span class="p">(</span><span class="s">"MYSTERE"</span><span class="p">);</span>

    
    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    
    <span class="n">position</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">motMystere</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Lettre au hasard :"</span> <span class="o">&lt;&lt;</span> <span class="n">motMystere</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Retirer une lettre d'une string</h4><br>
<br>
Pour éviter de tirer 2 fois la même lettre d'un mot, je vous conseille de retirer au fur et à mesure les lettres qui ont été piochées. Pour ce faire, on va faire appel à erase() sur le mot mystère comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">motMystere</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Retire la lettre n°5</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Il y a 2 paramètres :<br>
<br>
<ul>
<li>Le numéro de la lettre à retirer du mot (ici 4, ce qui correspond à la 5ème lettre car on commence à compter à partir de 0).</li>
<li>Le nombre de lettres à retirer (ici 1).</li>
</ul><br>
<br>
<h4>Créez des fonctions !</h4><br>
<br>
Ce n'est pas une obligation, mais plutôt que de tout mettre dans le main(), vous pourriez créer des fonctions qui ont des rôles spécifiques. Par exemple, l'étape 2 qui génère un mot dont les lettres ont été mélangées mériterait d'être faite dans une fonction.<br>
<br>
Ainsi, on pourrait appeler la fonction comme ceci dans le main() :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">motMelange</span> <span class="o">=</span> <span class="n">melangerLettres</span><span class="p">(</span><span class="n">motMystere</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On lui envoie le motMystere, elle nous retourne un motMelange. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Bien entendu, toute la difficulté consiste ensuite à coder cette fonction melangerLettres. Allez au boulot ! <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420422">Correction</h2>
		<div class="ss_part_texte">
		C'est l'heure de la correction !<br>
<br>
Vous avez sûrement passé du temps à réfléchir à ce programme, ça n'a peut-être pas toujours été facile et vous n'avez pas forcément su tout faire. Ce n'est pas grave ! Ce qui compte, c'est d'avoir essayé : c'est comme ça que vous progressez le plus !<br>
<br>
Normalement, les étapes 1 et 3 étaient assez faciles pour tout le monde. Seule l'étape 2 (mélange des lettres) demandait plus de réflexion : je l'ai isolée dans une fonction melangerLettres comme je vous l'ai suggéré plus tôt.<br>
<br>
<h3>Le code</h3><br>
<br>
Sans plus attendre, voici la correction :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;ctime&gt;</span>
<span class="cp">#include &lt;cstdlib&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">string</span> <span class="n">melangerLettres</span><span class="p">(</span><span class="n">string</span> <span class="n">mot</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">melange</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">position</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Tant que nous n'avons pas extrait toutes les lettres du mot</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">mot</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// On choisit un numéro de lettre au hasard dans le mot</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">mot</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="c1">// On ajoute la lettre dans le mot mélangé</span>
        <span class="n">melange</span> <span class="o">+=</span> <span class="n">mot</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
        <span class="c1">// On retire cette lettre du mot mystère pour ne pas la prendre une 2e fois</span>
        <span class="n">mot</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// On renvoie le mot mélangé</span>
    <span class="k">return</span> <span class="n">melange</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">motMystere</span><span class="p">,</span> <span class="n">motMelange</span><span class="p">,</span> <span class="n">motUtilisateur</span><span class="p">;</span>

    <span class="c1">// Initialisation des nombres aléatoires</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>


    <span class="c1">// 1 : On demande à saisir un mot</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Saisissez un mot"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">motMystere</span><span class="p">;</span>

    <span class="c1">// 2 : On récupère le mot avec les lettre mélangées dans motMelange</span>
    <span class="n">motMelange</span> <span class="o">=</span> <span class="n">melangerLettres</span><span class="p">(</span><span class="n">motMystere</span><span class="p">);</span>

    <span class="c1">// 3 : On demande à l'utilisateur quel est le mot mystère</span>
    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">"Quel est ce mot ? "</span> <span class="o">&lt;&lt;</span> <span class="n">motMelange</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">motUtilisateur</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">motUtilisateur</span> <span class="o">==</span> <span class="n">motMystere</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bravo !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ce n'est pas le mot !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="k">while</span> <span class="p">(</span><span class="n">motUtilisateur</span> <span class="o">!=</span> <span class="n">motMystere</span><span class="p">);</span> <span class="c1">// On recommence tant qu'il n'a pas trouvé</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
Ne vous laissez pas surprendre par la "taille" du code (qui n'est d'ailleurs pas très gros) et soyez méthodiques en le lisant : commencez par lire le main() et non la fonction melangerLettres(). Regardez les différentes étapes du programme une par une : isolées, elles sont plus simples à comprendre.<br>
<br>
<h3>Des explications</h3><br>
<br>
Voici quelques explications pour mieux comprendre le programme, étape par étape.<br>
<br>
<h4>Etape 1 : saisir un mot</h4><br>
<br>
C'était, de loin, l'étape la plus simple : un cout pour afficher un message, un cin pour récupérer un mot que l'on stocke dans la variable motMystere. Facile !<br>
<br>
<h4>Etape 2 : mélanger les lettres</h4><br>
<br>
Plus difficile, cette étape est réalisée en fait dans une fonction melangerLettres (en haut du programme). Le main() appelle la fonction melangerLettres() en lui envoyant le mot mystère. Le but de la fonction est de retourner une version mélangée des lettres, que l'on stocke dans motMelange.<br>
<br>
Analysons la fonction melangerLettres. Elle extrait une à une les lettres du mot aléatoirement et recommence tant qu'il reste des lettres à extraire dans le mot :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">while</span> <span class="p">(</span><span class="n">mot</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">mot</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">melange</span> <span class="o">+=</span> <span class="n">mot</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
    <span class="n">mot</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
A chaque passage de boucle, on tire un nombre au hasard compris entre 0 et le nombre de lettres qu'il reste dans le mot. On ajoute ces lettres piochées aléatoirement dans une string <span class="code2 cpp"><span class="n">melange</span></span> et on retire les lettres du mot d'origine pour ne pas les piocher une deuxième fois.<br>
<br>
Une fois toutes les lettres extraites, on sort de la boucle et on retourne la variable <span class="code2 cpp"><span class="n">melange</span></span> qui contient les lettres dans le désordre.<br>
<br>
<h4>Etape 3 : demander à l'utilisateur le mot mystère</h4><br>
<br>
Cette étape prend la forme d'une boucle do ... while, qui nous permet de s'assurer qu'on demande bien au moins une fois quel est le mot mystère.<br>
<br>
L'utilisateur saisit un mot grâce à cin, et on compare ce mot avec le <span class="code2 cpp"><span class="n">motMystere</span></span> qu'il faut trouver. On continue la boucle tant que le mot n'a pas été trouvé, d'où la condition : <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="p">}</span><span class="k">while</span> <span class="p">(</span><span class="n">motUtilisateur</span> <span class="o">!=</span> <span class="n">motMystere</span><span class="p">);</span> <span class="c1">// On recommence tant qu'il n'a pas trouvé</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On affiche un message différent selon si on a trouvé ou non le mot mystère. Le programme s'arrête dès qu'on est sorti de la boucle, donc dès qu'on a trouvé le mot mystère. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<h3>Téléchargement</h3><br>
<br>
Vous pouvez télécharger le programme avec le lien suivant :<br>
<br>
<div class="centre"><span class="gros"><a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/cpp/mot_mystere.zip">Télécharger le code source du jeu "Mot mystère"</a></span></div><br>
<br>
Le fichier ZIP contient :<br>
<br>
<ul>	
<li>main.cpp : le fichier source du programme (l'essentiel !)</li>	
<li>mot_mystere.cbp : le fichier de projet Code::Blocks (facultatif, pour ceux qui utilisent cet IDE)</li>
</ul><br>
Vous pouvez ainsi tester le programme et éventuellement vous en servir comme base par la suite pour réaliser les améliorations que je vais vous proposer (si vous n'avez pas réussi à faire le programme vous-même bien entendu !).
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420458">Aller plus loin</h2>
		<div class="ss_part_texte">
		Notre programme est terminé... mais on peut toujours l'améliorer. Je vais vous présenter une série de suggestions pour aller plus loin, ce qui vous donnera l'occasion de travailler un peu plus sur ce petit jeu. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Ces propositions sont de difficulté croissante :<br>
<ul>
<li><strong>Ajoutez des sauts de ligne au début</strong> : lorsque le premier joueur saisit le mot mystère la première fois, vous devriez créer plusieurs sauts de ligne pour que le joueur 2 ne voie pas le mot qui a été saisi, sinon c'est trop facile pour lui. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Utilisez plusieurs <span class="code2 cpp"><span class="n">endl</span></span> par exemple pour créer plusieurs retours à la ligne.</li>
<li>Proposez au joueur de faire une <strong>nouvelle partie</strong>. Actuellement, une fois le mot trouvé, le programme s'arrête. Et si vous demandiez <span class="italique">"Voulez-vous faire une autre partie ? (o/n)"</span>. En fonction de la réponse saisie, vous reprenez au début du programme. Pour ce faire, il faudra créer une grosse boucle do...while qui englobe les 3 étapes du programme.</li>
<li><strong>Fixez un nombre maximal de coups</strong> pour trouver le mot mystère. Vous pouvez par exemple indiquer "Il vous reste 5 essais" et lorsque les 5 essais sont écoulés, le programme s'arrête en affichant la solution.</li>
<li>Calculez le <strong>score moyen du joueur</strong> à la fin du programme : après plusieurs parties du joueur, affichez-lui son score. Ce score sera la moyenne des parties précédentes. Vous pouvez calculer le nombre de points comme vous le voulez.<br>
Vous devrez sûrement utiliser les tableaux dynamiques vector pour stocker les scores de chaque partie au fur et à mesure avant d'en faire la moyenne.</li>
<li><strong>Piochez le mot dans un fichier-dictionnaire</strong> : pour que l'on puisse jouer seul, vous pourriez créer un fichier contenant une série de mots (un par ligne) dans lequel le programme va aller piocher aléatoirement à chaque fois. Voici un exemple de fichier-dictionnaire :<br>
<span class="code">Code : Autre - <a href="#" class="select_code">Sélectionner</a></span><div class="code2"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
</pre></td><td class="code"><div class="syntax"><pre>MYSTERE
XYLOPHONE
ABEILLE
PLUTON
MAGIQUE
AVERTISSEMENT</pre></div></td></tr></tbody></table></div><br>
Au lieu de demander le mot à deviner (étape 1) on va chercher dans un fichier comme celui-ci un mot aléatoirement. A vous d'utiliser les fonctionnalités de lecture de fichiers que vous avez apprises ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
... Allez, puisque vous m'êtes sympathiques, je vous propose même de télécharger un fichier-dictionnaire tout prêt avec des dizaines de milliers de mots ! Merci qui ?! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<div class="centre"><span class="gros"><a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/cpp/dico.zip">Télécharger le fichier-dictionnaire (600 Ko)</a></span></div><br>
<br>
</li>
</ul><br>
<br>
Si vous avez d'autres idées, n'hésitez pas à compléter encore ce programme ! Cela vous fera beaucoup progresser, vous verrez. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Je suis sûr que ce premier TP vous aura fait bien plus progresser que tous les chapitres précédents réunis. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Ne vous arrêtez pas au seul sujet du TP : essayez de faire les améliorations proposées, trouvez d'autres améliorations à faire, et lancez-vous ! Si vous avez un problème et que vous avez besoin d'aide, n'oubliez pas que <a href="http://www.siteduzero.com/forum-81-237-langage-c.html">le forum C++</a> est à votre disposition. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_420420">Les pointeurs</h1>
	<div id="chap_intro">
	Nous voilà dans le dernier chapitre de présentation des bases du C++. Accrochez-vous car le niveau monte d'un cran !<br>
Le sujet des pointeurs fait peur à beaucoup de monde et c'est certainement un des chapitres les plus complexes de ce cours. Une fois cet écueil passé, beaucoup de choses vous paraîtront plus simples et plus claires. <br>
<br>
Les pointeurs sont utilisés dans <strong>tous</strong> les programmes C++, même si vous n'en avez pas eu conscience jusque là. Il y en a partout. Pour l'instant, ils étaient cachés et vous n'avez pas eu à en manipuler directement. Cela va changer avec ce chapitre. Nous allons apprendre à gérer très finement ce qui se passe dans la mémoire de l'ordinateur.  <br>
<br>
C'est un chapitre plutôt difficile, il est donc normal que vous ne compreniez pas tout du premier coup. N'ayez pas peur de le relire une seconde fois dans quelques jours pour vous assurer que vous avez bien tout assimilé !
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420448">Une question d'adresse</h2>
		<div class="ss_part_texte">
		Est-ce que vous vous rappelez du <a href="http://www.siteduzero.com/tutoriel-3-403539-1-utiliser-la-memoire.html">chapitre sur la mémoire</a> ? Oui, oui, celui qui présentait la notion de variable. Je vous invite à le relire et surtout à vous remémorer les différents schémas. <br>
<br>
Je vous avais dit que lorsque l'on déclare une variable, l'ordinateur nous prête une place dans sa mémoire et y accroche une étiquette portant le nom de la variable. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On pouvait donc représenter la mémoire utilisée dans ce programme sur le schéma suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/290887.png" alt="La mémoire lorsque l&#39;on déclare une variable"></div><br>
<br>
C'était simple et beau. Malheureusement, je vous ai un peu menti. Je vous ai simplifié les choses !<br>
Vous commencez à le savoir, dans un ordinateur tout est bien ordonné et rangé de manière logique. Le système des étiquettes dont je vous ai parlé n'est donc pas tout à fait correct. <br>
<br>
La mémoire d'un ordinateur est réellement constituée de "cases", là je ne vous ai pas menti. Il y en a même énormément. Plusieurs milliards sur un ordinateur récent ! Il faut donc un système pour que l'ordinateur puisse retrouver les cases dont il a besoin. Chaque "case" possède un numéro unique, son <strong>adresse</strong>. <br>
<br>
<div class="centre"><img src="./cpp_files/290888.png" alt="Le vrai visage de la mémoire : beaucoup de cases numérotées"></div><br>
<br>
Sur le schéma, on voit cette fois toutes les cases de la mémoire avec leur adresse. Notre programme utilise une seule de ces cases, la <strong>53768</strong>, pour y stocker sa variable. <br>
<br>
<div class="rmq erreur">On ne peut PAS mettre deux variables dans la même case.</div><br>
<br>
L'important est que chaque variable possède une seule adresse. Et chaque adresse correspond à une seule variable. <br>
<br>
L'adresse est donc un deuxième moyen d'accéder à une variable. On peut accéder à la case jaune du schéma par deux chemins différents :<br>
<br>
<ul>	
<li>On peut passer par <strong>son nom</strong> (l'étiquette) comme on sait déjà le faire...</li>	
<li>Mais on peut aussi accéder à la variable grâce à son <strong>adresse </strong>(son numéro de case).. On pourrait alors dire à l'ordinateur "<span class="italique">Affiche moi le contenu de l'adresse 53768" ou encore "Additionne les contenus des adresses 1267 et 91238</span>".</li>
</ul><br>
<br>
Est-ce que ça vous tente d'essayer ?  <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> Vous vous demandez peut-être à quoi ça peut bien servir. Utiliser l'étiquette était un moyen simple et efficace. C'est vrai. Mais nous verrons plus loin que passer par les adresses peut parfois être nécessaire.<br>
<br>
Commençons par voir comment connaître l'adresse d'une variable.<br>
<br>
<h3>Afficher l'adresse</h3><br>
<br>
En C++, le symbole pour obtenir l'adresse d'une variable est l'espérluette (<strong>&amp;</strong>). Si je veux afficher l'adresse de la variable <span class="code2 cpp"><span class="n">ageUtilisateur</span></span>, je dois donc écrire <span class="code2 cpp"><span class="o">&amp;</span><span class="n">ageUtilisateur</span></span>. Essayons. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"L'adresse est : "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">ageUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// Affichage de l'adresse de la variable</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Chez moi, j'obtiens le résultat suivant :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>L'adresse&nbsp;est&nbsp;:&nbsp;0x22ff1c</pre></div></td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Vous aurez certainement un résultat différent. La case peut changer d'une exécution à l'autre du programme. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
Même si elle contient des lettres, cette adresse est un nombre. Celui-ci est juste écrit en héxadécimal (en base 16), une autre façon d'écrire les nombres. Les ordinateurs aiment bien travailler dans cette base. Pour information, en base 10, dans notre écriture courante, cette adresse correspond à <strong>2 293 532</strong>. Ce n'est pas une information très intéressante cependant.  <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> <br>
<br>
Ce qui est sûr c'est qu'afficher une adresse est très rarement utile. Souvenez-vous simplement de la notation. L'esperluette veut dire "adresse de". Donc <span class="code2 cpp"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span></span> se traduit en français par "<span class="italique">Affiche l'adresse de la variable a</span>". <br>
<br>
<div class="rmq attention">On a déjà utilisé l'esperluette dans ce cours pour tout autre chose : lors de la déclaration d'une <a href="http://www.siteduzero.com/tutoriel-3-403539-1-utiliser-la-memoire.html#ss_part_5">référence</a>. C'est le même symbole qui est utilisé pour deux choses différentes. <br>
Attention à ne pas vous tromper !</div><br>
<br>
Voyons maintenant ce que l'on peut faire avec ces adresses.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420471">Les pointeurs</h2>
		<div class="ss_part_texte">
		Les adresses sont des nombres. Vous connaissez plusieurs types permettant de stocker des nombres : <span class="code2 cpp"><span class="kt">int</span></span>, <span class="code2 cpp"><span class="kt">unsigned</span> <span class="kt">int</span></span>, <span class="code2 cpp"><span class="kt">double</span></span>. Peut-on donc stocker une adresse dans une variable ?<br>
<br>
La réponse est "oui". C'est possible. Mais pas avec les types que vous connaissez. Il nous faut utiliser un type un peu particulier : le <strong>pointeur</strong>.<br>
<br>
<strong>Un pointeur est une variable qui contient l'adresse d'une autre variable.</strong><br>
<br>
Retenez bien cette phrase. Elle peut vous sauver la vie dans les moments les plus difficiles de ce chapitre.  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies"> <br>
<br>
<h3>Déclarer un pointeur</h3><br>
<br>
Pour déclarer un pointeur, il faut, comme pour les variables, deux choses :<br>
<ul>
<li>Un type</li>
<li>Un nom</li>
</ul><br>
Pour le nom, il n'y a rien de particulier à signaler. Les mêmes règles que pour les variables s'appliquent. Ouf !<br>
Le type d'un pointeur a une petite subtilité. Il faut indiquer quel est le type de variable dont on veut stocker l'adresse et ajouter une étoile (<strong>*</strong>).  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> Je crois qu'un exemple sera plus simple.<br>
<br>
<span class="code">Code : C++ - Déclaration d'un pointeur - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">pointeur</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce code déclare un pointeur qui peut contenir l'adresse d'une variable de type <span class="code2 cpp"><span class="kt">int</span></span>. <br>
<br>
<br>
<div class="rmq information">On peut également écrire <span class="code2 cpp"><span class="kt">int</span><span class="o">*</span> <span class="n">pointeur</span></span> (l'étoile collée au mot <span class="code2 cpp"><span class="kt">int</span></span>). <br>
Cette notation a un léger désavantage, c'est qu'on ne peut pas déclarer plusieurs pointeurs sur la même ligne comme ceci : <span class="code2 cpp"><span class="kt">int</span><span class="o">*</span> <span class="n">pointeur1</span><span class="p">,</span> <span class="n">pointeur2</span><span class="p">,</span> <span class="n">pointeur3</span><span class="p">;</span></span>. En faisant ça, seul <span class="code2 cpp"><span class="n">pointeur1</span></span> sera un pointeur, les deux autres variables seront des entiers tout à fait standards.</div><br>
<br>
On peut bien sûr faire ça pour n'importe quel type :<br>
<br>
<br>
<span class="code">Code : C++ - Déclaration de pointeurs - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">double</span> <span class="o">*</span><span class="n">pointeurA</span><span class="p">;</span> <span class="c1">//Un pointeur qui peut contenir l'adresse d'un nombre a virgule</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pointeurB</span><span class="p">;</span> <span class="c1">//Un pointeur qui peut contenir l'adresse d'un nombre entier positif</span>

<span class="n">string</span> <span class="o">*</span><span class="n">pointeurC</span><span class="p">;</span> <span class="c1">//Un pointeur qui peut contenir l'adresse d'une chaîne de caractères</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pointeurD</span><span class="p">;</span> <span class="c1">//Un pointeur qui peut contenir l'adresse d'un tableau dynamique de nombres entiers</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Pour le moment, ces pointeurs ne contiennent aucune adresse connue. C'est une situation très dangereuse. Si vous essayez d'utiliser le pointeur, vous ne savez pas quelle case de la mémoire vous manipulez. Ca peut être n'importe laquelle, par exemple la case qui contient votre mot de passe Windows ou la case qui contient l'heure actuelle. J'imagine que vous vous rendez compte des conséquences que peut avoir une mauvaise manipulation des pointeurs. Il ne faut donc <strong>JAMAIS</strong> déclarer un pointeur sans lui donner d'adresse. <br>
<br>
Il faut donc toujours déclarer un pointeur en lui donnant la valeur 0 pour être tranquille :<br>
<br>
<span class="code">Code : C++ - Déclaration d'un pointeur - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">pointeur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">pointeurA</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> 
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pointeurB</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">string</span> <span class="o">*</span><span class="n">pointeurC</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pointeurD</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous l'avez peut-être remarqué sur mon schéma un peu plus tôt, la première case de la mémoire avait l'adresse 1. En effet, l'adresse 0 n'existe pas.<br>
Lorsque vous créez un pointeur contenant l'adresse 0, cela signifie qu'il ne contient l'adresse d'<strong>aucune</strong> case.<br>
<br>
<div class="rmq erreur">Je me répète, mais c'est très important : déclarez toujours vos pointeurs en les initialisant à l'adresse 0.</div><br>
<br>
<h3>Stocker une adresse</h3><br>
<br>
Maintenant qu'on a la variable, il n'y a plus qu'à mettre une valeur dedans. Vous savez déjà comment obtenir l'adresse d'une variable (rappelez-vous du <strong>&amp;</strong>). Allons-y !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>    <span class="c1">//Une variable de type int.</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>               <span class="c1">//Un pointeur pouvant contenir l'adresse d'un nombre entier.</span>

    <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ageUtilisateur</span><span class="p">;</span>  <span class="c1">//On met l'adresse de 'ageUtilisateur' dans le pointeur 'ptr'.</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La ligne 6 est celle qui nous intéresse. Elle écrit l'adresse de la variable <span class="code2 cpp"><span class="n">ageUtilisateur</span></span> dans le pointeur <span class="code2 cpp"><span class="n">ptr</span></span>. On dit alors que le pointeur <span class="code2 cpp"><span class="n">ptr</span></span> <strong>pointe sur</strong> <span class="code2 cpp"><span class="n">ageUtilisateur</span></span>.<br>
<br>
Voyons comment tout cela se déroule dans la mémoire avec un ... schéma !  <img src="./cpp_files/rire.gif" alt=":lol:" class="smilies"> <br>
<br>
<div class="centre"><br>
<img src="./cpp_files/290889.png" alt="La mémoire après la déclaration d&#39;une variable et d&#39;un pointeur pointant sur la variable"></div><br>
<br>
On retrouve quelques éléments familiers. La mémoire avec sa grille de cases et la variable <span class="code2 cpp"><span class="n">ageUtilisateur</span></span> dans la case n°53768. <br>
La nouveauté est bien sûr le pointeur. Dans la case mémoire n°14566, il y a une variable nommée <span class="code2 cpp"><span class="n">ptr</span></span> qui a pour valeur l'adresse 53768, c'est-à-dire l'adresse de la variable <span class="code2 cpp"><span class="n">ageUtilisateur</span></span>.<br>
<br>
Voilà. Vous savez tout ou presque. Cela peut sembler absurde pour le moment ("Pourquoi stocker l'adresse d'une variable dans une autre case ?"), mais faites-moi confiance les choses vont progressivement s'éclairer pour vous.<br>
Si vous avez compris le schéma précédent, alors vous pouvez vous attaquer aux programmes les plus complexes. <br>
<br>
<h3>Afficher l'adresse</h3><br>
<br>
Comme pour toutes les variables, on peut afficher le contenu d'un pointeur. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  

    <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ageUtilisateur</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"L'adresse de 'ageUtilisateur' est : "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">ageUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"La valeur de pointeur est : "</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>    

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce qui donne :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>L'adresse&nbsp;de&nbsp;'ageUtilisateur'&nbsp;est&nbsp;:&nbsp;0x2ff18
La&nbsp;valeur&nbsp;de&nbsp;pointeur&nbsp;est&nbsp;:&nbsp;0x2ff18</pre></div></td></tr></tbody></table></div><br>
<br>
La valeur du pointeur est donc bien l'adresse de la variable pointée. On a bien réussi à stocker une adresse ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<h3>Accéder à la valeur pointée</h3><br>
<br>
Vous vous souvenez du but des pointeurs ? Accéder à une variable sans passer par son nom. Voici comment faire. Il faut utiliser l'étoile (<strong>*</strong>) sur le pointeur pour afficher la valeur de la variable pointée. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ageUtilisateur</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  

    <span class="n">ptr</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">ageUtilisateur</span><span class="p">;</span>
	
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"La valeur est :  "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>   

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
En faisant <span class="code2 cpp"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr</span></span>, le programme va effectuer les étapes suivantes :<br>
<br>
<ol class="liste_1">
<li>Aller dans la case mémoire nommée <span class="code2 cpp"><span class="n">ptr</span></span>.</li>
<li>Lire la valeur enregistrée.</li>
<li>"Suivre la flèche" pour aller à l'adresse pointée.</li>
<li>Lire la valeur stockée dans la case.</li>
<li>Afficher cette valeur. Ici, ce sera bien sûr 16 qui sera affiché.</li></ol><br>
<br>
En utilisant l'étoile, on accède à la <strong>valeur de la variable pointée</strong>. C'est ce qui s'appelle <strong>déréférencer </strong>un pointeur. <br>
Voici donc un deuxième moyen d'accéder à la valeur de <span class="code2 cpp"><span class="n">ageUtilisateur</span></span>. <br>
<br>
<div class="rmq question">Mais, à quoi cela sert-il ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> </div><br>
<br>
Je suis sûr que vous vous êtes retenu de poser la question avant. <img src="./cpp_files/smile.png" alt=":)" class="smilies"> C'est vrai que ça a l'air assez inutile. Eh bien, je ne peux pas vous répondre rapidement pour le moment. <img src="./cpp_files/triste.png" alt=":(" class="smilies"> <br>
Il va falloir lire la fin de ce chapitre pour tout savoir. <br>
<br>
<h3>Récapitulatif de la notation</h3><br>
<br>
Je suis d'accord avec vous, la notation est compliquée. L'étoile a deux significations différentes et on utilise l'esperluette alors qu'elle est déjà utilisée pour les références... Ce n'est pas ma faute ! Si vous voulez vous plaindre, il faut voir du côté des concepteurs du langage. C'est eux les responsables de ce charabia.  <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies"> <br>
Nous, on ne peut que faire avec. Essayons donc de récapituler le tout.<br>
<br>
Pour une variable <span class="code2 cpp"><span class="kt">int</span> <span class="n">nombre</span></span> :<br>
<ul>
<li> <span class="code2 cpp"><span class="n">nombre</span></span> permet d'accéder à la <strong>valeur </strong> de la variable.</li>
<li> <span class="code2 cpp"><span class="o">&amp;</span><span class="n">nombre</span></span> permet d'accéder à l' <strong>adresse</strong> de la variable.</li>
</ul><br>
Sur un pointeur <span class="code2 cpp"><span class="kt">int</span> <span class="o">*</span><span class="n">pointeur</span></span> :<br>
<ul>
<li> <span class="code2 cpp"><span class="n">pointeur</span></span> permet d'accéder à la <strong>valeur </strong>du pointeur, c'est-à-dire à l'<strong>adresse de la variable pointée</strong>.</li>
<li> <span class="code2 cpp"><span class="o">*</span><span class="n">pointeur</span></span> permet d'accéder à la <strong>valeur de la variable pointée</strong>.</li>
</ul><br>
<br>
C'est ce qu'il faut retenir de cette sous-partie. Je vous invite à tester tout ça chez vous pour bien vérifier que vous avez compris comment afficher une adresse, comment utiliser un pointeur, etc. <br>
<br>
"C'est en forgeant qu'on devient forgeron" dit le dicton, et bien c'est en programmant avec des pointeurs que l'on devient programmeur. Il faut impérativement s'entraîner pour bien comprendre. Les meilleurs sont tous passés par là et je peux vous assurer qu'ils ont aussi souffert en découvrant les pointeurs. Si vous ressentez une petite douleur dans la tête, prenez un cachet d'aspirine, faites une pause, puis relisez ce que vous venez de lire encore et encore. Aidez-vous en particulier des schémas ! <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420439">L'allocation dynamique</h2>
		<div class="ss_part_texte">
		Vous vouliez savoir à quoi servent les pointeurs ? Vous êtes sûr ? Bon, alors je vous montre une première utilisation.<br>
<br>
<h3>La gestion automatique de la mémoire</h3><br>
<br>
Dans notre tout premier chapitre sur les variables, je vous avais expliqué que lors de la déclaration d'une variable, le programme effectuait deux étapes :<br>
<ol class="liste_1">	
<li>Il demande à l'ordinateur de lui fournir une zone dans la mémoire. En termes techniques, on parle d'<strong>allocation</strong> de la mémoire.</li>	
<li>Il remplit cette case avec la valeur fournie. On parle alors d'<strong>initialisation</strong> de la variable.</li></ol><br>
<br>
Tout cela est entièrement automatique, le programme se débrouille tout seul. De même lorsque l'on arrive à la fin d'une fonction, le programme rend la mémoire utilisée à l'ordinateur. C'est ce qu'on appelle la <strong>libération </strong>de la mémoire. C'est à nouveau automatique. Nous n'avons jamais dû dire à l'ordinateur : "Tiens reprends cette case mémoire, je n'en ai plus besoin." <br>
<br>
Tout ceci se faisait automatiquement. Nous allons maintenant apprendre à le faire manuellement, et pour cela... vous vous doutez sûrement qu'on va utiliser les pointeurs.  <img src="./cpp_files/soleil.png" alt=":soleil:" class="smilies"> <br>
<br>
<h3>Allouer un espace mémoire</h3><br>
<br>
Pour demander manuellement une case dans la mémoire, il faut utiliser l'opérateur <span class="code2 cpp"><span class="k">new</span></span>.<br>
<span class="code2 cpp"><span class="k">new</span></span> va demander une case à l'ordinateur et renvoyer un <strong>pointeur</strong> pointant vers cette case.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">pointeur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">pointeur</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La deuxième ligne demande une case mémoire pouvant stocker un entier et l'adresse de cette case est stockée dans le pointeur. Le mieux est encore de prendre un petit schéma.<br>
<br>
<div class="centre"><img src="./cpp_files/290938.png" alt="La mémoire après l&#39;allocation dynamique d&#39;un entier"></div><br>
<br>
Ce schéma est très similaire au précédent. Il y a deux cases mémoires utilisées :<br>
<ul>
<li> La case 14563 qui contient une variable de type <span class="code2 cpp"><span class="kt">int</span></span> non-initialisée.</li>
<li> La case 53771 qui contient un pointeur pointant sur la variable.</li>
</ul><br>
Rien de neuf. Mais, la chose importante, c'est que la variable à la case 14563 n'a <strong>pas </strong>d'étiquette. Le seul moyen d'y accéder est donc de passer par le pointeur. <br>
<br>
<div class="rmq erreur">Si vous changez la valeur du pointeur, vous perdez le seul moyen d'accès à la case mémoire. Vous ne pourrez donc plus l'utiliser ni la supprimer ! Elle sera définitivement perdue mais elle continuera à prendre de la place. C'est ce qu'on appelle une <strong>fuite de mémoire</strong>.<br>
Il faut donc faire très attention ! <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> </div><br>
<br>
Une fois allouée manuellement, la variable s'utilise comme n'importe quelle autre. On doit juste se rappeler qu'il faut y accéder par le pointeur en le déréférençant. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">pointeur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">pointeur</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>

<span class="o">*</span><span class="n">pointeur</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//On accède à la case mémoire pour en modifier la valeur</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La case sans étiquette est maintenant remplie. La mémoire est donc dans l'état suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/292097.png" alt="La mémoire après avoir alloué une variable et changé la valeur de cette variable"></div><br>
<br>
A part son accès un peu spécial (via <span class="code2 cpp"><span class="o">*</span><span class="n">pointeur</span></span>), nous avons donc une variable en tout point semblable à une autre.<br>
<br>
Il nous faut maintenant rendre la mémoire que l'ordinateur nous a gentiment prêtée. <br>
<br>
<h3>Libérer la mémoire</h3><br>
<br>
Une fois que l'on a plus besoin de la case mémoire, il faut la rendre à l'ordinateur. Cela se fait via l'opérateur <span class="code2 cpp"><span class="k">delete</span></span>.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">pointeur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">pointeur</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>

<span class="k">delete</span> <span class="n">pointeur</span><span class="p">;</span>    <span class="c1">//On libère la case mémoire</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La case est alors rendue à l'ordinateur qui pourra l'utiliser pour autre chose. Le pointeur, lui, existe toujours. Et il pointe toujours sur la case mais vous n'avez <strong>plus le droit</strong> de l'utiliser. <br>
<br>
<div class="centre"><img src="./cpp_files/292100.png" alt="Un pointeur pointant sur une case vide après un appel à delete."></div><br>
<br>
L'image est très parlante. Si l'on suit la flèche, on arrive sur une case qui ne nous appartient pas. Il faut donc impérativement empêcher ça. Imaginez que cette case soit soudainement utilisée par un autre programme ! Vous risqueriez de modifier les variables de cet autre programme. <br>
Il est donc <strong>essentiel</strong> de supprimer cette "flèche" en mettant le pointeur à l'adresse 0 après avoir utilisé <span class="code2 cpp"><span class="k">delete</span></span>. Ne pas le faire est une source très courante de plantage des programmes.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">pointeur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">pointeur</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>

<span class="k">delete</span> <span class="n">pointeur</span><span class="p">;</span>    <span class="c1">//On libère la case mémoire</span>
<span class="n">pointeur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">//On indique que le pointeur ne pointe vers plus rien</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq erreur">N'oubliez pas de libérer la mémoire. Si vous ne le faites pas, votre programme risque d'utiliser de plus en plus de mémoire jusqu'au moment où il n'y aura plus aucune case disponible ! Votre programme va alors planter. </div><br>
<br>
<h3>Un exemple complet</h3><br>
<br>
Terminons cette section avec un exemple complet : un programme qui demande son âge à l'utilisateur et qui l'affiche en utilisant un pointeur. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
     <span class="kt">int</span><span class="o">*</span> <span class="n">pointeur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
     <span class="n">pointeur</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>

     <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Quel est votre age ? "</span><span class="p">;</span>
     <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="n">pointeur</span><span class="p">;</span> <span class="c1">//On écrit dans la case mémoire pointée par le pointeur 'pointeur'</span>

     <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous avez "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">pointeur</span> <span class="o">&lt;&lt;</span> <span class="s">" ans."</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//On utilise à nouveau *pointeur</span>

     <span class="k">delete</span> <span class="n">pointeur</span><span class="p">;</span>   <span class="c1">//Ne pas oublier de libérer la mémoire</span>
     <span class="n">pointeur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">//Et de faire pointer le pointeur vers rien</span>

     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce programme est plus compliqué que sa version sans allocation dynamique ! C'est vrai. Mais on a le contrôle complet sur l'allocation et la libération de la mémoire. <br>
<br>
Dans la plupart des cas, ce n'est pas utile de le faire. Mais vous verrez plus tard, que pour faire des fenêtres, la bibliothèque Qt utilise beaucoup <span class="code2 cpp"><span class="k">new</span></span> et <span class="code2 cpp"><span class="k">delete</span></span>. On peut ainsi maîtriser précisément quand une fenêtre est ouverte et quand on la referme par exemple. 
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420455">Quand utiliser des pointeurs</h2>
		<div class="ss_part_texte">
		Je vous avais promis des explications sur quand utiliser des pointeurs. La voici. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Il y a en réalité trois cas d'application :<br>
<ul>
<li>Gérer soi-même le moment de la création et de la destruction des cases mémoire.</li>
<li>Partager une variable dans plusieurs morceaux du code.</li>
<li>Sélectionner une valeur parmi plusieurs options.</li>
</ul><br>
Si vous n'êtes pas dans un de ces trois cas, c'est très certainement que vous n'avez pas besoin des pointeurs. <br>
<br>
Vous connaissez déjà le premier de ces trois cas. Concentrons nous sur les deux autres.<br>
<br>
<h3>Partager une variable</h3><br>
<br>
Pour l'instant, je ne peux pas vous donner un code source complet pour ce cas d'utilisation. Ou alors, il ne sera pas intéressant du tout. Quand vous aurez quelques notions de programmation orientée objet, vous aurez de vrais exemples.<br>
<br>
En attendant, je vous propose un exemple plus ... visuel.  <img src="./cpp_files/smile.png" alt=":)" class="smilies"> <br>
<br>
Vous avez déjà joué à un jeu de stratégie ? J'imagine que oui, prenons un exemple tiré d'un jeu de ce genre. Voici une image issue du fameux <span class="italique">Warcraft III</span>.<br>
<br>
<div class="centre"><img src="./cpp_files/290951.png" alt="Image utilisateur"></div><br>
<br>
Programmer un tel jeu est bien sûr très compliqué. Mais on peut quand même réfléchir à certains des mécanismes utilisés. Sur l'image, on voit des humains en rouge attaquer des orcs en bleu. Chaque personnage a une cible précise. Par exemple, le fusilier au milieu de l'écran semble tirer sur le gros personnage bleu qui tient une hache. <br>
<br>
Nous verrons dans la suite de ce cours comment créer des objets, c'est-à-dire des variables plus évoluées. Par exemple une variable de type "personnage", de type "orc" ou encore de type "batiment". Bref, chaque élément du jeu pourra être modélisé en C++ par un objet. <br>
<br>
Comment feriez-vous pour indiquer, en C++, la cible du personnage rouge ?  <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> <br>
Bien sûr, vous ne savez pas encore comment faire en détail, mais vous avez peut-être une petite idée. Rappelez-vous du titre de ce chapitre.  <img src="./cpp_files/smile.png" alt=":)" class="smilies"> <br>
Oui oui, un pointeur est une bonne solution ! Chaque personnage possède un pointeur qui pointe vers sa cible. Il a ainsi un moyen de savoir qui viser et attaquer. On pourrait par exemple écrire quelque chose comme :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span> <span class="o">*</span><span class="n">cible</span><span class="p">;</span> <span class="c1">//Un pointeur qui pointe sur un autre personnage</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Quand il n'y a pas de combat en cours, le pointeur pointe vers l'adresse 0, il n'a pas de cible. Quand le combat est engagé, le pointeur pointe vers un ennemi. Et finalement, quand cet ennemi meurt, on déplace le pointeur vers une autre adresse, c'est-à-dire vers un autre personnage. <br>
<br>
Le pointeur est donc réellement utilisé ici comme une flèche reliant un personnage à son ennemi. <br>
<br>
Nous verrons comment écrire du code comme cela dans la suite, je crois même qu'un des TP sera de créer un mini-jeu de ce genre. Mais chut, c'est pour plus tard.  <img src="./cpp_files/smile.png" alt=":)" class="smilies"> <br>
<br>
<h3>Choisir parmi plusieurs éléments</h3><br>
<br>
Le troisième et dernier cas permet de faire évoluer un programme en fonction des choix de l'utilisateur. <br>
Prenons le cas d'un QCM. Nous allons demander à l'utilisateur de choisir parmi trois réponses possibles à une question. Une fois qu'il aura choisi, nous allons utiliser un pointeur pour indiquer quelle réponse a été choisie. <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">reponseA</span><span class="p">,</span> <span class="n">reponseB</span><span class="p">,</span> <span class="n">reponseC</span><span class="p">;</span>
    <span class="n">reponseA</span> <span class="o">=</span> <span class="s">"La peur des jeux de loterie"</span><span class="p">;</span>
    <span class="n">reponseB</span> <span class="o">=</span> <span class="s">"La peur du noir"</span><span class="p">;</span>
    <span class="n">reponseC</span> <span class="o">=</span> <span class="s">"La peur des vendredis treize"</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Qu'est-ce que la 'kenophobie' ? "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//On pose la question</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A) "</span> <span class="o">&lt;&lt;</span> <span class="n">reponseA</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//Et on affiche les trois propositions</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B) "</span> <span class="o">&lt;&lt;</span> <span class="n">reponseB</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C) "</span> <span class="o">&lt;&lt;</span> <span class="n">reponseC</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="kt">char</span> <span class="n">reponse</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Votre reponse (A,B ou C) : "</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">reponse</span><span class="p">;</span>                         <span class="c1">//On récupère la réponse de l'utilisateur</span>

    <span class="n">string</span> <span class="o">*</span><span class="n">reponseUtilisateur</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>          <span class="c1">//Un pointeur qui pointera sur la réponse choisie</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">reponse</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="sc">'A'</span><span class="o">:</span>
        <span class="n">reponseUtilisateur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reponseA</span><span class="p">;</span>  <span class="c1">//On déplace le pointeur sur la réponse choisie</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'B'</span><span class="o">:</span>
        <span class="n">reponseUtilisateur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reponseB</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'C'</span><span class="o">:</span>
        <span class="n">reponseUtilisateur</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">reponseC</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//On peut alors utiliser le pointeur pour afficher la réponse choisie</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vous avez choisi la reponse : "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">reponseUtilisateur</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Une fois que le pointeur a été déplacé (dans le <span class="code2 cpp"><span class="k">switch</span></span>) on peut l'utiliser comme moyen d'accès à la réponse de l'utilisateur. On a ainsi un moyen d'atteindre directement cette variable sans devoir refaire le test à chaque fois qu'on en a besoin. <br>
C'est une variable qui contient une valeur que l'on ne pouvait pas connaître avant (puisqu'elle dépend de ce que l'utilisateur a entré). <br>
<br>
C'est certainement le cas d'utilisation le plus rare des trois, mais il arrive parfois qu'on soit dans cette situation. Il sera alors temps de vous rappeler des pointeurs !  <img src="./cpp_files/clin.png" alt=";)" class="smilies"> <br>

		</div>
		<hr>
		
	<div id="chap_conclusion">
	Nous en avons fini avec les bases du C++ !<br>
<br>
Vous n'avez peut-être pas tout compris dans les moindres détails, ce n'est pas grave ! C'est surtout en pratiquant que l'on apprend et je vous assure que de nombreuses personnes (dont moi  <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ) ont eu besoin de beaucoup de temps pour bien tout saisir. Certaines des notions présentées jusque-là vont réapparaître plus loin dans le cours, ce sera alors le moment de venir lire ce qu'il vous manquait. <br>
<br>
Vous êtes prêt ? Alors attaquons le monde magique de la <span class="italique">programmation orientée objet</span>, le coeur du C++...  <img src="./cpp_files/magicien.png" alt=":magicien:" class="smilies">
	</div>
	
<div>
<br>

</div>

<hr>
<h2>Partie 2 : [Théorie] La Programmation Orientée Objet</h2>
<div>
Maintenant que vous connaissez les bases de la programmation C++, attaquons le coeur du sujet : la programmation orientée objet (POO) !<br>
Soyez attentifs car les choses deviennent un peu plus complexes à partir d'ici. Prenez bien le temps de tout lire, car vous ne pouvez pas faire de C++ sans bien connaître la POO. <img src="./cpp_files/clin.png" alt=";)" class="smilies">
</div>
	
	<hr>
	<h1 id="chap_11159">Introduction : la vérité sur les strings enfin dévoilée</h1>
	<div id="chap_intro">
	Nous attaquons la 2ème moitié de la première partie du cours de C++. Et comme dans la vie rien n'est jamais simple, cette "deuxième moitié" sera la plus dense et... la plus délicate aussi. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Nous allons maintenant, et dans les chapitres suivants, découvrir la notion de <strong>programmation orientée objet</strong> (POO).  Comme je vous l'ai dit plus tôt, c'est une nouvelle façon de programmer. Ca ne va pas révolutionner immédiatement vos programmes, ça va vous paraître un peu inutile au début, mais faites-moi confiance : faites l'effort de faire ce que je dis à la lettre, et bientôt vous serez bien plus efficaces lorsque vous programmerez.<br>
<br>
Ce chapitre va vous parler des 2 facettes de la POO, le côté <span class="italique">utilisateur </span>et le côté <span class="italique">créateur</span>.<br>
Puis, je vais faire carrément l'inverse de ce que tous les cours de programmation font (je sais je suis fou <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ) : au lieu de commencer par vous apprendre à <span class="italique">créer </span>des objets, je vais d'abord vous montrer comment les <span class="italique">utiliser </span>avec pour exemple le type <strong>string</strong> fourni par le langage C++.
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11158">Des objets... pour quoi faire ?</h2>
		<div class="ss_part_texte">
		<h3>Ils sont beaux, ils sont frais mes objets</h3><br>
<br>
S'il y a bien un mot qui doit vous frustrer depuis que vous en entendez parler, c'est celui-ci : <strong>objet</strong>.<br>
<br>
<div class="rmq question">Encore un concept mystique ? Un délire de programmeurs après une soirée trop arrosée ?<br>
Non parce que franchement, un objet c'est quoi ? Mon écran est un objet, ma voiture est un objet, mon téléphone portable... ce sont tous des objets !</div><br>
<br>
Bien vu, c'est un premier point. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
En effet, nous sommes entourés d'objets. En fait, tout ce que nous connaissons (ou presque) peut être considéré comme un objet. L'idée de la programmation orientée objet, c'est de manipuler des éléments que l'on appelle des "objets" dans son code source.<br>
<br>
<div class="rmq question">Mais concrètement, c'est quoi ? Une variable ? Une fonction ?</div><br>
<br>
Ni l'un, ni l'autre. C'est un nouvel élément en programmation.<br>
Pour être plus précis, un objet c'est... un mélange de plusieurs variables et fonctions. <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"><br>
<br>
Ne faites pas cette tête-là, vous allez découvrir tout cela par la suite. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Imaginez... un objet</h3><br>
<br>
Pour éviter que ce que je vous raconte ressemble à un traité d'art moderne conceptuel, on va imaginer ensemble ce qu'est un objet à l'aide de plusieurs schémas concrets.<br>
Les schémas 3D que vous allez voir par la suite ont été réalisés pour moi par l'ami Nab, que je remercie d'ailleurs vivement au passage.<br>
<br>
<br>
Imaginez qu'un programmeur décide un jour de créer un programme qui permet d'afficher une fenêtre à l'écran, de la redimensionner, de la déplacer, de la supprimer... Le code est complexe : il va avoir besoin de plusieurs fonctions qui s'appellent entre elles, et de variables pour mémoriser la position, la taille de la fenêtre, etc.<br>
Il met du temps à écrire ce code, c'est un peu compliqué, mais il y arrive. Au final, le code qu'il a écrit est composé de plusieurs fonctions et variables. Quand on regarde ça pour la première fois, ça ressemble à une expérience de savant fou à laquelle on ne comprend rien :<br>
<br>
<br>
<div class="centre"><img src="./cpp_files/50574.jpg" alt="Image utilisateur"></div><br>
<br>
<br>
Ce programmeur est content de son code et veut le distribuer sur internet pour que tout le monde puisse créer des fenêtres sans passer du temps à tout réécrire. Seulement voilà, à moins d'être un expert en chimie certifié, vous allez mettre pas mal de temps avant de comprendre comment tout ce bazar fonctionne. <br>
<br>
Quelle fonction appeler en premier ? Quelles valeurs envoyer à quelle fonction pour redimensionner la fenêtre ? Autrement dit : comment utiliser ce bazar sans qu'une fiole ne nous explose entre les mains ? <img src="./cpp_files/huh.png" alt=":o" class="smilies"><br>
<br>
C'est là que notre ami programmeur pense à nous. Il conçoit son code <span class="souligne">de manière orientée objet</span>. Cela signifie qu'il place tout son bazar chimique à l'intérieur d'un simple cube. Ce cube est ce qu'on appelle un objet :<br>
<br>
<div class="centre"><img src="./cpp_files/50705.jpg" alt="Image utilisateur"></div><br>
<br>
Ici, une partie du cube a été volontairement mise en transparence pour vous montrer que nos fioles chimiques sont bien situées à l'intérieur du cube. Mais en réalité, le cube est complètement opaque, on ne voit <strong>rien</strong> de ce qu'il y a à l'intérieur :<br>
<br>
<div class="centre"><img src="./cpp_files/50704.jpg" alt="Image utilisateur"></div><br>
<br>
Ce cube contient toutes les fonctions et les variables (nos fioles de chimie), mais il les <span class="souligne">masque</span> à l'<span class="vertf">utilisateur</span>.<br>
<br>
Au lieu d'avoir des tonnes de tubes et fioles chimiques dont il faut comprendre le fonctionnement, on nous propose juste quelques boutons sur la face avant du cube : un bouton "ouvrir fenêtre", un bouton "redimensionner", etc. L'<span class="vertf">utilisateur </span>n'a plus qu'à se servir des boutons du cube et n'a plus besoin de se soucier de tout ce qui se passe à l'intérieur. Pour l'utilisateur, c'est donc complètement simplifié.<br>
<br>
En clair : programmer de manière orientée objet, c'est <span class="italique"><span class="rouge">créer</span></span> du code source (peut-être complexe), mais que l'on <span class="souligne">masque</span> en le plaçant à l'intérieur d'un cube (un objet) à travers lequel on ne voit rien. Pour le programmeur qui va l'<span class="italique"><span class="vertf">utiliser</span></span>, travailler avec un objet est donc beaucoup plus simple qu'avant : il a juste à appuyer sur des boutons et n'a pas besoin d'être diplômé en chimie pour s'en servir.<br>
<br>
Bien sûr, c'est une image, mais c'est ce qu'il faut comprendre et retenir pour le moment. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<br>
Nous n'allons pas voir tout de suite comment faire pour <span class="italique"><span class="rouge">créer </span></span>des objets. En revanche, nous allons apprendre à en <span class="italique"><span class="vertf">utiliser </span></span>un. Nous allons nous pencher sur le cas de <span class="code2 cpp"><span class="n">string</span></span> dans ce chapitre.<br>
<br>
<div class="rmq question">J'ai déjà utilisé le type string, ce n'est pas une nouveauté pour moi ! C'est le type qui permet de stocker du texte en mémoire c'est ça ?</div><br>
<br>
Oui. Mais comme je vous l'ai dit il y a quelques chapitres, le type string est différent des autres. <span class="code2 cpp"><span class="kt">int</span></span>, <span class="code2 cpp"><span class="kt">bool</span></span>, <span class="code2 cpp"><span class="kt">float</span></span>, <span class="code2 cpp"><span class="kt">double</span></span> sont des types naturels du C++. Ils stockent des données très simples. Ce n'est pas le cas de <span class="code2 cpp"><span class="n">string</span></span> qui est en fait... un objet ! Le type <span class="code2 cpp"><span class="n">string</span></span> cache beaucoup de secrets à l'intérieur de sa boîte.<br>
<br>
Jusqu'ici, nous n'avons fait qu'appuyer sur des boutons (comme sur les schémas), mais en réalité ce qui se cache à l'intérieur de la boîte des objets <span class="code2 cpp"><span class="n">string</span></span> est très complexe. Horriblement complexe. <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> 
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_420450">L'horrible secret du type string</h2>
		<div class="ss_part_texte">
		<div class="flot_droite"><img src="./cpp_files/291986.png" alt="L&#39;horrible secret du type string"></div>Les enfants, il faut que je vous raconte une terrible vérité : <span class="barre">le Père Noël n'existe pas</span> ! Euh non... mauvaise fiche désolé. Ah oui, voilà ce que je voulais dire : le type string est affreusement plus complexe qu'il n'en a l'air au fond de ses entrailles.<br>
<br>
Grâce aux mécanismes de la programmation orientée objet, nous avons pu utiliser le type string dès les premiers chapitres de ce cours alors qu'il est pourtant assez compliqué dans son fonctionnement interne ! Pour vous en convaincre, je vais vous montrer comment fonctionne string "à l'intérieur du cube". Préparez-vous à d'horribles vérités. <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> <br>
<br>
<h3>Pour un ordinateur, les lettres n'existent pas</h3><br>
<br>
Comme nous l'avons vu, l'avantage des objets est de masquer la complexité du code au programmeur. Plutôt que de manipuler des fioles chimiques dangereuses, ils nous permettent d'appuyer sur de simples boutons pour faire des choses parfois compliquées.<br>
<br>
Et justement, les choses sont compliquées parce qu'à la base <span class="italique">un ordinateur ne sait pas gérer du texte</span> ! Oui, l'ordinateur n'est véritablement qu'une grosse machine à calculer dénuée de sentiments. Il ne reconnaît que des nombres.<br>
<br>
<div class="rmq question">Mais alors, si l'ordinateur ne peut manipuler que des nombres, comment se fait-il qu'il puisse afficher du texte à l'écran ?</div><br>
<br>
C'est une vieille astuce que l'on utilise depuis longtemps. Peut-être avez-vous entendu parler de la <strong>table ASCII</strong> ? (prononcez "aski")<br>
C'est une table qui sert de convention pour convertir des nombres en lettres.<br>
<br>
<div class="centre"><img src="./cpp_files/290825.png" alt="Table ASCII"></div><br>
<br>
Il faut lire les colonnes "Dec" et "Glyph" en particulier pour bien comprendre. Comme vous le voyez, la lettre "A" majuscule correspond au nombre 65. La lettre "a" minuscule correspond au nombre 97, etc.<br>
<br>
<div class="rmq question">Cela veut dire qu'à chaque fois que l'ordinateur voit le nombre 65, il prend ça comme la lettre A ?</div><br>
<br>
Non, l'ordinateur ne traduit un nombre en lettre que si on le lui demande. En pratique, on va se baser sur le type de la variable pour savoir si le nombre stocké est véritablement un nombre ou en fait une lettre :<br>
<br>
<ul>	
<li>Si on utilise le type <span class="code2 cpp"><span class="kt">int</span></span> pour stocker le nombre 65, l'ordinateur considèrera que c'est un nombre.</li>	
<li>En revanche, si on utilise le type <span class="code2 cpp"><span class="kt">char</span></span> pour stocker le nombre 65, l'ordinateur se dira "C'est la lettre A". Le type <span class="code2 cpp"><span class="kt">char</span></span> (abréviation de <span class="italique">character</span>, "caractère" en français) est prévu pour stocker un caractère.</li>
</ul><br>
Le type <span class="code2 cpp"><span class="kt">char</span></span> stocke donc un nombre qui est interprété comme un caractère.<br>
<br>
<div class="rmq question">Un <span class="code2 cpp"><span class="kt">char</span></span> ne peut stocker qu'un seul caractère ? Comment fait-on alors pour stocker une phrase entière ?</div><br>
<br>
Eh bien là non plus ce n'est pas simple ! C'est un autre problème que l'on va voir...<br>
<br>
<h3>Les textes sont des tableaux de char</h3><br>
<br>
Puisque <span class="code2 cpp"><span class="kt">char</span></span> ne peut stocker qu'une seule lettre, les programmeurs ont eu l'idée de créer... un tableau de <span class="code2 cpp"><span class="kt">char</span></span> ! Les tableaux permettant de retrouver plusieurs variables d'un même type côte à côte en mémoire, ils sont le moyen idéal de stocker du texte (on parle aussi de "chaînes de caractères", vous comprenez maintenant pourquoi).<br>
<br>
Ainsi, il suffit de déclarer un tableau de <span class="code2 cpp"><span class="kt">char</span></span> comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">char</span> <span class="n">texte</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... pour pouvoir stocker du texte (environ 100 caractères) !<br>
<br>
Le texte n'est donc en fait qu'un assemblage de lettres en mémoire dans un tableau :<br>
<br>
<div class="centre"><img src="./cpp_files/290833.png" alt="Une chaîne de caractères"></div><br>
<br>
Chaque case correspond à un <span class="code2 cpp"><span class="kt">char</span></span>. Tous ces <span class="code2 cpp"><span class="kt">char</span></span> mis côte à côte forment du texte.<br>
<br>
<div class="rmq erreur">Attention : il faut prévoir suffisamment de place dans le tableau pour stocker tout le texte ! Ici, c'est un tableau de 100 cases, mais ça peut être juste si on veut stocker plusieurs phrases en mémoire !<br>
Pour résoudre ce problème, on peut créer un très grand tableau (en prévision de la taille de ce qu'on va stocker), mais cela risque parfois de consommer beaucoup de mémoire pour rien.</div><br>
<br>
<h3>Les chaînes de caractères doivent toujours terminer par \0</h3><br>
<br>
Histoire de compliquer encore les choses, l'ordinateur ne sait pas quand la chaîne de caractères s'arrête. Il a besoin d'un signal qui lui dit "<span class="italique">Stop, c'est la fin du texte ici, pas la peine d'aller lire plus loin</span>". Ce signal prend la forme d'un caractère un peu spécial appelé "\0".<br>
<br>
Le texte dans les tableaux de char doit donc <span class="souligne">toujours</span> se terminer par un \0 pour ne pas provoquer de bugs ou de plantages :<br>
<br>
<div class="centre"><img src="./cpp_files/290834.png" alt="Une chaîne de caractères avec caractère de fin"></div><br>
<br>
Compliqué n'est-ce pas ?
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11157">Créer et utiliser des objets string</h2>
		<div class="ss_part_texte">
		Vous venez d'en avoir un aperçu : gérer du texte n'est pas vraiment simple. Il faut créer un tableau de <span class="code2 cpp"><span class="kt">char</span></span> d'une taille suffisante pour stocker le texte que l'on souhaite, il faut terminer la chaîne par un symbole \0 sinon ça plante... Bref, ça fait beaucoup de choses auxquelles il faut penser.<br>
<br>
Ca ne vous rappelle pas nos fioles chimiques ? Eh oui, tout ceci est aussi dangereux et compliqué qu'une expérience de chimiste. C'est là que la programmation orientée objet intervient : un développeur place le tout dans un cube facile à utiliser où il suffit d'appuyer sur des boutons. <strong>Ce cube, c'est l'objet <span class="code2 cpp"><span class="n">string</span></span>.</strong><br>
<br>
<h3>Créer un objet string</h3><br>
<br>
La création d'un objet ressemble beaucoup à la création d'une variable classique comme <span class="code2 cpp"><span class="kt">int</span></span> ou <span class="code2 cpp"><span class="kt">double</span></span> :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt; </span><span class="c1">// Obligatoire pour pouvoir utiliser les objets string</span>
 
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
 
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">maChaine</span><span class="p">;</span> <span class="c1">// Création d'un objet "maChaine" de type string</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous remarquerez pour commencer qu'il est nécessaire d'inclure le header de la librairie <span class="italique">string </span>pour pouvoir utiliser des objets de type string dans le code. <img src="./cpp_files/clin.png" alt=";)" class="smilies"> C'est ce que j'ai fait à la 2ème ligne.<br>
<br>
Intéressons-nous maintenant à la ligne où je crée un objet de type string...<br>
<br>
<div class="rmq question">Donc... on crée un objet de la même manière qu'on crée une variable ?</div><br>
<br>
Il y a plusieurs façons de créer un objet, celle que vous venez de voir est la plus simple. Et, oui, c'est exactement comme si on avait créé une variable !<br>
<br>
<div class="rmq question">Mais mais... comment on fait pour différencier les objets des variables ?</div><br>
<br>
C'est bien tout le problème : variables et objets se ressemblent dans le code. Pour éviter la confusion, il y a des conventions (qu'on n'est pas obligé de suivre). La plus célèbre d'entre elles est la suivante :<br>
<br>
<ul>
<li>Le type des <strong>variables</strong> commence par une <strong>minuscule </strong>(ex : int)</li>
<li>Le type des <strong>objets</strong> commence par une <strong>majuscule </strong>(ex : Voiture)</li>
</ul><br>
<br>
Je sais ce que vous allez me dire : "<span class="italique">string ne commence pas par une majuscule alors que c'est un objet !</span>". Il faut croire que ceux qui ont créé string ne respectaient pas cette convention. Mais rassurez-vous, maintenant la plupart des gens mettent une majuscule au début de leurs objets (dont moi), ça ne sera pas la foire dans la suite de ce cours. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<h4>Affecter une valeur à la chaîne lors de la déclaration</h4><br>
<br>
Pour affecter une valeur à notre objet au moment de la déclaration, il y a plusieurs possibilités. La plus courante consiste à ouvrir des parenthèses comme nous l'avons fait jusqu'ici :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">maChaine</span><span class="p">(</span><span class="s">"Bonjour !"</span><span class="p">);</span> <span class="c1">// Création d'un objet "maChaine" de type string et affectation</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est la technique classique que l'on connaît déjà, et qui s'applique aussi bien aux variables qu'aux objets.<br>
<br>
<div class="rmq information">Avec le type string, il faut noter qu'il est aussi possible d'initialiser avec le signe égal : <span class="code2 cpp"><span class="n">string</span> <span class="n">maChaine</span> <span class="o">=</span> <span class="s">"Bonjour !"</span><span class="p">;</span></span></div><br>
<br>
On a maintenant créé un objet maChaine qui contient la chaîne "Bonjour !".<br>
On peut l'afficher comme n'importe quelle chaîne de caractères avec un <span class="code2 cpp"><span class="n">cout</span></span> :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">maChaine</span><span class="p">(</span><span class="s">"Bonjour !"</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">maChaine</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// Affichage du string comme si c'était une chaîne de caractères</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Bonjour&nbsp;!</pre></div></td></tr></tbody></table></div><br>
<br>
<h4>Affecter une valeur à la chaîne après déclaration</h4><br>
<br>
Maintenant que notre objet est créé, ne nous arrêtons pas là. Changeons le contenu de la chaîne après sa déclaration :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">maChaine</span><span class="p">(</span><span class="s">"Bonjour !"</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">maChaine</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="n">maChaine</span> <span class="o">=</span> <span class="s">"Bien le bonjour !"</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">maChaine</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Bonjour&nbsp;!
Bien&nbsp;le&nbsp;bonjour&nbsp;!</pre></div></td></tr></tbody></table></div><br>
<br>
<div class="rmq attention">Pour changer le contenu d'une chaîne <span class="italique">après </span>sa déclaration, on doit obligatoirement utiliser le symbole "=".</div><br>
<br>
Ca n'a l'air de rien, mais c'est là que la magie de la POO opère. Vous, l'<span class="vertf">utilisateur</span>, vous avez appuyé sur un bouton pour dire "Je veux maintenant que la chaîne à l'intérieur change pour <span class="italique">Bien le bonjour !</span>". A l'intérieur de l'objet, des mécanismes (des fonctions) se sont activées lorsque vous avez fait ça. Ces fonctions ont vérifié entre autres s'il y avait de la place pour stocker la chaîne dans le tableau de <span class="code2 cpp"><span class="kt">char</span></span>. Elles ont vu que non. Elles ont alors créé un nouveau tableau de <span class="code2 cpp"><span class="kt">char</span></span>, suffisamment long cette fois, pour stocker la nouvelle chaîne. Et elles ont détruit l'ancien tableau qui ne servait plus à rien, tant qu'à faire.<br>
<br>
Et permettez-moi de vous parler franchement : ce qui s'est passé à l'intérieur de l'objet, on s'en fout royalement <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
C'est bien là tout l'intérêt de la POO : l'<span class="vertf">utilisateur</span> n'a pas besoin de comprendre comment ça marche à l'intérieur. On s'en moque que le texte soit stocké dans un tableau de <span class="code2 cpp"><span class="kt">char</span></span>. L'objet est en quelque sorte intelligent et gère tous les cas. Nous, on ne fait que l'<span class="vertf">utiliser</span> ici.<br>
<br>
<br>
<h3>Concaténation de chaînes</h3><br>
<br>
Imaginez que l'on souhaite concaténer (assembler) 2 chaînes. En théorie c'est compliqué à faire car il faut fusionner 2 tableaux de <span class="code2 cpp"><span class="kt">char</span></span>. En pratique, la POO nous permet de ne pas avoir à nous soucier du fonctionnement interne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">chaine1</span><span class="p">(</span><span class="s">"Bonjour !"</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">chaine2</span><span class="p">(</span><span class="s">"Comment allez-vous ?"</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">chaine3</span><span class="p">;</span>
 
    <span class="n">chaine3</span> <span class="o">=</span> <span class="n">chaine1</span> <span class="o">+</span> <span class="n">chaine2</span><span class="p">;</span> <span class="c1">// 3... 2... 1... Concaténatioooooon</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">chaine3</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Bonjour&nbsp;!Comment&nbsp;allez-vous&nbsp;?</pre></div></td></tr></tbody></table></div><br>
<br>
Ah, allez je reconnais, il manque un espace au milieu. On n'a qu'à changer la ligne de la concaténation :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">chaine3</span> <span class="o">=</span> <span class="n">chaine1</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">chaine2</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Bonjour&nbsp;!&nbsp;Comment&nbsp;allez-vous&nbsp;?</pre></div></td></tr></tbody></table></div><br>
<br>
C'est très simple à utiliser, alors que derrière les fioles chimiques s'activent pour assembler les 2 tableaux de <span class="code2 cpp"><span class="kt">char</span></span>.<br>
<br>
<br>
<h3>Comparaison de chaînes</h3><br>
<br>
Vous en voulez encore ? Très bien !<br>
Sachez que l'on peut comparer des chaînes entre elles à l'aide des symboles == ou != (que l'on peut donc utiliser dans un <span class="code2 cpp"><span class="k">if</span></span> !).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">chaine1</span><span class="p">(</span><span class="s">"Bonjour !"</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">chaine2</span><span class="p">(</span><span class="s">"Comment allez-vous ?"</span><span class="p">);</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">chaine1</span> <span class="o">==</span> <span class="n">chaine2</span><span class="p">)</span> <span class="c1">// Faux</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Les chaines sont identiques"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Les chaines sont differentes"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Les&nbsp;chaines&nbsp;sont&nbsp;differentes</pre></div></td></tr></tbody></table></div><br>
<br>
A l'intérieur de l'objet, la comparaison se fait caractère par caractère entre les deux tableaux de <span class="code2 cpp"><span class="kt">char</span></span> (à l'aide d'une boucle qui compare chacune des lettres). Nous, nous n'avons pas à nous soucier de tout cela : nous demandons à l'objet <span class="code2 cpp"><span class="n">chaine1</span></span> s'il est identique à <span class="code2 cpp"><span class="n">chaine2</span></span>, il fait des calculs et nous répond très simplement par un oui ou un non. <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11156">Opérations sur les string</h2>
		<div class="ss_part_texte">
		Le type string ne s'arrête pas à ce que nous venons de voir. Comme tout bon objet qui se respecte, il propose un nombre important d'autres fonctionnalités qui permettent de faire tout ce dont on a besoin.<br>
<br>
Nous n'allons pas passer toutes les fonctionnalités des string en revue (elles sont pas toutes indispensables et ce serait un peu long). Nous allons voir les principales dont vous pourriez avoir besoin dans la suite du cours <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Attributs et méthodes</h3><br>
<br>
Je vous avais dit qu'un objet était constitué de variables et de fonctions. En fait, on en reparlera plus tard mais le vocabulaire est un peu différent avec les objets. Les variables contenues à l'intérieur des objets sont appelées <strong>attributs</strong>, et les fonctions sont appelées <strong>méthodes</strong>.<br>
<br>
Imaginez que chaque méthode (fonction) que propose un objet correspond à un bouton différent sur la façade avant du cube. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="rmq information">On parle aussi de "variables membres" et de "fonctions membres".</div><br>
<br>
Pour appeler la méthode d'un objet, on utilise une écriture que vous avez déjà vue :<br>
<br>
<div class="centre"><strong><span class="courrier"><span class="tgros"><span class="bleu">objet</span>.<span class="violet">methode</span>()</span></span></strong></div><br>
<br>
On sépare le nom de l'objet et le nom de la méthode par un point. Cela signifie "Sur l'objet indiqué, j'appelle cette méthode" (traduction : "sur le cube indiqué, j'appuie sur ce bouton pour déclencher une action").<br>
<br>
<div class="rmq information">En théorie, on peut aussi accéder aux variables membres (les "attributs") de l'objet de la même manière. Cependant, en POO, il y a une règle très importante qui dit que l'utilisateur ne doit pas pouvoir accéder aux variables membres, mais seulement aux fonctions membres (les méthodes). On en reparlera dans le prochain chapitre plus en détail.</div><br>
<br>
<h3>Quelques méthodes utiles du type string</h3><br>
<br>
<h4>La méthode size()</h4><br>
<br>
La méthode <span class="code2 cpp"><span class="n">size</span><span class="p">()</span></span> permet de connaître la longueur de la chaîne actuellement stockée dans l'objet de type <span class="code2 cpp"><span class="n">string</span></span>.<br>
<br>
Cette méthode ne prend aucun paramètre et renvoie la longueur de la chaîne. Comme vous venez de le découvrir, il va falloir appeler la méthode de la manière suivante :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">maChaine</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Essayons ça dans un code complet qui affiche la longueur de la chaîne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">maChaine</span><span class="p">(</span><span class="s">"Bonjour !"</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Longueur de la chaine : "</span> <span class="o">&lt;&lt;</span> <span class="n">maChaine</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Longueur&nbsp;de&nbsp;la&nbsp;chaine&nbsp;:&nbsp;9</pre></div></td></tr></tbody></table></div><br>
<br>
<h4>La méthode erase()</h4><br>
<br>
Cette méthode très simple supprime tout le contenu de la chaîne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour !"</span><span class="p">);</span>
    <span class="n">chaine</span><span class="p">.</span><span class="n">erase</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"La chaine contient : "</span> <span class="o">&lt;&lt;</span> <span class="n">chaine</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>La&nbsp;chaine&nbsp;contient&nbsp;:</pre></div></td></tr></tbody></table></div><br>
<br>
Comme on pouvait s'y attendre, la chaîne ne contient plus rien <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="rmq information">Notez que c'est équivalent à faire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">chaine</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div></div><br>
<br>
<h4>La méthode substr()</h4><br>
<br>
Une autre méthode qui peut s'avérer utile : substr(). Elle permet de ne prendre qu'une partie de la chaîne stockée dans un string.<br>
<br>
<div class="rmq information">substr signifie "substring", soit "sous-chaîne" en anglais.</div><br>
<br>
Tenez, on va regarder son prototype, vous allez voir que c'est intéressant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">string</span> <span class="n">substr</span><span class="p">(</span> <span class="n">size_type</span> <span class="n">index</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">num</span> <span class="o">=</span> <span class="n">npos</span> <span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cette méthode retourne donc un objet de type string. Ce sera la sous-chaîne après "découpage".<br>
Elle prend 2 paramètres, ou plus exactement : 1 paramètre obligatoire, 1 paramètre facultatif. En effet, <span class="italique">num </span>possède une valeur par défaut (npos) ce qui fait que le second paramètre ne doit pas obligatoirement être renseigné.<br>
<br>
<ul>
<li><strong>index </strong>permet d'indiquer à partir de quel caractère on doit couper (ce doit être un numéro de caractère)</li>
<li><strong>num </strong>permet d'indiquer le nombre de caractères que l'on prend. Par défaut, la valeur est npos, ce qui correspond à prendre tous les caractères qui restent. Si vous indiquez 2, la méthode ne renverra que 2 caractères.</li>
</ul><br>
<br>
Allez, un exemple sera plus parlant je crois <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour !"</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">chaine</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>jour&nbsp;!</pre></div></td></tr></tbody></table></div><br>
<br>
On a demandé à couper à partir du 3ème caractère (soit la lettre "j" vu que la première lettre correspond au caractère n°0).<br>
On a volontairement omis le second paramètre facultatif, ce qui fait que du coup substr() a renvoyé tous les caractères restants avant la fin de la chaîne. Essayons de renseigner le paramètre facultatif pour ne pas prendre le point d'exclamation par exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour !"</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">chaine</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>jour</pre></div></td></tr></tbody></table></div><br>
<br>
Bingo ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
On a demandé à prendre 4 caractères en partant du caractère n°3, ce qui fait qu'on a récupéré "jour" <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h4>La méthode c_str()</h4><br>
<br>
Celle-là est un peu particulière, mais parfois fort utile. Son rôle ? Retourner un pointeur vers le tableau de <span class="code2 cpp"><span class="kt">char</span></span> que contient l'objet de type <span class="code2 cpp"><span class="n">string</span></span>.<br>
<br>
Quel intérêt me direz-vous ? En C++, à priori aucun intérêt. On préfère largement manipuler un objet <span class="code2 cpp"><span class="n">string</span></span> plutôt qu'un tableau de <span class="code2 cpp"><span class="kt">char</span></span> car c'est plus simple et plus sûr.<br>
<br>
Néanmoins, il peut (j'ai bien dit il "peut") arriver que vous deviez envoyer à une fonction un tableau de <span class="code2 cpp"><span class="kt">char</span></span>. Dans ce cas, la méthode c_str() vous permet de récupérer l'adresse du tableau de <span class="code2 cpp"><span class="kt">char</span></span> qui se trouve à l'intérieur de l'objet <span class="code2 cpp"><span class="n">string</span></span>. A n'utiliser qu'en cas de nécessité absolue !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour !"</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">chaineC</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
 
    <span class="n">chaineC</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span> <span class="c1">// On récupère le tableau de char dans chaineC</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"La chaine contient : "</span> <span class="o">&lt;&lt;</span> <span class="n">chaineC</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// On l'affiche pour vérifier que ça fonctionne</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Récupérer le tableau de <span class="code2 cpp"><span class="kt">char</span></span> vous sera utile si vous devez envoyer une chaîne à une fonction à la base prévue pour le langage C qui ne reconnaît pas les <span class="code2 cpp"><span class="n">string</span></span> (car les objets n'existent pas en C). C'est rare, mais ça arrive. Je préfère que vous sachiez qu'on a cette possibilité pour pas que vous soyez bêtement bloqués à un moment.
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Comme le disait si bien ma prof d'informatique "<span class="italique">C'est plus confortable de travailler avec un string</span>" (je vous <span class="souligne">jure</span> que c'est vrai, j'étais là <img src="./cpp_files/rire.gif" alt=":lol:" class="smilies"> )<br>
<br>
Bon plus sérieusement <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Vous avez découvert le côté <span class="vertf">utilisateur </span>de la POO et à quel point ces nouveaux mécanismes pouvaient vous simplifier la vie.<br>
<br>
Le côté <span class="vertf">utilisateur </span>est en fait le côté simple de la POO. Les choses se compliquent lorsqu'on passe du côté <span class="rouge">créateur</span>. Nous allons justement apprendre à créer des objets dans le prochain chapitre et tous les suivants. Une longue route pleine de péripéties nous attend <img src="./cpp_files/hihi.png" alt="^^" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11131">Premier programme C++ avec cout et cin</h1>
	<div id="chap_intro">
	Après un bref chapitre d'introduction, nous pouvons commencer à coder nos premières lignes de C++ <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Ce chapitre sera assez simple : nous verrons quelles techniques on utilise en C++ pour afficher du texte à l'écran (dans une console) et comment on récupère du texte saisi au clavier. Vous allez voir que c'est assez différent ce qu'on connaissait en C avec <span class="italique">printf </span>et <span class="italique">scanf</span>.<br>
<br>
Nous réutiliserons cela dans tout le cours de C++. Soyez donc attentifs, et ça ne devrait pas vous poser de problème <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>

	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11130">Configurer l'IDE pour le C++</h2>
		<div class="ss_part_texte">
		Jusqu'ici, vous n'avez créé dans votre IDE que des projets en C.<br>
Or, en C++ on utilise un autre compilateur. Par exemple, il y a gcc qui est un compilateur C, et g++ qui est un compilateur C++. Il va donc falloir dire à votre IDE que vous allez faire du C++, sinon il appellera le mauvais compilateur (et là ça risque pas de marcher <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).<br>
<br>
Lancez donc votre IDE favori. Pour ma part, vous l'aurez compris dans les chapitres précédents, je travaille principalement sous Code::Blocks. Si vous avez un autre IDE comme Visual C++ ou Dev C++ ça marche aussi <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Créez un nouveau projet de type console (eh oui, on retourne à la console pour faire nos expériences) et pensez à bien sélectionner C++.<br>
<br>
<div class="centre"><img src="./cpp_files/46644.png" alt="Nouveau projet C++"><br>
<span class="italique">Création d'un nouveau projet. Veillez à bien sélectionner C++</span></div><br>
<br>
<div class="rmq information">Si vous avez Dev C++ la manipulation est la même, je ne vous refais pas de screenshot vous êtes grands maintenant <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Sous Visual C++, le projet est par défaut compilé en C++, vous n'aurez donc pas besoin de spécifier quoi que ce soit.</div><br>
<br>
Cliquez sur "Create" pour créer le nouveau projet.<br>
Code::Blocks crée un premier fichier nommé <span class="courrier">main.cpp</span> dans le projet avec quelques premières lignes de code C++.<br>
<br>
<div class="rmq information">En C++, vos fichiers .c ont l'extension .cpp. Les fichiers .h, eux, gardent, l'extension .h.<br>
Certains trouvent cela illogique et ont choisi à la place d'utiliser .cc (pour les sources C++) et .hh (pour les headers C++). Ne soyez donc pas surpris par ce type de notation <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
Voici le code de base que nous propose Code::Blocks dans notre nouveau projet :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si vous avez un autre IDE, supprimez le code qui a été généré et utilisez celui-ci à la place pour qu'on soit sûrs de travailler sur le même code <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11129">Analyse du premier code source C++</h2>
		<div class="ss_part_texte">
		Intéressons-nous maintenant à chacune de ces lignes de code et voyons ce qui change pour le moment par rapport au C.<br>
<br>
<h3>Include</h3><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On reconnaît là une bonne vieille directive de préprocesseur.<br>
<br>
2 choses :<br>
<ul>
<li>Ce qui choque tout d'abord, c'est qu'<strong>il n'y a pas d'extension .h</strong>. En effet, en C++ les fichiers d'en-tête standard ne possèdent plus d'extension .h, mais vous verrez qu'il y a des exceptions (des gens qui n'ont pas encore fait l'évolution <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ).</li>
<li>D'autre part, la directive d'inclusion n'est plus la même. Ici, elle s'appelle iostream, ce qui signifie "flux d'entrée-sortie". Oubliez stdlib et stdio, ce sont des en-têtes du C, on ne les utilise plus en C++.</li>
</ul><br>
<br>
On inclut donc ici la librairie iostream qui contient les outils nécessaires pour afficher du texte dans la console et récupérer la saisie au clavier.<br>
<br>
<h3>Fonction main()</h3><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">// ...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On retrouve notre fonction main habituelle. Cela fonctionne comme en C : tout programme commence par la fonction <span class="courrier">main()</span>. Rien de choquant ici <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
La fonction retourne 0, ce qui est là encore logique puisque la fonction doit retourner un int.<br>
<br>
<div class="rmq information">Pour info, 2 formes de <span class="italique">main </span>sont possibles. Celle-ci :<br>
<span class="courrier">int main()</span><br>
... mais aussi cette forme un peu plus compliquée que vous connaissez aussi :<br>
<span class="courrier">int main(int argc, char *argv[])</span><br>
La seconde forme permet de récupérer les arguments d'appel du programme, ce qu'on ne fait pas toujours. Vous pouvez donc vous contenter de la première forme qui est surtout plus simple à retenir <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
<h3>cout</h3><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La première ligne du <span class="italique">main </span>est la plus intéressante, c'est d'ailleurs la seule qui doit vraiment vous surprendre.<br>
En effet, ça ne ressemble pas à un appel de fonction, il y a plein de signes bizarres, pas de parenthèses comme on a l'habitude dans un appel de fonction. Bon sang de bonsoir qu'est-ce que c'est ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"><br>
<br>
On va découvrir ça maintenant plus en détails <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11128">Le flux de sortie cout</h2>
		<div class="ss_part_texte">
		<span class="italique">cout</span> n'est pas une fonction mais un flux, un élément nouveau introduit en C++. Notez que ça n'a rien à voir avec la POO pour le moment <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="rmq information">Rassurez-vous, les fonctions existent toujours en C++ (d'ailleurs vous avez vu qu'il y a un <span class="italique">main()</span>), mais vous vous rendrez compte petit à petit qu'on ne les utilise plus de la même manière.</div><br>
<br>
Le flux <span class="italique">cout </span>est l'équivalent de la fonction printf... mais en mieux, en plus simple <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Revoyons cette fameuse ligne de code :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Il y a deux mots-clé particuliers dans cette ligne : cout et endl. Vous noterez qu'ils ont tous les deux le préfixe <span class="courrier">std::</span><br>
Tous les mots-clé de la librairie standard du C++ utilisent ce préfixe. Théoriquement, on est obligé de le mettre à chaque fois, mais c'est un peu lourd.<br>
On a heureusement une solution pour se simplifier la vie. Rajoutez cette ligne de code avant le <span class="italique">main()</span> :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Du coup, vous pouvez virer tous les préfixes <span class="courrier">std::</span><br>
Ca rend déjà notre code un peu plus facile à lire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voilà un premier point de réglé. Nous ne rentrerons pas dans le détail de ce "using namespace" pour le moment (pour ne pas compliquer inutilement les choses).<br>
<br>
Intéressons-nous de plus près à cette ligne avec cout, désormais plus lisible :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous voyez qu'il y a un nouveau symbole : le chevron <span class="rouge">&lt;</span><br>
On le rencontre d'ailleurs toujours par paire, comme ceci : <span class="rouge">&lt;&lt;</span><br>
<br>
Imaginez que ces chevrons représentent en fait des flèches. Du coup, la ligne se lit de droite à gauche :<br>
<br>
<ol class="liste_1">
<li>On prend le mot-clé endl, qui signifie <span class="italique">retour à la ligne</span>.</li>
<li>On l'insère à la fin de la chaîne "Hello world!"</li>
<li>On insère le résultat obtenu dans cout.</li></ol><br>
<br>
cout est la contraction de "c-out" (console out = sortie console). En bon français, vous devez prononcer cela "Ci Aoute" <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
cout représente la sortie en C++ (out = sortie). La sortie d'un programme, ben c'est tout simplement l'écran. Donc cout représente l'écran <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Résultat des courses, ce code signifie que le texte "Hello world!" suivi d'un retour à la ligne est envoyé vers l'écran. Il faut bien imaginer que les chevrons &lt;&lt; indiquent le sens dans lequel les données sont envoyées.<br>
<br>
Cette ligne de code commande donc un affichage de texte à l'écran. Compilez et exécutez le programme pour voir :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Hello&nbsp;world!</pre></div></td></tr></tbody></table></div><br>
<br>
Revenons un peu sur <strong>endl</strong>.<br>
endl est un mot-clé qui signifie "fin de ligne" (<span class="italique">end line</span> en anglais). En fait, c'est tout bêtement un mot qui remplace le \n que vous connaissez du C, qu'on utilisait pour faire des sauts de ligne.<br>
<br>
<div class="rmq question">Ah bon, on ne peut plus utiliser \n en C++ ?</div><br>
<br>
Si si. En fait, le mot-clé endl a été entre autres introduit pour améliorer la lisibilité du code source (pour ne pas qu'on mélange le "n" avec le texte à afficher).<br>
Vous pouvez d'ailleurs tester, vous verrez que l'\n fonctionne toujours :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le résultat à l'écran est <span class="souligne">exactement</span> le même :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Hello&nbsp;world!</pre></div></td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Désormais, j'utiliserai <span class="italique">endl </span>à la place de \n dans la suite du cours.</div><br>
<br>
<h3>L'intérêt de cout</h3><br>
<br>
Pour le moment, vous devez vous dire que cout ressemble étrangement à la fonction printf, avec juste des symboles &lt;&lt; en plus pour vous embrouiller l'esprit <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
En fait, c'est encore plus facile à utiliser que printf. L'intérêt se voit notamment lorsqu'on veut afficher le contenu d'une variable.<br>
Regardez ce code, c'est super simple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Salut, j'ai "</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">" ans"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Salut,&nbsp;j'ai&nbsp;21&nbsp;ans</pre></div></td></tr></tbody></table></div><br>
<br>
Voilà, c'est assez intuitif pour que je n'aie pas besoin de vous expliquer comment ça marche <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Ce qui est génial, c'est qu'on n'a plus besoin de s'embêter avec la syntaxe des printf : %d, %lf, %s, %c etc... Ici, le langage est plus intelligent, il reconnaît le type de variable qui lui est envoyé.<br>
<br>
Sceptiques ? Ok, essayez d'ajouter une variable de type chaîne de caractère dans ce cout :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">pseudo</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"M@teo21"</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Salut, j'ai "</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">" ans et je m'appelle "</span> <span class="o">&lt;&lt;</span> <span class="n">pseudo</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Salut,&nbsp;j'ai&nbsp;21&nbsp;ans&nbsp;et&nbsp;je&nbsp;m'appelle&nbsp;M@teo21</pre></div></td></tr></tbody></table></div><br>
<br>
Vous voyez, on a envoyé d'un coup à cout un entier et une chaîne de caractères, sans préciser le type de variable, et il n'a pas bronché <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Pour rappel, en C on aurait dû faire :<br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">printf</span><span class="p">(</span><span class="s">"Salut, j'ai %d ans et je m'appelle %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">pseudo</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Non seulement il fallait se souvenir des codes %d et %s, mais en plus les variables utilisées sont indiquées à la fin. En C++ avec cout, comme vous avez pu le constater, la variable est placée au milieu, ce qui rend le code plus facile à lire <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Bien entendu, vous n'êtes pas limité à un seul cout par programme <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Vous pouvez tout à fait faire plusieurs cout si vous le voulez :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Salut, j'ai "</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">" ans"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Je m'appelle "</span> <span class="o">&lt;&lt;</span> <span class="n">pseudo</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Salut,&nbsp;j'ai&nbsp;21&nbsp;ans

Je&nbsp;m'appelle&nbsp;M@teo21</pre></div></td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Le endl à la fin de chaque cout n'est pas obligatoire. Si vous l'enlevez, il n'y aura juste pas de retour à la ligne.<br>
Entraînez-vous un peu avec cout, vous devriez vous y habituer rapidement !</div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11127">Le flux d'entrée cin</h2>
		<div class="ss_part_texte">
		Après avoir vu comment afficher du texte, voyons voir maintenant comment <span class="souligne">récupérer du texte saisi au clavier</span>.<br>
Là encore, ça fonctionne avec un système de flux, et vous allez voir que c'est un vrai régal de simplicité <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Le mot-clé à connaître ici est <strong>cin</strong>. Il vient en remplacement de la pratique (mais complexe) fonction scanf du langage C.<br>
cin est la contraction de "c-in", ce qui signifie <span class="italique">entrée console</span>. Prononcez ça comme il faut siouplaît : "Ci in" <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
cin représente l'entrée en C++. Et qu'est-ce que l'entrée ? C'est le clavier ! Eh oui, c'est par le clavier qu'on entre les données.<br>
<br>
cin représente donc le clavier et permet de récupérer du texte saisi par l'utilisateur.<br>
Tenez, on va faire un truc super original : on va lui demander son âge <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
Regardez comment ça fonctionne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">age</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si vous êtes un peu observateur, 2 choses doivent vous avoir choqué :<br>
<br>
<ul>
<li><strong>Les flèches ont changé de sens !</strong> Eh oui, la lecture se fait ici de gauche à droite. cin représente le clavier et <span class="italique">envoie</span> les données dans la variable age. Il faut donc imaginer que les données transitent du clavier vers la variable age. C'est ce qu'on appelle un flux <img src="./cpp_files/clin.png" alt=";)" class="smilies"></li>
<li><strong>Il n'y a pas de symbole &amp; devant age !</strong> En C, on aurait dû écrire &amp;age pour envoyer l'adresse de la variable à la fonction pour qu'elle sache où écrire en mémoire. En C++, c'est plus la peine ! Il y a en effet un mécanisme qui remplace un peu les pointeurs qu'on appelle les références. On étudiera ça dans le prochain chapitre plus en détails.</li>
</ul><br>
<br>
<div class="rmq erreur">Ne confondez pas le sens des flèches entre cout et cin. Le principe c'est que les données transitent dans un sens précis : de la mémoire vers l'écran (cout) ou du clavier vers la mémoire (cin).<br>
Les flèches sont donc dans le sens de déplacement des informations. Avec un peu de bon sens, vous ne devriez pas vous tromper <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
<h3>Programmes de test de cin</h3><br>
<br>
Testons maintenant cin dans un petit programme. Voici le code complet :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Quel age avez-vous ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">age</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ah ! Vous avez donc "</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">" ans !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Quel&nbsp;age&nbsp;avez-vous&nbsp;?

21

Ah&nbsp;!&nbsp;Vous&nbsp;avez&nbsp;donc&nbsp;21&nbsp;ans&nbsp;!</pre></div></td></tr></tbody></table></div><br>
<br>
Désolé si je me répète, mais je trouve cela d'une simplicité effarante <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Finis les %d qui nous agacent, finis les oublis de symbole &amp; dans les scanf, finis <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Bon d'accord, cette nouvelle syntaxe surprend un peu quand on a fait pas mal de C avant, mais on s'y fait vite rassurez-vous.<br>
<br>
<br>
On peut aussi s'entraîner à demander le pseudonyme de l'utilisateur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">pseudo</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Quel est votre pseudo ?"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">pseudo</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Salut "</span> <span class="o">&lt;&lt;</span> <span class="n">pseudo</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Quel&nbsp;est&nbsp;votre&nbsp;pseudo&nbsp;?

M@teo21

Salut&nbsp;M@teo21</pre></div></td></tr></tbody></table></div><br>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Alors, premières impressions du C++ ? <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> <br>
<br>
"Ca change" ? Ah ben oui un peu, c'est sûr <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
En effet, la syntaxe des flux cout et cin surprend un peu... mais je suis sûr que vous serez convaincu comme moi que grâce à ce système de nombreuses choses sont simplifiées !<br>
<br>
On va continuer notre tour d'horizon des ajouts-au-C++-qui-n'ont-rien-à-voir-avec-la-POO dans le chapitre suivant.<br>
Au programme, nous allons découvrir les changements au niveau de la gestion des variables. Nous verrons en particulier ce que sont ces mystérieuses <strong>références</strong> dont vous avez entendu parler.
	</div>
	
	<hr>
	<h1 id="chap_11141">Nouveautés pour les variables</h1>
	<div id="chap_intro">
	Nous continuons notre tour d'horizon des nouveautés du C++ dans ce chapitre. Nous n'allons pas encore voir ici la POO, mais patience, ça ne saurait tarder <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Nous nous intéresserons aux nouveautés relatives aux variables, c'est-à-dire à la gestion de la mémoire. Nous découvrirons entre autres le type bool, les modifications par rapport aux définitions de variables, les allocations dynamiques en C++ et les références.<br>
<br>
Rien de bien difficile au programme donc, mais il s'agit de nouveautés importantes, donc à ne pas négliger.
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11140">Le type bool</h2>
		<div class="ss_part_texte">
		On a découvert dès le début du cours de C qu'il existait un grand nombre de types de variable différents :<br>
<ul>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>char</li>
<li>etc.</li>
</ul><br>
<br>
Le problème s'est posé lorsqu'on a voulu stocker des <strong>booléens</strong>. Faute d'avoir un type de donnée spécialisé dans le stockage des booléens, on a fait comme la plupart des programmeurs C font : on a utilisé un type entier, comme int.<br>
<br>
<div class="rmq information">Rappel. Un booléen est une variable qui peut prendre 2 valeurs : vrai <span class="italique">ou </span>faux. Par exemple, "majeur" est un booléen : soit on est majeur, soit on ne l'est pas <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
On dit que le nombre 0 représente "Faux", tandis que le nombre 1 représente "Vrai" (en fait, tout nombre différent de 0 signifie "Vrai").</div><br>
<br>
Or, si on utilise int pour les booléens, on risque de les confondre avec des variables destinées à stocker des nombres, puisque int est à la base fait pour stocker des nombres !<br>
<br>
Petit exemple tout simple :<br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">majeur</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La variable <span class="italique">majeur</span> est un booléen, car elle signifie soit vrai soit faux.<br>
La variable <span class="italique">age</span>, elle, est un nombre. Elle peut valoir par exemple 21.<br>
<br>
Mais comment fait-on pour savoir laquelle de ces variables est un booléen et laquelle est un nombre ?<br>
On peut se baser sur le nom de la variable, c'est sûr, mais il aurait été plus pratique et plus clair d'avoir un type spécial pour les booléens.<br>
<br>
Ca tombe bien ! Il y a justement en C++ un nouveau type de base : le type <strong>bool</strong>. Toute variable de ce type peut prendre 2 valeurs :<br>
<br>
<ul>
<li><strong>true</strong>, qui signifie vrai.</li>
<li><strong>false</strong>, qui signifie faux.</li>
</ul><br>
<span class="italique">(je vous conseille de retenir ces 2 valeurs par coeur, vous en aurez besoin <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> )</span><br>
<br>
Du coup, le code qu'on a vu plus haut s'écrirait comme ceci en C++ :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="kt">bool</span> <span class="n">majeur</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voilà une bonne chose qui nous permettra d'éviter des ambigüités dans nos programmes <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="rmq erreur">Il n'y a pas de guillemets autour de true, car c'est un mot-clé du langage C++. Ce n'est pas une chaîne de caractères !</div><br>
<br>
<h3>Rappel : les booléens dans les conditions</h3><br>
<br>
Je tiens juste à vous faire un petit rappel. Si vous avez bien suivi le cours de C, ça ne devrait pas vous choquer <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
En théorie, on peut tester un booléen comme ceci dans une condition :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="k">if</span> <span class="p">(</span><span class="n">majeur</span> <span class="o">==</span> <span class="kc">true</span><span class="p">)</span> <span class="c">// S'il est majeur (forme longue)</span>
<span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Mais en général, si la variable a un nom clair, on préfèrera enlever la partie <span class="courrier">== true</span>. C'est tout à fait possible et l'ordinateur le comprend très bien :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="k">if</span> <span class="p">(</span><span class="n">majeur</span><span class="p">)</span> <span class="c">// S'il est majeur (forme courte)</span>
<span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce code est plus lisible et plus court que le précédent. On comprend bien que la condition est "<span class="italique">S'il est majeur</span>".<br>
<br>
Par ailleurs, le point d'exclamation sert à exprimer la négation. Dans notre cas, ce code signifierait "<span class="italique">S'il n'est pas majeur</span>" :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">majeur</span><span class="p">)</span> <span class="c">// S'il n'est PAS majeur</span>
<span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce n'est pas une nouveauté du C++ car ça existait déjà en C, mais je tenais juste à vous informer que cette technique fonctionnait toujours avec le type <strong>bool </strong> <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11139">Les déclarations de variables</h2>
		<div class="ss_part_texte">
		En C, les variables devaient être déclarées (= créées) au début des fonctions. Vous avez vu cela dans le chapitre sur les variables au tout début du cours <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Vous deviez donc faire toutes vos déclarations avant de commencer les instructions :<br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="nf">maFonction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">// D'abord on déclare les variables</span>
    <span class="kt">double</span> <span class="n">prixOrigine</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">prixAchat</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">difference</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="n">FILE</span><span class="o">*</span> <span class="n">fichier</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c">// Ensuite on peut exécuter des instructions, des appels de fonction, etc.</span>
    <span class="n">fichier</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"exemple.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fichier</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fonction</span><span class="p">();</span>

        <span class="n">fscanf</span><span class="p">(</span><span class="n">fichier</span><span class="p">,</span> <span class="s">"%lf"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prixOrigine</span><span class="p">);</span>
        <span class="n">fscanf</span><span class="p">(</span><span class="n">fichier</span><span class="p">,</span> <span class="s">"%lf"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prixAchat</span><span class="p">);</span>
        
        <span class="n">difference</span> <span class="o">=</span> <span class="n">prixAchat</span> <span class="o">-</span> <span class="n">prixOrigine</span><span class="p">;</span>
        <span class="c">// etc.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La nouveauté en C++, c'est que l'on peut désormais déclarer des variables <span class="italique">n'importe où</span> dans une fonction. C'est plus pratique lorsqu'on programme, ça nous évite d'avoir à remonter au début de la fonction si on n'a besoin d'une variable qu'à un moment de la fonction. Cela peut aussi améliorer la lisibilité du code surtout dans de grosses fonctions.<br>
<br>
On pourrait donc écrire le code précédent comme ceci en C++ :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">maFonction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">FILE</span><span class="o">*</span> <span class="n">fichier</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">fichier</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"exemple.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fichier</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fonction</span><span class="p">();</span>

        <span class="kt">double</span> <span class="n">prixOrigine</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c">// Déclaration au milieu</span>
        <span class="n">fscanf</span><span class="p">(</span><span class="n">fichier</span><span class="p">,</span> <span class="s">"%lf"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prixOrigine</span><span class="p">);</span>
        
        <span class="kt">double</span> <span class="n">prixAchat</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c">// Autre déclaration au milieu</span>
        <span class="n">fscanf</span><span class="p">(</span><span class="n">fichier</span><span class="p">,</span> <span class="s">"%lf"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prixAchat</span><span class="p">);</span>
        
        <span class="kt">double</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">prixAchat</span> <span class="o">-</span> <span class="n">prixOrigine</span><span class="p">;</span> <span class="c">// Encore autre déclaration au milieu</span>
        <span class="c">// etc.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Avec une version récente du langage C, il est aussi possible de déclarer une variable en plein milieu d'une fonction. Cependant, les programmeurs C préfèrent en général continuer à déclarer leurs variables au début des fonctions.</div><br>
<br>
Précision importante : les variables ainsi créées sont <span class="italique">locales </span>aux blocs où elles ont été déclarées. Je m'explique.<br>
On dit que les accolades { et } délimitent des <strong>blocs</strong>. Dans le code ci-dessus, vous devriez en voir deux : la fonction et le bloc if. Comme la variable <span class="italique">prixAchat </span>a été déclarée dans le bloc if, elle sera supprimée à la fin du bloc if. Si elle avait été déclarée au début de la fonction en revanche, elle aurait été accessible dans toute la fonction.<br>
<br>
Voilà, c'est assez simple à comprendre mais il faut le savoir ! La variable est détruite à la fin du bloc dans lequel elle a été déclarée.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">maFonction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">FILE</span><span class="o">*</span> <span class="n">fichier</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">fichier</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"exemple.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fichier</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fonction</span><span class="p">();</span>

        <span class="kt">double</span> <span class="n">prixOrigine</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c">// Création de prixOrigine</span>
        <span class="n">fscanf</span><span class="p">(</span><span class="n">fichier</span><span class="p">,</span> <span class="s">"%lf"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prixOrigine</span><span class="p">);</span>
        
        <span class="kt">double</span> <span class="n">prixAchat</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c">// Création de prixAchat</span>
        <span class="n">fscanf</span><span class="p">(</span><span class="n">fichier</span><span class="p">,</span> <span class="s">"%lf"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prixAchat</span><span class="p">);</span>
        
        <span class="kt">double</span> <span class="n">difference</span> <span class="o">=</span> <span class="n">prixAchat</span> <span class="o">-</span> <span class="n">prixOrigine</span><span class="p">;</span> <span class="c">// Création de difference</span>
    <span class="p">}</span> <span class="c">// Destruction automatique de prixOrigine, prixAchat et difference</span>
<span class="p">}</span> <span class="c">// Destruction automatique de fichier</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h3>Déclaration dans une boucle</h3><br>
<br>
Dans le même ordre d'idée, il y a une nouveauté <span class="souligne">vraiment très pratique</span> (comprenez : je m'en sers tout le temps <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ). On peut déclarer une variable directement <span class="italique">dans </span>une instruction for.<br>
<br>
Prenons un exemple. Vous codez votre programme, tout va bien. Puis à un moment, pour une raison ou une autre, vous avez besoin de faire une boucle qui se répète 10 fois. Vous allez sûrement faire un for. Mais pour boucler 10 fois, vous aurez besoin d'une variable de boucle qui va retenir le nombre de tours de boucle (quand on n'est pas inspiré on appelle en général cette variable <strong>i</strong> ).<br>
<br>
En C, c'est un peu embêtant parce qu'il faut remonter au début de la fonction pour rajouter la déclaration de la variable. En plus, on ne sait pas trop quand elle sera utilisée en lisant la déclaration :<br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="nf">maFonction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c">/* Plein de code</span>
<span class="c">    ....</span>
<span class="c">    ....</span>
<span class="c">    */</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La nouveauté en C++, c'est que vous pouvez déclarer votre variable i directement dans l'instruction for. Elle sera détruite à la fin de la boucle, quand vous n'en aurez plus besoin.<br>
Avantages : vous n'avez pas à remonter au début de la fonction pour déclarer la variable, et celle-ci est automatiquement détruite à la fin de la boucle. Pas d'utilisation inutile de la mémoire.<br>
<br>
Le code C++ ressemblera donc à cela :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">maFonction</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">/* Plein de code</span>
<span class="c">    ....</span>
<span class="c">    ....</span>
<span class="c">    */</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c">// Déclaration de i</span>
    <span class="p">{</span>

    <span class="p">}</span> <span class="c">// Destruction automatique de i</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ca n'a l'air de rien, mais je vous assure qu'en pratique quand on programme, ça c'est vraiment génial <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Vous me verrez donc le faire la plupart du temps dans la suite du cours.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11138">Les allocations dynamiques</h2>
		<div class="ss_part_texte">
		Si je vous dis "malloc" et "free", ça vous rappelle de joyeux souvenirs non ? <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">variable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">variable</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c">// Allocation de mémoire</span>

    <span class="n">free</span><span class="p">(</span><span class="n">variable</span><span class="p">);</span> <span class="c">// Libération de mémoire</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
L'allocation dynamique est une technique qui permet de gérer vous-même l'allocation de mémoire pour vos variables. C'est notamment très pratique dans le cas de l'allocation de tableaux dont on ne connaît pas la taille avant compilation (revoyez le <a href="http://www.siteduzero.com/tuto-3-4830-1-l-allocation-dynamique.html">chapitre sur l'allocation dynamique</a> au besoin !).<br>
<br>
En C++, les allocations dynamiques existent toujours et on en fait toujours. D'ailleurs, les fonctions malloc et free sont toujours utilisables. Cependant, le C++ dispose de nouveaux opérateurs spécialisés dans les allocations dynamiques : <strong>new </strong>et <strong>delete</strong>.<br>
<br>
<div class="rmq information">new et delete sont des opérateurs, des mots-clé du langage C++. Contrairement à malloc et free, ce ne sont pas des fonctions.<br>
new et delete font en fait eux-mêmes appel aux fonctions malloc et free (on n'a pas réinventé la roue). Cependant, ils font aussi des tests et des initialisations supplémentaires, ce qui fait qu'on préfèrera toujours utiliser new et delete au lieu de malloc et free. Ils sont plus adaptés en C++.</div><br>
<br>
<h3>Allocation dynamique d'une variable</h3><br>
<br>
new et delete ne s'utilisent pas exactement de la même manière que malloc et free.<br>
On va dans un premier temps apprendre à s'en servir pour allouer une variable simple, puis on verra ensuite le cas de l'allocation de tableaux.<br>
<br>
On souhaite donc allouer dynamiquement une variable (de type int par exemple).<br>
En C++, on va d'abord devoir créer le pointeur et l'initialiser à NULL, ça on n'y coupe pas :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">variable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Allocation de mémoire</h4><br>
<br>
L'allocation de mémoire avec new se fait comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">variable</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c">// Allocation dynamique</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Comparé à la "version C", il n'y a pas photo <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
On n'a plus besoin d'utiliser l'opérateur sizeof() du C. Ici, on indique juste le type de variable à créer.<br>
<br>
<h4>Libération de mémoire</h4><br>
<br>
Lorsque vous avez fini d'utiliser votre variable et que vous n'en avez plus besoin, vous devez la libérer avec l'opérateur delete. Ultra-simple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="k">delete</span> <span class="n">variable</span><span class="p">;</span> <span class="c">// Libération de mémoire</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq attention">new et delete étant des opérateurs, et non des fonctions (désolé d'insister <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ), on ne met pas de parenthèses.</div><br>
<br>
<h4>Résumé</h4><br>
<br>
En résumé, voici à quoi ressemble un code d'allocation / libération de mémoire en C++ :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">variable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">variable</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c">// Allocation de mémoire</span>

    <span class="k">delete</span> <span class="n">variable</span><span class="p">;</span> <span class="c">// Libération de mémoire</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h3>Allocation dynamique d'un tableau</h3><br>
<br>
Si on veut allouer un tableau, l'opération est là encore très simple. On n'a plus besoin de faire un calcul du type 20 * sizeof(int) comme on devait le faire en C.<br>
<br>
On commence par créer le pointeur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">tableau</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Allocation de mémoire</h4><br>
<br>
Ensuite, l'allocation se fait comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">tableau</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c">// Allocation de mémoire (20 cases)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Dans ce cas, un tableau de 20 cases sera alloué. Bien entendu, il est aussi possible de remplacer ce nombre par une variable :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">tableau</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">taille</span><span class="p">];</span> <span class="c">// Allocation de mémoire ("taille" cases)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La longueur du tableau sera définie par la valeur de la variable <span class="italique">taille</span>.<br>
<br>
<h4>Libération de mémoire</h4><br>
<br>
Lorsque vous n'avez plus besoin du tableau, vous devez le libérer... avec cette fois l'opérateur delete[] pour bien préciser qu'il s'agit d'un tableau. Vous n'avez pas besoin de préciser la taille entre crochets, mais n'oubliez pas ces crochets ils sont importants.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="k">delete</span><span class="p">[]</span> <span class="n">tableau</span><span class="p">;</span> <span class="c">// Libération de mémoire</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Résumé</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">tableau</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">tableau</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span> <span class="c">// Allocation de mémoire (tableau)</span>

    <span class="k">delete</span><span class="p">[]</span> <span class="n">tableau</span><span class="p">;</span> <span class="c">// Libération de mémoire (tableau)</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Il y a donc en tout 4 opérateurs :<br>
<ul>
<li>new s'utilise avec delete pour allouer une variable</li>
<li>new[] s'utilise avec delete[] pour allouer un tableau</li>
</ul></div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11143">Le typedef automatique</h2>
		<div class="ss_part_texte">
		Vous souvenez-vous du chapitre sur les <a href="http://www.siteduzero.com/tuto-3-4350-1-creez-vos-propres-types-de-variables.html">structures et énumérations</a> ? <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
On y avait appris à créer nos propres types de variables. On avait notamment utilisé l'exemple d'une structure nommée <span class="italique">Coordonnees</span> :<br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="k">struct</span> <span class="n">Coordonnees</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le problème des structures en C, c'est qu'il fallait placer le mot-clé struct au début de chaque déclaration d'une variable de type personnalisé :<br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="k">struct</span> <span class="n">Coordonnees</span> <span class="n">point</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Pour éviter d'avoir à répéter ce mot à chaque déclaration, on avait découvert l'instruction <strong>typedef </strong>qu'on utilisait comme ceci avant la définition de notre structure :<br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7</pre></td><td class="code"><div class="syntax"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Coordonnees</span> <span class="n">Coordonnees</span><span class="p">;</span> <span class="c">// typedef permet d'éviter d'avoir à taper "struct" à chaque déclaration</span>

<span class="k">struct</span> <span class="n">Coordonnees</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Du coup, on pouvait déclarer une variable sans avoir à écrire <span class="courrier">struct</span> devant :<br>
<br>
<span class="code">Code : C - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 c"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">Coordonnees</span> <span class="n">point</span><span class="p">;</span> <span class="c">// Le mot-clé struct est inutile grâce au typedef</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
<h3>La nouveauté</h3><br>
<br>
En C++, qu'on se rassure, les structures existent toujours (il y a même encore mieux, mais n'anticipons pas <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ).<br>
<br>
La nouveauté du C++, c'est que le typedef est désormais automatique. A chaque fois que l'on déclare une structure (ou une énumération), un typedef est réalisé automatiquement par le compilateur. On peut donc n'écrire que l'instruction de déclaration de la structure :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7</pre></td><td class="code"><div class="syntax"><pre><span class="c">// Le typedef est réalisé automatiquement par le compilateur, pas besoin de l'écrire</span>

<span class="k">struct</span> <span class="n">Coordonnees</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Grâce à cela, le mot-clé <span class="courrier">struct</span> devient totalement inutile lors d'une déclaration de variable :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">Coordonnees</span> <span class="n">point</span><span class="p">;</span> <span class="c">// Le mot-clé struct est inutile grâce au typedef automatique</span>
</pre></div>
</td></tr></tbody></table></div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11142">Les références</h2>
		<div class="ss_part_texte">
		Nous arrivons maintenant au point le plus important (et délicat) de ce chapitre. Ouvrez grandes vos oreilles (ou plutôt vos yeux <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).<br>
<br>
Le C++ introduit un nouveau concept : <strong>les références</strong>. <span class="souligne">Une référence est un synonyme d'une autre variable</span>. On verra ce que ça veut dire un peu plus loin <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Vous allez voir que les références ressemblent beaucoup aux pointeurs. Elles ont en effet été créées pour simplifier l'utilisation des pointeurs. Attention toutefois : je vous préviens qu'au début vous risquez de confondre les références avec les pointeurs (c'est assez perturbant quand on voit ça la première fois j'avoue <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ).<br>
<br>
<br>
<h3>Les références à l'intérieur d'une fonction</h3><br>
<br>
Pour créer une référence, on doit utiliser le symbole &amp; dans la déclaration :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="o">&amp;</span><span class="n">referenceSurAge</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq erreur"><strong>Attention à ne pas confondre !</strong><br>
Dans une déclaration, le symbole &amp; signifie "Je veux créer une référence" (c'est ce qu'on découvre maintenant). Partout ailleurs, le symbole &amp; signifie "Je veux obtenir l'adresse de cette variable" (ça on l'avait déjà vu).<br>
On confond facilement quand on débute. Il faut dire que les programmeurs n'ont pas été très malins en réutilisant le symbole &amp; ici, y'a rien de tel pour confondre <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
Quand vous voyez un &amp; désormais, vérifiez s'il se trouve dans une déclaration : si c'est dans une déclaration, c'est qu'on cherche à créer une référence, sinon c'est qu'on demande à obtenir l'adresse de la variable.</div><br>
<br>
Bon, on a créé une référence. Et alors ?<br>
Et alors si vous compilez le code ci-dessus, le compilateur va vous insulter poliment :<br>
<br>
<span class="citation">Citation : Compilateur C++</span><div class="citation2">error: 'referenceSurAge' declared as reference but not initialized</div><br>
<br>
Si vous lisez l'anglais (et si vous ne le lisez pas vous devriez), vous avez compris le problème : le compilateur veut qu'on initialise immédiatement la référence.<br>
Et ça c'est très important : une référence doit être immédiatement initialisée dès le début, contrairement aux pointeurs. Et ce n'est pas tout : une fois initialisée, la référence ne pourra plus changer !<br>
<br>
Il y a donc deux règles que j'aimerais que vous reteniez par coeur :<br>
<br>
<ul>
<li><strong>Règle 1</strong> : une référence doit être initialisée dès sa déclaration.</li>
<li><strong>Règle 2</strong> : une fois initialisée, une référence ne peut plus être modifiée.</li>
</ul><br>
<br>
<h4>Initialisation d'une référence</h4><br>
<br>
On va donc initialiser notre référence.<br>
Comme je vous l'ai dit un peu plus tôt, une référence est un synonyme d'une autre variable. Cela veut donc dire qu'il faut créer une autre variable pour y trouver un minimum d'intérêt <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Allez hop, il est l'heure de ressortir la bonne vieille variable qui a fait ses preuves : la variable... age !<br>
<span class="italique">(le premier qui ose dire que je fais des cours pas originaux il va tâter de mon sabre <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies"> )</span><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span> <span class="c">// Déclaration de la variable age (rien de nouveau)</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">referenceSurAge</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span> <span class="c">// Déclaration et initialisation d'une référence sur la variable age</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Pour initialiser une référence, vous avez juste besoin d'écrire le nom de la variable dont elle sera le synonyme. Pas besoin d'écrire &amp;age comme on le faisait avant avec les pointeurs.<br>
<br>
<div class="rmq attention">Je vous avais prévenu, vous risquez de confondre avec les pointeurs.<br>
Je vous ferai un résumé comparatif pointeurs / références un peu plus loin pour que vous puissiez bien les comparer.</div><br>
<br>
<h4>Utilisation de la référence</h4><br>
<br>
Bon, maintenant notre référence est créée. On a un synonyme de la variable age.<br>
Comment on s'en sert concrètement ? Exactement comme la variable age ! Pas besoin de mettre une étoile * devant pour dire qu'on veut obtenir la valeur. Les références permettent, vous allez le voir, de simplifier l'écriture de nos programmes pour éviter au maximum les erreurs (un oubli d'une étoile est si vite arrivé !).<br>
<br>
Regardez ce petit programme complet qui affiche la variable age, la modifie, et la réaffiche, le tout en passant par une référence :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span><span class="n">referenceSurAge</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">referenceSurAge</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">referenceSurAge</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">referenceSurAge</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>21

21

40

40</pre></div></td></tr></tbody></table></div><br>
<br>
Comme vous pouvez le voir, une référence s'utilise exactement comme la variable d'origine. C'est le compilateur qui fait la "conversion" et qui sait qu'il doit affecter la variable "age" lorsqu'on travaille avec la référence.<br>
<br>
<h4>Comparatif pointeur / référence</h4><br>
<br>
En C++, les pointeurs existent toujours. Les références sont juste une alternative aux pointeurs. Elles ont surtout l'avantage d'être plus simples à utiliser, mais elles ne peuvent pas les remplacer complètement.<br>
Pourquoi ? On l'a vu : une référence ne peut pas faire référence à une nouvelle variable une fois qu'elle a été initialisée. Un pointeur, lui, peut toujours pointer vers une nouvelle variable au cours de l'exécution du programme.<br>
<br>
<div class="rmq information">Dans certains langages récents, comme le Java, les pointeurs ont complètement disparu. On n'utilise plus que des références, ce qui limite beaucoup les risques d'erreur et simplifie les programmes. La différence, c'est qu'en Java on peut modifier les références en cours de route, contrairement au C++ <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
Il est <span class="souligne">très courant</span> de confondre les pointeurs et les références lorsqu'on débute (si ça peut vous rassurer, moi aussi j'ai pas mal confondu au début). Je vais donc vous donner 2 codes source : le premier utilise les pointeurs, le second les références. Si à un moment vous avez un doute et que vous vous mettez à confondre pointeurs et références, servez-vous de l'exemple ci-dessous pour vous assurer que vous faites les choses correctement :<br>
<br>
<table class="tab_user">


<thead><tr><th>-------- Code d'exemple avec un pointeur --------</th><th>-------- Code d'exemple avec une référence --------</th></tr></thead><tbody><tr>
<td><span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pointeurSurAge</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">age</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">pointeurSurAge</span><span class="p">;</span>

    <span class="o">*</span><span class="n">pointeurSurAge</span>  <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">pointeurSurAge</span><span class="p">;</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div></td>
<td><span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span><span class="n">referenceSurAge</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">referenceSurAge</span><span class="p">;</span>

    <span class="n">referenceSurAge</span>  <span class="o">=</span> <span class="mi">40</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">referenceSurAge</span><span class="p">;</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div></td>
</tr></tbody></table><br>
<br>
Voilà, j'espère que ce comparatif vous permettra d'y voir plus clair <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Ce qu'il faut retenir dans l'histoire, c'est que les références sont là pour <span class="souligne">simplifier l'écriture du code source</span>. Comme on n'a plus besoin d'utiliser le symbole * à chaque fois qu'on veut accéder à la variable age, on minimise les risques d'erreur dans nos programmes.<br>
<br>
<h3>Les références vers des structures</h3><br>
<br>
Si vous faites une référence vers une structure, il faudra utiliser le symbole point "." et non le symbole flèche "-&gt;" lorsque vous voulez accéder à un élément d'une structure.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><div class="syntax"><pre><span class="k">struct</span> <span class="n">Coordonnees</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Coordonnees</span> <span class="n">point</span><span class="p">;</span>
    <span class="n">Coordonnees</span> <span class="o">&amp;</span><span class="n">referenceSurPoint</span> <span class="o">=</span> <span class="n">point</span><span class="p">;</span>

    <span class="n">referenceSurPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">referenceSurPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x : "</span> <span class="o">&lt;&lt;</span> <span class="n">referenceSurPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"y : "</span> <span class="o">&lt;&lt;</span> <span class="n">referenceSurPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>x&nbsp;:&nbsp;10

y&nbsp;:&nbsp;5</pre></div></td></tr></tbody></table></div><br>
<br>
Une fois de plus, vous voyez qu'une référence s'utilise <span class="italique">exactement </span>comme une variable <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<h3>Les références lors d'un appel de fonction</h3><br>
<br>
Les codes qu'on a vus jusqu'ici n'étaient pas très utiles. En pratique, on n'est pas suffisamment maso pour créer des références juste "pour le plaisir" si elles ne sont pas indispensables.<br>
<br>
En fait, comme pour les pointeurs, les références révèlent toute leur utilité lorsqu'on appelle une fonction.<br>
<br>
Voyons voir ça dans un exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><div class="syntax"><pre><span class="k">struct</span> <span class="n">Coordonnees</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">remiseAZero</span><span class="p">(</span><span class="n">Coordonnees</span> <span class="o">&amp;</span><span class="n">pointAModifier</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Coordonnees</span> <span class="n">point</span><span class="p">;</span>

    <span class="n">remiseAZero</span><span class="p">(</span><span class="n">point</span><span class="p">);</span> <span class="c">// Pas besoin d'indiquer l'adresse de point avec un &amp; lors de l'appel</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">remiseAZero</span><span class="p">(</span><span class="n">Coordonnees</span> <span class="o">&amp;</span><span class="n">pointAModifier</span><span class="p">)</span> <span class="c">// La fonction indique qu'elle récupère une référence</span>
<span class="p">{</span>
    <span class="c">// La référence s'utilise exactement comme une variable</span>
    <span class="c">// On utilise donc des points "." et non des flèches "-&gt;"</span>
    <span class="n">pointAModifier</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pointAModifier</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On transmet la référence à la fonction RemiseAZero le plus simplement du monde, sans avoir à mettre de symbole &amp;.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">remiseAZero</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le but des références est là encore très clair : éviter d'avoir à taper des symboles en plus pour minimiser les erreurs.<br>
<br>
La fonction doit bien préciser qu'elle reçoit une référence. On doit donc placer le symbole &amp; dans la déclaration (et dans le prototype) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">remiseAZero</span><span class="p">(</span><span class="n">Coordonnees</span> <span class="o">&amp;</span><span class="n">pointAModifier</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ensuite, à l'intérieur de la fonction, on se sert de la référence comme si c'était une variable (dans le cas présent, on utilise donc le symbole point et non la flèche -&gt; ) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">pointAModifier</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pointAModifier</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
<h4>Comparaison pointeur / référence</h4><br>
<br>
Une fois de plus, je crois qu'il est utile que je vous fasse un comparatif du même code utilisant d'un côté un pointeur, de l'autre une référence.<br>
<br>
<table class="tab_user">


<thead><tr><th>----------------------- Code d'exemple avec un pointeur -------------------</th><th>----------------- Code d'exemple avec une référence ---------------------</th></tr></thead><tbody><tr>
<td><span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Coordonnees</span> <span class="n">point</span><span class="p">;</span>

    <span class="n">remiseAZero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">point</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">remiseAZero</span><span class="p">(</span><span class="n">Coordonnees</span> <span class="o">*</span><span class="n">pointAModifier</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pointAModifier</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pointAModifier</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div></td>
<td><span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Coordonnees</span> <span class="n">point</span><span class="p">;</span>

    <span class="n">remiseAZero</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">remiseAZero</span><span class="p">(</span><span class="n">Coordonnees</span> <span class="o">&amp;</span><span class="n">pointAModifier</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pointAModifier</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pointAModifier</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div></td>
</tr></tbody></table><br>
<br>
Ces codes fonctionnent tous deux très bien en C++. Autant que possible, on utilisera des références en C++, sauf quand l'utilisation d'un pointeur est obligatoire.<br>
<br>
<div class="rmq information">Pour ceux qui se posent la question : on aurait tout à fait pu appeler la référence de la fonction "remiseAZero" <span class="italique">point </span>au lieu de <span class="italique">pointAModifier</span>. Il n'y a pas de risque de conflit avec la variable <span class="italique">point </span> du main car elle se trouve dans une autre fonction. J'ai juste changé le nom pour que vous évitiez de les confondre <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
<strong>A retenir</strong> : s'il y a un code que vous devez retenir pour les références, c'est celui de l'appel d'une fonction utilisant une référence (celui que nous venons de voir). Dans 99,99% des cas, on utilise les références lorsqu'on fait appel à une fonction.
		</div>
		<hr>
		
	<div id="chap_conclusion">
	<span class="italique">Que de nouveautés !</span> C'est le moins qu'on puisse dire <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Et encore, vous n'avez pas tout vu ! Dans le prochain chapitre, nous découvrirons les nouveautés du C++ relatives aux fonctions.<br>
<br>
Et après... après, je pense qu'on pourra commencer à parler de POO <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
<div class="rmq information">Tout ce que nous avons découvert dans ce chapitre est utile et sera largement utilisé par la suite. Prenez le temps de vous familiariser avec. Faites en particulier quelques tests et exercices avec les références car c'est un peu délicat au début, vu qu'on les mélange facilement avec les pointeurs. Heureusement, avec un peu d'expérience, on ne se trompe plus <img src="./cpp_files/smile.png" alt=":)" class="smilies"></div>
	</div>
	
	<hr>
	<h1 id="chap_11151">Nouveautés pour les fonctions</h1>
	<div id="chap_intro">
	Nous avons vu que le C++ proposait de nombreuses nouveautés relatives pour les variables.<br>
Ce chapitre est la suite du précédent, mais est cette fois axé sur les nouveautés relatives aux fonctions.<br>
<br>
Ce chapitre sera un peu plus court car il y a assez peu de changements au final. Ne vous endormez pas pour autant parce que vous allez découvrir les valeurs par défaut et les fonctions surchargées, deux éléments très importants que nous réutiliserons largement dans la suite.<br>
<br>
Courage, c'est le dernier chapitre avant la POO (<span class="italique">ou plutôt devrais-je dire : "Profitez-en bien mes petits ! <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> ")</span>.
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11150">Des valeurs par défaut pour les paramètres</h2>
		<div class="ss_part_texte">
		Si je vous dis "paramètre de fonction", vous voyez de quoi je parle n'est-ce pas ?<br>
Je l'espère, parce qu'il serait temps de le savoir à votre niveau maintenant. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<br>
<h3>Bon allez, un petit rappel !</h3><br>
<br>
Comme un petit rappel ne fait jamais de mal, voici un exemple de fonction :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">total</span> <span class="o">=</span> <span class="n">heures</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">minutes</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">secondes</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cette fonction calcule le nombre de secondes en additionnant les heures, minutes et secondes qu'on lui envoie. Rien de bien compliqué ! <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Les variables <span class="italique">heures</span>, <span class="italique">minutes </span>et <span class="italique">secondes </span>sont les <strong>paramètres </strong>de la fonction nombreDeSecondes. Ce sont des valeurs qu'elle reçoit, celles avec lesquelles elle va travailler.<br>
Il est facile de reconnaître les paramètres d'une fonction, car ceux-ci se trouvent toujours écrits entre les parenthèses. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Les valeurs par défaut</h3><br>
<br>
La nouveauté en C++, c'est qu'on peut donner des valeurs par défaut à certains paramètres de nos fonctions. Ainsi, on ne sera pas obligé d'indiquer à chaque fois tous les paramètres lorsqu'on appelle une fonction !<br>
<br>
Pour bien voir comment on doit procéder, on va regarder le code complet. J'aimerais que vous le copiez dans votre IDE pour faire les tests en même temps que moi :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// Prototype de la fonction</span>
<span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">);</span>

<span class="c1">// Main</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Définition de la fonction</span>
<span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">total</span> <span class="o">=</span> <span class="n">heures</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">minutes</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">secondes</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce code donne le résultat suivant :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>4225</pre></div></td></tr></tbody></table></div><br>
<br>
Sachant qu'1 heure = 3600s, 10 minutes = 600s, 25 secondes =... 25s, le résultat est logique car 3600 + 600 + 25 = 4225. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Bref, tout va bien.<br>
<br>
Maintenant supposons que l'on veuille rendre certains paramètres facultatifs, par exemple parce qu'on utilise en pratique plus souvent les heures que le reste.<br>
On va devoir modifier le prototype de la fonction (et non sa définition, attention).<br>
<br>
Indiquez la valeur par défaut que vous voulez donner aux paramètres si on ne les a pas renseigné lors de l'appel de la fonction :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Dans cet exemple, seul le paramètre heures sera obligatoire, les deux autres étant désormais facultatifs. Si on ne renseigne pas les minutes et les secondes, les variables vaudront alors 0 dans la fonction.<br>
<br>
Voici le code complet que vous devriez avoir sous les yeux :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// Prototype avec les valeurs par défaut</span>
<span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// Main</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Définition de la fonction, SANS les valeurs par défaut</span>
<span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">total</span> <span class="o">=</span> <span class="n">heures</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">minutes</span> <span class="o">*</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">secondes</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq erreur">Si vous avez lu attentivement ce code, vous avez dû vous rendre compte de quelque chose : <span class="souligne">les valeurs par défaut sont spécifiées uniquement dans le prototype</span>, PAS dans la définition de la fonction ! On se fait souvent avoir, je vous préviens... <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Si vous vous trompez, le compilateur vous indiquera une erreur à la ligne de la définition de la fonction.</div><br>
<br>
Bon, ce code ne change pas beaucoup du précédent. A part les valeurs par défaut dans le prototype, rien n'a été modifié (et le résultat à l'écran sera toujours le même).<br>
La nouveauté maintenant, c'est qu'on peut supprimer des paramètres lors de l'appel de la fonction (ici dans le <span class="italique">main</span>). On peut par exemple écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le compilateur lit les paramètres de gauche à droite. Comme il n'y en a qu'un et que seules les heures sont obligatoires, il devine que la valeur "1" correspond à un nombre d'heures.<br>
<br>
Le résultat à l'écran sera le suivant :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>3600</pre></div></td></tr></tbody></table></div><br>
<br>
Mieux encore, vous pouvez indiquer juste les heures et les minutes si vous le désirez :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>4200</pre></div></td></tr></tbody></table></div><br>
<br>
Du temps que vous indiquez au moins les paramètres obligatoires, il n'y a pas de problème. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Cas particuliers, attention danger</h3><br>
<br>
Bon, mine de rien il y a quand même quelques pièges, ce n'est pas si simple que ça ! <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
On va voir ces pièges sous la forme de questions / réponses :<br>
<br>
<div class="rmq question">Et si je veux envoyer à la fonction juste les heures et les secondes, mais pas les minutes ?</div><br>
<br>
Tel quel, c'est impossible. En effet, je vous l'ai dit plus haut, le compilateur va analyser les paramètres de gauche à droite. Le premier correspondra forcément aux heures, le second aux minutes et le troisième aux secondes.<br>
<br>
<strong>Vous ne pouvez PAS écrire :</strong><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">,,</span><span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est interdit. Si vous le faites, le compilateur vous fera comprendre qu'il n'apprécie guère vos manoeuvres. C'est comme ça : en C++, on ne peut pas "sauter" des paramètres, même s'ils sont facultatifs. Si vous voulez indiquer le premier et le dernier paramètre, il vous faudra obligatoirement spécifier ceux du milieu. On devra donc écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Est-ce que je peux rendre juste les heures facultatives, et rendre les minutes et secondes obligatoires ?</div><br>
<br>
Si le prototype est défini dans le même ordre que tout à l'heure : non.<br>
<strong>Les paramètres facultatifs doivent obligatoirement se trouver à la fin</strong> (à droite).<br>
<br>
Ce code ne compilera donc pas :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">);</span>
                                  <span class="c1">// Erreur, les paramètres par défaut doivent être à droite</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La solution, pour régler ce problème, consiste à placer le paramètre <span class="italique">heures </span>à la fin :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">secondes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">heures</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
                                                <span class="c1">// OK</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Est-ce que je peux rendre tous mes paramètres facultatifs ?</div><br>
<br>
Oui, ça ne pose pas de problème :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">nombreDeSecondes</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Dans ce cas, l'appel de la fonction pourra être fait comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nombreDeSecondes</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le résultat retourné sera bien entendu 0 dans notre cas. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<h3>Règles à retenir</h3><br>
<br>
En résumé, il y a 2 règles que vous devez retenir pour les valeurs par défaut :<br>
<br>
<ul>
<li>Seul le prototype doit contenir les valeurs par défaut (pas la définition de la fonction).</li>
<li>Les valeurs par défaut doivent se trouver à la fin de la liste des paramètres ("à droite").</li>
</ul>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11149">La surcharge des fonctions</h2>
		<div class="ss_part_texte">
		Ca, c'est probablement <span class="italique">la</span> nouveauté la plus importante des fonctions ! Cela nous aidera énormément lorsque nous ferons de la POO un peu plus loin <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
De quoi s'agit-il ? D'un nouveau système en C++ qui permet de <strong>surcharger des fonctions</strong>.<br>
En gros, et pour faire simple, c'est une technique qui nous permet de créer plusieurs fonctions ayant <span class="souligne">le même nom</span>... sans que le compilateur crie au loup <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<br>
<h3>La signature d'une fonction</h3><br>
<br>
Avant toute chose, il faut que je vous parle de ce qu'on appelle la <strong>signature d'une fonction</strong>. C'est un peu sa carte d'identité, ce qui permet au compilateur de différencier les fonctions entre elles.<br>
<br>
Chaque fonction est constituée de 3 éléments, ni plus ni moins :<br>
<br>
<ul>
<li>Un type de retour</li>
<li>Un nom</li>
<li>Une liste de paramètres</li>
</ul><br>
<br>
On va représenter ça sur un schéma pour être sûr qu'on voie bien la même chose <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<div class="centre"><img src="./cpp_files/47767.png" alt="Image utilisateur"></div><br>
<br>
<div class="rmq information">Le compilateur se moque complètement des noms des variables passées en paramètre. Ce qui compte pour lui, c'est juste le type de ces paramètres. Je vous l'avais d'ailleurs dit dans le <a href="http://www.siteduzero.com/tuto-3-3040-1-la-programmation-modulaire.html#ss_part_1">chapitre sur la compilation modulaire</a> <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Voilà donc pourquoi j'ai marqué (int, int, int) pour les paramètres. C'est ce que le compilateur "voit", le nom des variables est donc ignoré pour l'identification de la fonction.</div><br>
<br>
Bon, qu'est-ce qui permet d'identifier une fonction d'après vous ? Comment le compilateur fait-il pour vérifier si une fonction est bien différente d'une autre ?<br>
<br>
<strong>En C</strong>, le compilateur se basait sur le nom, et uniquement sur le nom. Si 2 fonctions avaient le même nom, la compilation plantait. L'identification était donc faite sur le nom.<br>
<strong>En C++</strong>, le compilateur se base sur <span class="souligne">le nom et les paramètres</span> ! On peut avoir du coup 2 fonctions avec le même nom, à condition que celles-ci reçoivent des paramètres différents.<br>
<br>
Le nom et les paramètres de la fonction constituent ce qu'on appelle la <strong>signature de la fonction</strong>. C'est ce qui permet au compilateur de l'identifier en C++.<br>
<br>
<div class="centre"><img src="./cpp_files/47768.png" alt="Image utilisateur"></div><br>
<br>
Le type de retour n'est donc pas pris en compte pour identifier la fonction.<br>
<br>
<br>
<h3>La surcharge d'une fonction</h3><br>
<br>
La surcharge consiste à créer des fonctions qui ont le même nom, mais qui ont des paramètres différents (donc une signature différente).<br>
<br>
Voici ce qui peut varier :<br>
<br>
<ul>
<li>Le nombre de paramètres</li>
<li>Le type de chacun de ces paramètres</li>
</ul><br>
<br>
Encore une fois, je le rappelle, le nom que l'on donne à chacun des paramètres, le compilo il s'en fout complètement <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Prenons un exemple pour bien comprendre ce que ça va nous permettre de faire. Imaginez une fonction addition. On peut additionner des entiers (int), mais aussi des décimaux (double).<br>
<br>
En C, il aurait fallu nommer les deux fonctions différemment (par exemple sommeEntiers et sommeDecimaux). En C++, on peut leur donner le même nom et ça va grandement simplifier leur utilisation, vous allez voir.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">somme</span><span class="p">(</span><span class="kt">int</span> <span class="n">nb1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nb2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">nb1</span> <span class="o">+</span> <span class="n">nb2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="n">somme</span><span class="p">(</span><span class="kt">double</span> <span class="n">nb1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">nb2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">nb1</span> <span class="o">+</span> <span class="n">nb2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les prototypes de ces fonctions sont donc :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">somme</span><span class="p">(</span><span class="kt">int</span> <span class="n">nb1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nb2</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">somme</span><span class="p">(</span><span class="kt">double</span> <span class="n">nb1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">nb2</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Leurs signatures sont :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">somme</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>
<span class="n">somme</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ces fonctions ont des signatures différentes et portent le même nom. <strong>Ce sont des fonctions surchargées</strong> <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
Maintenant, dans le main on peut faire appel à la fonction somme pour additionner indifféremment des entiers ou des décimaux. C'est le compilateur qui décide quelle fonction il appelle en fonction du nombre et du type des paramètres.<br>
<br>
Voici un code complet que vous pouvez tester :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="kt">int</span> <span class="n">somme</span><span class="p">(</span><span class="kt">int</span> <span class="n">nb1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nb2</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">somme</span><span class="p">(</span><span class="kt">double</span> <span class="n">nb1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">nb2</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">somme</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">somme</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">somme</span><span class="p">(</span><span class="kt">int</span> <span class="n">nb1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nb2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">nb1</span> <span class="o">+</span> <span class="n">nb2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="n">somme</span><span class="p">(</span><span class="kt">double</span> <span class="n">nb1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">nb2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">nb1</span> <span class="o">+</span> <span class="n">nb2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>25

2.8</pre></div></td></tr></tbody></table></div><br>
<br>
On a appelé 2 fois la fonction "somme", mais c'est en fait une fonction différente qui a été appelée à chaque fois <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Vous pouvez surcharger la fonction autant de fois que vous le désirez. On pourrait donc aussi rajouter par exemple la fonction qui fait la somme d'un entier et d'un décimal :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="kt">double</span> <span class="n">somme</span><span class="p">(</span><span class="kt">int</span> <span class="n">nb1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">nb2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">nb1</span> <span class="o">+</span> <span class="n">nb2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... ou encore celle qui fait la somme de 3 entiers :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">somme</span><span class="p">(</span><span class="kt">int</span> <span class="n">nb1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nb2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nb3</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">nb1</span> <span class="o">+</span> <span class="n">nb2</span> <span class="o">+</span> <span class="n">nb3</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les possibilités sont infinies <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Bien entendu, on fait de la surcharge de fonction pour des choses plus "intéressantes" que des sommes, mais ça on le découvrira petit à petit en fonction de nos besoins.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11148">Les fonctions inline</h2>
		<div class="ss_part_texte">
		Ce que nous allons voir ici ressemble beaucoup aux macros (relisez le <a href="http://www.siteduzero.com/tuto-3-4200-1-le-preprocesseur.html#ss_part_3">chapitre sur le préprocesseur</a> si vous avez oublié ce que c'est <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ).<br>
<br>
Les macros sont un bon moyen, utilisées intelligemment, d'accélérer la vitesse d'exécution du programme si certains bouts de code sont souvent réutilisés.<br>
Toutefois, les macros sont assez délicates à manipuler et impliquent l'utilisation du préprocesseur.<br>
<br>
En C++, on a inventé le mot-clé <span class="italique">inline </span>qui permet de faire, grosso modo, la même chose que les macros sans cette fois passer par le préprocesseur. C'est donc le compilateur qui se charge de faire le "remplacement de code" au moment de la compilation. L'avantage, c'est qu'on peut faire plus de vérifications (notamment sur les types des paramètres).<br>
<br>
<br>
<h3>Exemple d'utilisation d'une fonction inline</h3><br>
<br>
Prenons l'exemple suivant (on le discutera ensuite) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="kr">inline</span> <span class="kt">int</span> <span class="n">carre</span><span class="p">(</span><span class="kt">int</span> <span class="n">nombre</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">carre</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="n">carre</span><span class="p">(</span><span class="kt">int</span> <span class="n">nombre</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">nombre</span> <span class="o">*</span> <span class="n">nombre</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous voyez que j'ai ajouté le mot-clé <span class="italique">inline </span>au début du prototype ET au début de la définition de la fonction. Cela signifie pour le compilateur "<span class="italique">A chaque fois qu'on fera appel à la fonction carre, je placerai directement le code de cette fonction à l'endroit de l'appel</span>".<br>
<br>
En clair, après compilation voici ce qu'il restera dans votre exécutable :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La fonction inline disparaît complètement après compilation. Tout son code se trouve placé à l'endroit de l'appel (la ligne du cout dans notre cas).<br>
<br>
<strong>L'avantage</strong> est que l'exécution du programme sera plus rapide, surtout si la fonction est appelée plusieurs fois. En effet, lors d'un appel "classique" de fonction, le processeur va sauter à l'adresse de la fonction en mémoire, retenir l'adresse où il en était pour revenir à la fonction appelante une fois l'autre fonction terminée... Bref, c'est très rapide, mais si la fonction est amenée à être appelée très souvent, il est préférable d'en faire une inline (on dit l'<span class="italique">inliner</span> <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ) pour éviter de répéter tout ce processus.<br>
<strong>Le défaut</strong>, c'est que le programme risque de grossir un peu une fois compilé (le même code étant répété dans l'exécutable). Mais bon, en général cette différence est quand même négligeable <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="rmq information">En règle générale, les fonctions inline sont donc des fonctions très courtes que l'on est susceptible de réutiliser souvent, comme c'est le cas de la fonction carre ici.</div><br>
<br>
En pratique, on utilise quand même assez peu les fonctions inline, sachez-le (c'est comme les macros, je ne pense pas que vous vous en soyez beaucoup servis jusqu'ici <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ). Ca reste cependant une des nouveautés du C++ relatives aux fonctions que je devais vous présenter <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<span class="italique">pssst, puisqu'on y est, serez-vous capables de surcharger la fonction inlinée carre pour qu'elle calcule le carré d'un nombre décimal ? <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"></span>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Bon, vous êtes capables de surcharger des fonctions inlinées avec des paramètres par défaut, qu'est-ce qui pourrait bien vous faire peur maintenant ? <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies"> <br>
Oh, mais ne faites pas les malins, tout ceci n'était qu'une misérable mise en bouche comparé à ce qui vous attend <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
En effet, dans le prochain chapitre on va rentrer en plein dans le coeur du C++ : on va découvrir la <strong>programmation orientée objet</strong>. Bien sûr, on va y aller pas à pas, en douceur, sinon ça risque d'être un peu... violent <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
Quand vous êtes prêts, rendez-vous au proch... bon, je suis déjà dans le chapitre suivant moi, qu'est-ce que vous attendez ? <img src="./cpp_files/langue.png" alt=":p" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11167">Les classes (Partie 1/2)</h1>
	<div id="chap_intro">
	Dans le chapitre précédent, vous avez vu que la programmation orientée objet pouvait nous simplifier la vie en "masquant" en quelque sorte le code complexe. Ca c'est un des avantages de la POO, mais ce n'est pas le seul comme vous allez le découvrir petit à petit. Par exemple, un autre gros avantage des objets est qu'ils sont facilement réutilisables et modifiables.<br>
<br>
A partir de maintenant, <strong>nous allons apprendre à <span class="rouge">créer</span> des objets</strong>. Vous allez voir que c'est tout un art et que ça demande de la pratique. Il y a beaucoup de programmeurs qui prétendent faire de la POO et qui le font pourtant très mal (et je ne m'exclue pas forcément du lot <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ). En effet, on peut créer un objet de 100 façons différentes, et c'est à nous de choisir à chaque fois la meilleure, la plus adaptée. Pas évident. Il faudra donc bien réfléchir avant de se lancer dans le code comme des forcenés <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<br>
Allez, on prend une <span class="gros">grande </span>inspiration, et on plonge ensemble dans l'océan de la POO ! <img src="./cpp_files/hihi.png" alt="^^" class="smilies">
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11166">Créer une classe</h2>
		<div class="ss_part_texte">
		Commençons par la question qui doit vous brûler les lèvres <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<div class="rmq question">Je croyais qu'on allait apprendre à créer des objets, pourquoi tu nous parles de créer une classe maintenant ?<br>
Quel est le rapport ?</div><br>
<br>
Eh bien justement, pour créer un objet, il faut d'abord créer une classe !<br>
Je m'explique : pour construire une maison, vous avez besoin d'un plan d'architecte non ? Eh bien imaginez simplement que la classe c'est le plan, et  que l'objet c'est la maison.<br>
<br>
"Créer une classe", c'est donc dessiner les plans de l'objet.<br>
<br>
Une fois que vous avez les plans, vous pouvez faire autant de maisons que vous voulez en vous basant sur les plans. Pour les objets c'est pareil : une fois que vous avez fait la classe (le plan), vous pourrez créer autant d'objets du même type que vous voulez <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="rmq information">Vocabulaire : on dit qu'un objet est une <strong>instance </strong>d'une classe. C'est un mot très courant que l'on rencontre souvent en POO. Cela signifie qu'un objet est la matérialisation concrète d'une classe (tout comme la maison est la matérialisation concrète du plan de la maison).<br>
Oui je sais c'est très métaphysique la POO, mais vous allez voir on s'y fait <img src="./cpp_files/hihi.png" alt="^^" class="smilies"></div><br>
<br>
<br>
<h3>Créer une classe, oui mais laquelle ?</h3><br>
<br>
Avant tout, il va falloir choisir la classe sur laquelle nous allons travailler.<br>
<br>
Pour reprendre mon exemple sur l'architecture : allons-nous créer un appartement, une villa avec piscine, un spacieux loft ?<br>
En clair, quel type d'objet voulons-nous être capable de créer ?<br>
<br>
Les choix ne manquent pas. Je sais que, quand on débute, on a du mal à imaginer ce qui peut être considéré comme un objet. La réponse est : presque tout  !<br>
<br>
Vous allez voir, vous allez petit à petit avoir le feeling qu'il faut avec la POO. Puisque vous débutez, c'est moi qui vais choisir (vous avez pas trop le choix de toute façon <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ).<br>
Pour notre exemple, nous allons créer une classe <strong>Personnage</strong> qui va permettre de représenter un personnage de jeu de rôle (RPG).<br>
<br>
<div class="rmq information">Si vous n'avez pas l'habitude des jeux de rôle, rassurez-vous, moi non plus. Vous n'avez pas besoin de savoir jouer à des RPG pour suivre ce chapitre. J'ai choisi cet exemple car il me paraît didactique, amusant, et qu'il peut déboucher sur la création d'un jeu à la fin <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
<h3>Bon, on la crée cette classe ?</h3><br>
<br>
C'est parti <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Pour commencer, je vous rappelle qu'une classe est constituée :<br>
<br>
<ul>
<li>De variables, ici appelées <strong>attributs</strong> (on parle aussi de <span class="italique">variables membres</span>)</li>
<li>De fonctions, ici appelées <strong>méthodes</strong> (on parle aussi de <span class="italique">fonctions membres</span>)</li>
</ul><br>
(n'oubliez pas ce vocabulaire, il est fon-da-men-tal !)<br>
<br>
Pour tout vous dire, les classes ressemblent beaucoup aux <a href="http://www.siteduzero.com/tuto-3-4350-1-creez-vos-propres-types-de-variables.html">structures</a> qu'on avait étudiées en C, sauf qu'elles contiennent en plus des méthodes (les fonctions).<br>
Vous allez donc voir que cela ressemble pas mal aux structures, du moins au premier abord.<br>
<br>
Voici le code minimal pour créer une classe :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    
<span class="p">};</span> <span class="c">// N'oubliez pas le point-virgule à la fin !</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On utilise comme vous le voyez le mot-clé <span class="courrier">class</span>.<br>
Il est suivi du nom de la classe que l'on veut créer. Ici, c'est Personnage.<br>
<br>
<div class="rmq information">Souvenez-vous de cette règle très importante : il faut que le nom de vos classes commence toujours par une lettre majuscule ! Bien que ce ne soit pas obligatoire (le compilateur ne gueulera pas si vous commencez par une minuscule), cela vous sera très utile par la suite pour différencier les types de variable classiques (int, double, bool, ...) des classes (Personnage, ...). </div><br>
<br>
C'est entre les accolades que nous allons écrire la définition de la classe. Tout ou presque se passera à l'intérieur de ces accolades.<br>
Et surtout, super important, le truc qu'on oublie au moins une fois dans sa vie : <strong>il y a un point-virgule après l'accolade fermante</strong>, tout comme avec les structures !<br>
<br>
<br>
<h3>Ajout de méthodes et d'attributs</h3><br>
<br>
Bon c'est bien beau, mais notre classe Personnage est plutôt... vide.<br>
Que va-t-on mettre dans la classe ? Vous le savez déjà voyons <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<ul>
<li>Des <strong>attributs</strong>, c'est le nom que l'on donne aux variables contenues dans des classes</li>
<li>Des <strong>méthodes</strong>, c'est le nom que l'on donne aux fonctions contenues dans des classes</li>
</ul><br>
<br>
Le but du jeu maintenant, c'est justement d'arriver à faire la liste de tout ce qu'on veut mettre dans notre Personnage. De quels attributs et de quelles méthodes a-t-il besoin ? Ca, c'est justement l'étape de <span class="italique">réflexion</span>, la plus importante. C'est pour ça que je vous ai dit au début de ce chapitre qu'il fallait surtout pas coder comme des barbares dès le début, mais prendre le temps de <span class="italique">réfléchir</span>.<br>
<br>
<div class="rmq information">Cette étape de réflexion avant le codage est essentielle quand on fait de la POO. Beaucoup de gens, dont moi, ont l'habitude de sortir une feuille de papier et un crayon pour arriver à établir la liste des attributs et méthodes dont ils vont avoir besoin.<br>
On en reparlera plus tard, mais sachez déjà qu'un langage spécial appelé <strong>UML</strong> a été spécialement conçu pour "dessiner" les classes avant de commencer à les coder.</div><br>
<br>
Par quoi commencer : les attributs ou les méthodes ? Il n'y a pas d'ordre en fait, mais je trouve un peu plus logique de commencer par voir les attributs <span class="italique">puis </span>les méthodes.<br>
<br>
<br>
<h4>Les attributs</h4><br>
<br>
C'est ce qui va caractériser votre classe, ici le personnage. Ce sont des variables, elles peuvent donc évoluer au fil du temps. Mais qu'est-ce qui caractérise un personnage de jeu de rôle ? Allons, un petit effort <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<ul>
<li>Par exemple, tout personnage a un niveau de vie. Hop, ça fait un premier attribut : <strong>vie </strong>! On dira que ce sera un int, et qu'il sera compris entre 0 et 100 (0 = mort, 100 = toute la vie).</li>
<li>Dans un jeu de rôle (RPG), il y a le niveau de magie, aussi appelé <strong>mana</strong>. Là encore, on va dire que c'est un int compris entre 0 et 100. Si le personnage a 0 de mana, il ne peut plus lancer de sorts magiques et doit attendre que sa mana se recharge toute seule au fil du temps (ou boire une potion de mana !).</li>
<li>On pourrait rajouter aussi le nom de l'arme que porte le joueur : <strong>nomArme</strong>. Puisque c'est une chaîne de caractères et qu'on fait du C++, on n'est pas fou, on va utiliser un string <img src="./cpp_files/heureux.png" alt=":D" class="smilies"></li>
<li>Enfin, il me semble indispensable d'ajouter un attribut <strong>degatsArme</strong>, un int toujours, qui indiquerait cette fois le nombre de dégâts que fait notre arme à chaque coup</li>
</ul><br>
On peut donc déjà commencer à compléter notre classe avec ces premiers attributs :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_mana</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">m_nomArme</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_degatsArme</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Deux trois petites choses à savoir sur ce code :<br>
<br>
<ul>
<li>Ce n'est pas une obligation, mais une grande partie des programmeurs (dont moi) a l'habitude de faire commencer tous les noms des attributs de classe par <span class="rouge">m_</span> (le "m" signifiant "membre", pour indiquer que c'est une variable membre, c'est-à-dire un attribut). Cela permet de bien différencier les attributs des variables "classiques" (contenues dans des fonctions par exemple).</li>
<li>Il est impossible d'initialiser les attributs ici. Cela doit être fait via ce qu'on appelle un constructeur, comme on le verra un peu plus loin.</li>
<li>Comme on utilise un objet string, il faut bien penser à rajouter un <span class="courrier">#include &lt;string&gt;</span> dans votre fichier.</li>
</ul><br>
<br>
<h4>Les méthodes</h4><br>
<br>
Les méthodes, elles, sont grosso modo les actions que le personnage peut faire ou qu'on peut lui faire faire. Les méthodes lisent et modifient les attributs.<br>
<br>
Voici quelques actions qu'on peut faire avec notre personnage :<br>
<br>
<ul>
<li><strong>recevoirDegats </strong>: le personnage prend un certain nombre de dégâts, donc perd de la vie.</li>
<li><strong>attaquer </strong>: le personnage attaque un autre personnage avec son arme. Il fait autant de dégâts que son arme lui permet d'en faire (c'est-à-dire degatsArme).</li>
<li><strong>boirePotionDeVie </strong>: le personnage boit une potion de vie et regagne un certain nombre de points de vie.</li>
<li><strong>changerArme </strong>: le personnage récupère une nouvelle arme plus puissante. On change le nom de l'arme et les dégâts qui vont avec.</li>
<li><strong>estVivant </strong>: renvoie vrai si le personnage est toujours vivant (+ que 0 points de vie), renvoie faux sinon.</li>
</ul><br>
Voilà c'est un bon début je trouve <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
On va rajouter ça dans la classe avant les attributs (on préfère présenter les méthodes <span class="italique">avant </span>les attributs en POO, bien que ça ne soit pas obligatoire) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="c">// Méthodes</span>
    <span class="kt">void</span> <span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbDegats</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">boirePotionDeVie</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantitePotion</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">changerArme</span><span class="p">(</span><span class="n">string</span> <span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsNouvelleArme</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">estVivant</span><span class="p">()</span>
    <span class="p">{</span>

    <span class="p">}</span>

    <span class="c">// Attributs</span>
    <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_mana</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">m_nomArme</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_degatsArme</span><span class="p">;</span>    
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Je n'ai pas écrit le code des méthodes exprès, on le fera après <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
Ceci dit, vous devriez déjà avoir une petite idée de ce que vous allez mettre dans ces méthodes.<br>
<br>
Par exemple, <span class="italique">recevoirDegats </span>retranchera le nombre de dégâts indiqués en paramètre par nbDegats à la vie du personnage.<br>
Intéressante aussi : la méthode <span class="italique">attaquer</span>. Elle prend en paramètre... un autre personnage, plus exactement une référence vers le personnage cible que l'on doit attaquer ! Et que fera cette méthode à votre avis ? Eh oui, elle appellera la méthode recevoirDegats de la cible pour lui infliger des dégâts <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Vous commencez à comprendre un peu comment tout cela est lié et terriblement logique ? <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
On met en général un peu de temps avant de "penser objet" correctement. Si vous vous dites que vous n'auriez pas pu inventer un truc comme ça tout seul, rassurez-vous, tous les débutants passent par là. A force de pratiquer, ça va venir <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Pour info, toutes les méthodes que l'on pourrait créer ne sont pas là : par exemple, on n'utilise pas de magie (mana) ici. Le personnage attaque seulement avec une arme (une épée par exemple) et n'utilise donc pas de sorts magiques. Je laisse exprès quelques fonctions manquantes pour vous inciter à compléter la classe avec vos idées <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<strong>En résumé</strong> : comme je vous l'avais dit, un objet est bel et bien un mix de "variables" (les attributs) et de "fonctions" (les méthodes). La plupart du temps, les méthodes lisent et modifient les attributs de l'objet pour le faire évoluer.<br>
Un objet est au final un petit système intelligent et autonome qui est capable de surveiller son bon fonctionnement tout seul.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11165">Droits d'accès et encapsulation</h2>
		<div class="ss_part_texte">
		Nous allons maintenant nous intéresser au concept le plus <span class="souligne">fondamental</span> de la POO : <strong>l'encapsulation</strong>. Ne vous laissez pas effrayer par ce mot, vous allez vite comprendre ce que ça signifie.<br>
<br>
Tout d'abord un petit rappel. En POO, il y a 2 parties bien distinctes :<br>
<br>
<ul>
<li>On <strong><span class="rouge">crée </span></strong>des classes pour définir le fonctionnement des objets. C'est ce qu'on apprend à faire ici.</li>
<li>On <strong><span class="vertf">utilise </span></strong>des objets. C'est ce qu'on a appris à faire dans le chapitre précédent.</li>
</ul><br>
Il faut bien distinguer ces 2 parties, car ça devient ici très important.<br>
<br>
Je mets un exemple création / utilisation côte à côte pour que vous puissiez bien les différencier :<br>
<br>
<table class="tab_user">


<thead><tr><th><span class="rouge">Création de la classe</span></th><th><span class="vertf">Utilisation de l'objet</span></th></tr></thead><tbody><tr>
<td><span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbDegats</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">boirePotionDeVie</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantitePotion</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">changerArme</span><span class="p">(</span><span class="n">string</span> <span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsNouvelleArme</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">bool</span> <span class="n">estVivant</span><span class="p">()</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_mana</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">m_nomArme</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_degatsArme</span><span class="p">;</span>
 
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div></td>
<td><span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Personnage</span> <span class="n">david</span><span class="p">,</span> <span class="n">goliath</span><span class="p">;</span>
 
    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span>
    <span class="n">david</span><span class="p">.</span><span class="n">boirePotionDeVie</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span>
    <span class="n">david</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">goliath</span><span class="p">);</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">changerArme</span><span class="p">(</span><span class="s">"Double hache tranchante vénéneuse de la mort"</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span>
 
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div></td>
</tr></tbody></table><br>
<br>
Tenez, pourquoi on n'essaierait pas ce code ?<br>
Allez, on met tout dans un même fichier (en prenant soin de définir la classe <span class="italique">avant </span>le main), et zou !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
 
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="c">// Méthodes</span>
    <span class="kt">void</span> <span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbDegats</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">boirePotionDeVie</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantitePotion</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">changerArme</span><span class="p">(</span><span class="n">string</span> <span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsNouvelleArme</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">bool</span> <span class="n">estVivant</span><span class="p">()</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="c">// Attributs</span>
    <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_mana</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">m_nomArme</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_degatsArme</span><span class="p">;</span>
<span class="p">};</span>
 
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Personnage</span> <span class="n">david</span><span class="p">,</span> <span class="n">goliath</span><span class="p">;</span> <span class="c">// Création de 2 objets de type Personnage : david et goliath</span>
 
    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span> <span class="c">// goliath attaque david</span>
    <span class="n">david</span><span class="p">.</span><span class="n">boirePotionDeVie</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="c">// david boit une potion de vie qui lui rapporte 20 de vie</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span> <span class="c">// goliath réattaque david</span>
    <span class="n">david</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">goliath</span><span class="p">);</span> <span class="c">// david contre-attaque... c'est assez clair non ? ^^</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">changerArme</span><span class="p">(</span><span class="s">"Double hache tranchante vénéneuse de la mort"</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span>
 
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Compilez et admirez... la belle erreur de compilation ?! <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"><br>
<br>
<span class="rouge"><span class="courrier">Error : void Personnage::attaquer(Personnage&amp;) is private within this context</span></span><br>
<br>
Une nouvelle insulte ?<br>
Vous allez voir, le compilateur ne manque pas d'insultes en C++, vous allez sûrement en rencontrer pas mal <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<br>
<h3>Les droits d'accès</h3><br>
<br>
On en arrive justement au problème qui nous intéresse : celui des droits d'accès (eh ouais j'ai fait exprès de provoquer cette erreur de compilation, vous aviez quand même pas cru que j'avais pas tout prévu ? <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).<br>
<br>
Ouvrez grand vos oreilles : chaque attribut et chaque méthode d'une classe peut posséder son propre droit d'accès. Il existe grosso modo 2 droits d'accès différents :<br>
<br>
<ul>
<li><strong>public </strong>: l'attribut ou la méthode peut être appelé depuis l'extérieur de l'objet.</li>
<li><strong>private </strong>: l'attribut ou la méthode ne peut pas être appelé depuis l'extérieur de l'objet. <span class="souligne">Par défaut, tous les éléments d'un objet sont private</span>.</li>
</ul><br>
<div class="rmq information">Il existe d'autres droits d'accès mais ils sont un peu plus complexes. Nous les verrons plus tard.</div><br>
<br>
Concrètement, qu'est-ce que ça signifie ? Qu'est-ce que "l'extérieur" de l'objet ?<br>
Eh bien sur notre exemple, "l'extérieur" c'est le main. En effet, c'est là où on utilise l'objet. On fait appel à des méthodes, mais comme elles sont privées par défaut, on ne peut pas les appeler depuis le main !<br>
<br>
Pour modifier les droits d'accès et mettre par exemple public, il faut taper <span class="courrier">public</span> suivi du symbole <span class="rouge"><span class="courrier">:</span></span> (deux points). Tout ce qui se trouvera à la suite sera public.<br>
<br>
Voici ce que je vous propose de faire : on va mettre en public toutes les méthodes, et en privé tous les attributs.<br>
Ca donne ça :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="c">// Tout ce qui suit est public (accessible depuis l'extérieur)</span>
    <span class="k">public</span><span class="o">:</span>
    
    <span class="kt">void</span> <span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbDegats</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">boirePotionDeVie</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantitePotion</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">void</span> <span class="n">changerArme</span><span class="p">(</span><span class="n">string</span> <span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsNouvelleArme</span><span class="p">)</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="kt">bool</span> <span class="n">estVivant</span><span class="p">()</span>
    <span class="p">{</span>
 
    <span class="p">}</span>
 
    <span class="c">// Tout ce qui suit est privé (inaccessible depuis l'extérieur)</span>
    <span class="k">private</span><span class="o">:</span>
    
    <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_mana</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">m_nomArme</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_degatsArme</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Tout ce qui suit le <span class="courrier">public:</span> est public. Donc toutes nos méthodes sont publiques.<br>
Ensuite vient le mot-clé <span class="courrier">private:</span>. Tout ce qui suit ce mot-clé est privé.  Donc tous nos attributs sont privés.<br>
<br>
Voilà, vous pouvez maintenant compiler ce code, et vous verrez qu'il n'y a pas de problème (même si le code ne fait rien pour l'instant <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ). On appelle des méthodes depuis le main, mais comme elles sont publiques, on a le droit de le faire.<br>
... par contre, nos attributs sont privés, ce qui veut dire qu'on n'a pas le droit de les modifier depuis le main. En clair, <span class="souligne">on ne peut pas faire</span> depuis le main :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">goliath</span><span class="p">.</span><span class="n">m_vie</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Essayez,  vous verrez que le compilateur vous ressort la même erreur que tout à l'heure : "ton bidule est private... bla bla bla... pas le droit d'appeler un élément private depuis l'extérieur de la classe".<br>
<br>
Mais alors... ça veut dire qu'on ne peut pas modifier la vie du personnage depuis le main ? Eh oui !<br>
C'est nul ? Non au contraire, c'est très bien pensé, ça s'appelle l'encapsulation <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>L'encapsulation</h3><br>
<br>
<div class="rmq question">Moi j'ai une solution ! Si on mettait tout en public ? Les méthodes ET les attributs en public, comme ça on peut tout modifier depuis le main et plus aucun problème !<br>
... quoi j'ai dit une connerie ? <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> </div><br>
Oh, trois fois rien, vous venez juste de vous faire autant d'ennemis qu'il n'y a de programmeurs qui font de la POO dans le monde <img src="./cpp_files/rire.gif" alt=":lol:" class="smilies"><br>
<br>
Il y a une règle d'or en POO, et <span class="italique">tout </span>découle de là. S'il vous plaît, imprimez ceci en gros sur une feuille, et placardez cette feuille sur un mur de votre chambre :<br>
<br>
<div class="centre"><span class="ttgros"><span class="rouge"><span class="arial"><strong><span class="souligne">Encapsulation</span> : tous les attributs d'une classe<br>
doivent toujours être privés</strong></span></span></span></div><br>
<br>
Ca a l'air bête, stupide, irréfléchi, et pourtant tout ce qui fait que la POO est un principe puissant vient de là.<br>
En clair, si j'en vois un à partir de maintenant qui me met ne serait-ce qu'un seul attribut en public, je le brûle, je le torture, je l'écorche vif sur la place publique, compris ? <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> <br>
Et vous, si vous voyez quelqu'un d'autre faire ça un jour, écorchez-le vif en pensant à moi, vous serez sympa <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
Voilà qui explique pourquoi j'ai fait exprès dès le début de mettre les attributs en privé. Comme ça, on ne peut pas les modifier depuis l'extérieur de la classe, et ça respecte le principe d'encapsulation.<br>
<br>
Vous vous souvenez de ce schéma du chapitre précédent ?<br>
<br>
<div class="centre"><img src="./cpp_files/50705.jpg" alt="Image utilisateur"></div><br>
<br>
Les fioles chimiques, ce sont les <strong>attributs</strong>.<br>
Les boutons sur la façade avant, ce sont les <strong>méthodes</strong>.<br>
<br>
Et là, pif paf pouf, vous devriez avoir tout compris d'un coup. En effet, le but du modèle objet c'est justement de masquer les informations complexes à l'utilisateur (les attributs) pour éviter qu'il ne fasse des bêtises avec.<br>
<br>
Imaginez par exemple que l'utilisateur puisse modifier la vie... qu'est-ce qui l'empêcherait de mettre 150 de vie alors que la limite maximale est 100 ? C'est pour ça qu'il faut <span class="souligne">toujours</span> passer par des méthodes (des fonctions) qui vont <span class="italique">d'abord</span> vérifier qu'on fait les choses correctement avant de modifier les attributs.<br>
Cela permet de faire en sorte que le contenu de l'objet reste une "boîte noire". On ne sait pas comment ça fonctionne à l'intérieur quand on l'utilise, et c'est très bien. C'est une sécurité, ça permet d'éviter de faire péter tout le bazar de fioles chimiques à l'intérieur <img src="./cpp_files/siffle.png" alt=":-°" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11164">Séparer prototypes et définitions</h2>
		<div class="ss_part_texte">
		Bon, on avance mais on n'a pas fini <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Voici ce que je voudrais qu'on fasse :<br>
<br>
<ul>
<li>Séparer les méthodes en prototypes et définitions dans 2 fichiers différents pour avoir un code plus modulaire</li>
<li>Implémenter les méthodes de notre classe Personnage (c'est-à-dire écrire le code à l'intérieur parce que pour le moment y'a rien <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> )</li>
</ul><br>
<br>
Pour le moment, on a mis notre classe dans le fichier main.cpp, juste au-dessus du main. Et les méthodes sont directement écrites dans la définition de la classe.<br>
Ca fonctionne, mais c'est un peu bourrin. Tout comme on avait appris en C à faire du code modulaire, on va voir comment on procède en POO pour séparer tout ça proprement dans des fichiers différents.<br>
<br>
Tout d'abord, il faut clairement séparer le main (qui se trouve dans main.cpp) des classes.<br>
Pour <span class="italique">chaque </span>classe, on va créer :<br>
<br>
<ul>
<li>Un header (*.h) qui contiendra les attributs et les prototypes de la classe</li>
<li>Un fichier source (*.cpp) qui contiendra la définition des méthodes et leurs implémentations</li>
</ul><br>
Je vous propose d'ajouter à votre projet 2 fichiers nommés très exactement :<br>
<br>
<ul>
<li>Personnage.h</li>
<li>Personnage.cpp</li>
</ul><br>
(vous noterez que je mets aussi une majuscule à la première lettre du nom de fichier, histoire d'être cohérent jusqu'au bout)<br>
<br>
Vous devriez être capables de faire ça tous seuls avec votre IDE favori. Sous Code::Blocks, je fais File / New File, je rentre par exemple le nom "Personnage.h" avec l'extension, et je réponds "Oui" quand Code::Blocks me demande si je veux ajouter le nouveau fichier au projet en cours :<br>
<br>
<div class="centre"><img src="./cpp_files/55370.png" alt="Ajouter un fichier au projet"></div><br>
<br>
<h3>Personnage.h</h3><br>
<br>
Le fichier .h va donc contenir la déclaration de la classe avec les attributs et les prototypes des méthodes. Dans notre cas, pour la classe Personnage, ça va donner ça :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef DEF_PERSONNAGE</span>
<span class="cp">#define DEF_PERSONNAGE</span>

<span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>

    <span class="kt">void</span> <span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbDegats</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">boirePotionDeVie</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantitePotion</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">changerArme</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsNouvelleArme</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">estVivant</span><span class="p">();</span>


    <span class="k">private</span><span class="o">:</span>

    <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_mana</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_nomArme</span><span class="p">;</span> <span class="c1">// Pas de using namespace std, donc il faut mettre std:: devant string.</span>
    <span class="kt">int</span> <span class="n">m_degatsArme</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Comme vous pouvez le constater, seuls les prototypes des méthodes sont présents dans le .h. C'est déjà beaucoup plus clair <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="rmq information">Dans les .h, il est recommandé de ne jamais mettre la directive <span class="courrier">using namespace std;</span> car cela pourrait avoir des effets néfastes lorsque vous utiliserez la classe par la suite.<br>
Par conséquent, il faut rajouter le préfixe "std::" devant chaque string du .h. Sinon, le compilateur vous sortira une erreur du type "<span class="courrier">string does not name a type</span>".</div><br>
<br>
<h3>Personnage.cpp</h3><br>
<br>
C'est là qu'on va écrire le code de nos méthodes (on dit qu'on <strong>implémente </strong>les méthodes).<br>
Première chose à ne pas oublier, sinon ça va pas bien se passer, c'est d'inclure &lt;string&gt; et "Personnage.h".<br>
On peut aussi rajouter ici un <span class="courrier">using namespace std;</span>. On a le droit de le faire car on est dans le .cpp (par contre comme je vous l'ai expliqué plus tôt, il faut éviter de le mettre dans le .h).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include "Personnage.h"</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq erreur">Veillez à inclure &lt;string&gt; AVANT Personnage.h, sinon la déclaration de la classe contenue dans Personnage.h n'aura pas connu au préalable le type string... et donc la compilation plantera.</div><br>
<br>
Maintenant, voilà comment ça se passe : pour chaque méthode, vous devez faire précéder le nom de la méthode par le nom de la classe suivi de deux fois deux points "<span class="rouge">::</span>". Pour recevoirDegats ça donne ça :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbDegats</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cela permet au compilateur de savoir que cette méthode se rapporte à la classe Personnage. En effet, comme la méthode est ici écrite en dehors de la définition de la classe, le compilateur n'aurait pas su à quelle classe appartenait cette méthode.<br>
<br>
<br>
<h4>Personnage::recevoirDegats</h4><br>
<br>
Maintenant, c'est parti, implémentons la méthode recevoirDegats. Je vous avais expliqué un peu plus haut ce qu'il fallait faire. Vous allez voir, c'est très simple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbDegats</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_vie</span> <span class="o">-=</span> <span class="n">nbDegats</span><span class="p">;</span> <span class="c1">// On enlève le nombre de dégâts reçus à la vie du personnage</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">m_vie</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Pour éviter d'avoir une vie négative</span>
    <span class="p">{</span>
        <span class="n">m_vie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// On met la vie à 0 (ça veut dire mort)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La méthode modifie donc la valeur de la vie. <span class="souligne">La méthode a le droit de modifier l'attribut</span>, car elle fait partie de la classe. Ne soyez donc pas surpris, c'est justement l'endroit où on a le droit de toucher aux attributs <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
La vie est diminuée du nombre de dégâts reçus. En théorie, on aurait pu se contenter de la première instruction, mais on fait une vérification supplémentaire. Si la vie est descendue en-dessous de 0 (parce qu'on a reçu 20 de dégâts alors qu'on n'avait que 10 de vie), on ramène la vie à 0 afin d'éviter d'avoir une vie négative (ça fait pas très pro une vie négative <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ). De toute façon, à 0 de vie, le personnage est considéré comme mort <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Et voilà pour la première méthode ! Allez on enchaîne hop hop hop !<br>
<br>
<br>
<h4>Personnage::attaquer</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cible</span><span class="p">.</span><span class="n">recevoirDegats</span><span class="p">(</span><span class="n">m_degatsArme</span><span class="p">);</span> <span class="c1">// On inflige à la cible les dégâts que causent notre arme</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cette méthode est peut-être très courante, elle n'en est pas moins très intéressante !<br>
On reçoit en paramètre une référence vers un objet de type Personnage. On aurait pu recevoir un pointeur aussi, mais comme les références sont plus faciles à manipuler (cf les chapitres précédents) on ne va pas s'en priver.<br>
<br>
La référence concerne le personnage cible que l'on doit attaquer. Pour infliger des dégâts à la cible, on appelle sa méthode recevoirDegats en faisant : <span class="courrier">cible.recevoirDegats</span><br>
<br>
Quelle quantité de dégâts envoyer à la cible ? Vous avez la réponse sous vos yeux : le nombre de points de dégâts indiqués par l'attribut <span class="courrier">m_degatsArme</span> ! On envoie donc la valeur des m_degatsArme de notre personnage à la cible.<br>
<br>
<h4>Personnage::boirePotionDeVie</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">boirePotionDeVie</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantitePotion</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_vie</span> <span class="o">+=</span> <span class="n">quantitePotion</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m_vie</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">// Interdiction de dépasser 100 de vie</span>
    <span class="p">{</span>
        <span class="n">m_vie</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le personnage reprend autant de vie que ce que la potion qu'il boit lui permet d'en récupérer. On vérifie au passage qu'il ne dépasse pas les 100 de vie, car comme on l'a dit plus tôt, il est interdit d'avoir plus de 100 de vie.<br>
<br>
<br>
<h4>Personnage::changerArme</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">changerArme</span><span class="p">(</span><span class="n">string</span> <span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsNouvelleArme</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_nomArme</span> <span class="o">=</span> <span class="n">nomNouvelleArme</span><span class="p">;</span>
    <span class="n">m_degatsArme</span> <span class="o">=</span> <span class="n">degatsNouvelleArme</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Pour changer d'arme, on stocke dans nos attributs le nom de la nouvelle arme ainsi que ses nouveaux dégâts. Les instructions sont très simples : on fait juste passer ce qu'on a reçu en paramètres dans nos attributs.<br>
Grâce à l'objet string d'ailleurs, il suffit de faire un simple "=" pour affecter la chaîne, et on n'a plus à se préoccuper de la taille du tableau car l'objet string se débrouille tout seul pour ça (à chaque fois que j'y pense je trouve ça génial <img src="./cpp_files/hihi.png" alt="^^" class="smilies"> ).<br>
<br>
<br>
<h4>Personnage::estVivant</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">bool</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">estVivant</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_vie</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Plus de 0 de vie ?</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// VRAI, il est vivant !</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// FAUX, il n'est plus vivant !</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cette méthode permet de vérifier si le personnage est toujours vivant. Elle renvoie vrai (true) s'il a plus de 0 de vie, et faux (false) sinon.<br>
<br>
<br>
<h4>Code complet de Personnage.cpp</h4><br>
<br>
En résumé, le code complet de notre Personnage.cpp est le suivant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include "Personnage.h"</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbDegats</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_vie</span> <span class="o">-=</span> <span class="n">nbDegats</span><span class="p">;</span> <span class="c1">// On enlève le nombre de dégâts reçus à la vie du personnage</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m_vie</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Pour éviter d'avoir une vie négative</span>
    <span class="p">{</span>
        <span class="n">m_vie</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// On met la vie à 0 (ça veut dire mort)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cible</span><span class="p">.</span><span class="n">recevoirDegats</span><span class="p">(</span><span class="n">m_degatsArme</span><span class="p">);</span> <span class="c1">// On inflige à la cible les dégâts que causent notre arme</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">boirePotionDeVie</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantitePotion</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_vie</span> <span class="o">+=</span> <span class="n">quantitePotion</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m_vie</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">// Interdiction de dépasser 100 de vie</span>
    <span class="p">{</span>
        <span class="n">m_vie</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">changerArme</span><span class="p">(</span><span class="n">string</span> <span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsNouvelleArme</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_nomArme</span> <span class="o">=</span> <span class="n">nomNouvelleArme</span><span class="p">;</span>
    <span class="n">m_degatsArme</span> <span class="o">=</span> <span class="n">degatsNouvelleArme</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">estVivant</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_vie</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Plus de 0 de vie ?</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// VRAI, il est vivant !</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// FAUX, il n'est plus vivant !</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
<h3>main.cpp</h3><br>
<br>
Retour au main. Première chose à ne pas oublier : inclure Personnage.h pour pouvoir créer des objets de type Personnage.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "Personnage.h" </span><span class="c1">// Ne pas oublier</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Après, le main reste le même que tout à l'heure, on n'a pas besoin de le changer. Au final, le code du main est donc très court, et le fichier main.cpp ne fait qu'<strong><span class="vertf">utiliser </span></strong>les objets :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include "Personnage.h" </span><span class="c1">// Ne pas oublier</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Personnage</span> <span class="n">david</span><span class="p">,</span> <span class="n">goliath</span><span class="p">;</span> <span class="c1">// Création de 2 objets de type Personnage : david et goliath</span>

    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span> <span class="c1">// goliath attaque david</span>
    <span class="n">david</span><span class="p">.</span><span class="n">boirePotionDeVie</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// david boit une potion de vie qui lui rapporte 20 de vie</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span> <span class="c1">// goliath réattaque david</span>
    <span class="n">david</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">goliath</span><span class="p">);</span> <span class="c1">// david contre-attaque... c'est assez clair non ? ^^</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">changerArme</span><span class="p">(</span><span class="s">"Double hache tranchante vénéneuse de la mort"</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq erreur"><strong>N'exécutez pas le programme pour le moment</strong>. En effet, nous n'avons toujours pas vu comment faire pour initialiser les attributs, ce qui fait que notre programme n'est pas encore utilisable.<br>
Nous verrons comment le rendre pleinement fonctionnel dans le chapitre suivant, et vous pourrez alors (enfin) l'exécuter <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
Il faudra donc pour le moment vous contenter de votre imagination. Essayez d'imaginer que David et Goliath sont bien en train de combattre ! (et je veux pas faire mon gros spoiler, mais normalement c'est David qui gagne à la fin <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Là, on peut dire qu'on est rentré en plein dans la POO <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Pourtant, ce n'est encore qu'un début ! De nombreuses nouvelles choses complètement dingues vous attendent dans les chapitres qui suivent (et elles vont vous rendre dingues ça c'est sûr <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> )<br>
<br>
Un conseil si je puis me permettre : assurez-vous d'avoir bien compris qu'il y avait deux faces dans la POO, la création de la classe, et l'utilisation des objets. Il faut être à l'aise avec ce concept.<br>
Mais tout n'est pas si simple. Comme vous le verrez, ce que font les objets la plupart du temps c'est... utiliser d'autres objets ! Et c'est en combinant plusieurs objets entre eux que l'on découvrira le vrai pouvoir de la POO <img src="./cpp_files/clin.png" alt=";)" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11177">Les classes (Partie 2/2)</h1>
	<div id="chap_intro">
	Allez, hop hop hop, on enchaîne ! Pas question de s'endormir, on est en plein dans la POO là <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Dans le chapitre précédent, nous avons appris à créer une classe basique, à rendre le code modulaire en POO, et surtout nous avons découvert le principe d'encapsulation (suuuper important l'encapsulation, c'est la base de tout je le rappelle).<br>
<br>
Dans cette seconde partie du chapitre, nous allons découvrir comment initialiser nos attributs à l'aide d'un constructeur, un élément indispensable à toute classe qui se respecte. Puisqu'on parlera de constructeur, on parlera aussi de destructeur, ça va de paire vous verrez.<br>
Nous complèterons notre classe Personnage et nous l'associerons avec une nouvelle classe Arme que nous allons créer. Nous découvrirons alors tout le pouvoir qu'il y a de combiner des classes entre elles, et vous devriez normalement commencer à imaginer pas mal de possibilités à partir de là <img src="./cpp_files/clin.png" alt=";)" class="smilies">
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11176">Constructeur et destructeur</h2>
		<div class="ss_part_texte">
		Reprenons. Nous avons maintenant 3 fichiers :<br>
<br>
<ul>
<li><strong>main.cpp</strong> : il contient le main, dans lequel on a créé 2 objets de type Personnage : david et goliath.</li>
<li><strong>Personnage.h</strong> : c'est le header de la classe Personnage. On y liste les prototypes des méthodes et les attributs. On y définit la portée (public / private) de chacun des éléments. Pour respecter le principe d'encapsulation, tous nos attributs sont privés, c'est-à-dire non accessibles de l'extérieur.</li>
<li><strong>Personnage.cpp</strong> : c'est le fichier dans lequel on implémente nos méthodes, c'est-à-dire qu'on écrit le code source des méthodes.</li>
</ul><br>
Pour l'instant, nous avons défini et implémenté pas mal de méthodes. Je voudrais vous parler ici de 2 méthodes particulières que l'on retrouve dans la plupart des classes : le constructeur et le destructeur.<br>
<br>
<ul>
<li><strong>Le constructeur</strong> : c'est une méthode qui est appelée automatiquement à chaque fois que l'on crée un objet basé sur cette classe.</li>
<li><strong>Le destructeur</strong> : c'est une méthode qui est automatiquement appelée lorsqu'un objet est détruit, par exemple à la fin de la fonction dans laquelle il a été déclaré ou lors d'un delete si l'objet a été alloué dynamiquement avec new.</li>
</ul><br>
Voyons voir plus en détail comment fonctionnent ces méthodes un peu particulières...<br>
<br>
<br>
<h3>Le constructeur</h3><br>
<br>
Comme son nom l'indique, c'est une méthode qui sert à <span class="italique">construire </span>l'objet. Dès qu'on crée un objet, le constructeur est automatiquement appelé s'il existe.<br>
<br>
Par exemple, lorsqu'on fait dans notre main :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span> <span class="n">david</span><span class="p">,</span> <span class="n">goliath</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
S'il existe, le constructeur de l'objet david est appelé, et de même pour le constructeur de l'objet goliath.<br>
Mais... comme nous n'avons pas encore défini de constructeur dans la classe Personnage, rien de particulier ne s'est passé. <span class="souligne">Le constructeur n'est pas obligatoire</span>, mais on a presque toujours besoin d'en créer un, vous allez vite comprendre pourquoi.<br>
<br>
<br>
<h4>Le rôle du constructeur</h4><br>
<br>
Si le constructeur est appelé lors de la création de l'objet, ce n'est pas pour faire joli. En fait, le rôle principal du constructeur est d'<span class="italique">initialiser</span> les attributs.<br>
En effet, souvenez-vous : nos attributs sont déclarés dans Personnage.h, mais pas initialisés !<br>
<br>
Revoici Personnage.h :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;string&gt;</span>
 
<span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
 
    <span class="kt">void</span> <span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbDegats</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">boirePotionDeVie</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantitePotion</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">changerArme</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsNouvelleArme</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">estVivant</span><span class="p">();</span>
 
 
    <span class="k">private</span><span class="o">:</span>
 
    <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_mana</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_nomArme</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_degatsArme</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Nos attributs m_vie, m_mana, et m_degatsArmes ne sont pas initialisés ! Pourquoi ? Parce qu'on n'a pas le droit d'initialiser les attributs ici. C'est justement dans le constructeur qu'il faut le faire.<br>
<br>
<div class="rmq information">En fait, le constructeur est indispensable pour initialiser les attributs qui ne sont pas des objets (type classique : int, double, char...). En effet, ceux-ci ont une valeur inconnue en mémoire (ça peut être 0 comme -3451).<br>
En revanche, les attributs qui sont des objets, comme c'est le cas de m_nomArme ici qui est un string, sont automatiquement initialisés par le langage C++ avec une valeur par défaut.</div><br>
<br>
<h4>Créer un constructeur</h4><br>
<br>
<span class="souligne">Le constructeur est une méthode</span>, mais une méthode un peu particulière.<br>
En effet, pour créer un constructeur, il y a 2 règles à respecter :<br>
<br>
<ul>
<li>Il faut que la méthode ait le même nom que la classe. Dans notre cas, la méthode devra s'appeler "Personnage".</li>
<li>La méthode ne doit RIEN renvoyer, pas même void ! C'est une méthode sans aucun type de retour.</li>
</ul><br>
<br>
Si on déclare son prototype dans Personnage.h, ça donne ça :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;string&gt;</span>
 
<span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
 
    <span class="n">Personnage</span><span class="p">();</span> <span class="c1">// Constructeur</span>
    <span class="kt">void</span> <span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbDegats</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">boirePotionDeVie</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantitePotion</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">changerArme</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsNouvelleArme</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">estVivant</span><span class="p">();</span>
 
 
    <span class="k">private</span><span class="o">:</span>
 
    <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_mana</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_nomArme</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_degatsArme</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le constructeur se voit du premier coup d'oeil : déjà parce qu'il n'a aucun type de retour (pas de void ni rien), et ensuite parce qu'il a le même nom que la classe <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Et si on en profitait pour implémenter ce constructeur dans Personnage.cpp maintenant ? <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Voici à quoi pourrait ressembler son implémentation :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_vie</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">m_mana</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">m_nomArme</span> <span class="o">=</span> <span class="s">"Epée rouillée"</span><span class="p">;</span>
    <span class="n">m_degatsArme</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous noterez une fois de plus qu'il n'y a pas de type de retour, pas même void (très important, c'est une erreur que l'on fait souvent <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ).<br>
J'ai choisi de mettre la vie et la mana à 100, le maximum, ce qui est logique. J'ai mis par défaut une arme appelée "Epée rouillée" qui fait 10 de dégâts à chaque coup.<br>
<br>
Et voilà ! Notre classe Personnage a un constructeur qui initialise les attributs, elle est désormais pleinement utilisable <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Maintenant, à chaque fois que l'on crée un objet de type Personnage, celui-ci est initialisé à 100 points de vie et de mana, avec l'arme "Epée rouillée". Nos deux compères david et goliath commencent donc à égalité lorsqu'ils sont créés dans le main :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span> <span class="n">david</span><span class="p">,</span> <span class="n">goliath</span><span class="p">;</span> <span class="c1">// Les constructeurs de david et goliath sont appelés.</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Autre façon d'initialiser avec un constructeur : la liste d'initialisation</h4><br>
<br>
Le C++ permet d'initialiser les attributs de la classe d'une autre manière (un peu déroutante) appelée <strong>liste d'initialisation</strong>.<br>
Reprenons le constructeur qu'on vient de créer :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_vie</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">m_mana</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">m_nomArme</span> <span class="o">=</span> <span class="s">"Epée rouillée"</span><span class="p">;</span>
    <span class="n">m_degatsArme</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le code que vous allez voir ci-dessous produit le même effet :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_vie</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_mana</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_nomArme</span><span class="p">(</span><span class="s">"Epée rouillée"</span><span class="p">),</span> <span class="n">m_degatsArme</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Rien à mettre dans le corps du constructeur, tout a déjà été fait !</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La nouveauté, c'est qu'on rajoute un symbole deux-points (<span class="rouge">:</span>) suivi de la liste des attributs que l'on veut initialiser avec la valeur entre parenthèses. Avec ce code, on initialise la vie à 100, la mana à 100, l'attribut m_nomArme à "Epée rouillée", etc.<br>
<br>
Cette technique est un peu surprenante, surtout que du coup on n'a plus rien à mettre dans le corps du constructeur entre les accolades, vu que tout a déjà été fait avant ! Elle a toutefois l'avantage d'être "plus propre" et se révèlera pratique dans la suite du chapitre.<br>
On va donc utiliser autant que possible les listes d'initialisation avec les constructeurs, c'est une bonne habitude à prendre.<br>
<br>
<div class="rmq information">Le prototype du constructeur (dans le .h) ne change pas. Toute la partie après les deux-points n'apparaît pas dans le prototype.</div><br>
<br>
<br>
<h4>Surcharger le constructeur</h4><br>
<br>
Vous savez qu'en C++ on a le droit de surcharger les fonctions, donc de surcharger les méthodes. Et comme le constructeur est une méthode, on a le droit de le surcharger lui aussi.<br>
Pourquoi je vous en parle ? Ce n'est pas par hasard : en fait, le constructeur est une méthode que l'on a tendance à beaucoup surcharger. Cela permet de créer un objet de plusieurs façons différentes.<br>
<br>
Pour l'instant, on a créé un constructeur sans paramètres :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On appelle ça : <strong>le constructeur par défaut</strong> (il fallait bien lui donner un nom le pauvre <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ).<br>
<br>
<br>
Supposons que l'on souhaite créer un personnage qui ait dès le départ une meilleure arme... comment diable faire ?<br>
C'est là que la surcharge devient utile. On va créer un 2ème constructeur qui prendra en paramètre le nom de l'arme et ses dégâts.<br>
<br>
Dans Personnage.h, on va donc rajouter ce prototype :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nomArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsArme</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Le préfixe std:: est obligatoire ici comme je vous l'ai dit plus tôt car on n'utilise pas la directive <span class="courrier">using namespace std;</span> dans le .h (cf chapitre précédent).</div><br>
<br>
L'implémentation dans Personnage.cpp sera la suivante :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">(</span><span class="n">string</span> <span class="n">nomArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsArme</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_vie</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_mana</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_nomArme</span><span class="p">(</span><span class="n">nomArme</span><span class="p">),</span> <span class="n">m_degatsArme</span><span class="p">(</span><span class="n">degatsArme</span><span class="p">)</span>
<span class="p">{</span>
 
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous noterez ici tout l'intérêt de mettre le préfixe <span class="rouge">m_</span> au début des attributs : comme ça on peut faire la différence dans notre code entre <span class="italique">m_nomArme</span>, qui est un attribut, et <span class="italique">nomArme</span>, qui est le paramètre envoyé au constructeur.<br>
Ce qu'on fait ici, c'est juste placer dans l'attribut de l'objet le nom de l'arme envoyé en paramètre. On recopie juste la valeur. C'est tout bête, mais il faut le faire, sinon l'objet ne se "souviendra pas" du nom de l'arme qu'il possède.<br>
<br>
La vie et la mana, eux, sont toujours fixés à 100 (il faut bien les initialiser), mais l'arme, elle, peut maintenant être indiquée par l'utilisateur lorsqu'il crée l'objet.<br>
<br>
<div class="rmq question">Quel utilisateur ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"></div><br>
<br>
Souvenez-vous, l'utilisateur c'est celui qui crée et utilise les objets. Le concepteur c'est celui qui crée les classes.<br>
Dans notre cas, la création des objets est faite dans le main. Pour le moment, la création de nos objets ressemble à ça :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span> <span class="n">david</span><span class="p">,</span> <span class="n">goliath</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Comme on n'a spécifié aucun paramètre, c'est le constructeur par défaut (celui sans paramètres) qui sera appelé.<br>
Maintenant supposons que l'on veuille donner dès le départ une meilleure arme à Goliath (c'est lui le plus fort après tout <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ). On va indiquer entre parenthèses le nom et la puissance de cette arme :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span> <span class="n">david</span><span class="p">,</span> <span class="n">goliath</span><span class="p">(</span><span class="s">"Epée aiguisée"</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Goliath est équipé de l'épée aiguisée dès sa création. David est équipé de l'arme par défaut, l'épée rouillée.<br>
Comme on n'a spécifié aucun paramètre lors de la création de david, c'est le constructeur par défaut qui sera appelé pour lui. Pour goliath, comme on a spécifié des paramètres, c'est le constructeur correspondant à la signature (string, int) qui sera appelé.<br>
<br>
<div class="rmq information">Si vous avez oublié ce qu'est une signature de fonction (ou de méthode, c'est pareil), je vous invite très fortement à relire <a href="http://www.siteduzero.com/tuto-3-13047-1-nouveautes-pour-les-fonctions.html#ss_part_2">ce passage du cours</a>, que vous avez normalement dû lire quelques chapitres plus tôt <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"></div><br>
<br>
<strong>Exercice</strong> : on aurait aussi pu permettre à l'utilisateur de modifier la vie et la mana de départ, mais je ne l'ai pas fait ici. Ce n'est pas compliqué, vous pouvez le faire pour vous entraîner. Ca vous fera un troisième constructeur surchargé <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Le destructeur</h3><br>
<br>
Le destructeur est une méthode appelée lorsque l'objet est supprimé de la mémoire. Son principal rôle est de désallouer la mémoire (via des delete) qui a été allouée dynamiquement.<br>
<br>
Dans le cas de notre classe Personnage, on n'a fait aucune allocation dynamique (il n'y a aucun new). Le destructeur est donc inutile. Cependant, vous en aurez certainement besoin un jour où l'autre, car on est souvent amené à faire des allocations dynamiques. <br>
Tenez, l'objet string par exemple, vous croyez qu'il fonctionne comment ? Il a un destructeur qui lui permet, juste avant la destruction de l'objet, de supprimer le tableau de char qu'il a alloué dynamiquement en mémoire. Il fait donc un delete sur le tableau de char, ce qui permet de garder une mémoire propre et d'éviter les fameuses "fuites de mémoire" <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
<br>
<h4>Créer un destructeur</h4><br>
<br>
Bien que ce soit inutile dans notre cas (je n'ai pas mis d'allocations dynamiques pour ne pas trop compliquer de suite <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ), je vais vous montrer comment on crée un destructeur. Voici les règles à suivre :<br>
<br>
<ul>
<li>Un destructeur est une méthode qui commence par un tilde ~ suivi du nom de la classe</li>
<li>Un destructeur ne renvoie aucune valeur, pas même void (comme le constructeur)</li>
<li>Et, nouveauté : le destructeur ne peut prendre aucun paramètre. Il y a donc toujours un seul destructeur, il ne peut pas être surchargé.</li>
</ul><br>
<br>
Dans Personnage.h, le prototype du destructeur sera donc :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="o">~</span><span class="n">Personnage</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Dans Personnage.cpp, l'implémentation sera :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::~</span><span class="n">Personnage</span><span class="p">()</span>
<span class="p">{</span>
    <span class="cm">/* Rien à mettre ici car on ne fait pas d'allocation dynamique</span>
<span class="cm">    dans la classe Personnage. Le destructeur est donc inutile mais</span>
<span class="cm">    je le mets pour montrer à quoi ça ressemble ^^</span>
<span class="cm">    En temps normal, un destructeur fait souvent des delete et quelques</span>
<span class="cm">    autres vérifications si nécessaire avant la destruction de l'objet */</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Bon vous l'aurez compris, mon destructeur ne fait rien. C'était même pas la peine de le créer (il n'est pas obligatoire après tout).<br>
Cela vous montre néanmoins la procédure à suivre. Soyez rassurés, nous ferons des allocations dynamiques plus tôt que vous ne le pensez (je sais je suis diabolique <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> ), et nous aurons alors grand besoin du destructeur pour désallouer la mémoire !
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11175">Associer des classes entre elles</h2>
		<div class="ss_part_texte">
		La programmation orientée objet devient vraiment intéressante et puissante lorsqu'on se met à combiner plusieurs objets entre eux. Pour l'instant, nous n'avons créé qu'une seule classe : Personnage.<br>
Or en pratique, un programme objet est un programme constitué d'une multitude d'objets différents !<br>
<br>
Il n'y a pas de secret, c'est en pratiquant que l'on apprend petit à petit à penser objet.<br>
Ce que nous allons voir par la suite ne sera pas nouveau : vous allez réutiliser tout ce que vous savez déjà sur la création de classes, de manière à améliorer notre petit RPG et à vous entraîner encore plus à manipuler des objets <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>La classe Arme</h3><br>
<br>
Ce que je vous propose dans un premier temps, c'est de créer une nouvelle classe Arme. Plutôt que de mettre les informations de l'arme (m_nomArme, m_degatsArme) directement dans le Personnage, <strong>nous allons l'équiper d'un objet de type Arme</strong>. Le découpage de notre programme sera alors un peu plus dans la logique d'un programme orienté objet.<br>
<br>
<div class="rmq information">Souvenez-vous ce que je vous ai dit au début : il y a 100 façons différentes de concevoir un même programme en POO. Tout est dans l'organisation des classes entre elles, comment elles communiquent, etc.<br>
Ce que nous avons fait jusqu'ici était pas mal, mais je veux vous montrer ici qu'on peut faire <span class="italique">autrement</span>, un peu plus dans l'esprit objet, donc... mieux <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
Qui dit nouvelle classe dit 2 nouveaux fichiers :<br>
<br>
<ul>
<li>Arme.h : contient la définition de la classe</li>
<li>Arme.cpp : contient l'implémentation des méthodes de la classe</li>
</ul><br>
<div class="rmq information">On n'est pas obligé de procéder ainsi. On pourrait tout mettre dans un seul fichier. On pourrait même mettre plusieurs classes par fichier, rien ne l'interdit en C++. Cependant, pour des raisons d'organisation, je vous recommande de faire comme moi.</div><br>
<br>
<h4>Arme.h</h4><br>
<br>
Voici ce que je propose de mettre dans Arme.h :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef DEF_ARME</span>
<span class="cp">#define DEF_ARME</span>

<span class="cp">#include &lt;string&gt;</span>
 
<span class="k">class</span> <span class="nc">Arme</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
 
    <span class="n">Arme</span><span class="p">();</span>
    <span class="n">Arme</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nom</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degats</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">changer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nom</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degats</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">afficher</span><span class="p">();</span>
 
    <span class="k">private</span><span class="o">:</span>
 
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_nom</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_degats</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Mis à part les includes qu'il ne faut pas oublier, le reste de la classe est très simple.<br>
<br>
On met le nom de l'arme et ses dégâts dans des attributs, et comme ce sont des attributs, <span class="souligne">on vérifie qu'ils soient bien privés</span> (encapsulation). Vous remarquerez qu'au lieu de m_nomArme et m_degatsArme, j'ai choisi de nommer mes attributs m_nom et m_degats tout simplement. C'est plus logique en effet : vu qu'on est <span class="italique">déjà </span>dans l'Arme, ce n'est pas la peine de repréciser dans les attributs qu'il s'agit de l'arme, on le sait déjà, on est dedans <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Ensuite, on ajoute un ou deux constructeurs, une méthode pour changer d'arme à tout moment, et une autre allez, soyons fous <img src="./cpp_files/langue.png" alt=":p" class="smilies"> , pour afficher le contenu de l'arme.<br>
<br>
Reste à implémenter toutes ces méthodes dans Arme.cpp. Pfeuh, fastoche ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> <br>
<br>
<h4>Arme.cpp</h4><br>
<br>
Entraînez-vous à écrire Arme.cpp, c'est tout bête, les méthodes font maxi 2 lignes, bref c'est à la portée de tout le monde <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Voici mon Arme.cpp pour comparer :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include "Arme.h"</span>
 
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="n">Arme</span><span class="o">::</span><span class="n">Arme</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_nom</span><span class="p">(</span><span class="s">"Epée rouillée"</span><span class="p">),</span> <span class="n">m_degats</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">{</span>
 
<span class="p">}</span>
 
<span class="n">Arme</span><span class="o">::</span><span class="n">Arme</span><span class="p">(</span><span class="n">string</span> <span class="n">nom</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degats</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_nom</span><span class="p">(</span><span class="n">nom</span><span class="p">),</span> <span class="n">m_degats</span><span class="p">(</span><span class="n">degats</span><span class="p">)</span>
<span class="p">{</span>
 
<span class="p">}</span>
 
<span class="kt">void</span> <span class="n">Arme</span><span class="o">::</span><span class="n">changer</span><span class="p">(</span><span class="n">string</span> <span class="n">nom</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degats</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_nom</span> <span class="o">=</span> <span class="n">nom</span><span class="p">;</span>
    <span class="n">m_degats</span> <span class="o">=</span> <span class="n">degats</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="n">Arme</span><span class="o">::</span><span class="n">afficher</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Arme : "</span> <span class="o">&lt;&lt;</span> <span class="n">m_nom</span> <span class="o">&lt;&lt;</span> <span class="s">" (Dégâts : "</span> <span class="o">&lt;&lt;</span> <span class="n">m_degats</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Bon là je n'ai rien à ajouter vraiment, c'est beaucoup trop simple <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
N'oubliez quand même pas d'inclure "Arme.h" si vous voulez que ça marche <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<h4>Et ensuite ?</h4><br>
<br>
Bon, notre classe Arme est créée, c'est bon pour ça. Mais maintenant, il va falloir adapter la classe Personnage pour qu'elle utilise non pas m_nomArme et m_degatsArme, mais un objet de type Arme.<br>
Et là... c'est là que ça se complique <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<br>
<h3>Adapter la classe Personnage pour utiliser une Arme</h3><br>
<br>
La classe Personnage va subir quelques modifications pour utiliser la classe Arme. Restez attentifs, car utiliser un objet DANS un objet, c'est un peu particulier.<br>
<br>
<br>
<h4>Personnage.h</h4><br>
<br>
Zou, direction le .h. On commence par virer nos 2 attributs m_nomArme et m_degatsArme qui ne servent plus à rien.<br>
<br>
Les méthodes n'ont pas besoin d'être changées. En fait, il ne vaut mieux pas les changer. Pourquoi ? Parce que les méthodes sont déjà potentiellement utilisées par quelqu'un (par exemple dans notre main). Si on les renomme ou si on en supprime, notre programme ne fonctionnera plus.<br>
<br>
Ce n'est peut-être pas grave pour un si petit programme, mais dans le cas d'un gros programme si on supprime une méthode, c'est la cata assurée dans le reste du programme. Et je vous parle même pas de ceux qui écrivent des librairies C++ : si d'une version à l'autre des méthodes disparaissent, tous les programmes qui utilisent la librairie ne fonctionneront plus ! <img src="./cpp_files/waw.png" alt=":waw:" class="smilies"> <br>
<br>
Je vais peut-être vous surprendre en vous disant ça, mais c'est là tout l'intérêt de la programmation orientée objet, et plus particulièrement de l'<strong>encapsulation</strong>. On peut changer nos attributs comme on veut, vu qu'ils ne sont pas accessibles de l'extérieur, on ne prend pas le <span class="italique">risque</span> que quelqu'un les utilise déjà dans le programme.<br>
En revanche, pour les méthodes, faites plus attention. Vous pouvez ajouter de nouvelles méthodes, modifier l'implémentation des méthodes existantes, mais PAS en supprimer ou en renommer, sinon l'utilisateur risque d'avoir des problèmes.<br>
<br>
<br>
Cette petite réflexion sur l'encapsulation étant faite (vous en comprendrez tout le sens avec la pratique <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ), il va falloir ajouter un objet de type Arme à notre Personnage.<br>
<br>
<div class="rmq attention">Il faut penser à ajouter un include de "Arme.h" si on veut pouvoir utiliser un objet de type Arme.</div><br>
<br>
Voici mon nouveau Personnage.h :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef DEF_PERSONNAGE</span>
<span class="cp">#define DEF_PERSONNAGE</span>
<span class="cp"> </span>
<span class="cp">#include "Arme.h" </span><span class="c1">// Ne PAS oublier d'inclure Arme.h pour en avoir la définition</span>
 
<span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
 
    <span class="n">Personnage</span><span class="p">();</span>
    <span class="n">Personnage</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nomArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsArme</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Personnage</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">nbDegats</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">boirePotionDeVie</span><span class="p">(</span><span class="kt">int</span> <span class="n">quantitePotion</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">changerArme</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsNouvelleArme</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">estVivant</span><span class="p">();</span>
 
 
    <span class="k">private</span><span class="o">:</span>
 
    <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_mana</span><span class="p">;</span>
    <span class="n">Arme</span> <span class="n">m_arme</span><span class="p">;</span> <span class="c1">// Notre arme est "contenue" dans le Personnage</span>
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
<h4>Personnage.cpp</h4><br>
<br>
Nous n'avons besoin de changer que les méthodes qui utilisent l'arme pour les adapter.<br>
On commence par les constructeurs :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_vie</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_mana</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">{</span>
 
<span class="p">}</span>
 
<span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">(</span><span class="n">string</span> <span class="n">nomArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsArme</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_vie</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_mana</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_arme</span><span class="p">(</span><span class="n">nomArme</span><span class="p">,</span> <span class="n">degatsArme</span><span class="p">)</span>
<span class="p">{</span>
 
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notre objet m_arme est ici initialisé avec les valeurs reçues en paramètre par Personnage (nomArme, degatsArme). C'est là que la liste d'initialisation devient utile. En effet, on n'aurait pas pu initialiser m_arme sans une liste d'initialisation !<br>
<br>
Peut-être ne voyez-vous pas bien pourquoi. Conseil perso : ne vous prenez pas la tête à essayer de comprendre le pourquoi du comment ici, et contentez-vous de <span class="souligne">toujours utiliser les listes d'initialisation avec vos constructeurs</span>, ça vous évitera bien des problèmes.<br>
<br>
<br>
Revenons au code.<br>
Dans le premier constructeur, c'est le constructeur par défaut de la classe Arme qui est appelé, tandis que dans le second c'est celui ayant la signature (string, int) qui est appelé.<br>
<br>
<br>
<br>
La méthode recevoirDegats n'a pas besoin de changer.<br>
En revanche, la méthode attaquer est délicate. En effet, on ne peut pas faire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cible</span><span class="p">.</span><span class="n">recevoirDegats</span><span class="p">(</span><span class="n">m_arme</span><span class="p">.</span><span class="n">m_degats</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Pourquoi est-ce interdit ? Parce que m_degats est un attribut, et que comme tout bon attribut qui se respecte, il est <span class="italique">privé </span>! Diantre... On est en train d'utiliser la classe Arme au sein de la classe Personnage, et comme on est utilisateurs, on ne peut pas accéder aux éléments privés <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"><br>
<br>
<span class="italique">(La POO, ça peut parfois donner mal à la tête j'avais oublié de vous prévenir <img src="./cpp_files/langue.png" alt=":p" class="smilies"> )</span><br>
<br>
Bon, comment résoudre le problème ? Il n'y a pas 36 solutions. Ca va peut-être vous surprendre, mais on doit créer une méthode pour récupérer la valeur de cet attribut. Cette méthode est appelée accesseur et commence généralement par le préfixe get (<span class="italique">récupérer</span>, en anglais). Dans notre cas, notre méthode s'appellerait getDegats.<br>
<br>
On conseille généralement de rajouter le mot-clé const aux accesseurs.<br>
<br>
<div class="rmq question">Une méthode... constante ? Qu'est-ce que ça signifie ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"></div><br>
Une méthode constante est une méthode qui ne peut pas modifier les attributs de la classe. Cela garantit que la méthode ne fait que "lire" les attributs et qu'elle ne modifie donc pas l'objet. C'est une bonne habitude de programmation de créer des accesseurs const, bien que là encore ça ne soit pas obligatoire.<br>
<br>
Voici à quoi ressemble la méthode, avec le mot-clé const :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">Arme</span><span class="o">::</span><span class="n">getDegats</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">m_degats</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Oubliez pas de mettre à jour Arme.h avec le prototype aussi, qui sera le suivant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">getDegats</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voilà, c'est con comme bonjour, ça peut paraître lourd, et pourtant c'est une sécurité nécessaire. On est parfois obligé de créer une méthode qui fait juste un return pour accéder indirectement à un attribut.<br>
<br>
<div class="rmq information">De même, on crée parfois des accesseurs permettant de modifier des attributs. Ces accesseurs sont généralement précédés du préfixe <span class="italique">set</span> (<span class="italique">mettre</span>, en anglais).<br>
Vous avez peut-être l'impression qu'on viole la règle d'encapsulation ? Eh bien non. Car la méthode nous permet de faire des tests pour vérifier qu'on ne met pas n'importe quoi dans l'attribut, donc ça reste une façon sécurisée de modifier un attribut.</div><br>
<br>
Vous pouvez maintenant retourner dans Personnage.cpp et écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cible</span><span class="p">.</span><span class="n">recevoirDegats</span><span class="p">(</span><span class="n">m_arme</span><span class="p">.</span><span class="n">getDegats</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
getDegats renvoie le nombre de dégâts, qu'on envoie à la méthode recevoirDegats de la cible. Pfiou !  <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<br>
Le reste des méthodes n'a pas besoin de changer, à part changerArme de la classe Personnage :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">changerArme</span><span class="p">(</span><span class="n">string</span> <span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsNouvelleArme</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_arme</span><span class="p">.</span><span class="n">changer</span><span class="p">(</span><span class="n">nomNouvelleArme</span><span class="p">,</span> <span class="n">degatsNouvelleArme</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On appelle la méthode changer de m_arme.<br>
Le Personnage répercute donc la demande de changement d'arme à la méthode changer de son objet m_arme.<br>
<br>
<br>
Comme vous pouvez le voir, on peut faire communiquer des objets entre eux, à condition d'être bien organisé et de se demander à chaque instant "est-ce que j'ai le droit d'accéder à cet élément ou pas ?".<br>
N'hésitez pas à créer des accesseurs si besoin est, même si ça peut paraître lourd c'est la bonne méthode. En aucun cas vous ne devez mettre un attribut public pour simplifier un problème. Vous perdriez tous les avantages et la sécurité de la POO (et vous n'auriez aucun intérêt à continuer le C++ dans ce cas <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ). 
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11174">Action !</h2>
		<div class="ss_part_texte">
		Nos personnages combattent dans le main, mais... on ne voit rien de ce qui se passe. Il serait bien d'afficher l'état de chacun des personnages pour savoir où ils en sont.<br>
<br>
Je vous propose de créer une méthode afficherEtat dans Personnage. Cette méthode sera chargée de faire des <span class="italique">cout</span> pour afficher dans la console la vie, la mana et l'arme du personnage.<br>
<br>
<br>
<h3>Prototype et include</h3><br>
<br>
On va rajouter le prototype, tout bête, dans le .h :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">afficherEtat</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h3>Implémentation</h3><br>
<br>
Implémentons ensuite la méthode. C'est simple, on a juste des cout à faire. Grâce aux attributs, on peut indiquer toutes les infos sur le personnage :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">afficherEtat</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Vie : "</span> <span class="o">&lt;&lt;</span> <span class="n">m_vie</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Mana : "</span> <span class="o">&lt;&lt;</span> <span class="n">m_mana</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">m_arme</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Comme vous pouvez le voir, les informations sur l'arme sont demandées à l'objet m_arme via sa méthode afficher(). Encore une fois, les objets communiquent entre eux pour récupérer les informations dont ils ont besoin.<br>
<br>
<br>
<h3>Appel de afficherEtat dans le main</h3><br>
<br>
Bien, tout ça c'est bien beau, mais tant qu'on n'appelle pas la méthode, elle ne sert à rien <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Je vous propose donc de compléter le main et de rajouter à la fin les appels de méthode :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">// Création des personnages</span>
    <span class="n">Personnage</span> <span class="n">david</span><span class="p">,</span> <span class="n">goliath</span><span class="p">(</span><span class="s">"Epée aiguisée"</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
 
    <span class="c">// Au combat !</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span>
    <span class="n">david</span><span class="p">.</span><span class="n">boirePotionDeVie</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span>
    <span class="n">david</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">goliath</span><span class="p">);</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">changerArme</span><span class="p">(</span><span class="s">"Double hache tranchante vénéneuse de la mort"</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">attaquer</span><span class="p">(</span><span class="n">david</span><span class="p">);</span>
 
    <span class="c">// Temps mort ! Voyons voir la vie de chacun...</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"David"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">david</span><span class="p">.</span><span class="n">afficherEtat</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">"Goliath"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">goliath</span><span class="p">.</span><span class="n">afficherEtat</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On peut <span class="italique">enfin </span>exécuter le programme et voir quelque chose dans la console <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>David
Vie&nbsp;:&nbsp;40
Mana&nbsp;:&nbsp;100
Arme&nbsp;:&nbsp;Epée&nbsp;rouillée&nbsp;(Degats&nbsp;:&nbsp;10)
&nbsp;
Goliath
Vie&nbsp;:&nbsp;90
Mana&nbsp;:&nbsp;100
Arme&nbsp;:&nbsp;Double&nbsp;hache&nbsp;tranchante&nbsp;vénéneuse&nbsp;de&nbsp;la&nbsp;mort&nbsp;(Degats&nbsp;:&nbsp;40)</pre></div></td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Si vous êtes sous Windows, vous aurez probablement un bug avec les accents dans la console. Ignorez-le, ne vous en préoccupez pas, ce qui nous intéresse c'est le fonctionnement de la POO ici. Et puis de toute manière, dans la prochaine partie du cours on travaillera avec de vraies fenêtres, donc la console c'est temporaire pour nous <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"></div><br>
<br>
<br>
Pour que vous puissiez vous faire une bonne idée du projet dans son ensemble, je vous propose de télécharger un fichier zip contenant :<br>
<br>
<ul>
<li>main.cpp</li>
<li>Personnage.cpp</li>
<li>Personnage.h</li>
<li>Arme.cpp</li>
<li>Arme.h</li>
</ul><br>
... bref, c'est-à-dire tout le projet tel qu'il est sur mon ordinateur à l'heure actuelle.<br>
<br>
<div class="centre"><span class="tgros"><a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/cpp/rpg.zip">Télécharger le projet RPG (3 Ko)</a></span></div><br>
<br>
Je vous invite à faire des tests pour vous entraîner. Par exemple :<br>
<br>
<ul>
<li>Continuez à faire combattre david et goliath dans le main en affichant leur état de temps en temps.</li>
<li>Introduisez un troisième personnage dans l'arène pour rendre le combat plus <span class="barre">brutal</span> intéressant <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"></li>
<li>Rajoutez un attribut m_nom pour stocker le nom du personnage dans l'objet. Pour le moment, nos personnages ne savent même pas comment ils s'appellent, c'est un peu bête <img src="./cpp_files/rire.gif" alt=":lol:" class="smilies"><br>
Du coup, je pense qu'il faudrait modifier les constructeurs et obliger l'utilisateur à indiquer un nom pour le personnage lors de sa création... à moins que vous ne donniez un nom par défaut si rien n'est précisé ? A vous de choisir !</li>
<li>Rajoutez des cout dans les autres méthodes de Personnage pour indiquer à chaque fois ce qui est en train de se passer ("machin boit une potion qui lui redonne 20 points de vie")</li>
<li>Rajoutez d'autres méthodes au gré de votre imagination... et pourquoi pas des attaques magiques qui utilisent de la mana ?</li>
<li>Enfin, pour l'instant le combat est tout écrit dans le main, mais vous pourriez laisser le joueur choisir les attaques dans la console. Vous savez le faire, allez allez !</li>
</ul><br>
Prenez cet exercice très au sérieux, ceci est peut-être la base de votre futur MMORPG révolutionnaire !<br>
<br>
<div class="rmq information">Précision utile : la phrase ci-dessus était une boutade <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
Ce cours ne vous apprendra pas à créer un MMORPG, vu le travail phénoménal que cela représente. Mieux vaut commencer par se concentrer sur de plus petits projets réalistes, et notre RPG en est un. Ce qui est intéressant ici, c'est de voir comment est conçu un jeu orienté objet (comme c'est le cas de la plupart des jeux aujourd'hui). Si vous avez bien compris le principe, vous devriez commencer à voir des objets dans tous les jeux que vous connaissez ! Par exemple, un bâtiment dans Age of Empires est un objet qui a un niveau de vie, un nom, il peut produire des unités (via une méthode), etc.</div><br>
Si vous commencez à voir des objets partout, c'est bon signe ! C'est ce que l'on appelle "penser objet" <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11173">Méga schéma résumé</h2>
		<div class="ss_part_texte">
		Croyez-moi si vous le voulez, mais je vous demande même pas vraiment d'être capable de programmer tout ce qu'on vient de voir en C++. Je veux que vous reteniez le principe, le concept, comment tout cela est agencé.<br>
Et pour retenir, rien de tel qu'un méga schéma bien mastoc, non ? Ouvrez grand vos yeux, je veux que vous soyez capable de le reproduire les yeux fermés la tête en bas avec du poil à gratter dans le dos !<br>
<br>
<div class="centre"><img src="./cpp_files/85453.png" alt="Image utilisateur"></div>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Si vous avez dû retenir une bonne chose de ce second chapitre, c'est cet échange, cette communication constante entre les objets. Et encore ! On n'avait ici que 2 classes, Personnage et Arme. Je vous laisse imaginer dans un vrai projet ce que ça donne <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
L'intérêt de la POO est là : une organisation précise, chaque objet fait ce qu'il a à faire et délègue certaines parties de son travail à d'autres objets (ici, Personnage déléguait la gestion de l'arme à un objet de type Arme).<br>
<br>
On ne peut pas dire "Je fais de la POO" du jour au lendemain, c'est clair. C'est un travail qui demande de l'organisation, de la méthode. Il faut toujours bien réfléchir avant de se lancer dans un projet, si simple soit-il.<br>
Mais réfléchir un peu avant de programmer, est-ce un mal ? Je ne crois pas <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Concentrez-vous sur le fichier zip que je vous ai donné et essayez de vous familiariser avec, en faisant par exemple les améliorations proposées. Il ne faut surtout pas que vous soyez perdus.<br>
<br>
<br>
Dans le chapitre suivant, nous allons aller un peu plus dans le détail des classes en introduisant... les pointeurs ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Les pointeurs en POO méritent en effet à eux seuls au moins un chapitre entier.
	</div>
	
	<hr>
	<h1 id="chap_11187">Classes et pointeurs</h1>
	<div id="chap_intro">
	Dans les chapitres précédents, j'ai volontairement évité d'introduire les pointeurs avec les classes. En effet, les pointeurs en C++ sont un vaste sujet, et un sujet sensible. Comme vous l'avez probablement remarqué par le passé, bien gérer les pointeurs est essentiel car à la moindre erreur votre programme risque de :<br>
<br>
<ul>
<li>Consommer trop de mémoire parce que vous oubliez de libérer certains éléments</li>
<li>Voire tout simplement de planter si votre pointeur pointe vers n'importe où dans la mémoire</li>
</ul><br>
Comment associe-t-on classes et pointeurs ? Quelles sont les règles à connaître, les bonnes habitudes à prendre ?<br>
Voilà un sujet qui méritait au moins un chapitre à lui tout seul <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="rmq attention"><span class="souligne">Attention</span> : c'est un chapitre que je classe entre "très difficile" et "très très difficile". Bref, vous m'avez compris, les pointeurs en C++ c'est pas de la tarte, alors quadruplez d'attention lorsque vous lirez ce chapitre. Le sujet est complexe et épineux, je ne vous le dirai pas deux fois <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div>
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11186">Pointeur d'une classe vers une autre classe</h2>
		<div class="ss_part_texte">
		Reprenons notre classe Personnage <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Dans le dernier chapitre, nous lui avons ajouté une Arme que nous avons directement intégré à ses attributs :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>

    <span class="c">// Quelques méthodes...</span>


    <span class="k">private</span><span class="o">:</span>

    <span class="n">Arme</span> <span class="n">m_arme</span><span class="p">;</span> <span class="c">// L'Arme est "contenue" dans le Personnage</span>
    <span class="c">// ...</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Il y a plusieurs façons différentes d'associer des classes entre elles. Celle-ci fonctionne bien dans notre cas, mais l'Arme est vraiment "liée" au Personnage. Elle ne peut pas en sortir.<br>
<br>
Schématiquement, ça donnerait quelque chose de ce genre :<br>
<br>
<div class="centre"><img src="./cpp_files/63505.png" alt="Image utilisateur"></div><br>
<br>
L'Arme est vraiment <span class="italique">dans</span> le Personnage.<br>
<br>
Il y a une autre technique, plus souple, qui permet plus de possibilités, mais qui est plus complexe : ne pas intégrer l'Arme au Personnage et utiliser un pointeur à la place. Au niveau de la déclaration de la classe, le changement correspond à... une étoile en plus :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>

    <span class="c">// Quelques méthodes...</span>


    <span class="k">private</span><span class="o">:</span>

    <span class="n">Arme</span> <span class="o">*</span><span class="n">m_arme</span><span class="p">;</span> <span class="c">// L'Arme est un pointeur, l'objet n'est plus contenu dans le Personnage</span>
    <span class="c">// ...</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notre Arme étant un pointeur, on ne peut plus dire qu'elle appartient au Personnage.<br>
En schéma, ça donne ça :<br>
<br>
<div class="centre"><img src="./cpp_files/63507.png" alt="Image utilisateur"></div><br>
<br>
On considère que l'arme est maintenant externe au personnage.<br>
Les avantages de cette technique sont les suivants :<br>
<br>
<ul>
<li>Le Personnage peut changer d'Arme en faisant tout simplement pointer m_arme vers un autre objet. Par exemple, si le Personnage possède un inventaire (dans un sac à dos), il peut changer son Arme à tout moment en modifiant le pointeur.</li>
<li>Le Personnage peut donner son Arme à un autre Personnage, il suffit de changer les pointeurs de chacun des personnages.</li>
<li>Si le Personnage n'a plus d'Arme, il suffit de mettre le pointeur m_arme à NULL.</li>
</ul><br>
<br>
Mais des défauts, il y en a aussi. Gérer une classe qui contient des pointeurs, c'est pas de la tarte vous pouvez me croire, et d'ailleurs vous allez le voir <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<div class="rmq information">Alors, faut-il utiliser un pointeur ou pas pour l'arme ? Les 2 façons de faire sont valables, et ont chacune leurs avantages et défauts. Utiliser un pointeur est probablement ce qu'il y a de plus souple, mais c'est aussi plus difficile.<br>
Retenez donc qu'il n'y a pas de "meilleure" méthode adaptée à tous les cas, ce sera à vous de choisir en fonction de votre cas si vous intégrez directement un objet dans une classe ou si vous utilisez un pointeur.</div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11185">Gestion de l'allocation dynamique</h2>
		<div class="ss_part_texte">
		On va ici voir comment on travaille quand une classe contient des pointeurs vers des objets.<br>
<br>
On travaille là encore sur notre classe Personnage et je suppose que vous avez mis l'attribut m_arme en pointeur comme je l'ai montré un peu plus haut :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
 
    <span class="c">// Quelques méthodes...</span>
 
 
    <span class="k">private</span><span class="o">:</span>
 
    <span class="n">Arme</span> <span class="o">*</span><span class="n">m_arme</span><span class="p">;</span> <span class="c">// L'Arme est un pointeur, l'objet n'est plus contenu dans le Personnage</span>
    <span class="c">// ...</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="italique">(je ne réécris volontairement pas tout le code, juste l'essentiel pour qu'on puisse se concentrer dessus)</span><br>
<br>
Notre arme étant un pointeur, il va falloir faire une allocation dynamique avec <span class="italique">new </span>pour créer l'objet. Sinon, l'objet ne se créera pas tout seul <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Allocation de mémoire pour l'objet</h3><br>
<br>
L'allocation de mémoire pour notre arme se fait où à votre avis ?<br>
Il n'y a pas 36 endroits pour ça : c'est dans le <strong>constructeur</strong>. C'est en effet le rôle du constructeur que de faire en sorte que l'objet soit bien construit, donc notamment que tous les pointeurs pointent vers quelque chose <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Dans notre cas, on est obligé de faire une allocation dynamique, donc d'utiliser <strong>new</strong>. Voici ce que ça donne dans le constructeur par défaut :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_vie</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_mana</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_arme</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Arme</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si vous vous souvenez bien, on avait aussi fait un second constructeur pour ceux qui veulent que le Personnage commence avec une arme plus puissante dès le départ. Il faut là aussi y faire une allocation dynamique :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">(</span><span class="n">string</span> <span class="n">nomArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsArme</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_vie</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_mana</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_arme</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Arme</span><span class="p">(</span><span class="n">nomArme</span><span class="p">,</span> <span class="n">degatsArme</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<strong>Explications :</strong> new Arme() appelle le constructeur par défaut de la classe Arme, tandis que new Arme(nomArme, degatsArme) appelle le constructeur surchargé. Le new renvoie l'adresse de l'objet créé, adresse qui est stockée dans notre pointeur m_arme.<br>
On ne peut pas faire de new dans la liste d'initialisation, ce qui explique pourquoi on le fait entre les accolades { }.<br>
<br>
<br>
<h3>Désallocation de mémoire pour l'objet</h3><br>
<br>
Notre arme étant un pointeur, lorsque l'objet de type Personnage est supprimé l'arme ne disparaît pas toute seule ! Si on fait juste un new dans le constructeur, et rien dans le destructeur, il va se passer ceci lorsque l'objet de type Personnage sera détruit :<br>
<br>
<div class="centre"><img src="./cpp_files/63659.png" alt="Image utilisateur"></div><br>
<br>
L'objet de type Personnage va bel et bien disparaître, mais l'objet de type Arme va subsister en mémoire et il n'y aura plus aucun pointeur pour se "rappeler" de son adresse. En clair, l'arme va traîner en mémoire et on ne pourra plus jamais la supprimer.<br>
<br>
Pour résoudre ce problème, il faut faire un delete de l'arme dans le <strong>destructeur </strong>du personnage afin que l'arme soit supprimée <span class="italique">avant </span>le personnage. Le code est tout simple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::~</span><span class="n">Personnage</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span> <span class="n">m_arme</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cette fois le destructeur est réellement indispensable. Maintenant, lorsque quelqu'un demandera à détruire le Personnage, il va se passer ceci :<br>
<br>
<ol class="liste_1">
<li>Appel du destructeur... et donc dans notre cas suppression de l'Arme (avec le delete).</li>
<li>Puis enfin suppression du Personnage.</li></ol><br>
<br>
Au final, les 2 objets seront bel et bien supprimés et la mémoire sera propre :<br>
<br>
<div class="centre"><img src="./cpp_files/63657.png" alt="Image utilisateur"></div><br>
<br>
<h3>N'oubliez pas que m_arme est maintenant un pointeur !</h3><br>
<br>
Cela implique de changer toutes les méthodes qui l'utilisent. Par exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cible</span><span class="p">.</span><span class="n">recevoirDegats</span><span class="p">(</span><span class="n">m_arme</span><span class="p">.</span><span class="n">getDegats</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... devient :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">attaquer</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cible</span><span class="p">.</span><span class="n">recevoirDegats</span><span class="p">(</span><span class="n">m_arme</span><span class="o">-&gt;</span><span class="n">getDegats</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notez la différence : le point a été remplacé par la flèche, car m_arme est un pointeur. Cela ne devrait pas être nouveau pour vous si vous avez bien suivi le cours jusqu'ici, mais je préfère le rappeler sait-on jamais <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11184">Le constructeur de copie</h2>
		<div class="ss_part_texte">
		Le <strong>constructeur de copie</strong>, c'est une <span class="italique">surcharge </span>particulière du constructeur.<br>
Le constructeur de copie devient généralement indispensable dans une classe qui contient des pointeurs, et ça tombe bien vu que c'est justement notre cas ici <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Le problème</h3><br>
<br>
Pour bien comprendre l'intérêt du constructeur de copie, voyons voir concrètement ce qui se passe lorsqu'on crée un objet en l'affectant par... un autre objet ! Par exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Personnage</span> <span class="n">goliath</span><span class="p">(</span><span class="s">"Epée aiguisée"</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
    
    <span class="n">Personnage</span> <span class="n">david</span> <span class="o">=</span> <span class="n">goliath</span><span class="p">;</span> <span class="c">// On crée david à partir de goliath. David sera une "copie" de goliath.</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Lorsqu'on construit un objet en lui affectant directement un autre objet, comme on vient de le faire ici avec le signe "=", le compilateur appelle une méthode appelée constructeur de copie.<br>
<br>
Le rôle du constructeur de copie est de <span class="souligne">copier la valeur de tous les attributs</span> du premier objet dans le second. Donc david récupère la vie de goliath, la mana de goliath, etc.<br>
<br>
<br>
<div class="rmq question">Dans quels cas le constructeur de copie est-il appelé ?</div><br>
<br>
On vient de le voir, le constructeur de copie est appelé lorsqu'on crée un nouvel objet en l'affectant par la valeur d'un autre :<br>
<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span> <span class="n">david</span> <span class="o">=</span> <span class="n">goliath</span><span class="p">;</span> <span class="c">// Appel du constructeur de copie (cas 1)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ceci est strictement équivalent à écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span> <span class="n">david</span><span class="p">(</span><span class="n">goliath</span><span class="p">);</span> <span class="c">// Appel du constructeur de copie (cas 2)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Dans ce second cas le constructeur de copie est là aussi appelé.<br>
<br>
Mais ce n'est pas tout ! Lorsque vous envoyez un objet à une fonction sans utiliser de pointeur ni de référence, l'objet est là aussi copié !<br>
Imaginons la fonction :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">maFonction</span><span class="p">(</span><span class="n">Personnage</span> <span class="n">unPersonnage</span><span class="p">)</span>
<span class="p">{</span>

<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si vous appelez cette fonction qui n'utilise pas de pointeur ni de référence, alors l'objet sera copié en utilisant un constructeur de copie au moment de l'appel de la fonction :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">maFonction</span><span class="p">(</span><span class="n">Goliath</span><span class="p">);</span> <span class="c">// Appel du constructeur de copie (cas 3)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Bien entendu, il est préférable d'utiliser un pointeur ou une référence en général car l'objet n'a pas besoin d'être copié, donc ça va bien plus vite et ça prend moins de mémoire. Toutefois, il arrivera des cas où vous aurez besoin de créer une fonction comme ici qui fait une copie de l'objet.<br>
<br>
<br>
<div class="rmq information">Si vous n'écrivez pas vous-mêmes un constructeur de copie pour votre classe, il sera généré automatiquement pour vous par le compilateur. Ok, c'est sympa de sa part, mais le compilateur est... comment dire pour pas le froisser... bête <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
En fait, le constructeur de copie généré se contente de copier la valeur de tous les attributs... même des pointeurs !</div><br>
<br>
Le problème ? Eh bien justement, il se trouve qu'un des attributs est un pointeur dans notre classe Personnage ! Que fait l'ordinateur ? Il copie la valeur du pointeur, donc l'adresse de l'arme. Au final, les 2 objets ont un pointeur qui pointe vers le même objet de type Arme !<br>
Ah les fourbes !<br>
<br>
<div class="centre"><img src="./cpp_files/63672.png" alt="Image utilisateur"><br>
<span class="italique">L'ordinateur a copié le pointeur, et donc les 2 pointeurs pointent vers la même arme !</span></div><br>
<br>
<div class="rmq attention">Si on ne fait rien pour régler ça, imaginez ce qu'il va se passer lorsque les 2 personnages seront détruits... Le premier sera détruit, ainsi que son arme car le destructeur ordonnera la suppression de l'arme avec un delete. Et quand arrivera le tour du second personnage, le delete va planter (et votre programme avec <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ) parce que l'arme aura <span class="italique">déjà </span>été détruite !</div><br>
<br>
Le constructeur de copie généré automatiquement par le compilateur n'est pas assez intelligent pour comprendre qu'il faut allouer de la mémoire pour une autre arme... Qu'à cela ne tienne, nous allons le lui expliquer <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<br>
<h3>Création du constructeur de copie</h3><br>
<br>
Le constructeur de copie, comme je vous l'ai dit un peu plus haut, est une surcharge particulière du constructeur. C'est un constructeur qui prend pour paramètre... une référence constante vers un objet du même type !<br>
Si vous trouvez pas ça clair, peut-être qu'un exemple vous aidera <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>

    <span class="n">Personnage</span><span class="p">();</span>
    <span class="n">Personnage</span><span class="p">(</span><span class="k">const</span> <span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">personnageACopier</span><span class="p">);</span> <span class="c">// Le prototype du constructeur de copie</span>
    <span class="n">Personnage</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nomArme</span><span class="p">,</span> <span class="kt">int</span> <span class="n">degatsArme</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Personnage</span><span class="p">();</span>
    
    <span class="c">/*</span>
<span class="c">    ... plein d'autres méthodes qui ne nous intéressent pas ici</span>
<span class="c">    */</span>

    <span class="k">private</span><span class="o">:</span>

    <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_mana</span><span class="p">;</span>
    <span class="n">Arme</span> <span class="o">*</span><span class="n">m_arme</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
En résumé, le prototype d'un constructeur de copie est :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">Objet</span><span class="p">(</span><span class="k">const</span> <span class="n">Objet</span> <span class="o">&amp;</span><span class="n">objetACopier</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le const indique juste qu'on n'a pas le droit de modifier les valeurs de l'objetACopier (c'est logique, on a juste besoin de "lire" ses valeurs pour le copier).<br>
<br>
Ecrivons l'implémentation de ce constructeur. Il va falloir copier tous les attributs du personnageACopier dans le personnage actuel. Commençons par les attributs "simples", c'est-à-dire ceux qui ne sont pas des pointeurs :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">(</span><span class="k">const</span> <span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">personnageACopier</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_vie</span> <span class="o">=</span> <span class="n">personnageACopier</span><span class="p">.</span><span class="n">m_vie</span><span class="p">;</span>
    <span class="n">m_mana</span> <span class="o">=</span> <span class="n">personnageACopier</span><span class="p">.</span><span class="n">m_mana</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Vous vous demandez peut-être comment cela se fait qu'on puisse accéder aux attributs m_vie et m_mana du personnageACopier ? Si vous vous l'êtes demandé, je vous félicite, ça veut dire que le principe d'encapsulation commence à rentrer dans votre tête <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Eh oui, en effet, m_vie et m_mana sont privés, donc on ne peut pas y accéder depuis l'extérieur de la classe... sauf qu'il y a une exception ici : on est dans une méthode de la classe Personnage, et on a le droit d'accéder à tous les éléments (même privés) d'un autre Personnage.<br>
<br>
C'est un peu tordu je l'avoue, mais dans le cas présent ça nous simplifie grandement la vie <img src="./cpp_files/smile.png" alt=":)" class="smilies"> Retenez donc qu'un objet de type X peut accéder à tous les éléments (même privés) d'un autre objet s'il est du même type X.</div><br>
<br>
Il reste maintenant à "copier" m_arme. Si on écrit :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">m_arme</span> <span class="o">=</span> <span class="n">personnageACopier</span><span class="p">.</span><span class="n">m_arme</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... on fait exactement la même erreur que le compilateur, c'est-à-dire qu'on ne copie que l'adresse de l'objet de type Arme, et pas l'objet en entier !<br>
<br>
Pour résoudre le problème, il va falloir copier l'objet de type Arme en faisant une allocation dynamique, donc un new. Attention, accrochez-vous parce que ce n'est pas simple <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Si on fait :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">m_arme</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Arme</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... on va bien créer une nouvelle arme, mais on utilisera le constructeur par défaut, donc cela créera l'arme de base. Or, on veut avoir exactement la même arme que celle du personnageACopier (ben oui, c'est un constructeur de copie <img src="./cpp_files/hihi.png" alt="^^" class="smilies"> ).<br>
<br>
La bonne nouvelle, comme je vous l'ai dit plus haut, c'est que le constructeur de copie est automatiquement généré par le compilateur. Tant que la classe n'utilise pas de pointeurs vers des attributs, il n'y a pas de danger. Et ça tombe bien, la classe Arme n'utilise pas de pointeurs, on va donc pouvoir se contenter du constructeur qui a été généré.<br>
<br>
Il faut donc appeler le constructeur de copie, en envoyant en paramètre l'objet à copier. Vous pourriez penser qu'il faut faire ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">m_arme</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Arme</span><span class="p">(</span><span class="n">personnageACopier</span><span class="p">.</span><span class="n">m_arme</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Presque ! Sauf que m_arme est un pointeur, et le prototype du constructeur de copie est :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">Arme</span><span class="p">(</span><span class="k">const</span> <span class="n">Arme</span> <span class="o">&amp;</span><span class="n">arme</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... ce qui veut dire qu'il faut envoyer l'objet lui-même et pas son adresse. Vous vous souvenez comment on fait pour obtenir l'objet (ou la variable) à partir de son adresse ? On utilise l'étoile * !<br>
Ce qui donne au final :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">m_arme</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Arme</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">personnageACopier</span><span class="p">.</span><span class="n">m_arme</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cette ligne alloue dynamiquement une nouvelle arme, en se basant sur l'arme du personnageACopier. Pas simple je le reconnais, mais relisez plusieurs fois les étapes de mon raisonnement et vous allez comprendre <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Pour bien suivre tout ce que j'ai dit, il faut vraiment que vous soyez au point sur tout : les pointeurs, les références, et les... constructeurs de copie <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Le constructeur de copie une fois terminé</h3><br>
<br>
Le bon constructeur de copie ressemblera donc à ceci au final :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">(</span><span class="k">const</span> <span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">personnageACopier</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_vie</span> <span class="o">=</span> <span class="n">personnageACopier</span><span class="p">.</span><span class="n">m_vie</span><span class="p">;</span>
    <span class="n">m_mana</span> <span class="o">=</span> <span class="n">personnageACopier</span><span class="p">.</span><span class="n">m_mana</span><span class="p">;</span>
    <span class="n">m_arme</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Arme</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">personnageACopier</span><span class="p">.</span><span class="n">m_arme</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ainsi, nos 2 personnages ont tous deux une arme identique, mais dupliquée afin d'éviter les problèmes que je vous ai expliqués plus haut :<br>
<br>
<div class="centre"><img src="./cpp_files/63673.png" alt="Image utilisateur"></div><br>
<br>
Notez qu'on peut aussi utiliser la liste d'initialisation pour tous les attributs qui ne nécessitent pas d'allocation dynamique, à savoir m_vie et m_mana. On peut donc aussi écrire le constructeur de copie de cette manière :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">(</span><span class="k">const</span> <span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">personnageACopier</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_vie</span><span class="p">(</span><span class="n">personnageACopier</span><span class="p">.</span><span class="n">m_vie</span><span class="p">),</span> <span class="n">m_mana</span><span class="p">(</span><span class="n">personnageACopier</span><span class="p">.</span><span class="n">m_mana</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_arme</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Arme</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">personnageACopier</span><span class="p">.</span><span class="n">m_arme</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La POO n'est pas simple comme vous commencez à vous en rendre compte, surtout quand on commence à manipuler des objets. Heureusement, vous aurez l'occasion de pratiquer tout cela par la suite, et vous allez petit à petit prendre l'habitude d'éviter les pièges des pointeurs.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11183">Le pointeur this</h2>
		<div class="ss_part_texte">
		Pour terminer ce chapitre sur une note plus <span class="italique">cool</span>, puisqu'on parle de POO et de pointeurs, je me dois de vous parler du pointeur <strong>this</strong>.<br>
Pas de panique, c'est très simple, ça ira vite et vous ne sentirez aucune douleur <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Dans toutes les classes, on dispose d'un pointeur ayant pour nom <span class="italique">this</span>. Ce pointeur pointe <strong>vers l'objet actuel</strong>.<br>
Je reconnais que ce n'est pas simple à imaginer, mais je pense que ça passera mieux avec un schéma maison :<br>
<br>
<br>
<div class="centre"><img src="./cpp_files/63859.png" alt="Pointeur this C++"><br>
<br>
<span class="italique">Chaque objet (ici de type Personnage) possède un pointeur this qui pointe vers... l'objet lui-même !</span></div><br>
<br>
<div class="rmq information"><span class="italique">this </span>étant utilisé par le langage C++ dans toutes les classes, vous ne pouvez donc pas créer de variable appelée this car cela créerait un conflit. De même, si vous commencez à essayer d'appeler vos variables <span class="italique">class</span>, <span class="italique">new</span>, <span class="italique">delete</span>, <span class="italique">return</span>, forcément ça risque de coincer un peu <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Ces mots-clés sont ce qu'on appelle des mots-clés réservés. Le langage C++ se les réserve pour son usage personnel, vous n'avez donc pas le droit de créer des variables (ou des fonctions) portant ces noms-là.</div><br>
<br>
<div class="rmq question">Mais... à quoi peut bien servir this ???</div><br>
<br>
Répondre à cette question me sera délicat <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Je peux vous donner un exemple : vous êtes dans une méthode de votre classe, et cette méthode doit renvoyer un pointeur vers l'objet auquel elle appartient. Sans le this, on ne pourrait pas l'écrire. Voilà ce que ça pourrait donner :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">*</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">getAdresse</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Dans l'immédiat, vous n'en avez certainement pas l'utilité, mais il arrivera un jour où, pour résoudre un problème particulier, vous aurez besoin d'un tel pointeur. Ce jour-là, souvenez-vous qu'un objet peut "retrouver" son adresse à l'aide du pointeur this.<br>
<br>
Comme c'est l'endroit le plus adapté pour en parler dans ce cours, j'en profite. Ca ne va pas changer votre vie tout de suite, mais il se peut que bien plus tard, dans plusieurs chapitres je vous dise tel un vieillard sur sa canne  "<span class="italique">Souvenez-vous, souvenez-vous du pointeur this !</span> <img src="./cpp_files/63861.gif" alt="Vieillard"> ". Alors ne l'oubliez pas <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Si vous êtes en train de vous shooter à l'aspirine pour éviter que votre tête n'explose, je vous conseille de conserver encore des munitions <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
En effet, on n'a pas fini d'en découdre avec la POO et il vous reste encore beaucoup de choses à apprendre. Heureusement, enfin si ça peut vous rassurer, ce chapitre était probablement l'un des plus difficiles de tout le cours (mais pas nécessairement LE plus difficile <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ).<br>
<br>
Sachez quoiqu'il en soit que les pointeurs en C++ sont de véritables casse-têtes, même pour les programmeurs plus expérimentés. Il faut faire constamment attention, car une fuite de mémoire (oubli de libérer des objets) est très vite arrivée, et je ne vous parle pas des plantages de programme que ça peut occasionner. Une très très grande part des plantages des programmes que vous connaissez sont dûs à une mauvaise gestion de la mémoire, c'est vous dire !<br>
<br>
<br>
Dans le prochain chapitre, nous allons jouer avec la <strong>surcharge des opérateurs</strong>, ce qui va nous permettre de faire des choses étonnantes avec nos objets.<br>
Puis, chemin faisant, nous nous rapprocherons d'un des thèmes majeurs de la programmation orientée objet, quelque chose d'indispensable à quoi vous ne pouvez échapper et qui porte un bien funeste nom : <strong>l'héritage</strong>. Voilà un peu le genre de choses qui vous attend <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
Qu'on ne s'y trompe pas : tout ceci est peut-être complexe et pas toujours très "amusant" à apprendre, mais vous en aurez vraiment besoin dans la partie II lorsque nous travaillerons avec la librairie Qt pour créer des fenêtres, travailler en réseau, etc. Donc on se motive, et on continue ! <img src="./cpp_files/hihi.png" alt="^^" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11199">La surcharge d'opérateurs</h1>
	<div id="chap_intro">
	On l'a vu, le langage C++ propose beaucoup de nouveautés qui peuvent se révéler très utiles, si on arrive à s'en servir correctement (je pense par exemple à la surcharge de fonctions).<br>
<br>
Une des nouveautés les plus étonnantes est la <strong>surcharge des opérateurs</strong>, que nous allons étudier dans ce chapitre. C'est une technique qui permet de réaliser des opérations mathématiques intelligentes entre vos objets lorsque vous utilisez dans votre code des symboles comme +, -, *, etc.<br>
Au final, votre code sera plus court et plus clair, et gagnera donc en lisibilité vous allez voir <img src="./cpp_files/smile.png" alt=":)" class="smilies">
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11198">Petits préparatifs</h2>
		<div class="ss_part_texte">
		<h3>Qu'est-ce que c'est ?</h3><br>
<br>
Le principe est très simple. Supposons que vous ayez créé une classe pour stocker une durée (ex. : 4h23m), et que vous avez 2 objets de type Duree. Vous voulez les additionner entre eux pour connaître la durée totale.<br>
<br>
En temps normal, il faudrait créer une fonction "additionner" :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">resultat</span> <span class="o">=</span> <span class="n">additionner</span><span class="p">(</span><span class="n">duree1</span><span class="p">,</span> <span class="n">duree2</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La fonction additionner ferait ici la somme de <span class="italique">duree1 </span>et <span class="italique">duree2 </span>et stockerait ça dans <span class="italique">resultat</span>.<br>
Ca fonctionne, mais ce n'est pas franchement lisible. Ce que je vous propose dans ce chapitre, c'est d'être capable d'écrire ça :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">resultat</span> <span class="o">=</span> <span class="n">duree1</span> <span class="o">+</span> <span class="n">duree2</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
En clair, on fait ici comme si nos objets étaient de simples "nombres". Mais comme un objet c'est plus complexe qu'un nombre (vous avez eu l'occasion de vous en rendre compte <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ), il va falloir expliquer à l'ordinateur comment effectuer l'opération.<br>
<br>
<br>
<h3>La classe Duree pour nos exemples</h3><br>
<br>
Toutes les classes ne sont pas forcément adaptées à la surcharge d'opérateurs. Ainsi, ajouter des objets de type Personnage entre eux serait pour le moins un peu louche <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> <br>
Nous allons donc changer d'exemple, ça sera l'occasion de vous aérer un peu l'esprit sinon vous allez finir par croire que le C++ ne sert qu'à créer des RPG <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Cette classe Duree sera capable de stocker des heures, des minutes et des secondes. Rassurez-vous, c'est une classe relativement facile à écrire (plus facile que Personnage en tout cas !), ça ne devrait vous poser aucun problème si vous avez compris les chapitres précédents.<br>
<br>
<h4>Duree.h</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef DEF_DUREE</span>
<span class="cp">#define DEF_DUREE</span>
 
<span class="k">class</span> <span class="nc">Duree</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
 
    <span class="n">Duree</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
 
    <span class="k">private</span><span class="o">:</span>
 
    <span class="kt">int</span> <span class="n">m_heures</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_minutes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_secondes</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Chaque objet de type Duree stockera un certain nombre d'heures, minutes et secondes.<br>
<br>
Vous noterez que j'ai utilisé des valeurs par défaut au cas où l'utilisateur aurait la flemme de les préciser <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
On pourra donc créer un objet de plusieurs façons différentes :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">Duree</span> <span class="n">chrono</span><span class="p">;</span> <span class="c">// Pour stocker 0 heures, 0 minutes et 0 secondes</span>
<span class="n">Duree</span> <span class="n">chrono</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c">// Pour stocker 5 heures, 0 minutes et 0 secondes</span>
<span class="n">Duree</span> <span class="n">chrono</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span> <span class="c">// Pour stocker 5 heures, 30 minutes et 0 secondes</span>
<span class="n">Duree</span> <span class="n">chrono</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">55</span><span class="p">);</span> <span class="c">// Pour stocker 0 heures, 12 minutes et 55 secondes</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Duree.cpp</h4><br>
<br>
L'implémentation de notre constructeur est expédiée en 30 secondes montre en main <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "Duree.h"</span>
 
<span class="n">Duree</span><span class="o">::</span><span class="n">Duree</span><span class="p">(</span><span class="kt">int</span> <span class="n">heures</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minutes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_heures</span><span class="p">(</span><span class="n">heures</span><span class="p">),</span> <span class="n">m_minutes</span><span class="p">(</span><span class="n">minutes</span><span class="p">),</span> <span class="n">m_secondes</span><span class="p">(</span><span class="n">secondes</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Et dans main.cpp ?</h4><br>
<br>
Pour l'instant notre main.cpp ne va déclarer que 2 objets de type Duree, que j'initialise un peu au pif :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Duree</span> <span class="n">duree1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span> <span class="n">duree2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voilà, nous sommes prêts à affronter les surcharges d'opérateurs maintenant ! <img src="./cpp_files/zorro.png" alt=":zorro:" class="smilies"> <br>
<br>
<div class="rmq attention">Les plus perspicaces d'entre vous auront remarqué que rien ne m'interdit de créer un objet avec 512 minutes et 1455 secondes. En effet, on peut écrire <span class="courrier">Duree chrono(0, 512, 1455);</span> sans être inquiété. Normalement, cela devrait être interdit, ou tout du moins notre constructeur devrait être assez intelligent pour "découper" les minutes et les convertir en heures/minutes, et de même pour les secondes, afin qu'elles ne dépassent pas 60.<br>
Je ne le fais pas ici, mais je vous encourage à modifier votre constructeur pour faire cette conversion si nécessaire, ça vous entraînera ! Etant donné qu'il faut faire des if et quelques petites opérations mathématiques dans le constructeur, vous ne pourrez pas utiliser de liste d'initialisation.</div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11197">Les opérateurs arithmétiques (+, -, *, /, %)</h2>
		<div class="ss_part_texte">
		Nous allons commencer par voir les opérateurs mathématiques les plus classiques, à savoir l'addition, la soustraction, la multiplication, la division et le modulo.<br>
Une fois que vous aurez appris à vous servir de l'un d'entre eux, vous verrez que vous saurez vous servir de tous les autres <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
Pour être capable d'utiliser le symbole "+" entre 2 objets, vous devez créer une méthode ayant précisément pour nom <span class="courrier"><strong>operator+</strong></span> qui a pour prototype :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">Objet</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Objet</span> <span class="o">&amp;</span><span class="n">monObjet</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La méthode reçoit donc une référence sur l'objet (constant, donc on ne peut pas le modifier) à additionner.<br>
Dans notre classe Duree, on doit donc rajouter cette méthode (ici dans le .h) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">Duree</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Duree</span> <span class="o">&amp;</span><span class="n">duree</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h3>Mode d'utilisation</h3><br>
<br>
<div class="rmq question">Comment ça marche ce truc ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"></div><br>
<br>
Dès le moment où vous avez créé cette méthode operator+, vous pouvez additionner 2 objets de type Duree entre eux :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">resultat</span> <span class="o">=</span> <span class="n">duree1</span> <span class="o">+</span> <span class="n">duree2</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce n'est pas de la magie. En fait le compilateur "traduit" ça par :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">resultat</span> <span class="o">=</span> <span class="n">duree1</span><span class="p">.</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">duree2</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... ce qui est beaucoup plus classique et compréhensible pour lui <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Il appelle donc la méthode operator+ de l'objet duree1, et envoie duree2 en paramètre à la méthode. La méthode, elle, va retourner un résultat de type Duree.<br>
<br>
<h3>Implémentation</h3><br>
<br>
L'implémentation n'est pas vraiment compliquée, mais il va quand même falloir réfléchir un peu. En effet, ajouter des secondes, minutes et heures ça va, mais il faut faire attention à la retenue si ça dépasse 60.<br>
Je vous recommande d'essayer d'écrire la méthode vous-même, c'est un excellent exercice algorithmique, ça entretient le cerveau, ça vous rend meilleur programmeur (je vous ai convaincus là ? <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> )<br>
<br>
Voici ce que donne mon implémentation pour ceux qui ont besoin de la solution :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td><td class="code"><div class="syntax"><pre><span class="n">Duree</span> <span class="n">Duree</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Duree</span> <span class="o">&amp;</span><span class="n">duree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">heures</span> <span class="o">=</span> <span class="n">m_heures</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">minutes</span> <span class="o">=</span> <span class="n">m_minutes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">secondes</span> <span class="o">=</span> <span class="n">m_secondes</span><span class="p">;</span>

    <span class="c">// 1 : ajout des secondes</span>
    <span class="n">secondes</span> <span class="o">+=</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_secondes</span><span class="p">;</span> <span class="c">// Exceptionnellement autorisé car même classe</span>
    <span class="c">// Si le nombre de secondes dépasse 60, on rajoute des minutes et on met un nombre de secondes inférieur à 60</span>
    <span class="n">minutes</span> <span class="o">+=</span> <span class="n">secondes</span> <span class="o">/</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">secondes</span> <span class="o">%=</span> <span class="mi">60</span><span class="p">;</span>

    <span class="c">// 2 : ajout des minutes</span>
    <span class="n">minutes</span> <span class="o">+=</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_minutes</span><span class="p">;</span>
    <span class="c">// Si le nombre de minutes dépasse 60, on rajoute des heures et on met un nombre de minutes inférieur à 60</span>
    <span class="n">heures</span> <span class="o">+=</span> <span class="n">minutes</span> <span class="o">/</span> <span class="mi">60</span><span class="p">;</span>
    <span class="n">minutes</span> <span class="o">%=</span> <span class="mi">60</span><span class="p">;</span>

    <span class="c">// 3 : ajout des heures</span>
    <span class="n">heures</span> <span class="o">+=</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_heures</span><span class="p">;</span>

    <span class="c">// Création de l'objet resultat et retour</span>
    <span class="n">Duree</span> <span class="n">resultat</span><span class="p">(</span><span class="n">heures</span><span class="p">,</span> <span class="n">minutes</span><span class="p">,</span> <span class="n">secondes</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">resultat</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce n'est pas un algorithme ultracomplexe, mais comme je vous avais dit il faut réfléchir un tout petit peu pour pouvoir l'écrire quand même <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
On commence par créer et initialiser 3 variables locales (heures, minutes et secondes) qui correspondent au résultat. Ce résultat, on le mettra dans un objet de type Duree que l'on renverra à la fin.<br>
<br>
On a initialisé ces 3 variables avec la valeur de l'objet sur lequel on travaille (duree1 si on se fie à l'exemple donné un peu plus haut).<br>
On va y ajouter les heures, minutes et secondes de l'objet reçu en paramètre, à savoir duree2. Comme on l'avait vu dans le chapitre précédent, on a exceptionnellement le droit d'accéder directement aux attributs de cet objet car on se trouve dans une méthode de la même classe. C'est un peu tordu mais ça nous aide bien (sinon il aurait fallu créer des méthodes "accesseur" comme getHeures()).<br>
<br>
Rajouter les secondes, c'est facile. Mais ensuite on doit rajouter un reste si on a dépassé 60 secondes (donc rajouter des minutes). Je ne vous explique pas comment ça fonctionne dans le détail, je vous laisse vous remuer les méninges un peu, ce n'est vraiment pas bien difficile (c'est du niveau des tous premiers chapitres du cours <img src="./cpp_files/hihi.png" alt="^^" class="smilies"> ). Vous noterez que c'est un cas où l'opérateur modulo (%), à savoir le reste de la division, est très utile. <br>
<br>
Bref, on fait de même avec les minutes, et quant aux heures c'est encore plus facile vu qu'il n'y a pas de reste (on peut dépasser les 24 heures donc pas de problème).<br>
<br>
<br>
<h3>Quelques tests</h3><br>
<br>
Pour mes tests, j'ai dû rajouter une méthode <span class="italique">afficher()</span> à la classe Duree (elle fait un cout de la durée tout bêtement). <br>
<br>
Voilà mon bôôô main <img src="./cpp_files/smile.png" alt=":)" class="smilies"> :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include "Duree.h"</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Duree</span> <span class="n">duree1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span> <span class="n">duree2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">Duree</span> <span class="n">resultat</span><span class="p">;</span>

    <span class="n">duree1</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">duree2</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>

    <span class="n">resultat</span> <span class="o">=</span> <span class="n">duree1</span> <span class="o">+</span> <span class="n">duree2</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"="</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">resultat</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Et le tant attendu résultat à l'écran :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>0h10m28s

+

0h15m2s

=

0h25m30s</pre></div></td></tr></tbody></table></div><br>
<br>
Cool, ça marche <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Bon mais ça c'était trop facile, il n'y avait pas de reste dans mon calcul. Corsons un peu les choses avec d'autres valeurs :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>1h45m50s

+

1h15m50s

=

3h1m40s</pre></div></td></tr></tbody></table></div><br>
<br>
Yeahhh ! Ca marche ! (et du premier coup pour moi nananère <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> )<br>
J'ai bien entendu testé d'autres valeurs pour être bien sûr que ça fonctionnait, mais de toute évidence ça marche très bien et mon algo est donc bon <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<br>
Bon, on en viendrait presque à oublier l'essentiel dans tout ça. Tout ce qu'on a fait là, c'était pour pouvoir écrire cette ligne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">resultat</span> <span class="o">=</span> <span class="n">duree1</span> <span class="o">+</span> <span class="n">duree2</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La surcharge de l'opérateur + nous a permis de rendre notre code clair, simple et lisible, alors qu'on aurait dû utiliser une méthode en temps normal.<br>
<br>
<h3>Télécharger le projet</h3><br>
<br>
Pour ceux d'entre vous qui n'auraient pas bien suivi la procédure, ou qui sont tout simplement fainéants ( <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ), je vous propose de télécharger le projet contenant :<br>
<br>
<ul>
<li>main.cpp</li>
<li>Duree.cpp</li>
<li>Duree.h</li>
<li>Ainsi que le fichier .cbp de Code::Blocks (si vous utilisez cet IDE comme moi)</li>
</ul><br>
<div class="centre"><span class="gros"><a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/cpp/operateurs.zip">Télécharger le projet (2 Ko)</a></span></div><br>
<br>
<h3>Bonus track #1</h3><br>
<br>
Ce qui est vraiment sympa dans tout ça, c'est que tel que notre système est fait, on peut très bien additionner plusieurs durées en même temps sans aucun problème.<br>
<br>
Par exemple, je rajoute juste une troisième durée dans mon main et je l'additionne avec les autres :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Duree</span> <span class="n">duree1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">duree2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">duree3</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
    <span class="n">Duree</span> <span class="n">resultat</span><span class="p">;</span>

    <span class="n">duree1</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">duree2</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">duree3</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>

    <span class="n">resultat</span> <span class="o">=</span> <span class="n">duree1</span> <span class="o">+</span> <span class="n">duree2</span> <span class="o">+</span> <span class="n">duree3</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"="</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">resultat</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>1h45m50s

+

1h15m50s

+

0h8m20s

=

3h10m0s</pre></div></td></tr></tbody></table></div><br>
<br>
C'est cool non vous trouvez pas ?<br>
En fait, la ligne-clé :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">resultat</span> <span class="o">=</span> <span class="n">duree1</span> <span class="o">+</span> <span class="n">duree2</span> <span class="o">+</span> <span class="n">duree3</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... revient à écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">resultat</span> <span class="o">=</span> <span class="n">duree1</span><span class="p">.</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">duree2</span><span class="p">.</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">duree3</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le tout s'imbrique dans une logique implacable et vient se placer finalement dans l'objet resultat <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<div class="rmq information">Notez que le C++ ne vous permet pas de changer la priorité des opérateurs.</div><br>
<br>
Vous voyez ici un exemple un peu plus mathématique (mais pas vraiment compliqué) de l'intérêt de la POO. En C, la même chose était faisable, mais on aurait mélangé les heures, minutes et secondes de chacun. Ici, tout est regroupé et chaque "Duree" est suffisamment intelligente pour être capable de s'additionner avec d'autres durées (et de faire bien d'autres choses encore !).<br>
<br>
<br>
<h3>Bonus track #2</h3><br>
<br>
Et pour notre seconde bonus track, sachez qu'on n'est pas obligé d'additionner des Duree avec des Duree, du temps que ça reste logique et compatible.<br>
Par exemple, on pourrait très bien additionner une Duree et un int. On considérerait dans ce cas que le nombre int est un nombre de secondes à ajouter.<br>
<br>
Cela nous permettra d'écrire par exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">resultat</span> <span class="o">=</span> <span class="n">duree</span> <span class="o">+</span> <span class="mi">30</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vive la surcharge des fonctions !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">Duree</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">secondes</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="tpetit">... mais vous croyiez tout de même pas que j'allais vous écrire l'implémentation. Allez hop hop hop au boulot ! <img src="./cpp_files/langue.png" alt=":p" class="smilies"></span><br>
<br>
<br>
<h3>Les autres opérateurs arithmétiques</h3><br>
<br>
Maintenant que vous avez vu assez en détail le cas d'un opérateur (celui d'addition pour ceux qui ont la mémoire courte <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ), vous allez voir que pour la plupart des autres opérateurs c'est très facile et qu'il n'y a pas de difficulté supplémentaire. Le tout est de s'en servir correctement pour la classe que l'on manipule.<br>
<br>
Ces opérateurs sont du même "type" que l'addition. Vous les connaissez déjà :<br>
<br>
<ul>
<li>La soustraction (-)</li>
<li>La multiplication (*)</li>
<li>La division (/)</li>
<li>Le modulo (%), c'est-à-dire le reste de la division</li>
</ul><br>
Pour surcharger ces opérateurs, rien de plus simple : créez une méthode dont le nom commence par operator suivi de l'opérateur en question. Cela donne donc :<br>
<br>
<ul>
<li><span class="courrier"><strong>operator-</strong></span></li>
<li><span class="courrier"><strong>operator*</strong></span></li>
<li><span class="courrier"><strong>operator/</strong></span></li>
<li><span class="courrier"><strong>operator%</strong></span></li>
</ul><br>
Pour notre classe Duree, il peut être intéressant de définir la soustraction (operator-).<br>
Je vous laisse le soin de le faire, en vous basant sur l'addition ça ne devrait pas être trop compliqué <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
En revanche, les autres opérateurs ne servent a priori à rien : en effet, on ne multiplie pas des durées entre elles, et on les divise encore moins. Comme quoi, tous les opérateurs ne sont pas utiles à toutes les classes : ne définissez donc que ceux qui vous seront vraiment utiles.<br>
<br>
<div class="rmq information">Si multiplier une Duree par une Duree n'a pas de sens, en revanche on peut imaginer que l'on multiplie une Duree par un nombre entier. Ainsi, l'opération <span class="courrier">2h25m50s * 3</span> est envisageable. Attention à utiliser le bon prototype, en l'occurence :<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">Duree</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="n">nombre</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div></div><br>
<br>

		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11196">Les opérateurs de comparaison (==, &gt;, &lt;, ...)</h2>
		<div class="ss_part_texte">
		Ces opérateurs vont vous permettre de comparer des objets entre eux. Le plus utilisé d'entre eux est probablement l'opérateur d'égalité (==) qui permet de vérifier si 2 objets sont égaux. C'est à vous d'écrire le code de la méthode qui détermine si les objets sont identiques, l'ordinateur ne peut pas le deviner pour vous car il ne connaît pas la "logique" de vos objets <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Tous ces opérateurs de comparaison ont un point en commun particulier : <span class="souligne">ils renvoient un booléen</span> (<strong>bool</strong>) et non un objet comme c'était le cas des autres opérateurs.<br>
<br>
<br>
<h3>L'opérateur ==</h3><br>
<br>
On va écrire l'implémentation de l'opérateur d'égalité pour commencer, vous allez voir que c'est très simple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7</pre></td><td class="code"><div class="syntax"><pre><span class="kt">bool</span> <span class="n">Duree</span><span class="o">::</span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Duree</span> <span class="o">&amp;</span><span class="n">duree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_heures</span> <span class="o">==</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_heures</span> <span class="o">&amp;&amp;</span> <span class="n">m_minutes</span> <span class="o">==</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_minutes</span> <span class="o">&amp;&amp;</span> <span class="n">m_secondes</span> <span class="o">==</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_secondes</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On compare à chaque fois un attribut de l'objet dans lequel on se trouve avec un attribut de l'objet auquel on se compare (les heures avec les heures, les minutes avec les minutes...). Si ces 3 valeurs sont identiques alors on peut considérer que les objets sont identiques et renvoyer true (vrai).<br>
<br>
Dans le main, on peut faire un simple test de comparaison pour vérifier si on a fait les choses correctement :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Duree</span> <span class="n">duree1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span> <span class="n">duree2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">28</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">duree1</span> <span class="o">==</span> <span class="n">duree2</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Les durees sont identiques"</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Les durees sont differentes"</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Les&nbsp;durees&nbsp;sont&nbsp;identiques</pre></div></td></tr></tbody></table></div><br>
<br>
<h3>L'opérateur &lt;</h3><br>
<br>
<span class="tpetit"><span class="italique">Je vous préviens on va pas tous les faire sinon on y est encore demain <img src="./cpp_files/hihi.png" alt="^^" class="smilies"></span></span><br>
<br>
Si l'opérateur == peut s'appliquer à la plupart des objets, il n'est pas certain que l'on puisse dire de tous nos objets qui est le plus grand. Tous n'ont pas forcément une notion de grandeur, prenez par exemple notre classe Personnage, il serait je pense assez stupide de vouloir vérifier si un Personnage est "inférieur" à un autre ou non (à moins que vous ne compariez les vies... à vous de voir).<br>
<br>
En tout cas avec la classe Duree on a de la chance, il est facile et "logique" de vérifier si une Duree est inférieure à une autre.<br>
<br>
Voici mon implémentation pour l'opérateur "est strictement inférieur à" (&lt;) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></td><td class="code"><div class="syntax"><pre><span class="kt">bool</span> <span class="n">Duree</span><span class="o">::</span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Duree</span> <span class="o">&amp;</span><span class="n">duree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_heures</span> <span class="o">&lt;</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_heures</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_heures</span> <span class="o">==</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_heures</span> <span class="o">&amp;&amp;</span> <span class="n">m_minutes</span> <span class="o">&lt;</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_minutes</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_heures</span> <span class="o">==</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_heures</span> <span class="o">&amp;&amp;</span> <span class="n">m_minutes</span> <span class="o">==</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_minutes</span> <span class="o">&amp;&amp;</span> <span class="n">m_secondes</span> <span class="o">&lt;</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_secondes</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Avec un peu de réflexion on finit par trouver cet algorithme, il suffit d'activer un peu ses méninges <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Vous noterez que la méthode renvoie false si les durées sont identiques : c'est normal, car il s'agit de l'opérateur "strictement inférieur à" (&lt;). En revanche, si ça avait été la méthode de l'opérateur "inférieur ou égal à" (&lt;=), il aurait fallu renvoyer true.<br>
<br>
Je vous laisse le soin de tester dans le main si ça fonctionne correctement <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<h3>Les autres opérateurs de comparaison</h3><br>
<br>
On ne va pas les implémenter ici, ça surchargerait inutilement. Par contre, je vous invite à essayer de les implémenter pour notre classe Duree, ça fera un bon exercice d'algorithmie. Il reste notamment :<br>
<br>
<ul>
<li><span class="courrier"><strong>operator&gt;</strong></span></li>
<li><span class="courrier"><strong>operator&lt;=</strong></span></li>
<li><span class="courrier"><strong>operator&gt;=</strong></span></li>
<li><span class="courrier"><strong>operator!=</strong></span></li>
</ul><br>

		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11195">L'opérateur d'affectation (=)</h2>
		<div class="ss_part_texte">
		Un des principaux pièges de ce chapitre vient de l'opérateur "=" que l'on peut lui aussi surcharger. C'est l'opérateur d'affectation, qui permet donc de donner une valeur à un objet.<br>
<br>
En fait, le "piège" vient du fait que vous risquez de le confondre avec le constructeur de copie. C'est pourquoi je vais insister plus précisément sur cet opérateur pour que vous voyiez bien la différence et ce à quoi il sert.<br>
<br>
<br>
<h3>Rappel : le constructeur de copie</h3><br>
<br>
Quand le constructeur de copie est-il appelé ? Vous vous en souvenez ?<br>
Il y a en fait plusieurs cas, les 3 principaux étant :<br>
<br>
<h4>1/ Lors de l'appel explicite au constructeur de copie</h4><br>
<br>
Lorsque vous déclarez un objet et que vous indiquez en paramètre un autre objet, le constructeur de copie est appelé :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Objet</span> <span class="n">monObjet</span><span class="p">;</span>
<span class="n">Objet</span> <span class="n">copieObjet</span><span class="p">(</span><span class="n">monObjet</span><span class="p">);</span> <span class="c1">// Appel du constructeur de copie</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>2/ Lors d'une affectation au moment de la déclaration</h4><br>
<br>
C'est pareil, sauf qu'on utilise le signe "=" ce qui rend le code plus lisible :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Objet</span> <span class="n">monObjet</span><span class="p">;</span>
<span class="n">Objet</span> <span class="n">copieObjet</span> <span class="o">=</span> <span class="n">monObjet</span><span class="p">;</span> <span class="c1">// Appel du constructeur de copie</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>3/ Lors d'un appel de fonction qui prend un objet en paramètre</h4><br>
<br>
Si la fonction prend un objet (et non pas un pointeur ni une référence) en paramètre, l'objet est "copié" spécialement pour la fonction. Il y a appel du constructeur de copie avant le début de la fonction.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">maFonction</span> <span class="p">(</span><span class="n">Objet</span> <span class="n">copieObjet</span><span class="p">)</span> <span class="c1">// Appel du constructeur de copie</span>
<span class="p">{</span>

<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
<h3>Le rapport avec la surcharge de l'opérateur = ?</h3><br>
<br>
Si elle existe, la méthode <span class="courrier"><strong>operator=</strong></span> sera appelée dès qu'on essaie d'affecter une valeur à notre objet.<br>
Par exemple, si à un moment dans le code on affecte à notre objet la valeur d'un autre objet :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">monObjet</span> <span class="o">=</span> <span class="n">unAutreObjet</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Mais attends... C'est pas le constructeur de copie qui sera appelé là ?</div><br>
<br>
Non justement, c'est là qu'est le piège. Dans le cas n°2 vu plus haut, c'est lors de la déclaration de l'objet qu'on fait une affectation. Dans ce cas, c'est le constructeur de copie qui est appelé.<br>
<span class="souligne">En revanche</span>, dans tout le reste du code, si on affecte une valeur à notre objet,  c'est cette fois la méthode operator= qui sera appelée.<br>
<br>
Donc en résumé :<br>
<br>
<ul>
<li>Lors de la déclaration (création) de notre objet, si vous utilisez le signe "=" pour lui affecter immédiatement la valeur d'un autre objet, c'est le <strong>constructeur de copie</strong> qui est appelé.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Objet</span> <span class="n">copieObjet</span> <span class="o">=</span> <span class="n">monObjet</span><span class="p">;</span> <span class="c1">// Déclaration de l'objet</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
</li>
<li>Après, à n'importe quel autre moment, si vous décidez d'affecter la valeur d'un autre objet à votre objet, c'est la méthode surchargeant l'opérateur = (<strong>operator=</strong>) qui sera appelée.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">copieObjet</span> <span class="o">=</span> <span class="n">monObjet</span><span class="p">;</span> <span class="c1">// Affectation APRES la déclaration</span>
</pre></div>
</td></tr></tbody></table></div></li>
</ul><br>
<br>
J'espère avoir été suffisamment clair <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Cela signifie donc qu'en général vous devrez écrire le code du constructeur de copie et de l'opérateur "=" en même temps si vous voulez qu'à n'importe quel moment dans votre code on puisse faire une affectation sur votre objet.<br>
<br>
<br>
<h3>Implémentation de la méthode operator= pour la classe Duree</h3><br>
<br>
Puisqu'on y est, implémentons la méthode pour la classe Duree et on sera tranquille <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">Duree</span> <span class="n">Duree</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Duree</span> <span class="o">&amp;</span><span class="n">duree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_heures</span> <span class="o">=</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_heures</span><span class="p">;</span>
    <span class="n">m_minutes</span> <span class="o">=</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_minutes</span><span class="p">;</span>
    <span class="n">m_secondes</span> <span class="o">=</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_secondes</span><span class="p">;</span>

    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous noterez que la méthode renvoie l'objet lui-même. En effet, souvenez-vous, this est un pointeur vers l'objet. Si on écrit *this, c'est donc l'objet lui-même que l'on renvoie. Cela permet de traiter le cas où on chaîne les affectations :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">objet1</span> <span class="o">=</span> <span class="n">objet2</span> <span class="o">=</span> <span class="n">objet3</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce n'est pas très courant mais mieux vaut être prévoyant.<br>
<br>
A part ça c'est tout bête. Et dans le même temps, si ce n'est pas fait, je vous conseille d'écrire le constructeur de copie pour que le signe "=" fonctionne dans tous les cas. Le code devrait être quasiment le même.<br>
<br>
<div class="rmq information">Le compilateur écrit un opérateur d'affectation par défaut automatiquement, mais c'est un opérateur "bête". Cet opérateur bête se contente de copier les valeurs des attributs un à un dans le nouvel objet.<br>
Je sais ce que vous allez me dire : c'est exactement ce qu'on vient de faire ! En effet, dans notre cas réécrire l'opérateur d'affectation n'était donc pas nécessaire. En revanche, ça l'aurait été si on avait eu par exemple des pointeurs et qu'il avait fallu faire des allocations de mémoire, afin d'éviter les problèmes expliqués dans le chapitre précédent.</div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11194">Les opérateurs de flux (&lt;&lt;, &gt;&gt;)</h2>
		<div class="ss_part_texte">
		Parmi les nombreuses choses qui ont dû vous choquer quand vous avez commencé le C++, dans la catégorie "<span class="italique">oulah c'est bizarre ça mais on verra plus tard</span>", il y a les flux d'entrée-sortie. Derrière ce nom barbare se cachent ces petits symboles <span class="courrier"><strong>&gt;&gt;</strong></span> et <span class="courrier"><strong>&lt;&lt;</strong></span>.<br>
Quand les utilise-t-on ? Allons allons, vous n'allez pas me faire croire que vous avez la mémoire si courte <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Coucou !"</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">variable</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Figurez-vous justement que &lt;&lt; et &gt;&gt; sont des opérateurs. Le code ci-dessus revient donc à écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">cout</span><span class="p">.</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="s">"Coucou !"</span><span class="p">);</span>
<span class="n">cin</span><span class="p">.</span><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">variable</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On a donc fait appel aux méthodes operator&lt;&lt; et operator&gt;&gt; des objets cout et cin ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Définir ses propres flux pour cout</h3><br>
<br>
Nous allons ici nous intéresser plus particulièrement à l'opérateur &lt;&lt; utilisé avec cout.<br>
Les opérateurs de flux sont définis par défaut pour les types de variables int, double, char*, ainsi que pour les objets comme string. C'est ainsi que l'on peut aussi bien écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Coucou !"</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... que :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="tpetit">(et c'est là qu'on dit "merci la surcharge des méthodes !" <img src="./cpp_files/langue.png" alt=":p" class="smilies"> )</span><br>
<br>
Bon, le problème c'est que cout ne connaît pas votre classe flambant neuve Duree, et donc qu'il ne possède pas de méthode surchargée pour les objets de ce type. On ne peut donc pas écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">Duree</span> <span class="n">chrono</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">chrono</span><span class="p">;</span> <span class="c">// Erreur : il n'existe pas de méthode cout.operator&lt;&lt;(Duree &amp;duree)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Qu'à cela ne tienne, nous allons écrire cette méthode !<br>
<br>
<div class="rmq question">Quoi ?! Mais on ne peut pas modifier le code de cout non ?</div><br>
<br>
Déjà si vous vous êtes posé la question, bravo, c'est que vous commencez à bien vous repérer. En effet, c'est une méthode de la classe ostream (dont l'objet cout est une instance) que l'on doit définir, et on n'a pas accès au code correspondant.<br>
<br>
<div class="rmq information">Lorsque vous incluez &lt;iostream&gt;, un objet cout est automatiquement déclaré comme ceci :<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">ostream</span> <span class="n">cout</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
ostream est la classe, cout est l'objet. C'est donc la classe ostream qu'il faudrait théoriquement retoucher pour pouvoir créer une nouvelle surcharge de l'opérateur &lt;&lt;... mais on n'a pas le droit car on n'a pas accès au code définissant la classe ostream !</div><br>
Par contre, il est possible de créer de simples fonctions (en dehors des objets) pour surcharger des opérateurs. C'est un peu particulier je le reconnais, mais on n'a pas le choix dans le cas présent.<br>
<br>
<br>
<h3>Implémentation d'operator&lt;&lt; en tant que fonction</h3><br>
<br>
C'est donc une surcharge d'opérateur un peu particulière que nous allons faire : nous allons écrire une fonction, en dehors de toute classe donc, et non pas une méthode.<br>
Comme c'est un cas assez particulier et que vous n'aurez pas à la reproduire tous les jours, je vous recommande de me suivre pas à pas.<br>
<br>
Commencez par écrire cette fonction :<br>
<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">Duree</span> <span class="o">&amp;</span><span class="n">duree</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_heures</span> <span class="o">&lt;&lt;</span> <span class="s">"h"</span> <span class="o">&lt;&lt;</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_minutes</span> <span class="o">&lt;&lt;</span> <span class="s">"m"</span> <span class="o">&lt;&lt;</span> <span class="n">duree</span><span class="p">.</span><span class="n">m_secondes</span> <span class="o">&lt;&lt;</span> <span class="s">"s"</span><span class="p">;</span> <span class="c">// Erreur</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous devriez la placer <span class="souligne">avant le main</span> (ou tout du moins son prototype), sinon le main ne la connaîtra pas.<br>
<br>
Le premier paramètre (référence sur un objet de type ostream) qui vous sera automatiquement passé est en fait l'objet cout (que l'on appelle ici out dans la fonction pour éviter les conflits de nom). Le second paramètre est une référence vers l'objet de type Duree que vous tentez d'afficher en utilisant le flux &lt;&lt;.<br>
<br>
La fonction doit récupérer les attributs qui l'intéressent dans l'objet et les envoyer à l'objet "out" (qui n'est autre que cout). Ensuite, elle retourne cet objet, ce qui permet de pouvoir faire une chaîne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">duree1</span> <span class="o">&lt;&lt;</span> <span class="n">duree2</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Si je compile ça plante ! Ca me dit que je n'ai pas le droit d'accéder aux attributs de l'objet duree depuis la fonction !</div><br>
<br>
Eh oui c'est parfaitement normal, car on est à l'<strong>extérieur </strong>de la classe, et les attributs m_heures, m_minutes et m_secondes sont privés. On ne peut donc pas les lire de cet endroit du code.<br>
<br>
2 solutions :<br>
<ul>
<li>Ou bien vous créez des accesseurs comme on l'a vu (ces fameuses méthodes getHeures, getMinutes...), ça marche bien mais c'est un peu ennuyeux à écrire</li>
<li>Ou bien vous utilisez la technique que je vais vous montrer <img src="./cpp_files/clin.png" alt=";)" class="smilies"></li>
</ul><br>
On va opter ici pour la seconde solution <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Changez la 1ère ligne de la fonction comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">Duree</span> <span class="o">&amp;</span><span class="n">duree</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">duree</span><span class="p">.</span><span class="n">afficher</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="p">;</span> <span class="c">// &lt;- Changement ici</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Et rajoutez une méthode afficher dans la classe Duree.<br>
Prototype à mettre dans Duree.h :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">afficher</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Implémentation de la méthode dans Duree.cpp :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Duree</span><span class="o">::</span><span class="n">afficher</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">m_heures</span> <span class="o">&lt;&lt;</span> <span class="s">"h"</span> <span class="o">&lt;&lt;</span> <span class="n">m_minutes</span> <span class="o">&lt;&lt;</span> <span class="s">"m"</span> <span class="o">&lt;&lt;</span> <span class="n">m_secondes</span> <span class="o">&lt;&lt;</span> <span class="s">"s"</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On passe donc le relai à une méthode à l'intérieur de la classe, qui, elle, a le droit d'accéder aux attributs. La méthode prend en paramètre la référence vers l'objet out pour pouvoir lui envoyer les valeurs qui nous intéressent. Ce qu'on n'a pas pu faire dans la fonction operator&lt;&lt;, on le donne à faire à une méthode de la classe Duree.<br>
<br>
<br>
<h3>Ouf ! Maintenant dans le main, que du bonheur !</h3><br>
<br>
Bon, c'était un peu gymnastique, mais maintenant c'est que du bonheur <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Vous allez pouvoir dans votre main afficher vos objets de type Duree très simplement :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Duree</span> <span class="n">duree1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span> <span class="n">duree2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">33</span><span class="p">);</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">duree1</span> <span class="o">&lt;&lt;</span> <span class="s">" et "</span> <span class="o">&lt;&lt;</span> <span class="n">duree2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>2h25m28s&nbsp;et&nbsp;0h16m33s</pre></div></td></tr></tbody></table></div><br>
<br>
Enfantin <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Comme quoi, on prend un peu de temps pour écrire la classe, mais ensuite quand on doit l'utiliser c'est extrêmement simple !<br>
<br>
<br>
Si vous avez un peu du mal à vous repérer dans le code, ce que je peux comprendre, je mets à votre disposition le projet complet comme tout à l'heure dans ce zip :<br>
<br>
<div class="centre"><span class="gros"><a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/cpp/operateurs2.zip">Télécharger les sources (2 Ko)</a></span></div>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Il y a énormément d'autres opérateurs surchargeables en C++, en fait presque tout peut être surchargé. Chaque opérateur étant particulier, il serait impossible de tout voir dans ce chapitre. Au moins avons-nous pu voir les principaux <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
A titre d'information, sachez qu'il est aussi possible de surcharger :<br>
<br>
<ul>
<li><strong>new et delete</strong> : l'allocation dynamique, s'il y a besoin de faire des vérifications spéciales lors d'une allocation de mémoire</li>
<li><strong>&amp; et *</strong> : opérateurs d'indirection et de déréférencement pour manipuler les pointeurs</li>
<li><strong>(int)</strong> et compagnie : opérateurs de transtypage</li>
<li><strong>++ et --</strong> : opérateurs d'incrémentation et de décrémentation</li>
<li><strong>[]</strong> : pour parcourir l'objet comme un tableau. Le type string s'en sert d'ailleurs pour que l'on puisse écrire monString[3] et ainsi accéder au 4ème caractère comme si c'était un tableau, alors que c'est en fait un objet. Malin, il fallait y penser !</li>
<li>etc.</li>
</ul><br>
Bref, vous l'aurez compris, la surcharge des opérateurs est un outil puissant, pour ne pas dire très puissant si on commence à s'en servir sur l'allocation dynamique, le transtypage ou encore les opérateurs d'indirection et de déréférencement.<br>
<br>
Mon conseil serait : ne faites la surcharge que si elle vous sera vraiment utile. C'est certes un outil puissant, mais il n'est pas nécessaire de le mettre à toutes les sauces. Votre classe doit proposer des fonctionnalités utiles et non pas farfelues !
	</div>
	
	<hr>
	<h1 id="chap_11213">TP : La POO en pratique avec ZString</h1>
	<div id="chap_intro">
	Vous avez dû vous en rendre compte au fil des chapitres : la programmation orientée objet n'est pas simple à comprendre. Il faut un temps avant d'arriver à imaginer que l'on manipule des "<strong>objets</strong>". Les objets sont des sortes de boîtes qui contiennent un <span class="orange">ensemble de variables</span> et de <span class="marron">fonctions qui modifient ces variables</span>.<br>
<br>
On peut voir la POO de 2 côtés :<br>
<ul>
<li><strong><span class="vertf">Le côté utilisateur</span></strong> : cela correspond à utiliser les classes en créant des objets. C'est là que la POO se révèle simple et agréable.</li>
<li><strong><span class="rouge">Le côté créateur</span></strong> : cela correspond à créer les classes. C'est le plus délicat car il faut bien réfléchir avant de se lancer à coder.</li>
</ul><br>
Nous avons déjà vu la POO côté utilisateur avec l'exemple de la classe string fournie avec la bibliothèque standard du C++.<br>
Ce que je vous propose dans ce TP, c'est de voir maintenant le côté créateur en pratique. <strong>Nous allons recréer la classe string</strong>.<br>
<br>
Vous vous demandez peut-être : pourquoi refaire la classe string si elle existe déjà ? Tout simplement parce que c'est un très bon exercice et que ça va beaucoup vous faire progresser.<br>
<br>
Comme je sais que la POO n'est pas simple à appréhender quand on débute, je ne vous laisserai pas vous débrouiller tous seuls dans ce TP. Au contraire, je vais vous aider tout au long de la création de notre classe.<br>
<br>
<div class="rmq information">Ce qui compte, c'est de lire, comprendre, et essayer de programmer. Si vous n'arrivez pas à programmer comme il faut du premier coup, ce n'est pas grave.<br>
Si vous vous dites "<span class="italique">Jamais je n'aurais pu deviner qu'il fallait faire comme ça</span>", ce n'est pas grave non plus. C'est le métier qui rentre. Faites l'effort de comprendre comment j'ai fait, et ce sera déjà très bien <img src="./cpp_files/smile.png" alt=":)" class="smilies"></div>
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11212">Notre objectif</h2>
		<div class="ss_part_texte">
		Notre objectif est de recréer la classe string de la bibliothèque standard du C++.<br>
C'est une classe qui gère les chaînes de caractères. Nous allons donc beaucoup manipuler les chaînes de caractères dans ce chapitre.<br>
<br>
<div class="rmq erreur">Il est important que vous soyez au point vis à vis des chaînes de caractères. Si vous ne vous souvenez plus qu'une chaîne de caractères se termine par un \0 de fin de chaîne par exemple, je vous invite à <strong><a href="http://www.siteduzero.com/tuto-3-4144-1-les-chaines-de-caracteres.html">relire le chapitre sur les chaînes de caractères</a></strong> vu dans le cours de C.<br>
<strong>C'est important, j'insiste</strong>. Prenez le temps de revoir ce chapitre si vous en avez besoin.</div><br>
<br>
Vous avez déjà appris à <a href="http://www.siteduzero.com/tuto-3-13435-1-la-magie-de-la-poo-par-l-exemple-string.html">utiliser la classe "string"</a> dans un chapitre précédent de ce cours. Vous avez vu à quel point c'était simple : c'est la classe qui gère tout pour nous. Plus besoin de créer un tableau de la bonne taille, c'est la classe qui s'en occupe. Si la taille de la chaîne change, le tableau de caractères est automatiquement réalloué par la classe.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">string</span> <span class="n">maChaine</span> <span class="o">=</span> <span class="s">"Bonjour"</span><span class="p">;</span> <span class="c">// Crée un tableau de caractères de 8 cases (\0 compris)</span>
<span class="n">maChaine</span> <span class="o">=</span> <span class="s">"Bonjour Mateo"</span><span class="p">;</span> <span class="c">// Change automatiquement la taille du tableau : 14 cases</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Un objet string n'est au final rien d'autre qu'<strong>un objet qui contient un tableau de char</strong> (pour stocker la chaîne de caractères). La particularité c'est que c'est la classe qui gère la taille de ce tableau, l'utilisateur n'a pas à s'en soucier.<br>
<br>
Quand vous modifiez le contenu de la chaîne, le tableau de char que l'objet <span class="italique">maChaine </span>contient est réalloué pour s'adapter à la nouvelle taille. Schématiquement il se passe donc ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/107347.png" alt="Réallocation dans un string"></div><br>
<br>
D'autre part, on bénéficie des outils puissants du C++ comme la surcharge des opérateurs. Cela nous permet d'écrire des choses intuitives comme :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">string</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Bonjour"</span><span class="p">;</span>
<span class="n">string</span> <span class="n">maChaine</span> <span class="o">=</span> <span class="n">message</span> <span class="o">+</span> <span class="s">" Mateo"</span><span class="p">;</span> <span class="c">// Vaudra "Bonjour Mateo"</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est ce genre de choses que je veux que l'on arrive à refaire. On va y aller méthodiquement en commençant par écrire les constructeurs, le destructeur, puis on rajoutera des fonctionnalités à la classe en créant de nouvelles méthodes (comme une méthode pour connaître la longueur de la chaîne actuelle). On verra enfin la surcharge des opérateurs en dernier.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11211">Quelques préparatifs</h2>
		<div class="ss_part_texte">
		Bon assez bavardé, on a du pain sur la planche pour arriver à faire tout ça.<br>
<br>
<h3>Choisir un nom</h3><br>
<br>
Il va falloir commencer par donner un nom à notre classe qui imite "string". On ne peut pas l'appeler "string" puisqu'il existe déjà une classe de ce nom dans la bibliothèque standard.<br>
Je vous propose de l'appeler ZString, pour "Zéro String" <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="rmq information">Par convention, la plupart des programmeurs mettent au moins la première lettre du nom de leurs classes en majuscules. C'est ce que je fais ici. Bon j'ai mis aussi la seconde lettre pour faire joli, j'avoue.<br>
La classe "string" de la bibliothèque standard est un mauvais exemple à ne pas suivre <img src="./cpp_files/langue.png" alt=":p" class="smilies"></div><br>
<br>
<h3>Créer un nouveau projet</h3><br>
<br>
Pour faire ce TP, vous allez devoir créer un nouveau projet. Utilisez l'IDE que vous voulez, moi pour ma part vous savez que j'utilise Code::Blocks <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Demandez à créer un <strong>nouveau projet console C++</strong>.<br>
Ce projet sera constitué de 3 fichiers que vous pouvez déjà créer :<br>
<br>
<ul>
<li><strong>main.cpp</strong> : ce fichier contiendra uniquement la fonction main. Dans la fonction main, nous créerons des objets basés sur notre classe ZString pour tester son fonctionnement. <span class="vertf">C'est le côté utilisateur</span>.</li>
<li><strong>ZString.h</strong> : ce fichier contiendra la définition de notre classe ZString avec la liste de ses attributs et les prototypes de ses méthodes. <span class="rouge">C'est une partie du côté créateur</span>.</li>
<li><strong>ZString.cpp</strong> : ce fichier contiendra l'implémentation des méthodes de la classe ZString, c'est-à-dire le "code" à l'intérieur des méthodes. <span class="rouge">C'est l'autre partie du côté créateur</span>.</li>
</ul><br>
<div class="rmq attention">Faites attention aux noms des fichiers et en particulier aux majuscules et minuscules. Les fichiers ZString.h et ZString.cpp commencent par 2 lettres majuscules, si vous écrivez "zstring" ou encore "Zstring" ça ne marchera pas et vous aurez des problèmes.</div><br>
<br>
<h3>Le code de base de chaque fichier</h3><br>
<br>
Nous allons écrire un peu de code dans chacun de ces fichiers. Juste le strict minimum pour pouvoir commencer.<br>
<br>
<br>
<h4>main.cpp</h4><br>
<br>
Ce fichier va contenir la fonction main, ainsi que les includes de iostream (pour faire des cout) et de ZString.h (pour pouvoir utiliser la classe ZString !).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include "ZString.h"</span>
 
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ZString</span> <span class="n">chaine</span><span class="p">;</span> <span class="c">// Crée un objet de type ZString (appel du constructeur par défaut)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Comme vous pouvez le voir, le main se contentera dans un premier temps de créer un objet de type ZString appelé "chaine". Les objets commencent par une lettre minuscule par convention.<br>
<br>
Ce code provoquera l'appel du constructeur par défaut de la classe ZString. Le constructeur est la méthode qui est appelée à chaque fois que l'on crée un nouvel objet, et là on parle de constructeur par défaut car on n'envoie aucun paramètre.<br>
<br>
Le main est court mais on le complètera par la suite pour tester notre classe au fur et à mesure qu'on lui rajoutera des possibilités.<br>
<br>
<h4>ZString.h</h4><br>
<br>
Ce fichier contiendra la définition de la classe ZString. Il fait aussi un include de iostream pour nos besoins futurs (nous aurons besoin de faire des cout dans la classe les premiers temps, ne serait-ce que pour débugger notre classe).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef DEF_ZSTRING</span>
<span class="cp">#define DEF_ZSTRING</span>
<span class="cp"> </span>
<span class="cp">#include &lt;iostream&gt;</span>
 
<span class="k">class</span> <span class="nc">ZString</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
 
    <span class="k">private</span><span class="o">:</span>
 
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous noterez que je n'ai pas oublié de faire un #ifndef pour vérifier que le header n'a pas été inclus plusieurs fois. C'est une <a href="http://www.siteduzero.com/tuto-3-4200-1-le-preprocesseur.html#ss_part_4">technique de protection</a> que nous avons vue dans le cours de C et que je vous recommande d'utiliser dans chacun de vos headers.<br>
<br>
La classe ZString est pour l'instant vide. Je l'ai séparée en deux : la partie publique et la partie privée.<br>
La partie publique est accessible de l'extérieur de la classe (par l'utilisateur) et la partie privée n'est accessible qu'à l'intérieur de la classe elle-même.<br>
<br>
Je vous rappelle que la règle d'or est que <strong>tous les attributs d'une classe doivent être privés</strong>. C'est le principe d'<strong>encapsulation</strong>.<br>
Les méthodes, elles, peuvent être soit publiques soit privées selon les cas (elles sont souvent publiques, mais il arrive qu'on ait besoin de créer des méthodes privées).<br>
<br>
<br>
<h4>ZString.cpp</h4><br>
<br>
Ce fichier doit contenir l'implémentation des méthodes de la classe. Pour l'instant, nous n'avons écrit aucune méthode, mais nous allons au moins faire un include de ZString.h, c'est le strict minimum <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "ZString.h"</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est tout !<br>
<br>
<br>
<h3>De quels attributs notre classe a-t-elle besoin ?</h3><br>
<br>
Comme vous le savez, une classe est constituée d'attributs et de méthodes.<br>
Les attributs sont des variables. Les méthodes interagissent sur ces variables.<br>
<br>
De quels attributs notre classe ZString doit-elle être constituée, vous en avez pas une petite idée hmm ?<br>
<br>
Réfléchissez, le but de notre classe est de gérer de manière intelligente une chaîne de caractères. Or, vous savez qu'une chaîne de caractères se présente en mémoire sous la forme d'un <strong>tableau de char</strong>, terminé par un \0 qui signifie "fin de chaîne" (j'espère que vous savez tout ça, sinon il est grand temps d'aller relire le <a href="http://www.siteduzero.com/tuto-3-4144-1-les-chaines-de-caracteres.html">chapitre sur les chaînes de caractères</a> !).<br>
<br>
Nous aurons donc besoin au moins d'un tableau de char en attribut.<br>
En plus de cela, il me semble nécessaire de mettre la <strong>taille de la chaîne de caractères (un int)</strong> en attribut aussi. Vous me direz : on peut toujours la recalculer (il suffit de compter le nombre de caractères jusqu'à l'\0), mais je pense que c'est une bonne idée de garder la taille de la chaîne en mémoire pour éviter d'avoir à la recalculer à chaque fois.<br>
<br>
Nous allons donc modifier notre ZString.h pour y ajouter ces 2 attributs :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef DEF_ZSTRING</span>
<span class="cp">#define DEF_ZSTRING</span>
<span class="cp"> </span>
<span class="cp">#include &lt;iostream&gt;</span>
 
<span class="k">class</span> <span class="nc">ZString</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
 
    <span class="k">private</span><span class="o">:</span>
<span class="ln-xtra">        <span class="kt">char</span> <span class="o">*</span><span class="n">m_chaine</span><span class="p">;</span> <span class="c">// Tableau de caractères (contiendra la chaîne)</span></span>
<span class="ln-xtra">        <span class="kt">int</span> <span class="n">m_longueur</span><span class="p">;</span> <span class="c">// Longueur de la chaîne</span></span>
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Nos attributs commencent toujours par le préfixe "m_". C'est une bonne habitude de programmation que je vous ai enseignée dans les chapitres précédents <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Cela nous permettra par la suite de savoir si on est en train de manipuler un attribut de la classe ou une simple variable "locale" à une méthode.<br>
<br>
<div class="rmq question">Hé ! Tu avais dit qu'il fallait créer un tableau de char pour gérer la chaîne ! Or là je ne vois qu'un pointeur de char, pourquoi as-tu fait ça ?</div><br>
<br>
J'attendais une question de ce genre <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Je vais vous répondre par une autre question : quelle taille vous donneriez à ce tableau de char vu que vous ne connaissez pas la taille de la chaîne à stocker ?<br>
<br>
Vous pourriez certes me dire "<span class="italique">Bah il suffit de créer un très grand tableau de char, par exemple m_chaine[10000]</span>".<br>
Mais ce serait mauvais. Non, ce serait même carrément nul :<br>
<br>
<ul>
<li>Rien ne vous dit que personne ne dépassera jamais les 10 000 caractères.</li>
<li>Ca fait beaucoup de mémoire inutilisée pour rien.</li>
<li>Notre but est justement d'allouer un tableau en mémoire qui fasse pile la taille nécessaire.</li>
</ul><br>
Donc comme on ne sait pas la taille que fera le tableau dans la suite du programme, on crée juste un pointeur sur char. C'est nous qui allouerons la taille nécessaire par la suite, dans le constructeur (c'est son rôle, initialiser les attributs).<br>
<br>
D'ailleurs en parlant de constructeur, je crois qu'il est temps de s'en occuper maintenant que nous nous sommes mis d'accord sur les attributs que la classe allait manipuler <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11210">Constructeurs et destructeur</h2>
		<div class="ss_part_texte">
		Nous allons commencer par écrire les méthodes les plus importantes d'une classe : les constructeurs et le destructeur.<br>
<br>
J'ai bien dit LES constructeurs, car on peut surcharger le constructeur (en faire plusieurs versions), et LE destructeur, car celui-ci ne peut pas être surchargé.<br>
<br>
Je vous propose de créer 3 constructeurs et le destructeur pour commencer :<br>
<br>
<ul>
<li><strong>Le constructeur par défaut</strong> (celui qui ne prend pas de paramètre). Si l'utilisateur se sert de ce constructeur, la chaîne sera vide  : "".</li>
<li><strong>Un autre constructeur</strong> (une surcharge) qui prendra en paramètre une chaîne de caractères pour initialiser la ZString avec une chaîne. La ZString contiendra donc dès le départ la chaîne qu'on lui aura envoyée.<br>
Ce constructeur recevra en paramètre un tableau de char (un char *) correspondant à la chaîne  envoyée par l'utilisateur pour initialiser la ZString.</li>
<li><strong>Le constructeur de copie</strong> : quelle que soit la classe qu'on écrit, il est toujours conseillé d'écrire le constructeur de copie car il est souvent nécessaire. C'est un constructeur qui prend une référence vers un objet du même type (un const ZString &amp;).</li>
<li><strong>Le destructeur</strong> pour supprimer le tableau de char <span class="italique">m_chaine</span> avant que l'objet ne soit lui-même supprimé. Cela permet d'éviter les fuites de mémoire.</li>
</ul><br>
<br>
On créera d'autres constructeurs par la suite, mais pour l'instant nous commençons simplement <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Commençons par ajouter les prototypes de nos méthodes dans <strong>ZString.h</strong> :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef DEF_ZSTRING</span>
<span class="cp">#define DEF_ZSTRING</span>
<span class="cp"> </span>
<span class="cp">#include &lt;iostream&gt;</span>
 
<span class="k">class</span> <span class="nc">ZString</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
<span class="ln-xtra">        <span class="n">ZString</span><span class="p">();</span> <span class="c">// Constructeur par défaut (crée une chaîne vide "")</span></span>
<span class="ln-xtra">        <span class="n">ZString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">);</span> <span class="c">// Constructeur surchargé (crée la chaîne envoyée)</span></span>
<span class="ln-xtra">        <span class="n">ZString</span><span class="p">(</span><span class="k">const</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span><span class="p">);</span> <span class="c">// Constructeur de copie</span></span>
<span class="ln-xtra">        <span class="o">~</span><span class="n">ZString</span><span class="p">();</span> <span class="c">// Destructeur (détruit le tableau de char pour libérer la mémoire)</span></span>
 
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">m_chaine</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m_longueur</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Bien, voilà qui est fait.<br>
Il faut maintenant implémenter ces méthodes, rendez-vous dans le fichier ZString.cpp.<br>
<br>
<br>
<h3>Le constructeur par défaut ZString()</h3><br>
<br>
On commence par implémenter le constructeur par défaut. Je vous rappelle que le but d'un constructeur est d'initialiser les attributs de la classe. La question est : <span class="italique">quelle valeur on va leur mettre</span> ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"><br>
<br>
Comme on travaille sur le constructeur par défaut, vous pouvez voir que celui-ci ne prend pas de paramètre. <span class="souligne">C'est le constructeur qui est appelé lorsqu'on crée un nouvel objet de type ZString sans préciser de paramètre</span>.<br>
<br>
C'est précisément ce que l'on a fait dans le main.cpp que je vous ai donné plus haut :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">chaine</span><span class="p">;</span> <span class="c">// Appel du constructeur par défaut (aucun paramètre envoyé)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Que doit contenir la chaîne lorsqu'on n'envoie rien ?<br>
Bah... rien <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Si l'utilisateur n'envoie aucun texte, nous n'allons rien mettre dans l'attribut m_chaine. Il est donc inutile d'allouer un tableau de char (y'a rien à stocker !).<br>
<br>
Ce qu'on va faire en revanche, c'est mettre le pointeur <span class="italique">m_chaine</span> à NULL pour indiquer qu'il ne pointe sur rien pour le moment.<br>
Quant à la longueur de la chaîne <span class="italique">m_longueur</span>, bah elle vaudra 0 vu que pour l'instant notre objet ne contiendra aucune chaîne en mémoire <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
On peut donc écrire dans <strong>ZString.cpp</strong> :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span><span class="o">::</span><span class="n">ZString</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">m_longueur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Notez que, comme je vous l'avais expliqué, on peut aussi initialiser les attributs avec une liste d'initialisation, comme ceci :<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span><span class="o">::</span><span class="n">ZString</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_chaine</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">m_longueur</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
 
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
Ce code revient au même que celui que je vous ai donné plus haut. Le seul problème de la liste d'initialisation est qu'elle ne convient pas dans tous les cas, comme on le verra plus loin.</div><br>
<br>
<h3>Le constructeur ZString(const char *)</h3><br>
<br>
Le constructeur par défaut était simple.<br>
Les choses se corsent quand l'utilisateur envoie un paramètre lorsqu'il crée la chaîne dans main.cpp :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... ou encore (ça revient au même) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">chaine</span> <span class="o">=</span> <span class="s">"Bonjour"</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Lorsqu'un objet est créé de cette façon, cela appelle automatiquement le constructeur qui correspond à la signature ZString(const char *) car le fait d'écrire un texte entre guillemets dans le code source provoque la création d'un tableau de char par le compilateur.<br>
<br>
Il va falloir écrire le code de ce constructeur dans ZString.cpp...<br>
Mais là les choses se corsent, suivez-moi bien.<br>
<br>
Notre but est d'initialiser nos attributs <span class="italique">m_chaine</span> et <span class="italique">m_longueur</span> correctement, on est bien d'accord ? C'est le but du constructeur d'initialiser des attributs.<br>
<br>
Le problème c'est que :<br>
<br>
<ul>
<li><strong>Pour <span class="courrier">m_longueur</span></strong> : on ne connaît pas la taille de la chaîne qu'on nous envoie ! Impossible d'initialiser m_longueur si on ne connaît pas la taille de la chaîne. On pourrait utiliser la fonction strlen de la bibliothèque C, mais notre but est que notre classe ZString soit autonome et qu'elle n'ait pas besoin de la bibliothèque du C (on est en C++ que diable !). Solution : il va falloir réécrire la fonction strlen() pour pouvoir calculer la longueur de la chaîne.</li>
<li><strong>Pour <span class="courrier">m_chaine</span></strong> : on nous envoie un tableau de char (appelé chaine), mais il ne faut surtout pas écrire <span class="courrier">m_chaine = chaine;</span> ! Pourquoi ? Parce que en faisant cela, vous faites pointer notre attribut m_chaine vers un tableau qui nous a été envoyé par l'utilisateur. Qu'est-ce qui vous dit que l'utilisateur ne va pas supprimer ce tableau par la suite ? Dans un tel cas, votre pointeur m_chaine pointerait sur un tableau qui n'existe plus ! Solution : copier le tableau qu'on nous envoie et affecter m_chaine à ce tableau pour s'assurer que personne d'autre ne pourra supprimer ce tableau.</li>
</ul><br>
Pour le problème de l'initialisation de m_longueur je pense que vous avez compris : on ne connaît pas la longueur de la chaîne et il va nous falloir écrire une fonction qui la calcule manuellement en comptant le nombre de caractères.<br>
<br>
Par contre, je pense que le problème de l'initialisation de m_chaine mérite plus d'explications (et même un schéma en fait).<br>
<br>
Tout d'abord, il faut savoir que lorsqu'on envoie au constructeur une chaîne de caractères entre guillemets, un tableau de char est automatiquement créé en mémoire. Celui-ci est ensuite passé en paramètre au constructeur :<br>
<br>
<div class="centre"><img src="./cpp_files/107735.png" alt="Schema constructeur ZString"></div><br>
<br>
L'erreur qu'on serait tenté de faire, c'est d'assigner l'attribut m_chaine directement au tableau chaine qu'on nous envoie, avec un code comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span><span class="o">::</span><span class="n">ZString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">;</span> <span class="c">// Très mauvaise idée !</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Pourquoi ? Parce qu'en faisant pointer notre attribut m_chaine vers le tableau de char qu'on nous a envoyé, on prend le risque que ce tableau de char soit supprimé par le main !<br>
Dans ce cas, si le tableau est supprimé par le main, notre attribut m_chaine ne pointera plus sur rien et on perdra la chaîne !<br>
<br>
<div class="centre"><img src="./cpp_files/107736.png" alt="Schema constructeur ZString"></div><br>
<br>
La solution ?<br>
Comme on l'a vu dans un des chapitres précédents, il faut copier la chaîne (en appelant une fonction de copie que l'on écrirera) et faire pointer m_chaine vers cette copie.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span><span class="o">::</span><span class="n">ZString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="n">copie</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span> <span class="c">// Bonne idée : copier la chaîne pour en avoir une version propre à la classe</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/107737.png" alt="Schema constructeur ZString"></div><br>
<br>
Comme notre classe sera la seule à connaître la copie, elle sera sûre que personne d'autre ne la supprimera dans le programme !<br>
<br>
<div class="rmq information">Si j'insiste pour faire une copie du tableau, ce n'est pas pour rien. Il faut vraiment être sûr de travailler sur <span class="souligne">une version du tableau que nous sommes les seuls à connaître</span> dans la classe, car sinon on prend le risque que quelqu'un d'autre la supprime sans notre autorisation.</div><br>
<br>
Je vous propose d'écrire ce constructeur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span><span class="o">::</span><span class="n">ZString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="n">copie</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
    <span class="n">m_longueur</span> <span class="o">=</span> <span class="n">longueur</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Pour que ce constructeur marche, il nous faut écrire 2 fonctions :<br>
<br>
<ul>
<li><strong>copie </strong>: qui copie un tableau de char et renvoie un pointeur vers la copie (équivalent de strcpy du C).</li>
<li><strong>longueur </strong>: qui calcule la longueur du tableau de char qu'on lui envoie (équivalent de strlen du C).</li>
</ul><br>
Ce sont des fonctions que vous avez déjà peut-être écrites si vous avez suivi mon cours de C. C'est un bon exercice que d'essayer de les réécrire.<br>
<br>
Je vous donne la solution, sans l'expliquer, parce que ça ça ne devrait pas être nouveau pour vous (ou alors faut revoir votre cours de C sur les chaînes de caractères !) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">ZString</span><span class="o">::</span><span class="n">longueur</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 
    <span class="k">while</span> <span class="p">(</span><span class="n">chaine</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">char</span> <span class="o">*</span><span class="n">ZString</span><span class="o">::</span><span class="n">copie</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">taille</span> <span class="o">=</span> <span class="n">longueur</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">chaineCopie</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">taille</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c">// +1 pour stocker \0</span>
 
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">taille</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">chaineCopie</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">chaineCopie</span><span class="p">[</span><span class="n">taille</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="n">chaineCopie</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Pensez à ajouter le prototype de ces méthodes dans ZString.h</div><br>
<br>
<br>
<h3>Le constructeur de copie ZString(const ZString &amp;)</h3><br>
<br>
Le constructeur de copie est un constructeur très utile qui est appelé dans plusieurs cas par le compilateur. Je ne reviens pas sur ces cas mais je vous invite en revanche à relire la <a href="http://www.siteduzero.com/tuto-3-16953-1-classes-et-pointeurs.html#ss_part_3">partie sur le constructeur de copie</a> dans les chapitres précédents.<br>
<br>
Le constructeur de copie est un constructeur qui prend en paramètre une référence vers un autre objet du même type.<br>
Voici le constructeur de copie de notre classe ZString :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span><span class="o">::</span><span class="n">ZString</span><span class="p">(</span><span class="k">const</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="n">copie</span><span class="p">(</span><span class="n">chaine</span><span class="p">.</span><span class="n">m_chaine</span><span class="p">);</span>
    <span class="n">m_longueur</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">.</span><span class="n">m_longueur</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce constructeur est à peu de choses près identique au constructeur qu'on vient d'écrire il y a 2 minutes.<br>
La seule différence est qu'il prend en entrée une ZString appelée <span class="italique">chaine</span>. Pour récupérer le tableau de char de la ZString, il suffit d'écrire <span class="italique">chaine.m_chaine</span>. Cela nous permet d'envoyer le tableau de char que les méthodes copie et longueur attendent.<br>
<br>
Vous vous demandez peut-être pourquoi on n'a pas tout simplement écrit par exemple :<br>
<span class="courrier">m_chaine = copie(chaine);</span><br>
La réponse est simple. Dans ce constructeur :<br>
<ul>
<li><span class="italique">chaine </span>est de type ZString (regardez le paramètre d'entrée)</li>
<li><span class="italique">chaine.m_chaine</span> est de type char *</li>
</ul><br>
Or nos méthodes copie et longueur attendent un char *, voilà pourquoi il faut dans ce cas envoyer <span class="italique">chaine.m_chaine</span>.<br>
<br>
<div class="rmq question">Comment peut-on avoir le droit d'écrire <span class="italique">chaine.m_chaine</span> ? Je croyais que <span class="italique">m_chaine</span> était un attribut privé, et donc qu'on ne pouvait pas y accéder ?<br>
Il n'aurait pas fallu créer une méthode accesseur <span class="italique">getChaine()</span> plutôt à la place ?</div><br>
<br>
En effet, on aurait très bien pu créer une méthode accesseur <span class="italique">getChaine()</span>. Faites-le si vous voulez d'ailleurs.<br>
<span class="souligne">Normalement, on n'a pas le droit d'accéder aux membres privés d'une classe</span>. Mais là nous sommes dans une <span class="souligne">exception</span>, car nous travaillons dans la même classe (nous sommes dans la classe ZString et nous essayons d'accéder à un attribut privé d'un autre objet de type ZString, ce qui est autorisé).<br>
<br>
<h3>Le destructeur ~ZString()</h3><br>
<br>
<br>
On arrive maintenant au destructeur. Son rôle est de détruire les attributs alloués dynamiquement en mémoire avant que l'objet ne soit supprimé (je vous rappelle que le destructeur est automatiquement appelé lorsqu'un objet va être supprimé).<br>
<br>
Le seul attribut alloué dynamiquement (avec un new[]), c'est m_chaine. Il faut penser à le supprimer avec un delete[].<br>
<br>
Notre destructeur sera tout simple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span><span class="o">::~</span><span class="n">ZString</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">m_chaine</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si on ne fait pas ça, le tableau de char m_chaine persistera en mémoire après la suppression de l'objet. Du coup, des tableaux "perdus" risqueraient de se ballader en mémoire et on assisterait à ce qu'on appelle des "fuites de mémoire". Votre programme prendrait beaucoup de place en mémoire parce qu'il aurait oublié de supprimer la mémoire dont il n'a plus besoin !<br>
<br>
<br>
<h3>Tester le code</h3><br>
<br>
Il est grand temps de compiler pour vérifier qu'on n'a pas fait d'erreur. Pour le moment, on va lancer le main que je vous ai donné au tout début, ce qui va provoquer l'appel du constructeur par défaut :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ZString</span> <span class="n">chaine</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Compilez, lancez. La console n'affichera rien (c'est normal, tout se passe dans la mémoire) mais si vous n'avez pas de plantage c'est que c'est bon signe déjà <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Testons le constructeur qui prend en paramètre un tableau de char pour initialiser la chaîne (celui qu'on a eu tant de mal à écrire, ne me dites pas que vous l'avez déjà oublié <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Compilez, lancez. Toujours pas d'erreur ? C'est très bien, c'est qu'on est sur la bonne voie <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="rmq question">Hé ! J'ai essayé de faire un cout de ma chaîne et ça ne marche pas ! Pourquoi ?</div><br>
<br>
Supposons que vous essayiez le code suivant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">chaine</span><span class="p">;</span></span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le compilateur vous répondra qu'il ne peut pas exécuter le cout car cout ne sait pas lire les objets de type ZString (pour lui c'est comme une boîte noire, il ne sait pas ce qu'il y a à l'intérieur). Il va falloir le lui apprendre en surchargeant l'opérateur &lt;&lt; comme on l'a appris dans le chapitre sur la surcharge des opérateurs.<br>
On verra ça un peu plus loin.<br>
<br>
<div class="rmq question">Ok, mais en attendant comment je fais pour afficher ce que contient ma chaine de type ZString ?</div><br>
<br>
Comme surcharger l'opérateur &lt;&lt; est un peu délicat et compliqué, on ne le verra que plus loin.<br>
En attendant par contre, vous pouvez écrire une méthode afficher() dans la classe ZString qui affichera la chaîne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">ZString</span><span class="o">::</span><span class="n">afficher</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_chaine</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Tout ce que la méthode afficher() fait, c'est afficher la chaîne de caractères qu'elle stocke. Ca consiste à faire un cout de m_chaine. C'est tout bête, mais si vous ne le dites pas à l'ordinateur il ne pourra pas deviner <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Dans le main, vous pouvez maintenant afficher votre chaîne !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">chaine</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span></span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Bonjour</pre></div></td></tr></tbody></table></div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11209">La surcharge des opérateurs</h2>
		<div class="ss_part_texte">
		Nous avons écrit des constructeurs, un destructeur et une méthode afficher().<br>
Avec ça, nous pouvons créer des chaînes de type ZString et les afficher. Cool. Mais c'est pas encore bien passionnant.<br>
<br>
Les choses vont commencer à devenir intéressantes à partir de maintenant. Nous allons faire quelques surcharges d'opérateurs pour profiter de toute la puissance du C++.<br>
<br>
Nous allons surcharger les opérateurs suivants :<br>
<br>
<ul>
<li><strong>L'opérateur =</strong> : c'est l'opérateur d'affectation qui permet d'affecter une nouvelle valeur à la chaîne après sa création.</li>
<li><strong>L'opérateur +</strong> : on va s'en servir pour combiner 2 chaînes de caractères (très pratique).</li>
<li><strong>L'opérateur &lt;&lt;</strong> : nous allons surcharger l'opérateur &lt;&lt; pour que cout soit capable d'afficher des ZString.</li>
</ul><br>
Au boulot !<br>
<br>
<h3>Surcharger l'opérateur =</h3><br>
<br>
Si on souhaite changer la chaîne après la création de la ZString, il faut surcharger l'opérateur =.<br>
Je vous propose de surcharger l'opérateur = 2 fois :<br>
<br>
<ul>
<li>Une fois pour prendre en paramètre un tableau de char (char *).<br>
<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span> <span class="c1">// Vaudra "Bonjour"</span>
<span class="n">chaine</span> <span class="o">=</span> <span class="s">"Salut"</span><span class="p">;</span> <span class="c1">// Vaudra "Salut" : appel de operator=(char *)</span>
</pre></div>
</td></tr></tbody></table></div><br>
</li>
<li>Une autre fois pour prendre en paramètre une autre ZString.<br>
<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span> <span class="c1">// Vaudra "Bonjour"</span>
<span class="n">ZString</span> <span class="n">autreChaine</span><span class="p">;</span>
 
<span class="n">autreChaine</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">;</span> <span class="c1">// Vaudra "Bonjour" : appel de operator=(ZString &amp;)</span>
</pre></div>
</td></tr></tbody></table></div></li>
</ul><br>
<br>
<h4>operator=(char *)</h4><br>
<br>
Commençons par le cas le plus simple : celui où on nous envoie un char * (un texte entre guillemets par exemple).<br>
<br>
Comme vous l'avez appris dans le chapitre sur la surcharge des opérateurs (je n'y reviens pas), le prototype de la méthode devra être le suivant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
A nous d'implémenter la méthode. Le but de l'opérateur = est de mettre dans l'objet la chaîne qu'on lui envoie en paramètre.<br>
Pour des raisons techniques que je ne détaillerai pas ici, il faudra que l'objet se renvoie lui-même à la fin de la méthode (via un return *this;).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">ZString</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">m_chaine</span><span class="p">;</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="n">copie</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
    <span class="n">m_longueur</span> <span class="o">=</span> <span class="n">longueur</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
 
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On doit dans un premier temps supprimer le tableau de char m_chaine que contenait notre objet. En effet, nous allons affecter une nouvelle chaîne à notre objet qui va "écraser" l'ancienne. Il faut bien penser à supprimer l'ancienne d'abord, sinon l'ancienne chaîne va persister en mémoire et va consommer de la mémoire pour rien !<br>
<br>
Vous noterez qu'à part ça et le return, c'est exactement le même code que le constructeur qu'on a écrit tout à l'heure. Et c'est logique, le but de cette méthode est le même (sauf qu'elle ne s'exécute pas au même moment) : il lui faut copier la chaîne qu'on lui envoie pour en avoir une propre à notre classe, et adapter l'attribut m_longueur pour qu'il indique la bonne longueur de chaîne.<br>
<br>
Le return *this, je ne reviens pas dessus, c'est comme ça que tout operator= doit terminer, point barre <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
On peut maintenant tester ce code dans le main et admirer comme c'est beau quand ça marche <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
    <span class="n">chaine</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>
 
    <span class="n">chaine</span> <span class="o">=</span> <span class="s">"Salut"</span><span class="p">;</span>
    <span class="n">chaine</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Bonjour
Salut</pre></div></td></tr></tbody></table></div><br>
<br>
<h4>operator=(const ZString &amp;)</h4><br>
<br>
Nous avons réussi à surcharger l'opérateur = pour qu'il accepte les tableaux de char, maintenant nous allons faire en sorte qu'il accepte aussi les ZString (pour pouvoir affecter une ZString par une autre ZString).<br>
<br>
Le code de cette méthode sera quasiment le même, il faut juste s'adapter au fait que l'on reçoit une référence vers une ZString au lieu d'un tableau de char :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">ZString</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">m_chaine</span><span class="p">;</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="n">copie</span><span class="p">(</span><span class="n">chaine</span><span class="p">.</span><span class="n">m_chaine</span><span class="p">);</span>
    <span class="n">m_longueur</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">.</span><span class="n">m_longueur</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voici un main pour tester cet opérateur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
    <span class="n">ZString</span> <span class="n">autreChaine</span><span class="p">;</span>
 
<span class="ln-xtra">    <span class="n">autreChaine</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">;</span> <span class="c1">// Vaudra "Bonjour" : appel de operator=(ZString &amp;)</span></span>
 
    <span class="c1">// Vérifions que les chaînes soient les mêmes</span>
    <span class="n">chaine</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>
    <span class="n">autreChaine</span><span class="p">.</span><span class="n">afficher</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si tout va bien, les deux affichages devraient produire le même résultat :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Bonjour
Bonjour</pre></div></td></tr></tbody></table></div><br>
<br>
Parfait <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
On peut maintenant affecter une ZString avec une autre ZString.<br>
<br>
<br>
<h3>Surcharger l'opérateur +</h3><br>
<br>
Passons à la surcharge de l'opérateur +, qui va nous permettre d'assembler 2 chaînes de caractères. Là encore, je pense qu'il serait bien d'écrire 2 versions de cette méthode :<br>
<br>
<ul>
<li>Une fois pour prendre en paramètre un tableau de char (char *).<br>
<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span> <span class="c1">// Vaudra "Bonjour"</span>
<span class="n">ZString</span> <span class="n">resultat</span><span class="p">;</span>
 
<span class="n">resultat</span> <span class="o">=</span> <span class="n">chaine</span> <span class="o">+</span> <span class="s">" Mateo"</span><span class="p">;</span> <span class="c1">// Vaudra "Bonjour Mateo" : appel de operator+(char *)</span>
</pre></div>
</td></tr></tbody></table></div><br>
</li>
<li>Une autre fois pour prendre en paramètre une autre ZString.<br>
<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">),</span> <span class="n">nom</span><span class="p">(</span><span class="s">" Mateo"</span><span class="p">);</span>
<span class="n">ZString</span> <span class="n">resultat</span><span class="p">;</span>
 
<span class="n">resultat</span> <span class="o">=</span> <span class="n">chaine</span> <span class="o">+</span> <span class="n">nom</span><span class="p">;</span> <span class="c1">// Vaudra "Bonjour Mateo" : appel de operator+(ZString &amp;)</span>
</pre></div>
</td></tr></tbody></table></div></li>
</ul><br>
<br>
<h4>operator+(char *)</h4><br>
<br>
Un opérateur + ne doit pas modifier l'objet lui-même mais retourner un résultat correspondant à la somme des objets qu'on additionne (ouf ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ).<br>
Cela veut dire qu'il ne faut pas trop se calquer sur l'opérateur = car ça fonctionne différemment.<br>
<br>
L'écriture de cette méthode est assez délicate (il faut un peu réfléchir quoi :-°).<br>
Voilà comment je vous propose d'additionner les 2 chaînes :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">ZString</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tailleTotale</span> <span class="o">=</span> <span class="n">m_longueur</span> <span class="o">+</span> <span class="n">longueur</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">sommeChaines</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">tailleTotale</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_longueur</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sommeChaines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_chaine</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_longueur</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tailleTotale</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sommeChaines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">m_longueur</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">sommeChaines</span><span class="p">[</span><span class="n">tailleTotale</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
 
    <span class="n">ZString</span> <span class="n">resultat</span><span class="p">(</span><span class="n">sommeChaines</span><span class="p">);</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">sommeChaines</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">resultat</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce qu'il faut bien comprendre, c'est qu'on travaille sur 2 chaînes :<br>
<ul>
<li><span class="italique">m_chaine</span> : correspondant à la chaîne de l'objet <strong>dans </strong>lequel on est (ici "Bonjour").</li>
<li><span class="italique">chaine </span>: qui est la chaîne qu'on ajoute (ici " Mateo").</li>
</ul><br>
Vous noterez qu'on se sert ici de l'attribut m_longueur de notre objet pour éviter d'avoir à recalculer la longueur de la chaîne contenue dans notre objet.<br>
Après le reste, ben c'est un algorithme. On crée une chaîne <span class="italique">sommeChaines </span>de la taille correspondant à la somme des 2 chaînes, puis on fait une première boucle pour y ajouter m_chaine, et une seconde boucle pour y ajouter chaine.<br>
<br>
Enfin, on crée un objet de type ZString (car il faut retourner une ZString impérativement) et on lui envoie la somme des chaînes pour que notre nouvelle ZString contienne "Bonjour Mateo".<br>
Enfin, on n'oublie pas de supprimer le tableau de char <span class="italique">sommeChaines </span>qu'on avait alloué dynamiquement et qui ne nous sert plus à rien maintenant.<br>
<br>
<div class="rmq information">Pour information, avant d'arriver à faire marcher cette méthode j'y ai passé facilement une bonne heure. Mon programme plantait pour diverses raisons.<br>
Tout ça pour vous dire que j'écris pas le bon algorithme du premier coup, qu'il m'arrive de faire des erreurs et de passer du temps à chercher pourquoi ça plante. Je suis un humain tout comme vous <img src="./cpp_files/langue.png" alt=":p" class="smilies"></div><br>
<br>
<h4>operator+(ZString &amp;)</h4><br>
<br>
Cette surcharge fonctionne de la même manière mais prend en entrée une autre ZString. Il suffit d'adapter un peu le code, le plus dur ayant déjà été fait.<br>
<br>
Et hop !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">ZString</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tailleTotale</span> <span class="o">=</span> <span class="n">m_longueur</span> <span class="o">+</span> <span class="n">chaine</span><span class="p">.</span><span class="n">m_longueur</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">sommeChaines</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">tailleTotale</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_longueur</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sommeChaines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_chaine</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_longueur</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tailleTotale</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sommeChaines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">.</span><span class="n">m_chaine</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">m_longueur</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">sommeChaines</span><span class="p">[</span><span class="n">tailleTotale</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
 
    <span class="n">ZString</span> <span class="n">resultat</span><span class="p">(</span><span class="n">sommeChaines</span><span class="p">);</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">sommeChaines</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">resultat</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le principe est le même. On profite du fait que l'élément qu'on nous envoie est une ZString pour utiliser son attribut m_longueur (ce qui nous évite d'avoir à recalculer la longueur de sa chaîne).<br>
<br>
<br>
<h3>Surcharger l'opérateur &lt;&lt;</h3><br>
<br>
Nous souhaitons maintenant pouvoir faire des <span class="italique">cout </span>sur des ZString.<br>
C'est un peu délicat, car il faut en théorie modifier la classe qui est derrière l'objet <span class="italique">cout</span>.<br>
<br>
En effet, faire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">chaine</span><span class="p">;</span>
 
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">chaine</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... revient à écrire comme vous le savez maintenant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">chaine</span><span class="p">;</span>
 
<span class="n">cout</span><span class="p">.</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Il faudrait donc surcharger la méthode operator&lt;&lt; de la classe qui gère l'objet cout, à savoir la classe <span class="italique">ostream</span>.<br>
<br>
Le problème, <a href="http://www.siteduzero.com/tuto-3-16681-1-la-surcharge-d-operateurs.html#ss_part_5">comme je vous l'avais déjà expliqué</a>, c'est qu'on ne peut pas modifier la classe ostream, on n'y a pas accès.<br>
En revanche, on peut tricher en créant une simple fonction (comme en C !) de cette forme-là :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">chaine</span><span class="p">.</span><span class="n">getChaine</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<span class="italique">J'ai placé cette fonction dans ZString.cpp. Son prototype est dans ZString.h, mais attention, mettez-le en-dehors de la déclaration de la classe car ce n'est pas une méthode de la classe !</span><br>
<br>
<div class="rmq question">Pourquoi ne pas avoir écrit <span class="italique">chaine.m_chaine</span> cette fois ?</div><br>
<br>
Jusqu'ici je pouvais le faire car j'étais à l'intérieur même de la classe, et donc j'avais accès à tous les attributs privés, même s'il s'agissait d'un autre objet de la même classe.<br>
<br>
Là, on est dans une fonction qui n'a rien à voir avec la classe ZString. Elle n'a donc pas accès aux attributs. C'est pour cette raison que j'appelle la méthode getChaine() de ZString...<br>
Je sais. On n'avait pas écrit de méthode getChaine() jusqu'ici. Il s'agit juste d'un accesseur : vous devriez être capable de l'écrire en 10s chrono, il fait juste un <span class="courrier">return m_chaine;</span> <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
On peut maintenant faire des cout d'objets de type ZString dans le main ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
 
<span class="ln-xtra">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">chaine</span><span class="p">;</span></span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Bonjour</pre></div></td></tr></tbody></table></div><br>
<br>
Joie, bonheur et volupté : ça marche ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11208">Récapitulatif</h2>
		<div class="ss_part_texte">
		Je crois que vu tout ce qu'on a fait jusqu'ici, un petit récapitulatif s'impose.<br>
Je vais vous donner le code source de chacun des 3 fichiers (main.cpp, ZString.cpp et ZString.h) puis je vous proposerai de télécharger le projet en l'état actuel.<br>
<br>
Nous finirons ensuite ce TP par une liste de suggestions d'améliorations de la classe ZString. Elle marche, certes, mais on pourrait encore lui rajouter de nombreuses fonctionnalités !<br>
<br>
<br>
<h3>main.cpp</h3><br>
<br>
Ce fichier contient le main qui fait quelques tests sur la classe ZString :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include "ZString.h"</span>
 
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ZString</span> <span class="n">chaine</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
    <span class="n">ZString</span> <span class="n">nom</span> <span class="o">=</span> <span class="s">"Mateo"</span><span class="p">;</span> <span class="c1">// Cette façon d'initialisation revient au même</span>
    <span class="n">ZString</span> <span class="n">resultat</span><span class="p">;</span>
 
    <span class="n">resultat</span> <span class="o">=</span> <span class="n">chaine</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">nom</span><span class="p">;</span>
 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Le resultat vaut maintenant : "</span> <span class="o">&lt;&lt;</span> <span class="n">resultat</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le résultat qui doit s'afficher si tout va bien est :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Le&nbsp;resultat&nbsp;vaut&nbsp;maintenant&nbsp;:&nbsp;Bonjour&nbsp;Mateo</pre></div></td></tr></tbody></table></div><br>
<br>
Avec ce code on teste le constructeur, le destructeur, l'opérateur =, les opérateurs +, le cout...<br>
<br>
<br>
<h3>ZString.h</h3><br>
<br>
Le coeur de notre classe est là. On y trouve la définition de ZString, ses attributs, ses méthodes.<br>
On trouve aussi le prototype de l'opérateur &lt;&lt;, en-dehors de la classe comme je vous l'ai dit car c'est l'opérateur de la classe ostream que l'on modifie là, pas celui de la classe ZString.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef DEF_ZSTRING</span>
<span class="cp">#define DEF_ZSTRING</span>
<span class="cp"> </span>
<span class="cp">#include &lt;iostream&gt;</span>
 
<span class="k">class</span> <span class="nc">ZString</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">ZString</span><span class="p">();</span>
        <span class="n">ZString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">);</span>
        <span class="n">ZString</span><span class="p">(</span><span class="k">const</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span><span class="p">);</span>
        <span class="o">~</span><span class="n">ZString</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">longueur</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">);</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">copie</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">);</span>
        <span class="kt">void</span> <span class="n">afficher</span><span class="p">();</span>
        <span class="n">ZString</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">);</span>
        <span class="n">ZString</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span><span class="p">);</span>
        <span class="n">ZString</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">);</span>
        <span class="n">ZString</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span><span class="p">);</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">getChaine</span><span class="p">();</span>
 
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">m_chaine</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m_longueur</span><span class="p">;</span>
<span class="p">};</span>
 
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span> <span class="p">);</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
<h3>ZString.cpp</h3><br>
<br>
C'est le plus gros fichier, celui qui nous aura donné le plus de fil à retordre aussi <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Il contient l'implémentation de toutes les méthodes de la classe ZString :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "ZString.h"</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="n">ZString</span><span class="o">::</span><span class="n">ZString</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">m_longueur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">ZString</span><span class="o">::</span><span class="n">ZString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="n">copie</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
    <span class="n">m_longueur</span> <span class="o">=</span> <span class="n">longueur</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="n">ZString</span><span class="o">::</span><span class="n">ZString</span><span class="p">(</span><span class="k">const</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="n">copie</span><span class="p">(</span><span class="n">chaine</span><span class="p">.</span><span class="n">m_chaine</span><span class="p">);</span>
    <span class="n">m_longueur</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">.</span><span class="n">m_longueur</span><span class="p">;</span>
<span class="p">}</span>
 
 
<span class="n">ZString</span> <span class="n">ZString</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">m_chaine</span><span class="p">;</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="n">copie</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
    <span class="n">m_longueur</span> <span class="o">=</span> <span class="n">longueur</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
 
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">ZString</span> <span class="n">ZString</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">m_chaine</span><span class="p">;</span>
    <span class="n">m_chaine</span> <span class="o">=</span> <span class="n">copie</span><span class="p">(</span><span class="n">chaine</span><span class="p">.</span><span class="n">m_chaine</span><span class="p">);</span>
    <span class="n">m_longueur</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">.</span><span class="n">m_longueur</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">ZString</span> <span class="n">ZString</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tailleTotale</span> <span class="o">=</span> <span class="n">m_longueur</span> <span class="o">+</span> <span class="n">longueur</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">sommeChaines</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">tailleTotale</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_longueur</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sommeChaines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_chaine</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_longueur</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tailleTotale</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sommeChaines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">m_longueur</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">sommeChaines</span><span class="p">[</span><span class="n">tailleTotale</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
 
    <span class="n">ZString</span> <span class="n">resultat</span><span class="p">(</span><span class="n">sommeChaines</span><span class="p">);</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">sommeChaines</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">resultat</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">ZString</span> <span class="n">ZString</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tailleTotale</span> <span class="o">=</span> <span class="n">m_longueur</span> <span class="o">+</span> <span class="n">chaine</span><span class="p">.</span><span class="n">m_longueur</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">sommeChaines</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">tailleTotale</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_longueur</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sommeChaines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_chaine</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">m_longueur</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tailleTotale</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sommeChaines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">.</span><span class="n">m_chaine</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">m_longueur</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">sommeChaines</span><span class="p">[</span><span class="n">tailleTotale</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
 
    <span class="n">ZString</span> <span class="n">resultat</span><span class="p">(</span><span class="n">sommeChaines</span><span class="p">);</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">sommeChaines</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">resultat</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">ZString</span> <span class="o">&amp;</span><span class="n">chaine</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">chaine</span><span class="p">.</span><span class="n">getChaine</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">char</span> <span class="o">*</span><span class="n">ZString</span><span class="o">::</span><span class="n">getChaine</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">m_chaine</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="n">ZString</span><span class="o">::</span><span class="n">afficher</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_chaine</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="n">ZString</span><span class="o">::</span><span class="n">longueur</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 
    <span class="k">while</span> <span class="p">(</span><span class="n">chaine</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">char</span> <span class="o">*</span><span class="n">ZString</span><span class="o">::</span><span class="n">copie</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">chaine</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">taille</span> <span class="o">=</span> <span class="n">longueur</span><span class="p">(</span><span class="n">chaine</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">chaineCopie</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">taille</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
 
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">taille</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">chaineCopie</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chaine</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">chaineCopie</span><span class="p">[</span><span class="n">taille</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
 
    <span class="k">return</span> <span class="n">chaineCopie</span><span class="p">;</span>
<span class="p">}</span>
 
 
<span class="n">ZString</span><span class="o">::~</span><span class="n">ZString</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">m_chaine</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
<h3>Télécharger le projet</h3><br>
<br>
Vous pouvez télécharger le projet (réalisé sous Code::Blocks) en cliquant sur le lien ci-dessous :<br>
<br>
<br>
<div class="centre"><span class="tgros"><a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/cpp/zstring.zip">Télécharger le projet (1 Ko)</a></span></div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11207">Aller (encore) plus loin</h2>
		<div class="ss_part_texte">
		Dans un premier temps, je vous conseille de bien potasser mon code source, d'essayer de le lire, le relire, le comprendre. Il y a peu de chances pour que vous ayez tout saisi du premier coup, mais si vous prenez le temps de bien analyser mon code et de relire mes explications, je suis sûr que vous allez progressivement vous sentir plus à l'aise là-dedans <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Maintenant, ce serait dommage de s'arrêter en si bon chemin vous ne trouvez pas ?<br>
Je vous propose une série de modifications et ajouts que vous pouvez faire sur la classe ZString pour améliorer ses fonctionnalités :<br>
<br>
<ul>
<li>On vient de faire l'accesseur <span class="italique">getChaine()</span>, mais ça pourrait être bien aussi de faire l'accesseur <span class="italique">getLongueur()</span> pour que l'utilisateur puisse savoir à tout moment la longueur de sa chaîne.</li>
<li>Une méthode <span class="italique">vider(</span>) pourrait supprimer le contenu de la ZString. Il faudrait supprimer la chaîne mais aussi penser à remettre l'attribut m_longueur à 0.</li>
<li>Une méthode <span class="italique">recherche()</span> pourrait faire une recherche dans la ZString. On pourrait même l'écrire en 3 versions :<br>
<ul>
<li>Une qui prend en paramètre un char (recherche d'un caractère)</li>
<li>Une qui prend en paramètre un char * (recherche d'une chaîne)</li>
<li>Une autre qui prend en paramètre une ZString (recherche d'une chaîne).</li>
</ul></li>
<li>Dans le même style, on peut imaginer une méthode <span class="italique">remplacer()</span> qui prend au moins 2 paramètres : ce que vous recherchez, et par quoi vous voulez le remplacer.</li>
<li>On n'a pas surchargé l'opérateur de comparaison == avec <span class="italique">operator==()</span> ! Si on veut pouvoir tester if (chaine1 == chaine2), il faut que l'on ait écrit cette méthode ! De même, vous devriez écrire <span class="italique">operator!=()</span> pour tester si 2 chaînes sont bien différentes, ça va de paire.</li>
<li>Plus difficile : essayez de surcharger l'opérateur [] avec la méthode <span class="italique">operator[]()</span>. Le but est de pouvoir écrire :<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">ZString</span> <span class="n">chaine</span> <span class="o">=</span> <span class="s">"Mateo"</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">chaine</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// Doit afficher "t"</span>
</pre></div>
</td></tr></tbody></table></div><br>
Le paramètre passé à cette méthode est un nombre (int) correspondant au caractère de la chaîne que l'on veut extraire. En écrivant cette méthode, on peut alors récupérer n'importe quel caractère de la chaîne comme on le faisait avec les tableaux de char !</li>
<li>Nous découvrirons dans un prochain chapitre ce que sont les méthodes statiques et constantes. Lorsque vous aurez lu ce chapitre, voyez si vous ne pouvez pas faire en sorte que certaines méthodes soient :<br>
<ul>
<li>Constantes : ce sont les méthodes qui ne modifient pas les attributs de votre objet.</li>
<li>Statiques : ce sont les méthodes qui n'interagissent pas du tout avec les attributs de votre objet et qui pourraient être de simples fonctions. C'est le cas de copie() et longueur() par exemple.</li>
</ul></li>
</ul><br>
<br>
Il vous faudra peut-être faire des recherches, voire demander de l'aide pour écrire certaines de ces méthodes.<br>
Il y a du challenge, mais le jeu en vaut la chandelle !
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Vous savez quoi ? Je crois que c'est un des premiers chapitres que j'écris où je suis soulagé d'arriver à la fin <img src="./cpp_files/rire.gif" alt=":lol:" class="smilies"><br>
<br>
Il faut dire que ce TP n'était pas facile, vous comprenez pourquoi il était impensable de vous lâcher dans la nature tous seuls. J'ai tenu à vous expliquer pas à pas mon raisonnement et ma démarche pour écrire une classe en C++.<br>
<br>
Je vous rassure : en temps normal on ne s'amuse pas à réécrire la classe string ! Toutefois, c'est vraiment un excellent exercice. Si vous prenez le temps de bien analyser ce qu'on a fait et de faire les améliorations proposées, vous allez <span class="italique">vraiment </span>progresser en C++.<br>
Vous voyez que ce n'est pas un langage simple, mais avec un peu de pratique on finit par acquérir certains automatismes qui limitent nos erreurs. Et encore. Si vous saviez le nombre d'erreurs que j'ai faites avant d'arriver à faire marcher la classe ZString ! <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Tout ça pour vous dire qu'il ne faut pas paniquer devant cette apparente difficulté. Retroussez vos manches, relisez, réfléchissez. Vous progresserez !
	</div>
	
	<hr>
	<h1 id="chap_11223">L'héritage</h1>
	<div id="chap_intro">
	Nous allons maintenant découvrir une des notions les plus importantes de la POO : <strong>l'héritage</strong>.<br>
Qu'on se rassure, il n'y aura pas de morts.<br>
<span class="italique"><span class="tpetit">(voilà ça c'est fait)</span></span><br>
<br>
L'héritage, c'est un concept très important qui fait à lui tout seul peut-être plus de la moitié de l'intérêt de la programmation orientée objet. Bref, ça rigole pas. C'est pas le moment de s'endormir au fond, j'vous ai à l'oeil <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Nous allons dans ce chapitre réutiliser notre exemple de la classe Personnage, mais on va beaucoup le simplifier pour se concentrer uniquement sur ce qui est important. En clair, on va juste garder le strict minimum, histoire d'avoir un exemple simple mais que vous connaissez déjà.<br>
<br>
Allez, bon courage, cette notion n'est pas bien dure à comprendre, elle est juste très riche.
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11222">Exemple d'héritage simple</h2>
		<div class="ss_part_texte">
		"Héritage", c'est un drôle de mot pour de la programmation hein <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Alors c'est quoi ? C'est une technique qui permet de créer une classe à partir d'une autre classe. Elle lui sert de modèle, de base de départ. Cela permet d'éviter à avoir à réécrire un même code source plusieurs fois.<br>
<br>
<br>
<h3>Comment reconnaître un héritage ?</h3><br>
<br>
C'est LA question à se poser. Certains ont tellement été traumatisés par l'héritage qu'ils en voient partout, d'autres au contraire (surtout les débutants) se demandent à chaque fois s'il y a un héritage à faire ou pas. Pourtant, ce n'est pas "mystique", il est très facile de savoir s'il y a une relation d'héritage entre 2 classes.<br>
<br>
Comment ? En suivant cette règle très simple :<br>
<br>
<div class="centre"><span class="gros">Il y a héritage quand on peut dire :<br>
"A est un B"</span></div><br>
<br>
Pas de panique c'est pas des maths <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Prenez un exemple très simple. On peut dire "Un guerrier est un personnage", ou encore "Un magicien est un personnage". Donc on peut faire un héritage : "La classe Guerrier hérite de Personnage", "La classe Magicien hérite de Personnage".<br>
<br>
Pour vous imprégner, voici quelques autres bons exemples où un héritage peut être fait  :<br>
<br>
<ul>
<li>Une voiture est un véhicule (Voiture hérite de Vehicule)</li>
<li>Un bus est un véhicule (Bus hérite de véhicule)</li>
<li>Un moineau est un oiseau (Moineau hérite d'Oiseau)</li>
<li>Un corbeau est un oiseau (Corbeau hérite d'Oiseau)</li>
<li>Un chirurgien est un docteur (Chirurgien hérite de Docteur)</li>
<li>Un diplodocus est un dinosaure (Diplodocus hérite de Dinosaure)</li>
<li>etc.</li>
</ul><br>
En revanche, vous ne pouvez pas dire "Un dinosaure est un diplodocus", ou encore "Un bus est un oiseau". Donc on ne peut pas faire d'héritage dans ces cas-là, du moins ça n'aurait aucun sens <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Nous allons voir comment réaliser un héritage en C++, mais d'abord il faut que je pose l'exemple sur lequel on va travailler <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<br>
<h3>Notre exemple : la classe Personnage</h3><br>
<br>
Petit rappel : cette classe représente un personnage d'un jeu vidéo de type RPG (jeu de rôle). Il n'est pas nécessaire de savoir jouer ou d'avoir joué à un RPG pour suivre mon exemple. J'ai juste choisi celui-là car il est plus ludique que la plupart des exemples barbants que les profs d'informatique aiment utiliser (Voiture, Bibliothèque, Université, PompeAEssence...).<br>
<br>
On va un peu simplifier notre classe Personnage. Voici ce sur quoi je vous propose de partir :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></td><td class="code"><div class="syntax"><pre><span class="c">/*</span>
<span class="c">Personnage.h</span>
<span class="c">*/</span>
<span class="cp"> </span>
<span class="cp">#ifndef DEF_PERSONNAGE </span><span class="c">// Pour éviter les inclusions multiples</span>
<span class="cp">#define DEF_PERSONNAGE </span><span class="c">// (revoir au besoin cours C, partie II, ch. 5)</span>
<span class="cp"> </span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
 
<span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Personnage</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">degats</span><span class="p">);</span>
        <span class="kt">void</span> <span class="n">coupDePoing</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">);</span>
 
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_nom</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notre Personnage a un nom et une quantité de vie.<br>
On n'a mis qu'un seul constructeur, un constructeur par défaut. Il permet d'initialiser le Personnage avec une vie et un nom de base.<br>
Le Personnage peut recevoir des dégâts, via la méthode <span class="italique">recevoirDegats</span> et en distribuer, via la méthode <span class="italique">coupDePoing</span>.<br>
<br>
A titre informatif, voici l'implémentation des méthodes dans Personnage.cpp :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><div class="syntax"><pre><span class="c">/*</span>
<span class="c">Personnage.cpp</span>
<span class="c">*/</span>
<span class="cp"> </span>
<span class="cp">#include "Personnage.h"</span>
 
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 
<span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_vie</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_nom</span><span class="p">(</span><span class="s">"Jack"</span><span class="p">)</span>
<span class="p">{</span>
 
<span class="p">}</span>
 
<span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">degats</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_vie</span> <span class="o">-=</span> <span class="n">degats</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">coupDePoing</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cible</span><span class="p">.</span><span class="n">recevoirDegats</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Rien d'extraordinaire pour le moment.<br>
<br>
<h3>La classe Guerrier hérite de la classe Personnage</h3><br>
<br>
Intéressons-nous maintenant à l'héritage. L'idée, c'est de <span class="souligne">créer une nouvelle classe qui est une  sous-classe de Personnage</span>. On dit que cette classe va <span class="italique">hériter </span>de Personnage.<br>
<br>
Pour cet exemple, je vais créer une classe Guerrier qui hérite de Personnage. La définition de la classe, dans Guerrier.h, ressemble à ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></td><td class="code"><div class="syntax"><pre><span class="c">/*</span>
<span class="c">Guerrier.h</span>
<span class="c">*/</span>
<span class="cp"> </span>
<span class="cp">#ifndef DEF_GUERRIER</span>
<span class="cp">#define DEF_GUERRIER</span>
<span class="cp"> </span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include "Personnage.h" </span><span class="c">// Ne pas oublier d'inclure Personnage.h pour pouvoir en hériter !</span>
 
<span class="k">class</span> <span class="nc">Guerrier</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Personnage</span> <span class="c">// Signifie : créer une classe Guerrier qui hérite de la classe Personnage</span>
<span class="p">{</span>
 
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Grâce à ce qu'on vient de faire, la classe Guerrier contiendra de base tous les attributs et toutes les méthodes de la classe Personnage.<br>
Dans un tel cas, la classe Personnage est appelée la classe "Mère", et la classe Guerrier la classe "Fille".<br>
<br>
<div class="rmq question">Mais quel intérêt de créer une nouvelle classe si c'est pour qu'elle contienne les mêmes attributs et les mêmes méthodes ?</div><br>
<br>
Attendez, justement ! Le truc, c'est qu'<span class="souligne">on peut rajouter des attributs et des méthodes spéciales dans la classe Guerrier</span>. Par exemple, on pourrait rajouter une méthode qui ne concerne que les guerriers, du genre frapperCommeUnSourdAvecUnMarteau (bon ok c'est un nom de méthode un peu long j'avoue <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><div class="syntax"><pre><span class="c">/*</span>
<span class="c">Guerrier.h</span>
<span class="c">*/</span>
<span class="cp"> </span>
<span class="cp">#ifndef DEF_GUERRIER</span>
<span class="cp">#define DEF_GUERRIER</span>
<span class="cp"> </span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include "Personnage.h"</span>
 
<span class="k">class</span> <span class="nc">Guerrier</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">frapperCommeUnSourdAvecUnMarteau</span><span class="p">();</span> <span class="c">// Méthode qui ne concerne que les guerriers</span>
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Schématiquement, on représente la situation comme ça :<br>
<br>
<div class="centre"><img src="./cpp_files/85384.png" alt="Image utilisateur"></div><br>
<br>
Le schéma se lit de bas en haut, c'est-à-dire "Guerrier hérite de Personnage".<br>
Guerrier est la classe fille, Personnage est la classe mère. On dit que Guerrier est une "spécialisation" de la classe Personnage. Elle possède toutes les caractéristiques d'un Personnage (de la vie, un nom, elle peut recevoir des dégâts), mais possède en plus des caractéristiques propres au Guerrier comme frapperCommeUnSourdAvecUnMarteau <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<div class="rmq information">Retenez bien que lorsqu'on fait un héritage, on hérite des méthodes <span class="italique"><strong>et</strong></span> des attributs.<br>
Je n'ai pas représenté les attributs sur le schéma ci-dessus pour ne pas surcharger, mais la vie et le nom du Personnage sont bel et bien hérités, ce qui fait qu'un Guerrier possède aussi de la vie et un nom !</div><br>
<br>
Vous commencez à comprendre le principe ? En C++, on utilise tellement de classes que bien souvent ça ne sert à rien de recréer une classe depuis le début, il vaut mieux hériter d'une classe plus "générale" pour éviter d'avoir à réécrire le même code 50 fois <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Ce concept a l'air de rien comme ça, mais croyez-moi ça fait la différence ! Vous n'allez pas tarder à voir tout ce que ça a de puissant lorsque vous pratiquerez plus loin dans le cours.<br>
<br>
<br>
<h3>La classe Magicien hérite aussi de Personnage</h3><br>
<br>
Tant qu'il n'y a qu'un seul héritage, l'intérêt semble encore limité. Mais multiplions un peu les héritages et les spécialisations et nous allons vite voir tout l'intérêt de la chose.<br>
<br>
Par exemple, si on créait une classe Magicien qui va elle aussi hériter de Personnage ? Après tout, un Magicien est un Personnage, donc il peut récupérer les mêmes propriétés de base : de la vie, un nom, donner un coup de poing, etc.<br>
La différence, c'est que le Magicien peut aussi envoyer des sorts magiques, par exemple bouleDeFeu et bouleDeGlace. Pour utiliser sa magie, il a une réserve de magie qu'on appelle "Mana" (ça va faire un attribut à rajouter). Quand la Mana tombe à zéro, il ne peut plus lancer de sort.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><div class="syntax"><pre><span class="c">/*</span>
<span class="c">Magicien.h</span>
<span class="c">*/</span>
<span class="cp"> </span>
<span class="cp">#ifndef DEF_MAGICIEN</span>
<span class="cp">#define DEF_MAGICIEN</span>
<span class="cp"> </span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include "Personnage.h"</span>
 
<span class="k">class</span> <span class="nc">Magicien</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">bouleDeFeu</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">bouleDeGlace</span><span class="p">();</span>
 
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">mana</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je ne vous donne pas l'implémentation des méthodes (le .cpp) ici, je veux juste que vous compreniez et reteniez le principe :<br>
<br>
<div class="centre"><img src="./cpp_files/85390.png" alt="Image utilisateur"></div><br>
<br>
Notez que sur le schéma je n'ai représenté que les méthodes des classes, mais les attributs (vie, nom...) sont eux aussi hérités !<br>
<br>
Et le plus beau, c'est qu'on peut faire une classe qui hérite d'une classe qui hérite d'une autre classe ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Imaginons qu'il y ait 2 types de magiciens : les magiciens blancs, qui sont des gentils qui envoient des sorts de guérison tout ça tout ça, et les magiciens noirs qui sont des méchants qui utilisent leurs sorts pour tuer des gens (super exemple, j'en suis fier).<br>
<br>
<span class="italique">Avada Kedavra !</span><br>
<br>
<div class="centre"><img src="./cpp_files/85401.png" alt="Image utilisateur"></div><br>
<br>
Et ça pourrait continuer longtemps comme ça. Vous verrez dans la prochaine partie sur la librairie C++ Qt qu'il y a souvent 5 ou 6 héritages qui sont faits à la suite. C'est vous dire si c'est utilisé !<br>
<br>
Je n'ai pas mis les noms des méthodes dans le schéma cette fois pour ne pas surcharger, c'est le principe qui compte hein <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>

		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11221">La dérivation de type</h2>
		<div class="ss_part_texte">
		Imaginons le code suivant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span> <span class="n">monPersonnage</span><span class="p">;</span>
<span class="n">Guerrier</span> <span class="n">monGuerrier</span><span class="p">;</span>
 
<span class="n">monPersonnage</span><span class="p">.</span><span class="n">coupDePoing</span><span class="p">(</span><span class="n">monGuerrier</span><span class="p">);</span>
<span class="n">monGuerrier</span><span class="p">.</span><span class="n">coupDePoing</span><span class="p">(</span><span class="n">monPersonnage</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Compilez : ça marche. Mais si vous êtes attentif, vous devriez vous demander <span class="italique">pourquoi</span> ça a marché, parce que normalement ça n'aurait pas dû !<br>
... non, vous ne voyez pas ? <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> <br>
<br>
Allez un effort, voici le prototype de coupDePoing (il est le même dans la classe Personnage et dans la classe Guerrier rappelez-vous) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">coupDePoing</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Quand on fait <span class="courrier">monGuerrier.coupDePoing(monPersonnage);</span>, on envoie bien un Personnage en paramètre.<br>
Mais quand on fait <span class="courrier">monPersonnage.coupDePoing(monGuerrier);</span>, ça marche aussi et le compilateur ne hurle pas à la mort alors que, selon toute logique, il devrait ! En effet, la méthode coupDePoing attend un Personnage et on lui envoie un Guerrier. Pourquoi diable cela fonctionne-t-il ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"><br>
<br>
<br>
Eh bien... c'est justement une propriété très intéressante de l'héritage en C++ que vous venez de découvrir là. <strong>On peut substituer un objet fille à un pointeur ou une référence d'un objet mère.</strong> Ce qui veut dire, dans une autre langue que le chinois, qu'on peut faire ça :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span> <span class="o">*</span><span class="n">monPersonnage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">Guerrier</span> <span class="o">*</span><span class="n">monGuerrier</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Guerrier</span><span class="p">();</span>
 
<span class="n">monPersonnage</span> <span class="o">=</span> <span class="n">monGuerrier</span><span class="p">;</span> <span class="c">// Mais... mais... Ca marche !?</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les 2 premières lignes n'ont rien d'extraordinaire : on crée un pointeur Personnage mis à NULL, et un pointeur Guerrier qu'on initialise avec l'adresse d'un nouvel objet de type Guerrier.<br>
Par contre, la ligne n°4 est assez surprenante. Normalement, on ne <span class="italique">devrait pas</span> pouvoir donner à un pointeur de type Personnage un pointeur de type Guerrier. C'est comme mélanger des carottes et des patates, ça se fait pas.<br>
<br>
Alors oui, en temps normal le compilateur n'accepte pas d'échanger des pointeurs (ou des références) de types différents. Or, Personnage et Guerrier ne sont pas n'importe quels types : Guerrier hérite de Personnage. Et la règle à connaître, c'est justement qu'<strong>on peut affecter un élément enfant à un élément parent</strong> !<br>
<br>
<div class="rmq erreur">L'inverse est faux par contre ! On ne peut PAS faire :<br>
<span class="courrier">monGuerrier = monPersonnage;</span><br>
Ceci plante et est strictement interdit. Attention au sens de l'affectation donc.</div><br>
<br>
Cela nous permet donc de placer un élément dans un pointeur (ou une référence) de type plus général.<br>
C'est très pratique dans notre cas lorsqu'on passe une cible en paramètre :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">coupDePoing</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notre méthode coupDePoing est capable de faire mal à n'importe quel Personnage ! Qu'il soit Guerrier, Magicien, MagicienBlanc, MagicienNoir ou autre, c'est un Personnage après tout, donc on peut lui donner un coupDePoing <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
C'est un peu choquant au début je le reconnais, mais on se rend compte au final qu'en fait c'est très bien fait. <span class="marine">Ca fonctionne, puisque la méthode coupDePoing ne fait qu'appeler des méthodes de la classe Personnage (<span class="italique">recevoirDegats</span>), et que ces méthodes se trouvent forcément dans toutes les classes filles (Guerrier, Magicien)</span>.<br>
<br>
Relisez-moi, essayez de comprendre, vous devriez saisir pourquoi ça marche <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<div class="rmq question">Eh ben non, moi je comprends PAS ! Je ne vois pas pourquoi ça marche si on fait :<br>
<span class="courrier">objetMere = objetFille;</span><br>
Là on affecte la fille à la mère, or la fille possède des attributs que la mère n'a pas. Ca devrait coincer ! L'inverse ne serait pas plus logique ?</div><br>
<br>
Je vous rassure, personnellement j'ai mis des mois avant d'arriver à comprendre ce qui se passait vraiment (comment ça ça vous rassure pas ? <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> )<br>
<br>
Votre erreur est de croire qu'on affecte la fille à la mère. Non on n'affecte pas la fille à la mère, on affecte un pointeur (ou une référence). Déjà c'est pas du tout pareil. Ensuite, ce n'est pas toute la fille qu'on affecte à la mère, mais <span class="souligne">seulement la partie qui hérite de la mère</span>.<br>
<br>
<div class="centre"><img src="./cpp_files/85555.png" alt="Image utilisateur"></div><br>
<br>
Voilà je peux difficilement pousser l'explication plus loin, j'espère que vous allez comprendre, sinon pas de panique j'ai survécu plusieurs mois de programmation en C++ sans bien comprendre ce qui se passait et j'en suis pas mort <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
(mais c'est mieux si vous comprenez c'est clair !)<br>
<br>
En tout cas sachez que c'est une technique très utilisée, on s'en sert vraiment souvent en C++ ! Vous découvrirez bien ça avec la pratique en utilisant Qt dans la prochaine partie.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11220">Héritage et constructeurs</h2>
		<div class="ss_part_texte">
		Vous avez peut-être remarqué que je n'ai pas encore parlé des constructeurs dans les classes filles (Guerrier, Magicien...). C'est le moment justement de s'y intéresser <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
On sait que Personnage a un constructeur (un constructeur par défaut) défini comme ceci dans le .h :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... et son implémentation dans le .cpp :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_vie</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_nom</span><span class="p">(</span><span class="s">"Jack"</span><span class="p">)</span>
<span class="p">{</span>
 
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Comme vous le savez, lorsqu'on crée un objet de type Personnage, le constructeur est appelé avant toute chose.<br>
<br>
Mais maintenant, que se passe-t-il lorsqu'on crée par exemple un Magicien qui hérite de Personnage ? Le Magicien a le droit d'avoir un constructeur lui aussi ! Est-ce que ça ne va pas interférer avec le constructeur de Personnage ? Il faut pourtant appeler le constructeur de Personnage si on veut que la vie et le nom soient initialisés !<br>
<br>
En fait, les choses se dérouleront dans l'ordre suivant :<br>
<br>
<ol class="liste_1">
<li>Vous demandez à créer un objet de type Magicien</li>
<li>Le compilateur appelle d'abord le constructeur de la classe mère (Personnage)</li>
<li>Puis, le compilateur appelle le constructeur de la classe fille (Magicien)</li></ol><br>
En clair, c'est d'abord le constructeur du "parent" qui est appelé, puis celui du fils, et éventuellement du petit fils (s'il y a un héritage d'héritage, comme c'est le cas avec MagicienBlanc).<br>
<br>
<br>
<h3>Appeler le constructeur de la classe mère</h3><br>
<br>
<br>
Pour appeler le constructeur de Personnage en premier, il faut y faire appel depuis le constructeur de Magicien. C'est dans un cas comme ça qu'il est <span class="barre">bon</span> indispensable de se servir de la liste d'initialisation (vous savez, tout ce qui suit le symbole deux-points dans l'implémentation).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">Magicien</span><span class="o">::</span><span class="n">Magicien</span><span class="p">()</span> <span class="o">:</span> <span class="n">Personnage</span><span class="p">(),</span> <span class="n">mana</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">{</span>
 
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le premier élément de la liste d'initialisation dit de faire d'abord appel au constructeur de la classe parente Personnage. Puis, les initialisations propres au Magicien sont faites (comme l'initialisation de la mana à 100).<br>
<br>
<div class="rmq information">Lorsqu'on crée un objet de type Magicien, le compilateur appelle le constructeur par défaut de la classe mère (celui qui ne prend pas de paramètre).</div><br>
<br>
<h3>Transmission de paramètres</h3><br>
<br>
Le gros avantage de cette technique est que l'on peut "transmettre" les paramètres du constructeur de Magicien au constructeur de Personnage. Par exemple, si le constructeur de Personnage prenait un nom en paramètre, il faudrait que le Magicien accepte lui aussi ce paramètre et le fasse passer au constructeur de Personnage :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">Magicien</span><span class="o">::</span><span class="n">Magicien</span><span class="p">(</span><span class="n">string</span> <span class="n">nom</span><span class="p">)</span> <span class="o">:</span> <span class="n">Personnage</span><span class="p">(</span><span class="n">nom</span><span class="p">),</span> <span class="n">mana</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">{</span>
 
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Bien entendu, si on veut que ça marche il faudra aussi surcharger le constructeur de Personnage pour qu'il accepte un paramètre string !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">Personnage</span><span class="o">::</span><span class="n">Personnage</span><span class="p">(</span><span class="n">string</span> <span class="n">nom</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_vie</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">m_nom</span><span class="p">(</span><span class="n">nom</span><span class="p">)</span>
<span class="p">{</span>
 
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Et voilà comment on fait "remonter" des paramètres d'un constructeur à un autre pour s'assurer que l'objet se crée correctement <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Schéma résumé</h3><br>
<br>
Pour bien mémoriser ce qui se passe, rien de tel qu'un schéma résumé n'est-ce pas ? <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="centre"><img src="./cpp_files/85519.png" alt="Image utilisateur"></div><br>
<br>
Il faut bien entendu le lire dans l'ordre pour en comprendre le fonctionnement. On commence par demander à créer un Magicien. "Oh mais c'est un objet" se dit le compilateur, "il faut que j'appelle son constructeur".<br>
Or, le constructeur du Magicien indique qu'il faut d'abord appeler le constructeur de la classe parente Personnage. Le compilateur va donc voir la classe parente, puis exécute son code. Il retourne ensuite au constructeur du Magicien et exécute son code.<br>
<br>
Une fois que tout cela est fait, notre objet <span class="italique">merlin</span> devient utilisable et on peut enfin faire subir les pires sévices à notre cible <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> 
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11219">La portée protected</h2>
		<div class="ss_part_texte">
		Il me serait vraiment impossible de vous parler d'héritage sans vous parler de la portée <span class="italique">protected</span>.<br>
<br>
<div class="rmq information">Rappel : les portées (ou droits d'accès) que vous connaissez déjà sont :<br>
<ul>
<li><strong>public </strong>: les éléments qui suivent seront accessibles depuis l'extérieur de la classe.</li>
<li><strong>private </strong>: les éléments qui suivent ne seront pas accessibles depuis l'extérieur de la classe.</li>
</ul></div><br>
Je vous ai en particulier donné la règle fondamentale du C++, l'encapsulation, qui veut que l'on empêche systématiquement au monde extérieur d'accéder aux attributs de nos classes.<br>
<br>
La portée protected est un autre type de droit d'accès que je classerais entre public (le plus permissif) et private (le plus restrictif). Il n'a de sens que pour les classes qui se font hériter (les classes mères) mais on peut les utiliser sur toutes les classes même quand il n'y a pas d'héritage.<br>
<br>
Sa signification est la suivante :<br>
<span class="marron"><strong>protected</strong> : les éléments qui suivent ne seront pas accessibles depuis l'extérieur de la classe, <span class="italique">sauf</span> si c'est une classe fille.</span><br>
<br>
Cela veut dire par exemple que si l'on met des éléments en protected dans la classe Personnage, on y aura accès dans les classes filles Guerrier et Magicien. Avec la portée private, on n'aurait pas pu y accéder !<br>
<br>
<div class="rmq information">En pratique, personnellement je donne toujours la portée protected aux attributs de mes classes. C'est comme private (donc ça respecte l'encapsulation) sauf que comme ça, au cas où j'hérite un jour de cette classe, j'aurai aussi directement accès aux attributs.<br>
Cela est souvent nécessaire voire indispensable sinon on doit utiliser des tonnes d'accesseurs (méthodes getTruc) et ça rend le code bien plus lourd.</div><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Personnage</span><span class="p">();</span>
        <span class="n">Personnage</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">nom</span><span class="p">);</span>
        <span class="kt">void</span> <span class="n">recevoirDegats</span><span class="p">(</span><span class="kt">int</span> <span class="n">degats</span><span class="p">);</span>
        <span class="kt">void</span> <span class="n">coupDePoing</span><span class="p">(</span><span class="n">Personnage</span> <span class="o">&amp;</span><span class="n">cible</span><span class="p">);</span>
 
    <span class="k">protected</span><span class="o">:</span> <span class="c">// Privé, mais accessible aux éléments enfants (Guerrier...)</span>
        <span class="kt">int</span> <span class="n">m_vie</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_nom</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On peut alors directement manipuler la vie et le nom dans tous les éléments enfants de Personnage, comme Guerrier et Magicien !
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Ce chapitre en impose peut-être un peu par sa taille, mais ne vous y fiez pas ce sont surtout les schémas qui prennent de la place <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
D'ailleurs, j'ai volontairement évité de trop montrer de codes sources complets différents et j'ai préféré que vous vous focalisiez sur ces schémas. C'est ce qu'on retient le mieux en général, et ça permet de bien se repérer. La pratique viendra dans la partie sur la librairie Qt.<br>
<br>
Ceci étant, peut-être que vous aimeriez avoir le code source complet de mes exemples (Personnage, Guerrier, Magicien...). Ce code n'est pas complet, certaines méthodes ne sont pas écrites, il ne fait rien d'extraordinaire. Mais il compile, et ça vous permettra peut-être de finir de mettre de l'ordre dans vos idées.<br>
<br>
Voici donc le code source :<br>
<br>
<div class="centre"><span class="gros"><a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/cpp/heritage.zip">Télécharger le code source complet (3 Ko)</a></span></div><br>
<br>
Bon bidouillage <img src="./cpp_files/clin.png" alt=";)" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11231">Eléments statiques et constants</h1>
	<div id="chap_intro">
	Vous tenez le coup ? <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Courage, vos efforts seront bientôt largement récompensés.<br>
<br>
Ce chapitre va d'ailleurs vous permettre de souffler un peu. Vous allez découvrir quelques notions spécifiques aux classes en C++ : les attributs et méthodes statiques et constants. Ce sont ce que j'appellerais des "points particuliers" du C++. Ce ne sont pas des détails pour autant, ce sont des choses à connaître.<br>
<br>
Car oui, tout ce que je vous apprends là, vous allez en avoir besoin et vous allez largement le réutiliser. Je suis sûr aussi que vous en comprendrez mieux l'intérêt lorsque vous pratiquerez pour de bon.<br>
N'allez pas croire que les programmeurs ont inventé des trucs un peu complexes comme ça juste pour le plaisir de programmer de façon tordue <img src="./cpp_files/langue.png" alt=":p" class="smilies">
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11230">Les méthodes constantes</h2>
		<div class="ss_part_texte">
		On en a rapidement parlé lorsqu'on a introduit les accesseurs (méthodes get/set pour accéder aux attributs), mais je pense que ça vaut le coup de faire le point complètement sur cette notion ici. Ca sera court, mais au moins vous le retiendrez bien et vous ne serez pas surpris si vous voyez des gens en faire.<br>
<br>
Euh de quoi je parle ? Des <strong>méthodes constantes</strong> ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Ce sont des méthodes qui possèdent le mot-clé const <span class="souligne">à la fin de leur prototype et de leur déclaration</span>.<br>
<br>
Quand vous dites "ma méthode est constante", vous indiquez au compilateur que votre méthode ne modifie pas l'objet, c'est-à-dire qu'elle ne modifie la valeur d'aucun de ses attributs. Par exemple, une méthode qui se contente d'afficher des informations à l'écran sur l'objet est une méthode constante : elle ne fait que lire les attributs. En revanche, une méthode qui met à jour le niveau de vie d'un personnage ne peut pas être constante <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Ca s'utilise comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9</pre></td><td class="code"><div class="syntax"><pre><span class="c">// Prototype de la méthode (dans le .h) :</span>
<span class="kt">void</span> <span class="n">maMethode</span><span class="p">(</span><span class="kt">int</span> <span class="n">parametre</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
 
 
<span class="c">// Déclaration de la méthode (dans le .cpp) :</span>
<span class="kt">void</span> <span class="n">maMethode</span><span class="p">(</span><span class="kt">int</span> <span class="n">parametre</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
 
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On utilisera souvent le mot-clé const sur les méthodes accesseur (getAttribut), ces méthodes qui se contentent de renvoyer la valeur d'un attribut pour respecter le principe d'encapsulation qui dit que l'attribut doit être privé.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">getVie</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">m_vie</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<div class="rmq question">Concrètement, ça sert à quoi de créer des méthodes constantes ?</div><br>
<br>
Ca sert à 2 choses principalement :<br>
<ul>
<li><strong>Pour vous</strong> : vous savez que votre méthode ne fait que lire les attributs, et vous vous interdisez dès le début de les modifier. Si par erreur vous en modifiez, le compilateur plantera en vous disant que vous ne respectez pas la règle que vous vous êtes fixée. Et ça c'est bien.</li>
<li><strong>Pour les utilisateurs de votre classe</strong> : c'est très important aussi pour eux, ça leur indique que la méthode ne fait que renvoyer un résultat mais qu'elle ne modifie pas l'objet. Dans une documentation, le mot-clé const apparaît dans le prototype de la méthode et est un excellent indicateur de ce qu'elle fait, ou plutôt de ce qu'elle ne peut pas faire (ça pourrait se traduire par : "<span class="italique">cette méthode ne modifiera pas votre objet</span>").</li>
</ul>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11229">Les méthodes statiques</h2>
		<div class="ss_part_texte">
		Ah les méthodes statiques... Alors ça, c'est un peu spécial <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Ce sont des méthodes qui appartiennent à la classe mais pas aux objets instanciés à partir de la classe... En fait, ce sont de bêtes "fonctions" rangées dans des classes qui n'ont pas accès aux attributs de la classe. Ca s'utilise d'une manière un peu particulière.<br>
<br>
Le mieux est encore un exemple je pense !<br>
<br>
<br>
<h3>Créer une méthode statique</h3><br>
<br>
Dans le .h, le prototype d'une méthode statique ressemble à ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">MaClasse</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">MaClasse</span><span class="p">();</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="n">maMethode</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Son implémentation dans le .cpp ne possède pas en revanche de mot-clé <span class="italique">static </span>:<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">Personnage</span><span class="o">::</span><span class="n">maMethode</span><span class="p">()</span> <span class="c">// Ne pas remettre "static" dans l'implémentation</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bonjour !"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
Ensuite, dans le main, la méthode statique s'appelle comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Personnage</span><span class="o">::</span><span class="n">maMethode</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Mais... on n'a pas créé d'objet de type Personnage et on appelle la méthode quand même ? C'est quoi ce bazar ?</div><br>
<br>
C'est justement ça la particularité des méthodes statiques. Pour les utiliser, pas besoin de créer un objet. Il suffit juste de faire précéder le nom de la méthode par le nom de la classe suivi de deux deux-points.<br>
D'où le : <span class="courrier">Personnage::maMethode();</span><br>
<br>
Cette méthode, comme je vous le disais, ne peut pas accéder aux attributs de la classe. C'est vraiment une bête fonction, mais <span class="souligne">rangée dans une classe</span>. Ca permet de regrouper les fonctions dans des classes, par thème, et aussi d'éviter des conflits de nom.<br>
<br>
<br>
<h3>Quelques exemples de l'utilité des méthodes statiques</h3><br>
<br>
Les méthodes statiques peuvent vous paraître un tantinet stupides. En effet, à quoi bon avoir inventé le modèle objet si c'est pour autoriser les gens à créer de bêtes "fonctions" regroupées dans des classes ?<br>
<br>
La réponse, c'est qu'on a toujours besoin d'utiliser de "bêtes" fonctions même en modèle objet, mais pour être un peu cohérent on les regroupe dans des classes en précisant qu'elles sont statiques.<br>
<br>
Il y a en effet des fonctions qui ne nécessitent pas de créer un objet, pour lesquelles ça n'aurait pas de sens.<br>
Des exemples ?<br>
<br>
<ul>
<li>Il existe dans la librairie Qt une classe <strong>QDate</strong> qui permet de manipuler des dates. On peut comparer des dates entre elles (surcharge d'opérateur) etc etc. Cette classe propose aussi un certain nombre de méthodes statiques, comme currentDate qui renvoie la date actuelle. Pas besoin de créer un objet pour avoir cette information ! Il suffit donc de taper <span class="courrier">QDate::currentDate()</span> pour récupérer la date actuelle <img src="./cpp_files/smile.png" alt=":)" class="smilies"></li>
<li>Toujours avec Qt, la classe <strong>QDir</strong>, qui permet de manipuler les dossiers du disque dur, propose quelques méthodes statiques. Par exemple, on trouve <span class="courrier">QDir::drives()</span> qui renvoie la liste des disques présents sur l'ordinateur (par exemple "C:\", "D:\", etc). Là encore, ça n'aurait pas eu d'intérêt d'instancier un objet à partir de la classe car ce sont des <span class="italique">informations générales</span>.</li>
<li>etc etc.</li>
</ul><br>
Mmmh mais c'est que ça donne envie de travailler avec Qt tout ça <img src="./cpp_files/hihi.png" alt="^^" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11228">Les attributs statiques</h2>
		<div class="ss_part_texte">
		Il existe aussi ce qu'on appelle des <strong>attributs statiques</strong>.<br>
Tout comme les méthodes statiques, les attributs statiques appartiennent à la classe et non aux objets créés à partir de la classe.<br>
<br>
<br>
<h3>Créer un attribut statique dans une classe</h3><br>
<br>
C'est assez simple en fait : il suffit de rajouter le mot-clé <span class="italique">static </span>au début de la ligne.<br>
Un attribut static, bien qu'il soit accessible de l'extérieur, peut très bien être déclaré <span class="italique">private </span>ou <span class="italique">protected</span>. Appelez ça une exception, car c'en est bien une <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">MaClasse</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">MaClasse</span><span class="p">();</span>
 
    <span class="k">private</span><span class="o">:</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">monAttribut</span><span class="p">;</span>
 
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Sauf qu'on ne peut pas initialiser l'attribut statique ici. Il faut le faire dans l'espace global, c'est-à-dire en dehors de toute classe ou fonction, <span class="souligne">en dehors du main notamment</span>.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="c1">// Initialiser l'attribut en dehors de toute fonction ou classe (espace global)</span>
<span class="kt">int</span> <span class="n">MaClasse</span><span class="o">::</span><span class="n">monAttribut</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Un attribut déclaré comme statique se comporte comme une variable globale, c'est-à-dire une variable accessible partout dans le code.<br>
<br>
<div class="rmq question">Ouaaaah ! Stop !<br>
Tu nous avais pas dit à un moment que les variables globales c'était le mal absolu et que même si ça existait il fallait préférer se pendre plutôt que de les utiliser ? <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> </div><br>
<br>
En effet. Bien qu'il y ait toujours des cas où ça se révèle utile et indispensable, c'est très rarement le cas. De manière générale, fuyez ces variables globales comme la peste.<br>
<br>
<br>
<h3>Créer un attribut statique dans une méthode d'une classe</h3><br>
<br>
Il y a un cas particulier : on peut aussi créer une variable statique à l'intérieur d'une méthode d'une classe. Cette fois c'est un peu moins bourrin : la variable ne sera accessible que depuis la méthode où elle se trouve.<br>
Le truc, c'est que la variable ne sera pas supprimée de la mémoire à la fin de la méthode. Elle reste en mémoire et sera réutilisée la prochaine fois que la méthode sera appelée, et ce <span class="souligne">quel que soit l'objet qui y fait appel</span>.<br>
<br>
<div class="rmq information">Pour ceux qui s'en souviennent, c'est exactement le même principe que les variables statiques qu'on avait vues dans le cours de C.</div><br>
<br>
Un exemple sera plus parlant <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<span class="code">Code : C++ - MaClasse.h - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">MaClasse</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">methode</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : C++ - MaClasse.cpp - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">MaClasse</span><span class="o">::</span><span class="n">methode</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">compteur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">compteur</span><span class="o">++</span><span class="p">;</span>
 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compteur</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : C++ - main.cpp - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">MaClasse</span> <span class="n">objet1</span><span class="p">,</span> <span class="n">objet2</span><span class="p">;</span>
 
    <span class="n">objet1</span><span class="p">.</span><span class="n">methode</span><span class="p">();</span>
    <span class="n">objet2</span><span class="p">.</span><span class="n">methode</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat à l'écran :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>1
2</pre></div></td></tr></tbody></table></div><br>
<br>
Lors de l'appel de la méthode du premier objet, la variable statique compteur est créée et le nombre 1 est affiché.<br>
Lors de l'appel de la méthode du second objet, la variable statique compteur existe déjà en mémoire donc elle n'est pas recréée. C'est celle créée pour le premier objet qui est réutilisée ici. La preuve : le compteur est incrémenté à nouveau et l'écran affiche 2, ce qui signifie que la variable compteur est la même dans les 2 objets.<br>
<br>
<div class="rmq information">Les variables statiques au sein d'une méthode ont une portée limitée à leur méthode. Ce ne sont pas des variables globales et c'est donc déjà bien moins crade <img src="./cpp_files/langue.png" alt=":p" class="smilies"> . Elles peuvent avoir une utilité, comme par exemple compter le nombre d'objets créés à partir d'une classe (il faudrait dans ce cas mettre la variable statique compteur dans le constructeur).</div>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Ces points un peu particuliers (mais pas bien compliqués) étant vus, je crois que vous avez suffisamment de bagage théorique pour commencer à pratiquer vraiment le C++.<br>
<br>
C'est justement l'objectif de la partie suivante, qui va porter sur la librairie Qt dont je vous parle depuis un petit moment maintenant <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Cette librairie est vraiment immense et va vous permettre entre autres choses de créer des fenêtres afin de rendre vos applications bien plus sympathiques d'utilisation.<br>
<br>
Vous en avez bavé pendant cette partie, vous avez dû emmagasiner pas mal de nouvelles connaissances, aussi vous pouvez considérer que la partie qui va suivre est la... récompense <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Tout ce que vous avez appris jusqu'ici va vous resservir, donc n'hésitez pas à relire les chapitres de cette partie que vous n'auriez pas trop bien compris. Parfois ça se débloque au bout de quelques lectures ! Et si ça débloque pas, tant pis, passez à la pratique quand même, je suis sûr que vous comprendrez mieux tous ces concepts du C++ en travaillant sur du concret !
	</div>
	
<div>
<br>

</div>

<hr>
<h2>Partie 3 : [Pratique] Créez vos propres fenêtres avec Qt</h2>
<div>
<div class="flot_droite"><img src="./cpp_files/86863.png" alt="Image utilisateur"></div>Vous l'avez compris en lisant la partie I : la POO, ce n'est pas évident à maîtriser au début, mais ça apporte un nombre important d'avantages : le code est plus facile à réutiliser, à améliorer, et... quand on utilise une bibliothèque là c'est carrément le pied <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Le but de la partie II est entièrement de pratiquer, pratiquer, pratiquer. Vous n'apprendrez pas de nouvelles notions théoriques ici, mais par contre vous allez apprendre à maîtriser le C++ par la pratique, et ça c'est important.<br>
<br>
Qt est une bibliothèque C++ très complète qui vous permet notamment de créer vos propres fenêtres, que vous soyez sous Windows, Linux ou Mac OS. Tout ce que nous allons faire sera très concret : ouverture de fenêtres, ajout de boutons, création de menus, de listes déroulantes... bref que des choses motivantes ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies">
</div>
	
	<hr>
	<h1 id="chap_11240">Introduction à Qt</h1>
	<div id="chap_intro">
	Les amis, le temps n'est plus aux bavardages mais au <strong>concret</strong> !<br>
Vous trouverez difficilement plus concret que cette partie II du cours <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<div class="rmq erreur">Pour bien pouvoir comprendre cette partie, il est <span class="souligne">vital</span> que vous ayez lu et compris la plupart de la partie I.<br>
Si certaines zones de la première partie vous sont encore un peu obscures, n'hésitez pas à y faire un tour  à nouveau. Au pire des cas, si vraiment ça ne rentre pas, vous pouvez quand même lire cette partie, vous aurez peut-être un déclic en pratiquant <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
Nous commencerons dans un premier temps par découvrir ce qu'est Qt concrètement, ce que cette bibliothèque permet de faire, et quelles sont aussi les alternatives qui existent (car il n'y a pas qu'avec Qt qu'on peut créer des fenêtres !).<br>
Nous verrons ensuite comment installer et configurer Qt.<br>
<br>
Préparez-vous bien, parce que dès le chapitre suivant on attaque dare-dare !
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11239">Dis papa, comment on fait des fenêtres ?</h2>
		<div class="ss_part_texte">
		Voilà une question que vous vous êtes tous déjà posés, j'en suis sûr ! J'en mettrais même ma main à couper (<span class="italique">et j'y tiens à ma main, c'est vous dire <img src="./cpp_files/langue.png" alt=":p" class="smilies"> </span>).<br>
<br>
<br>
<div class="rmq question">Alors alors, c'est comment qu'on programme des fenêtres ? <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> </div><br>
<br>
Douuucement, pas d'impatience. Si vous allez trop vite vous risquez de brûler des étapes et de vous retrouver bloqué après, alors allez-y progressivement et dans l'ordre en écoutant bien tout ce que j'ai à vous dire.<br>
<br>
<br>
<h3>Un mot de vocabulaire à connaître : GUI</h3><br>
<br>
Avant d'aller plus loin, je voudrais vous faire apprendre ce petit mot de vocabulaire car je vais le réutiliser tout au long de cette partie <strong>GUI</strong> (prononcez "Goui").<br>
C'est l'abréviation de <strong>Graphical User Interface</strong>, soit "Interface utilisateur graphique". Ca désigne tout ce qu'on appelle grossièrement "Programme avec des fenêtres".<br>
<br>
Pour bien que vous puissiez comparer, voici un programme sans GUI (en console) et un programme GUI :<br>
<br>
<div class="centre"><img src="./cpp_files/89347.png" alt="Sans GUI"><br>
<span class="italique">Programme sans GUI (console)</span></div><br>
<br>
<div class="centre"><img src="./cpp_files/89348.png" alt="Avec GUI"><br>
<span class="italique">Programme GUI, ici sous Windows Vista</span></div><br>
<br>
<br>
<h3>Les différents moyens de créer des GUI</h3><br>
<br>
Chaque système d'exploitation (Windows, Mac OS, Linux...) propose au moins un moyen de créer des fenêtres... le problème, c'est justement que ce moyen n'est en général pas <span class="italique">portable</span>, c'est-à-dire que votre programme créé uniquement pour Windows ne pourra marcher que sous Windows et pas ailleurs.<br>
<br>
On a grosso modo 2 types de choix :<br>
<ul>
<li>Soit on écrit son application <strong>spécialement pour l'OS</strong> qu'on veut, mais le programme ne sera pas portable.</li>
<li>Soit on utilise une bibliothèque <strong>qui s'adapte à tous les OS</strong>, c'est-à-dire une bibliothèque multi-plateforme.</li>
</ul><br>
La deuxième solution est en générale la meilleure car c'est la plus souple. C'est d'ailleurs celle que nous allons choisir pour que personne ne se sente abandonné.<br>
<br>
Histoire d'être suffisament complet quand même, je vais dans un premier temps vous parler des bibliothèques propres aux principaux OS pour que vous connaissiez au moins leurs noms.<br>
Ensuite, nous verrons quelles sont les principales bibliothèques multi-plateforme.<br>
<br>
<br>
<h4>Les bibliothèques propres aux OS</h4><br>
<br>
Chaque OS propose au moins une bibliothèque qui permet de créer des fenêtres. Le défaut de cette méthode est qu'en général cette bibliothèque ne marche que pour l'OS pour lequel elle a été créée. Ainsi, si vous utilisez la bilbiothèque de Windows, votre programme ne marchera que sous Windows.<br>
<br>
<ul>
<li><strong>Sous Windows</strong> : on dispose de ce qu'on appelle l'<span class="souligne">API Win32</span>. C'est une bibliothèque utilisable dans tous les langages (C, C++, Java, Python...) qui vous permet de créer des fenêtres sous Windows. Elle est toutefois assez complexe et il faut beaucoup de lignes de code pour arriver à ouvrir ne serait-ce qu'une simple fenêtre <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
L'API Win32 est un ensemble de fonctions. Ce n'est pas une bibliothèque qui utilise la POO. Pour palier ce problème, Microsoft a créé une autre bibliothèque appelée <span class="souligne">MFC</span>. La MFC est une bibliothèque orientée objet qui se contente en fait d'appeler les fonctions de l'API Win32 (on dit que c'est une surcouche).<br>
Ces bibliothèques tendent aujourd'hui à disparaître sous Windows, progressivement remplacée par la bibliothèque .NET qui est multi-plateforme et dont on reparlera donc un peu plus loin.<br>
<span class="italique"><a href="http://www.siteduzero.com/tuto-3-2361-0-apprentissage-de-l-api-windows.html">&gt; Tutoriel API Win32 réalisé par des membres du Site du Zéro</a></span><br>
</li>
<li><strong>Sous Mac OS X</strong> : la bibliothèque de prédilection s'appelle <span class="souligne">Cocoa</span>. On l'utilise en général en langage "Objective C". C'est une bibliothèque orientée objet.<br>
</li>
<li><strong>Sous Linux</strong> : tous les environnements de bureaux (appelés WM, Windows Managers) reposent sur X, la base des interfaces graphiques de Linux. X propose une bibliothèque appelée <span class="souligne">Xlib</span>, mais on programme rarement en Xlib sous Linux. On préfère utiliser une bibliothèque plus simple d'utilisation et multi-plateforme comme GTK+ ou Qt.<br>
</li>
</ul><br>
<br>
Comme vous le voyez, il y a en gros une bibliothèque "de base" pour chaque OS.<br>
<br>
L'API Win32 et la Xlib proposent des fonctions de bas niveau. Il faut en général beaucoup de lignes de code avant d'avoir un rendu correct.<br>
Quant à Cocoa, c'est une bibliothèque orientée objet qu'on ne peut utiliser que dans un langage orienté objet (traditionnellement Objective C, mais aussi C++, Python, Ruby...).<br>
<br>
Ces bibliothèques ont le gros défaut de ne marcher que sur le système pour lequel elles ont été conçues et d'être relativement complexes, notamment l'API Win32 et la Xlib. Heureusement, il existe un grand nombre de bibliothèques multi-plateforme qui s'adaptent à tous les OS.<br>
<br>
<br>
<h4>Les bibliothèques multi-plateforme</h4><br>
<br>
Les avantages d'utiliser une bibliothèque multi-plateforme sont nombreux. Même si vous voulez créer des programmes pour Windows et que vous n'en avez rien à faire de Linux et Mac OS, oui oui <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<ul>
<li>Tout d'abord, elles simplifient grandement la création d'une fenêtre. Il faut beaucoup moins de lignes de code pour ouvrir une "simple" fenêtre.</li>
<li>Ensuite, elles uniformisent le tout, elles forment un ensemble cohérent qui fait qu'il est facile de s'y retrouver. Les noms des fonctions et des classes sont choisis de manière logique de manière à vous aider autant que possible.</li>
<li>Enfin, elles font abstraction du système d'exploitation mais aussi de la version du système. Cela veut dire que si demain l'API Win32 cesse d'être utilisable sous Windows, votre application continuera à fonctionner car la bibliothèque multi-plateforme s'adaptera aux changements.</li>
</ul><br>
<br>
Bref, choisir une bibliothèque multi-plateforme, ce n'est pas seulement pour que le programme marche partout, mais aussi pour être sûr qu'il marchera tout le temps et pour avoir un certain confort en programmant.<br>
<br>
Voici quelques-unes des principales bibliothèques multi-plateforme à connaître, au moins de nom :<br>
<br>
<ul>
<li><strong>.NET</strong> (prononcez "Dot Net") : c'est en quelque sorte le successeur de l'API Win32. On l'utilise souvent en langage C#, un langage créé par Microsoft qui ressemble à Java (il ressemble plus à Java qu'au C++ d'ailleurs <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ). On peut néanmoins utiliser .NET dans une multitude d'autres langages dont le C++.<br>
.NET est portable car Microsoft a expliqué son fonctionnement. Ainsi, on peut utiliser un programme écrit en .NET sous Linux avec <a href="http://fr.wikipedia.org/wiki/Mono_%28logiciel%29">Mono</a>. Pour le moment néanmoins, .NET est principalement utilisé sous Windows.</li>
<li><strong>GTK+</strong> : une des plus importantes bibliothèques utilisées sous Linux. Elle est portable, c'est-à-dire utilisable sous Linux, Mac OS et Windows. GTK+ est utilisable en C. Néanmoins, il existe une version C++ appelée GTKmm (on parle de <span class="italique">wrapper</span>, ou encore de surcouche).<br>
GTK+ est la bibliothèque de prédilection pour ceux qui écrivent des applications pour Gnome sous Linux, mais elle fonctionne aussi sous KDE.<br>
C'est la bibliothèque utilisée par Firefox par exemple, pour ne citer que lui.<br>
<span class="italique"><a href="http://www.siteduzero.com/tuto-3-2609-0-creez-une-interface-avec-gtk.html">&gt; Tutoriel GTK+ réalisé par des membres du Site du Zéro</a></span></li>
<li><strong>Qt</strong> : bon je ne vous la présente pas trop longuement ici car tout ce chapitre est là pour ça <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Sachez néanmoins que Qt est très utilisée sous Linux aussi, en particulier sous l'environnement de bureau KDE.</li>
<li><strong>wxWidgets</strong> : une bibliothèque objet très complète elle aussi, comparable en gros à Qt. Sa licence est très semblable à celle de Qt (elle vous autorise à créer des programmes propriétaires). Néanmoins, j'ai choisi quand même de vous montrer Qt car cette bibliothèque est plus facile à prendre en main au début. Sachez qu'une fois qu'on l'a prise en main, wxWidgets n'est pas beaucoup plus compliquée que Qt.<br>
wxWidgets est la bibliothèque utilisée pour réaliser le GUI de l'IDE Code::Blocks.</li>
<li><strong>FLTK</strong> : contrairement à toutes les bibliothèques "poids lourd" précédentes, FLTK se veut légère. C'est une petite bibliothèque dédiée uniquement à la création d'interfaces graphiques multi-plateforme.</li>
</ul><br>
<br>
Comme vous le voyez, j'ai dû faire un choix parmi tout ça <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Je sais que certains vont me reprocher le choix de Qt par rapport à wxWidgets. Oui j'ai hésité un temps entre les 2, car ce sont 2 très bonnes bibliothèques, mais Qt a finalement gagné car elle est facile à prendre en main. C'est donc une bibliothèque plus "pédagogique" en quelque sorte <img src="./cpp_files/langue.png" alt=":p" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11238">Présentation de Qt</h2>
		<div class="ss_part_texte">
		Vous l'avez compris, Qt est une <strong>bibliothèque</strong> multi-plateforme pour créer des GUI (programme sous forme de fenêtre).<br>
Qt est écrite en C++ et est faite pour être utilisée à la base en C++, mais il est aujourd'hui possible de l'utiliser dans d'autres langages comme Java, Python, etc.<br>
<br>
<br>
<h3>Plus fort qu'une bibliothèque : un framework</h3><br>
<br>
<div class="flot_droite"><img src="./cpp_files/86863.png" alt="Image utilisateur"></div>Qt est en fait... bien plus qu'une bibliothèque. C'est un <span class="souligne">ensemble de bibliothèques</span>. Le tout est tellement énorme qu'on parle d'ailleurs plutôt de <strong>framework</strong> : cela signifie que vous avez à votre disposition un ensemble d'outils pour développer vos programmes plus efficacement.<br>
Qu'on ne s'y trompe pas : Qt est à la base faite pour créer des fenêtres, c'est en quelque sorte sa fonction centrale. Mais ce serait dommage de limiter Qt à ça.<br>
<br>
Qt est donc constituée d'un ensemble de bibliothèques, appelées "modules". On peut y trouver entre autres ces fonctionnalités :<br>
<br>
<ul>
<li><strong>Module GUI</strong> : c'est toute la partie création de fenêtres. Nous nous concentrerons surtout sur le module GUI dans ce cours.</li>
<li><strong>Module OpenGL</strong> : Qt peut ouvrir une fenêtre contenant de la 3D gérée par OpenGL.</li>
<li><strong>Module de dessin</strong> : pour tous ceux qui voudraient dessiner dans leur fenêtre (en 2D), le module de dessin est très complet !</li>
<li><strong>Module réseau</strong> : Qt fournit une batterie d'outils pour accéder au réseau, que ce soit pour créer un logiciel de Chat, un client FTP, un client Bittorent, un lecteur de flux RSS...</li>
<li><strong>Module SVG</strong> : possibilité de créer des images et animations vectorielles, à la manière de Flash.</li>
<li><strong>Module de script</strong> : Qt supporte le Javascript (ou ECMAScript), que vous pouvez réutiliser dans vos applications pour ajouter des fonctionnalités, sous forme de plugins par exemple.</li>
<li><strong>Module XML</strong> : pour ceux qui connaissent le XML, c'est un moyen très pratique d'échanger des données avec des fichiers formés à l'aide de balises, un peu comme le XHTML.</li>
<li><strong>Module SQL</strong> : permet un accès aux bases de données (MySQL, Oracle, PostgreSQL...).</li>
</ul><br>
Que les choses soient claires : Qt n'est pas gros, Qt est <span class="gros">énorme</span>, et il ne faut pas compter sur un tutoriel pour vous expliquer tout ce qu'il y a à savoir sur Qt. Je vais vous montrer beaucoup de ses possibilités mais on ne pourra jamais tout voir. On se concentrera surtout sur la partie GUI.<br>
Pour ceux qui veulent aller plus loin, il faudra lire la <a href="http://doc.trolltech.com/">documentation officielle</a> (uniquement en anglais, comme toutes les documentations pour les programmeurs de toute façon). Cette documentation est très bien faite, elle détaille toutes les fonctionnalités de Qt, même les plus récentes.<br>
<br>
Sachez d'ailleurs que j'ai choisi Qt en grande partie parce que sa documentation est très bien faite et facile à utiliser. Vous aurez donc intérêt à vous en servir <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Si vous êtes perdu ne vous en faites pas, je vous expliquerai dans un prochain chapitre comment on fait pour "lire" et naviguer dans une telle documentation.<br>
<br>
<h3>Qt est multiplateforme</h3><br>
<br>
Qt est un <strong>framework multiplateforme</strong>. Je le sais je me répète, mais c'est important de l'avoir bien compris. Tenez, d'ailleurs voilà un schéma qui illustre le fonctionnement de Qt :<br>
<br>
<div class="centre"><img src="./cpp_files/86994.png" alt="Abstraction offerte par Qt"></div><br>
<br>
Grâce à cette technique, les fenêtres que vous codez ont un "look" adapté à chaque OS. Vous codez pour Qt, et Qt traduit les instructions pour l'OS. Les utilisateurs de vos programmes n'y verront que du feu et ne sauront pas que vous utilisez Qt (de toute manière ils s'en moquent <img src="./cpp_files/hihi.png" alt="^^" class="smilies"> ).<br>
<br>
Voici une démonstration de ce que je viens de vous dire. Vous avez ci-dessous le même programme, donc la même fenêtre créée avec Qt, mais sous différents OS. Vous allez voir que Qt s'adapte à chaque fois :<br>
<br>
<br>
<table class="tab_user">


<tbody><tr>
<td><div class="centre"><a href="http://uploads.siteduzero.com/files/86001_87000/86988.png"><img src="./cpp_files/89416.png" alt="Qt sous Windows Vista"></a><br>
<span class="italique">Sous Windows Vista</span></div></td>
<td><div class="centre"><a href="http://uploads.siteduzero.com/files/89001_90000/89413.png"><img src="./cpp_files/89414.png" alt="Qt sous Windows XP"></a><br>
<span class="italique">Sous Windows XP</span></div></td>
</tr><tr>
<td><div class="centre"><a href="http://uploads.siteduzero.com/files/89001_90000/89490.png"><img src="./cpp_files/89491.png" alt="Image utilisateur"></a><br>
<span class="italique">Sous Linux</span></div></td>
<td><div class="centre"><a href="http://uploads.siteduzero.com/files/89001_90000/89411.jpg"><img src="./cpp_files/89415.jpg" alt="Qt sous Mac OS X"></a><br>
<span class="italique">Sous Mac OS X</span></div></td>
</tr></tbody></table><br>
Tout ce que vous avez à faire pour produire le même résultat, c'est recompiler votre programme sous chacun de ces OS. Par exemple, vous avez développé votre programme sous Windows, très bien, mais les .exe n'existent pas sous Linux. Il vous suffit simplement de recompiler votre programme sous Linux et c'est bon, vous avez une version Linux !<br>
<br>
<div class="rmq question">On est obligé de recompiler pour chacun des OS ?</div><br>
Oui, ça vous permet de créer des programmes binaires adaptés à chaque OS qui tournent à pleine vitesse.<br>
On ne va toutefois pas se préoccuper de compiler sous chacun des OS maintenant, on va déjà le faire pour votre OS ça sera bien <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="rmq information">Pour information, d'autres langages de programmation comme Java et Python ne nécessitent pas de recompilation car le terme "compilation" n'existe pas vraiment sous ces langages. Cela fait que les programmes sont un peu plus lents, mais ils s'adaptent automatiquement partout.<br>
L'avantage du C++ par rapport à ces langages est donc sa rapidité (bien que la différence se sente de moins en moins, sauf pour les jeux vidéo qui ont besoin de rapidité et qui sont donc majoritairement codés en C++).</div><br>
<br>
<h3>L'histoire de Qt</h3><br>
<br>
Bon, ne comptez pas sur moi pour vous faire un historique long et chiant sur Qt, mais je pense qu'un tout petit peu de culture générale ne peut pas vous faire de mal et vous permettra de savoir de quoi vous parlez <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Qt est un framework développé initialement par la société Trolltech, qui fut racheté par Nokia par la suite.<br>
Le développement de Qt a commencé en 1991 (ça remonte pas mal donc) et il a été dès le début utilisé par KDE, un des principaux environnements de bureau de Linux.<br>
<br>
Qt s'écrit "Qt" et non "QT", donc avec un "t" minuscule (si vous faites l'erreur un fanatique de Qt vous égorgera probablement pour vous le rappeler <img src="./cpp_files/langue.png" alt=":p" class="smilies"> )<br>
Qt signifie "Cute" (prononcez "Quioute"), ce qui signifie "Mignonne", parce que les développeurs trouvaient que la lettre Q était jolie dans leur éditeur de texte. Oui je sais, ils sont fous ces programmeurs.<br>
<br>
<br>
<h3>La licence de Qt</h3><br>
<br>
A l'origine, Qt possédait une licence propriétaire, son code source était fermé.<br>
<br>
Heureusement, maintenant Qt est sous licence LGPL. Cela signifie, en gros, que vous pouvez l'utiliser pour faire des programmes libres ou propriétaires, selon ce que vous souhaitez.<br>
<br>
<div class="rmq information">Pendant longtemps, Qt était sous licence GPL. Cela vous obligeait à faire des programmes libres.<br>
Toutefois, depuis son rachat par Nokia, la licence est passée à la LGPL qui est plus souple et qui vous permet de faire des programmes propriétaires.</div><br>
<br>
Bref, c'est vraiment l'idéal pour nous. On peut l'utiliser gratuitement et en faire usage dans des programmes libres comme dans des programmes propriétaires. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Qui utilise Qt ?</h3><br>
<br>
Une bibliothèque comme Qt a besoin de références, c'est-à-dire d'entreprises célèbres qui l'utilisent, pour montrer son sérieux.<br>
De ce point de vue là, pas de problème. Qt est utilisée par de nombreuses entreprises que vous connaissez sûrement :<br>
<br>
<ul>
<li><img src="./cpp_files/89532.png" alt="Adobe"></li>
<li><img src="./cpp_files/89533.png" alt="Archos"></li>
<li><img src="./cpp_files/89534.png" alt="Boeing"></li>
<li><img src="./cpp_files/89535.png" alt="Google"></li>
<li><img src="./cpp_files/89531.png" alt="NASA"></li>
<li><img src="./cpp_files/89536.png" alt="Skype"></li>
</ul><br>
<br>
Qt est utilisée pour réaliser de nombreux GUI, comme celui d'Adobe Photoshop Elements, de Google Earth ou encore de Skype !
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11237">Installation de Qt</h2>
		<div class="ss_part_texte">
		Vous êtes prêts à installer Qt ?<br>
On est parti !<br>
<br>
<br>
<h3>Télécharger Qt</h3><br>
<br>
Commencez par télécharger Qt sur le <a href="http://qt.nokia.com/downloads">site de Qt</a>.<br>
<br>
Je vous conseille de prendre le Qt SDK qui contient plus de programmes pour vous aider à développer (notamment un IDE appelé Qt Creator).<br>
Choisissez soit "Qt pour Windows: C++", "Qt pour Linux/X11: C++" ou "Qt pour Mac: C++" en fonction de votre système d'exploitation.<br>
<br>
Il y a 3 téléchargements possibles, en fonction de votre OS :<br>
<br>
<ul>
<li><strong>Windows </strong>: si vous avez Windows, passez par là ! Dans la page qui s'affiche, choisissez de préférence le ".exe"contenant mingw (plutôt que le zip), c'est un installeur prêt à l'emploi qui contient tout ce qu'il vous faut.</li>
<li><strong>Mac </strong>: pour ceux qui sont sous Mac OS ! Je vous conseille de prendre le fichier à l'extension .dmg (ex : qt-mac-opensource-4.4.0.dmg). Ce fichier contient un installeur .mpkg qui se charge d'installer tout le framework Qt de la même manière que Windows.</li>
<li><strong>Linux/X11 </strong>: si vous êtes sous Linux (vous utilisez donc X pour l'interface graphique), c'est pour vous ! Le plus simple sous Debian et Ubuntu est quand même de passer par la console (plutôt que par le site de Qt) et de taper <span class="courrier">sudo apt-get install libqt4-dev</span>, ça fait tout pour vous <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Il y a une version 32  bits et une version 64 bits, à choisir en fonction de votre installation.</li>
</ul><br>
<br>
<h3>Installation sous Windows</h3><br>
<br>
L'installation sous Windows se présente sous la forme d'un assistant d'installation classique.<br>
Je vais vous montrer comment ça se passe pas à pas, ce n'est pas bien compliqué.<br>
<br>
La première fenêtre est la suivante :<br>
<br>
<div class="centre"><img src="./cpp_files/89538.png" alt="Image utilisateur"></div><br>
<br>
Rien de particulier à signaler. Cliquez sur Next autant de fois que nécessaire en laissant les options par défaut, jusqu'à arriver à la fenêtre suivante :<br>
<br>
<div class="centre"><img src="./cpp_files/89539.png" alt="Image utilisateur"></div><br>
<br>
Cette fenêtre vous demande si vous voulez installer MinGW, le compilateur. Normalement, vous avez déjà installé MinGW en même temps que votre IDE, donc il est déjà sur votre disque.<br>
Toutefois, il faut que vous ayez la bonne version de MinGW avec l'API Win32 pour que Qt puisse faire la traduction correctement. Je vous recommande donc fortement de le réinstaller (ça ne pose aucun problème) dans le répertoire par défaut proposé par l'installeur, ici C:\MinGW.<br>
<br>
Lorsque les options sont comme chez moi, cliquez sur Next.<br>
On vous demande alors où télécharger MinGW (sur quel miroir) :<br>
<br>
<div class="centre"><img src="./cpp_files/89540.png" alt="Image utilisateur"></div><br>
<br>
Vous n'avez pas trop le choix, vous ne pouvez télécharger MinGW que chez Qt sur leurs serveurs en Norvège <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Sélectionnez donc "Trolltech (Norway)", ne cochez pas "Download MinGW source code" (on n'en a pas besoin) et cliquez sur Install.<br>
<br>
MinGW se télécharge et s'installe tout seul :<br>
<br>
<div class="centre"><img src="./cpp_files/89541.png" alt="Image utilisateur"></div><br>
<br>
Puis Qt s'installe enfin (il y a beaucoup de fichiers ça peut prendre un peu de temps) :<br>
<br>
<div class="centre"><img src="./cpp_files/89542.png" alt="Image utilisateur"></div><br>
<br>
Vous êtes à la fin ? Ouf !<br>
On vous propose d'ouvrir 2 programmes installés par Qt, ouvrez-les si vous voulez.<br>
<br>
<div class="centre"><img src="./cpp_files/89543.png" alt="Image utilisateur"></div><br>
<br>
<br>
<h3>Les programmes installés par Qt</h3><br>
<br>
En plus de tous les fichiers nécessaires au développement de GUI, Qt installe 4 programmes qui pourront vous être utiles par la suite.<br>
Je vais rapidement vous les présenter mais on ne va pas rentrer dans le détail de chacun d'eux, il est trop tôt.<br>
<br>
<h4>Qt Examples and Demos</h4><br>
<br>
<div class="centre"><img src="./cpp_files/89544.png" alt="Image utilisateur"></div><br>
<br>
Ca c'est juste une démonstration des possibilités de Qt. Vous pouvez explorer ce programme autant que vous voulez, il est juste là pour présenter Qt.<br>
<br>
<br>
<h4>Qt Assistant</h4><br>
<br>
<div class="centre"><img src="./cpp_files/89545.png" alt="Image utilisateur"></div><br>
<br>
Qt Assistant est la documentation de Qt. Dedans, <span class="souligne">il y a tout</span>. Tout ce que vous avez besoin de savoir, toutes les fonctionnalités de Qt, toutes les fonctions, toutes les classes que vous pouvez utiliser.<br>
C'est ce que vous trouverez de plus complet.<br>
<br>
Certes, la documentation est en anglais, comme la plupart des documentations pour développeurs. Elle est néanmoins très bien faite, et savoir s'en servir est indispensable si on veut essayer d'autres choses que ce que j'expliquerai dans le tuto. Je vous apprendrai donc à la lire dans un prochain chapitre <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<h4>Qt Linguist</h4><br>
<br>
<div class="centre"><img src="./cpp_files/89582.png" alt="Qt Linguist"></div><br>
<br>
Qt Linguist est une application à destination des traducteurs. Si votre programme doit être décliné en plusieurs langues, Qt vous offre donc tous les outils dont vous pourriez avoir besoin pour les traduire.<br>
<br>
Le gros avantage est qu'il n'y a pas besoin d'être programmeur pour traduire l'application. Il vous suffira de donner un fichier qui contient tout le texte de votre application (généré par Qt), de le donner à traduire à un traducteur avec Qt Linguist, et hop, votre application est multilingue ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h4>Qt Designer</h4><br>
<br>
<div class="centre"><img src="./cpp_files/89583.png" alt="Qt Designer"></div><br>
<br>
Qt Designer vous permet, vous l'aurez deviné, de créer les fenêtres de vos applications à la souris.<br>
<br>
Normalement, une fenêtre se code (on peut créer une fenêtre rien qu'avec du code sans passer par Qt Designer). Qt Designer vous fera gagner du temps... lorsque vous saurez vous servir de Qt. Avant d'utiliser Qt Designer, il faut savoir coder la fenêtre à la main !<br>
<br>
<div class="rmq erreur">Attention Qt Designer est un piège pour les débutants ! Il est très attirant, on pense que ça va être super simple de créer des fenêtres, mais en fait c'est bien plus complexe que cela. Vous ne DEVEZ PAS vous ruer dessus : vous ne pourriez pas vous en servir et l'exploiter correctement.<br>
Je vous expliquerai comment fonctionne Qt Designer, mais ce sera plus tard dans le cours. Il est impératif que vous sachiez d'abord coder une fenêtre à la main, sinon vous ne pourrez pas l'utiliser correctement.</div><br>
Sous ses apparences simples, Qt Designer est en fait une application complexe qu'on ne peut maîtriser que lorsqu'on a déjà de l'expérience avec Qt. Et cette expérience, on va l'acquérir au fil des chapitres qui suivent <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	<span class="courrier">Notion de GUI... OK<br>
Présentation des bibliothèques GUI... OK<br>
Présentation des modules de Qt... OK<br>
Notion de framework multi-plateforme... OK<br>
Culture générale sur Qt... OK<br>
Téléchargement de Qt... OK<br>
Installation de Qt... OK<br>
Présentation des programmes livrés avec Qt... OK<br>
</span><br>
<br>
- C'est bon mon commandant, ils sont parés au lancement <img src="./cpp_files/ninja.png" alt=":ninja:" class="smilies"> <br>
- Ouvrez le sas et accrochez-vous lieutenant, ça risque de bouger un peu <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11250">Compiler votre première fenêtre Qt</h1>
	<div id="chap_intro">
	Bonne nouvelle, votre patience et votre persévérance vont maintenant payer <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Dans ce chapitre, nous réaliserons notre premier programme utilisant Qt, et nous verrons comment ouvrir notre première fenêtre !<br>
<br>
La compilation sous Qt est un peu particulière car elle comporte plusieurs étapes. Je vais vous expliquer pourquoi la compilation avec Qt est différente et comment vous devez procéder pour compiler votre programme.<br>
<br>
<span class="italique">Let's go !</span>
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11249">Codons notre première fenêtre !</h2>
		<div class="ss_part_texte">
		Ok on est parti !<br>
Voilà comment on va procéder : ouvrez votre IDE favori, par exemple Code::Blocks, et créez un nouveau projet console C++ comme vous le faisiez jusqu'ici. Appelez ce projet comme vous voulez, par exemple "Test". Placez votre projet dans un dossier qui ne contient <span class="souligne">pas d'espace dans le nom</span>, c'est important pour la suite.<br>
<br>
<div class="rmq erreur">Sous Code::Blocks, il y a un assistant de création de nouveau projet Qt. Faites un projet <span class="souligne">console</span>. J'insiste bien là-dessus, ne vous trompez pas <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
<h3>Le code minimal d'un projet Qt</h3><br>
<br>
Votre projet est constitué normalement au départ d'un seul fichier : main.cpp.<br>
Supprimez le code qui a pu être généré par votre IDE, et remplacez-le par celui-ci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
 
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
 
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est le <strong>code minimal</strong> d'une application utilisant Qt !<br>
<br>
Comme vous pouvez le constater, ce qui est génial c'est que c'est vraiment très court <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
D'autres bibliothèques vous demandent beaucoup plus de lignes de code avant de pouvoir commencer à programmer, tandis qu'avec Qt c'est vraiment très simple et rapide <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Analysons ce code pas à pas !<br>
<br>
<br>
<h4>Includes un jour, includes toujours</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est le seul include que vous avez besoin de faire au départ. Vous pouvez oublier iostream et compagnie, avec Qt on ne s'en sert plus.<br>
Vous noterez qu'on ne met pas l'extension ".h", c'est voulu. Faites exactement comme moi.<br>
<br>
Cet include vous permet d'accéder à la classe QApplication, qui est la classe de base de tout programme Qt.<br>
<br>
<br>
<h4>QApplication, la classe de base</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La première ligne du <span class="italique">main</span> crée un nouvel objet de type QApplication. On a fait ça tout le long des derniers chapitres, vous ne devriez pas être surpris <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Cet objet est appelé app (mais vous pouvez l'appeler comme vous voulez). Le constructeur de QApplication exige que vous lui passiez les arguments du programme, c'est-à-dire les paramètres argc et argv que reçoit la fonction <span class="italique">main</span>. Cela permet de démarrer le programme avec certaines options précises, mais on ne s'en servira pas ici.<br>
<br>
<br>
<h4>Lancement de l'application</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cette ligne fait 2 choses :<br>
<ol class="liste_1">
<li>Elle appelle la méthode exec de notre objet app. Cette méthode démarre notre programme. Si vous ne le faites pas il ne se passera rien.</li>
<li>Elle retourne le résultat de app.exec() pour dire si le programme s'est bien déroulé ou pas. Le return provoque la fin de la fonction main, donc du programme.</li></ol><br>
C'est un peu du condensé en fait <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Ce que vous devez vous dire, c'est qu'en gros tout notre programme s'exécute à partir de ce moment-là. La méthode exec est gérée par Qt : tant qu'elle s'exécute, notre programme est ouvert. Dès que la méthode exec est terminée, notre programme s'arrête.<br>
<br>
<br>
<h3>Affichage d'un widget</h3><br>
<br>
Dans la plupart des bibliothèques GUI, dont Qt fait partie, tous les éléments d'une fenêtre sont appelés des <strong>widgets</strong>. Les boutons, les cases à cocher, les images... tout ça ce sont des widgets. La fenêtre elle-même est considérée comme un widget.<br>
<br>
Pour provoquer l'affichage d'une fenêtre, il suffit de demander à afficher n'importe quel widget. Ici par exemple, nous allons afficher un bouton.<br>
<br>
Voici le code complet que j'aimerais que vous utilisiez. Il utilise le code de base de tout à l'heure mais y ajoute quelques lignes :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="ln-xtra"><span class="cp">#include &lt;QPushButton&gt;</span></span>
 
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
 
<span class="ln-xtra">    <span class="n">QPushButton</span> <span class="n">bouton</span><span class="p">(</span><span class="s">"Salut les Zéros, la forme ?"</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">bouton</span><span class="p">.</span><span class="n">show</span><span class="p">();</span></span>
 
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les lignes ajoutées ont été surlignées pour bien que vous puissiez les repérer.<br>
On voit entre autres :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QPushButton&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cette ligne va vous permettre de créer des objets de type QPushButton, c'est-à-dire des boutons (vous noterez que sous Qt toutes les classes commencent par un "Q" d'ailleurs !).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QPushButton</span> <span class="n">bouton</span><span class="p">(</span><span class="s">"Salut les Zéros, la forme ?"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cela crée un nouvel objet de type QPushButton que nous appelons tout simplement <span class="italique">bouton</span>, mais on aurait très bien pu l'appeler autrement. Le constructeur attend un paramètre : le texte qui sera affiché sur le bouton.<br>
<br>
Malheureusement, le fait de créer un bouton ne suffit pas pour qu'il soit affiché. Il faut appeler sa méthode <span class="italique">show </span>:<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">bouton</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Et voilà !<br>
Cette ligne commande l'affichage d'un bouton. Comme un bouton ne peut pas "flotter" comme ça sur votre écran, Qt l'insère automatiquement dans une fenêtre. On a en quelque sorte créé une "fenêtre-bouton" <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Bien entendu, dans un vrai programme plus complexe, on crée d'abord une fenêtre et on y insère ensuite plusieurs widgets, mais là on commence simplement <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Notre code est prêt, il ne reste plus qu'à compiler et exécuter le programme !<br>
<br>
 <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> <br>
<br>
... mais, pour compiler avec Qt c'est un peu particulier. On ne pourra pas se contenter de cliquer sur le bouton "Compiler" de l'IDE.<br>
Je vais maintenant vous expliquer comment procéder pour compiler avec Qt, et je vous rassure ça n'a rien de compliqué, c'est juste un peu différent !
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11248">Compiler un projet Qt : la théorie</h2>
		<div class="ss_part_texte">
		La bibliothèque Qt est tellement importante qu'elle apporte quelques ajouts au langage C++, en particulier le mécanisme des signaux et slots dont on reparlera un peu plus loin.<br>
<br>
Pour ajouter ces fonctionnalités au langage C++, la compilation sort du schéma classique. On va en profiter ici pour revoir (ou voir pour certains <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ) comment la compilation fonctionne d'habitude dans les grandes lignes, puis nous découvrirons comment il faut compiler un programme utilisant Qt.<br>
<br>
<br>
<h3>La compilation "normale", sans Qt</h3><br>
<br>
Savez-vous vraiment ce qui se passe lorsque vous cliquez sur "Compiler" dans votre IDE favori (Code::Blocks, Visual Studio...) ?<br>
Il y a en fait 2 grosses étapes :<br>
<br>
<ol class="liste_1">
<li>L'IDE regarde la liste des fichiers de votre projet (.cpp et .h) et génère un fichier appelé Makefile qui contient la liste des fichiers à compiler pour le compilateur.</li>
<li>Ensuite, l'IDE appelle le compilateur (via le programme <span class="italique">make</span>). L'utilitaire <span class="italique">make</span> recherche un fichier Makefile et l'utilise pour savoir quoi compiler et avec quelles options.</li></ol><br>
<br>
Schématiquement ça donne ça :<br>
<br>
<div class="centre"><img src="./cpp_files/90024.png" alt="Compilation et makefile"></div><br>
<br>
En fait, le gros avantage de l'IDE c'est qu'il écrit le fichier Makefile pour vous. On peut écrire le Makefile à la main, mais c'est honnêtement pas très pratique ni toujours très simple, surtout pour de gros projets. En effet, le fichier Makefile est parfois très gros.<br>
<br>
Voici un aperçu (raccourci) d'un fichier Makefile pour vous donner une idée :<br>
<br>
<span class="code">Code : Autre - <a href="#" class="select_code">Sélectionner</a></span><div class="code2"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><div class="syntax"><pre>all:&nbsp;$(PROG)
&nbsp;
$(PROG):&nbsp;$(OBJS)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(CC)&nbsp;$(CFLAGS)&nbsp;$(LDFLAGS)&nbsp;$(LDLIBS)&nbsp;-o&nbsp;$(PROG)&nbsp;$(OBJS)
&nbsp;
.c.o:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(CC)&nbsp;$(CFLAGS)&nbsp;-c&nbsp;$*.c</pre></div></td></tr></tbody></table></div><br>
<br>
Qu'un IDE génère le Makefile pour nous n'est donc pas du luxe <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<br>
<h3>La compilation particulière avec Qt</h3><br>
<br>
Le problème survient quand vous utilisez des bibliothèques importantes comme Qt. Il faut configurer votre IDE pour qu'il puisse écrire le Makefile correctement, c'est-à-dire indiquer l'emplacement des fichiers .a (ou .lib), des headers de la bibliothèque, etc.<br>
<br>
On pourrait en théorie configurer votre IDE pour que ça marche en cliquant sur "Compiler"... mais ce serait un peu long et compliqué (il faudrait une explication par IDE, et parfois par version d'IDE). J'ai à la place choisi de vous montrer une technique universelle : <span class="souligne">passer par la ligne de commande</span> ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
 <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> <br>
<br>
Bah pourquoi tout le monde est parti ?<br>
Je vous rassure, ce n'est pas aussi infaisable que ce que vous pouvez croire, ce sera même plus simple que de configurer notre IDE, c'est vous dire <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Qt est livré avec un petit programme en ligne de commande appelé "<span class="italique">qmake</span>". Ce programme est capable de générer un fichier Makefile à partir d'un fichier spécifique à Qt : le .pro.<br>
Le .pro (qui s'appelle en général nomDeVotreProjet.pro) est un fichier texte court et simple à écrire qui donne la liste de vos fichiers .cpp et .h, ainsi que les options à envoyer à Qt.<br>
<br>
<div class="rmq information">Sous Linux, la commande n'est pas <span class="italique">qmake </span>mais <span class="italique">qmake-qt4</span>.</div><br>
<br>
Ca se passe donc comme ça avec Qt :<br>
<div class="centre"><img src="./cpp_files/90026.png" alt="Compilation avec qmake"></div><br>
<br>
<div class="rmq question">... Je suis obligé d'écrire moi-même le .pro ? Je ne sais pas faire ! Et puis faire la liste des fichiers du projet ça peut être long non ? <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> </div><br>
<br>
Rassurez-vous, Qt peut vous générer un .pro automatiquement ! Si on utilise d'abord qmake avec l'option -project dans le dossier de notre projet, qmake va analyser les fichiers du dossier et générer un fichier .pro basique (mais suffisant pour nous pour le moment).<br>
<br>
<div class="centre"><img src="./cpp_files/90027.png" alt="Compilation avec qmake"></div><br>
<br>
En résumé, pour compiler avec Qt il y a 3 commandes très simples à taper en console. Dans l'ordre :<br>
<br>
<ol class="liste_1">
<li><span class="courrier">qmake -project</span></li>
<li><span class="courrier">qmake</span></li>
<li><span class="courrier">make</span> (sous Linux) ou <span class="courrier">mingw32-make</span> (sous Windows)</li></ol><br>
<br>
<div class="rmq attention">Attention ! Sous Windows, dans les dernières versions de Qt, il faut taper <span class="courrier">mingw32-make</span> et <span class="courrier">non make</span> si vous avez installé Mingw avec Qt !</div><br>
<br>
Normalement, il n'est nécessaire de taper les 2 premières commandes (<span class="italique">qmake -project</span> et <span class="italique">qmake</span>) que la première fois pour générer le Makefile. Ensuite, vous n'aurez plus besoin que de relancer <span class="italique">make </span>pour recompiler votre projet.<br>
<br>
<div class="rmq information">Il faudra en fait relancer les commandes <span class="italique">qmake -project</span> et <span class="italique">qmake</span> à chaque fois que votre projet évoluera, c'est-à-dire à chaque fois que de nouveaux fichiers .cpp et .h seront ajoutés ou supprimés. Tant que la liste des fichiers de votre projet ne change pas, il n'est pas nécessaire de retaper ces 2 premières commandes.</div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11247">Compiler un projet Qt : la pratique</h2>
		<div class="ss_part_texte">
		Bien, si on la compilait cette fenêtre ? <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Pour commencer, il faut lancer une console. Sous Windows, Qt vous a normalement fait un raccourci dans le menu démarrer appelé "Qt Command Prompt" :<br>
<br>
<div class="centre"><img src="./cpp_files/90599.png" alt="Qt Raccourci"></div><br>
<br>
<div class="rmq erreur">Attention : vous savez peut-être lancer la console sous Windows en passant par un autre raccourci ou encore en faisant Démarrer / Exécuter / "cmd.exe". Mais ici, vous <span class="souligne">devez</span> utiliser ce raccourci car il précharge certaines informations relatives à Qt.</div><br>
<br>
Normalement, la console s'ouvre et affiche ces informations :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Setting&nbsp;up&nbsp;a&nbsp;MinGW/Qt&nbsp;only&nbsp;environment...
--&nbsp;QTDIR&nbsp;set&nbsp;to&nbsp;C:\Qt\4.3.2
--&nbsp;PATH&nbsp;set&nbsp;to&nbsp;C:\Qt\4.3.2\bin
--&nbsp;Adding&nbsp;C:\MinGW\bin&nbsp;to&nbsp;PATH
--&nbsp;Adding&nbsp;C:\WINDOWS\System32&nbsp;to&nbsp;PATH
--&nbsp;QMAKESPEC&nbsp;set&nbsp;to&nbsp;win32-g++
&nbsp;
C:\Qt\4.3.2&gt;</pre></div></td></tr></tbody></table></div><br>
<br>
Les premières lignes sont importantes. Elles signifient que dans cette console le compilateur connaîtra la position de la bibliothèque Qt ainsi que de ses headers. Ca nous enlève beaucoup beaucoup de maux de tête avec les paramétrages <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Pour l'instant, la console indique que nous sommes dans le dossier <span class="courrier">C:\Qt\4.3.2</span> (le chemin peut changer en fonction de la version de Qt mais ce n'est pas grave du tout).<br>
Je veux que vous vous rendiez dans le dossier où est enregistré votre projet. Pour cela, le plus simple est de taper dans la console :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>cd&nbsp;CheminDeVotreProjet</pre></div></td></tr></tbody></table></div><br>
<br>
<div class="rmq erreur">Attention : vous ne pourrez pas compiler avec make si le nom du dossier de votre projet comporte un espace. Veillez à placer votre projet dans un dossier qui ne contient pas d'espace.</div><br>
<br>
Si vous copiez-collez le chemin depuis l'explorateur de Windows ça devrait aller très vite (il faudra faire un clic droit pour coller le texte dans la console).<br>
<br>
<div class="centre"><img src="./cpp_files/90600.png" alt="Fichiers du premier projet Qt"></div><br>
<br>
Dans mon cas j'écrirai donc la commande suivante :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>cd&nbsp;C:\Users\Mateo\Projets\Test</pre></div></td></tr></tbody></table></div><br>
<br>
Tapez Entrée. Vous devriez vous retrouver dans le dossier de votre projet.<br>
<br>
<br>
<h4>Etape 1 : générer le .pro (qmake -project)</h4><br>
<br>
On va commencer par générer le fichier .pro automatiquement. Vous vous souvenez de la commande ? <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>C:\Users\Mateo\Projets\Test&gt;qmake&nbsp;-project
&nbsp;
C:\Users\Mateo\Projets\Test&gt;</pre></div></td></tr></tbody></table></div><br>
<br>
Si tout se passe bien, rien de spécial ne devrait s'afficher après avoir tapé la commande. Par contre, si vous regardez le dossier de votre projet, il contient maintenant un fichier .pro :<br>
<br>
<div class="centre"><img src="./cpp_files/90603.png" alt="Fichiers du premier projet Qt avec le .pro"></div><br>
<br>
On ne va pas étudier le contenu du fichier .pro maintenant, mais sachez que vous pouvez l'ouvrir avec un éditeur de texte comme Bloc-Notes sans problème.<br>
<br>
Passons à l'étape suivante !<br>
<br>
<h4>Etape 2 : générer le Makefile (qmake)</h4><br>
<br>
Retournez dans la console et tapez tout simplement <span class="courrier">qmake</span> (sans le <span class="courrier">-project</span> cette fois).<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>C:\Users\Mateo\Projets\Test&gt;qmake
&nbsp;
C:\Users\Mateo\Projets\Test&gt;</pre></div></td></tr></tbody></table></div><br>
<br>
Encore une fois, rien de particulier ne devrait s'afficher à l'écran, mais cette fois le fichier Makefile a été généré. Vous devriez en fait trouver plusieurs Makefiles et dossiers (selon si on compile en mode "Debug" pour le débogage, ou "Release" pour la compilation finale lorsque le programme est prêt à être distribué).<br>
<br>
<div class="centre"><img src="./cpp_files/90604.png" alt="Fichiers du premier projet Qt avec le Makefile"></div><br>
<br>
Vous pouvez ouvrir par exemple le fichier qui s'appelle "Makefile" (tout court, sans extension) avec un éditeur de texte comme Bloc-Notes. Vous constaterez que ce fichier, destiné à <span class="italique">make</span>, est beaucoup plus gros que le .pro. On ne modifiera jamais le Makefile, contrairement au .pro que l'on peut s'amuser à modifier facilement.<br>
<br>
<div class="rmq information">Si vous êtes sous Mac OS X, la commande <span class="code2">qmake</span> ne génère pas de Makefile par défaut. Il faut le lui dire avec l'option <span class="code2">-spec</span>. Tapez dans la console <span class="code2">qmake&nbsp;-spec&nbsp;macx-g++</span>. <img src="./cpp_files/clin.png" alt=";)" class="smilies"> </div><br>
<br>
<h4>Etape 3 : compiler (make ou mingw32-make)</h4><br>
<br>
Il ne vous reste plus qu'à taper <span class="italique">make </span> (ou mingw32-make si vous êtes sous Windows) dans la console pour lancer le compilateur ! Celui-ci va rechercher automatiquement le fichier "Makefile" dans le dossier dans lequel vous vous trouvez.<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>C:\Users\Mateo\Projets\Test&gt;mingw32-make
mingw32-make&nbsp;-f&nbsp;Makefile.Release
mingw32-make[1]:&nbsp;Entering&nbsp;directory&nbsp;`C:/Users/Mateo/Projets/Test'
g++&nbsp;-c&nbsp;-O2&nbsp;-frtti&nbsp;-fexceptions&nbsp;-mthreads&nbsp;-Wall&nbsp;-DUNICODE&nbsp;-DQT_LARGEFILE_SUPPORT
-DQT_DLL&nbsp;-DQT_NO_DEBUG&nbsp;-DQT_GUI_LIB&nbsp;-DQT_CORE_LIB&nbsp;-DQT_THREAD_SUPPORT&nbsp;-DQT_NEEDS
_QMAIN&nbsp;-I"..\..\..\..\Qt\4.3.2\include\QtCore"&nbsp;-I"..\..\..\..\Qt\4.3.2\include\Q
tCore"&nbsp;-I"..\..\..\..\Qt\4.3.2\include\QtGui"&nbsp;-I"..\..\..\..\Qt\4.3.2\include\Qt
Gui"&nbsp;-I"..\..\..\..\Qt\4.3.2\include"&nbsp;-I"."&nbsp;-I"c:\Qt\4.3.2\include\ActiveQt"&nbsp;-I"
release"&nbsp;-I"."&nbsp;-I"..\..\..\..\Qt\4.3.2\mkspecs\win32-g++"&nbsp;-o&nbsp;release\main.o&nbsp;main
.cpp
g++&nbsp;-enable-stdcall-fixup&nbsp;-Wl,-enable-auto-import&nbsp;-Wl,-enable-runtime-pseudo-rel
oc&nbsp;-Wl,-s&nbsp;-mthreads&nbsp;-Wl&nbsp;-Wl,-subsystem,windows&nbsp;-o&nbsp;"release\Test.exe"&nbsp;release\mai
n.o&nbsp;&nbsp;-L"c:\Qt\4.3.2\lib"&nbsp;-lmingw32&nbsp;-lqtmain&nbsp;-lQtGui4&nbsp;-lQtCore4
mingw32-make[1]:&nbsp;Leaving&nbsp;directory&nbsp;`C:/Users/Mateo/Projets/Test'
&nbsp;
C:\Users\Mateo\Projets\Test&gt;</pre></div></td></tr></tbody></table></div><br>
<br>
Contrairement à qmake, la commande make est un poil plus bavarde <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Vous voyez toutes les options qui ont été envoyées au compilateur... Et y'en a un paquet !<br>
<br>
Le compilateur se charge de compiler tous les fichiers qui ont été modifiés depuis la dernière compilation, puis il appelle le linker pour assembler tous les fichiers objet en un bel exécutable.<br>
<span class="italique">Si ce que je viens de vous dire à l'instant est du chinois pour vous, c'est que <a href="http://www.siteduzero.com/tuto-3-3040-1-la-programmation-modulaire.html#ss_part_3">vous n'avez sûrement pas lu ça</a>.</span><br>
<br>
Si par hasard il y a une erreur de compilation sur un des fichiers, l'erreur s'affichera dans la console. On vous indiquera dans quel fichier et à quelle ligne se trouve l'erreur, après il ne vous reste plus qu'à la corriger <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="rmq information">Pensez à configurer votre IDE dans les options pour qu'il affiche les numéros de ligne si ce n'est déjà fait, je ne veux pas vous voir "compter" les lignes à la main pour retrouver la ligne de l'erreur.</div><br>
<br>
<h3>Résumé des commandes</h3><br>
<br>
En résumé, j'ai tapé les commandes suivantes :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>Setting&nbsp;up&nbsp;a&nbsp;MinGW/Qt&nbsp;only&nbsp;environment...
--&nbsp;QTDIR&nbsp;set&nbsp;to&nbsp;C:\Qt\4.3.2
--&nbsp;PATH&nbsp;set&nbsp;to&nbsp;C:\Qt\4.3.2\bin
--&nbsp;Adding&nbsp;C:\MinGW\bin&nbsp;to&nbsp;PATH
--&nbsp;Adding&nbsp;C:\Windows\System32&nbsp;to&nbsp;PATH
--&nbsp;QMAKESPEC&nbsp;set&nbsp;to&nbsp;win32-g++
&nbsp;
C:\Qt\4.3.2&gt;cd&nbsp;C:\Users\Mateo\Projets\Test
&nbsp;
C:\Users\Mateo\Projets\Test&gt;qmake&nbsp;-project
&nbsp;
C:\Users\Mateo\Projets\Test&gt;qmake
&nbsp;
C:\Users\Mateo\Projets\Test&gt;mingw32-make
mingw32-make&nbsp;-f&nbsp;Makefile.Release
mingw32-make[1]:&nbsp;Entering&nbsp;directory&nbsp;`C:/Users/Mateo/Projets/Test'
g++&nbsp;-c&nbsp;-O2&nbsp;-frtti&nbsp;-fexceptions&nbsp;-mthreads&nbsp;-Wall&nbsp;-DUNICODE&nbsp;-DQT_LARGEFILE_SUPPORT
-DQT_DLL&nbsp;-DQT_NO_DEBUG&nbsp;-DQT_GUI_LIB&nbsp;-DQT_CORE_LIB&nbsp;-DQT_THREAD_SUPPORT&nbsp;-DQT_NEEDS
_QMAIN&nbsp;-I"..\..\..\..\Qt\4.3.2\include\QtCore"&nbsp;-I"..\..\..\..\Qt\4.3.2\include\Q
tCore"&nbsp;-I"..\..\..\..\Qt\4.3.2\include\QtGui"&nbsp;-I"..\..\..\..\Qt\4.3.2\include\Qt
Gui"&nbsp;-I"..\..\..\..\Qt\4.3.2\include"&nbsp;-I"."&nbsp;-I"c:\Qt\4.3.2\include\ActiveQt"&nbsp;-I"
release"&nbsp;-I"."&nbsp;-I"..\..\..\..\Qt\4.3.2\mkspecs\win32-g++"&nbsp;-o&nbsp;release\main.o&nbsp;main
.cpp
g++&nbsp;-enable-stdcall-fixup&nbsp;-Wl,-enable-auto-import&nbsp;-Wl,-enable-runtime-pseudo-rel
oc&nbsp;-Wl,-s&nbsp;-mthreads&nbsp;-Wl&nbsp;-Wl,-subsystem,windows&nbsp;-o&nbsp;"release\Test.exe"&nbsp;release\mai
n.o&nbsp;&nbsp;-L"c:\Qt\4.3.2\lib"&nbsp;-lmingw32&nbsp;-lqtmain&nbsp;-lQtGui4&nbsp;-lQtCore4
mingw32-make[1]:&nbsp;Leaving&nbsp;directory&nbsp;`C:/Users/Mateo/Projets/Test'
&nbsp;
C:\Users\Mateo\Projets\Test&gt;</pre></div></td></tr></tbody></table></div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11246">Exécuter le programme</h2>
		<div class="ss_part_texte">
		Pour tester le programme, vous avez 2 solutions :<br>
<br>
<ul>
<li>Soit vous le lancez depuis la console,</li>
<li>Soit vous double-cliquez sur l'exécutable depuis l'explorateur.</li>
</ul><br>
<br>
<h3>Lancer le programme depuis la console</h3><br>
<br>
Normalement, l'exécutable a été placé dans le sous-dossier "release".<br>
Il vous suffit de vous placer dans ce sous-dossier puis de taper le nom du programme pour qu'il s'exécute :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>C:\Users\Mateo\Projets\Test&gt;cd&nbsp;release
&nbsp;
C:\Users\Mateo\Projets\Test\release&gt;Test.exe</pre></div></td></tr></tbody></table></div><br>
<br>
<br>
<h3>Lancer le programme depuis l'explorateur</h3><br>
<br>
Je sais je sais, vous vous dites que lancer un programme depuis la console c'est un peu débile. Je suis d'accord, mais les programmes Qt ont besoin des fichiers DLL de Qt avec eux pour fonctionner.<br>
Quand vous exécutez votre programme depuis la console spéciale, la position des DLL est "connue", donc votre programme se lance sans erreur.<br>
<br>
Mais essayez de double-cliquer sur l'exécutable depuis l'explorateur pour voir !<br>
<br>
<div class="centre"><img src="./cpp_files/90606.png" alt="Le programme Test.exe"><br>
<span class="italique">Le programme Test.exe dans le dossier "release". Double-cliquez dessus.</span></div><br>
<br>
<div class="centre"><img src="./cpp_files/90607.png" alt="Exécution sans les DLL"><br>
<span class="italique">Miséricorde ! Ca ne marche pas !</span></div><br>
<br>
En effet, sans quelques DLL à côté notre programme est perdu. Il a besoin de ces fichiers qui contiennent de quoi le guider. Vous avez déjà eu affaire aux DLL si vous avez utilisé la SDL dans le cours de C normalement <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Pour pouvoir lancer l'exécutable depuis l'explorateur (et aussi pour qu'il marche chez vos amis / clients), il faut placer les DLL qui manquent dans le même dossier que l'exécutable. A vous de les chercher, vous les avez sur votre disque (chez moi je les ai trouvés dans le dossier C:\MinGW\bin et C:\Qt\4.3.2\bin). En tout, vous devriez avoir eu besoin de mettre 3 DLL :<br>
<br>
<div class="centre"><img src="./cpp_files/90613.png" alt="Programme Qt et ses DLL"></div><br>
<br>
Vous pouvez lancer le programme maintenant !<br>
<br>
<br>
<h3>Notre première fenêtre en action !</h3><br>
<br>
Ouf ! On est arrivé à compiler et lancer notre programme !<br>
<br>
Coucou petite fenêtre, fais risette à la caméra !<br>
<br>
<div class="centre"><img src="./cpp_files/90619.png" alt="Notre première fenêtre"></div><br>
<br>
Le bouton prend la taille du texte qui se trouve à l'intérieur, et la fenêtre qui est automatiquement créée prend la taille du bouton. Ca donne donc une toute petite fenêtre <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Mais... vous pouvez la redimensionner, voire même l'afficher en plein écran ! Rien ne vous en empêche, et le bouton s'adapte automatiquement à la taille de la fenêtre (ce qui peut donner un trèèès gros bouton) :<br>
<br>
<div class="centre"><img src="./cpp_files/90620.png" alt="Notre première fenêtre agrandie"></div>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Nous y sommes enfin arrivés, champagne ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Vous l'avez vu, le code nécessaire pour ouvrir une fenêtre toute simple constituée d'un bouton est ridicule. Quelques lignes à peine, et rien de bien compliqué à comprendre au final.<br>
C'est ce qui fait la force de Qt : <span class="italique">"un code simple est un beau code"</span> dit-on. Qt s'efforce de respecter ce dicton à la lettre, vous vous en rendrez compte dans les prochains chapitres.<br>
<br>
Le "défaut" de cette simplicité, c'est qu'on est obligé de passer par un utilitaire spécial appelé <span class="italique">qmake </span>pour générer le Makefile qui est parfois très complexe. Mais comme vous avez pu le constater, ça se fait sans problème <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Dans les prochains chapitres, nous allons voir comment changer l'apparence du bouton, comment faire une fenêtre un peu plus complexe. Nous découvrirons aussi le mécanisme des signaux et des slots, un des principes les plus importants de Qt qui permet de gérer les évènements : un clic sur un bouton pourra par exemple provoquer l'ouverture d'une nouvelle fenêtre ou sa fermeture !
	</div>
	
	<hr>
	<h1 id="chap_11260">Personnaliser les widgets</h1>
	<div id="chap_intro">
	La "fenêtre-bouton" que nous avons réalisée dans le chapitre précédent était un premier pas. Toutefois, nous avons passé plus de temps à expliquer les mécanismes de la compilation qu'à modifier le contenu de la fenêtre.<br>
<br>
Par exemple, comment faire pour modifier la taille du bouton ? Comment placer le bouton où on veut sur la fenêtre ?<br>
Comment modifier les propriétés du bouton ? Changer la couleur, le curseur de la souris, la police, l'icône...<br>
<br>
Dans ce chapitre, nous allons nous habituer à modifier les propriétés d'un widget : le bouton. Bien sûr, il existe des tonnes d'autres widgets (cases à cocher, listes déroulantes...) mais nous nous concentrerons sur le bouton pour nous habituer à éditer les propriétés d'un widget.<br>
Une fois que vous saurez le faire pour le bouton, vous n'aurez aucun mal à le faire pour les autres widgets.<br>
<br>
Enfin et surtout, nous reparlerons d'héritage dans ce chapitre. Nous apprendrons à créer un widget personnalisé qui "hérite" du bouton. C'est une technique extrêmement courante que l'on retrouve dans toutes les bibliothèques de création de GUI !<br>
<br>
<div class="flot_droite"><img src="./cpp_files/103142.png" alt="Pimp mon bouton"></div><br>
Allez hop, vous allez me personnaliser ce bouton tout gris !<br>
<br>
<span class="italique">"Yo man, on va te cus-to-mi-ser ton vieux bouton à la sauce west coast ! Aujourd'hui sur le Site du Zéro, c'est Pimp mon bouton !"</span><br>
<span class="tpetit">Pardonnez ce petit délire, je promets à l'avenir de ne plus regarder MTV avant de rédiger un tutoriel. Promis promis.</span><br>

	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11259">Modifier les propriétés d'un widget</h2>
		<div class="ss_part_texte">
		Comme tous les éléments d'une fenêtre, on dit que le bouton est un widget.<br>
Avec Qt, on crée un bouton à l'aide de la classe QPushButton.<br>
<br>
Comme vous le savez, une classe est constituée de 2 éléments :<br>
<ul>
<li><strong>Des attributs</strong> : ce sont les "variables" internes de la classe.</li>
<li><strong>Des méthodes</strong> : ce sont les "fonctions" internes de la classe.</li>
</ul><br>
La règle d'encapsulation dit que les utilisateurs de la classe ne doivent pas pouvoir modifier les attributs : ceux-ci doivent donc tous être privés.<br>
<br>
Or, je ne sais pas si vous avez remarqué, mais nous sommes justement des <span class="italique">utilisateurs </span>des classes de Qt. Ce qui veut dire... que nous n'avons pas accès aux attributs puisque ceux-ci sont privés ! <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"><br>
<br>
<div class="rmq question">Hé, mais tu avais parlé d'un truc à un moment je crois... Les accesseurs, c'est pas ça ?</div><br>
Ah... J'aime les gens qui ont de la mémoire <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Effectivement oui, j'avais dit que le créateur d'une classe devait rendre ses attributs privés, mais du coup proposer des méthodes <span class="italique">accesseurs</span>, c'est-à-dire des méthodes permettant de lire et de modifier les attributs de manière sécurisée (get et set ça vous dit rien ?).<br>
<br>
<br>
<h3>Les accesseurs avec Qt</h3><br>
<br>
Justement, les gens qui ont créé Qt chez Trolltech sont des braves gars : ils ont codé proprement en respectant ces règles. Et il valait mieux qu'ils fassent bien les choses s'ils ne voulaient pas que leur bibliothèque devienne un véritable foutoir !<br>
<br>
Du coup, pour chaque propriété d'un widget, on a :<br>
<br>
<ul>
<li><span class="rouge"><strong>Un attribut</strong> : il est privé on ne peut pas le lire ni le modifier directement.<br>
Exemple : <span class="courrier">text</span></span></li>
<li><span class="vertf"><strong>Un accesseur pour le lire</strong> : cet accesseur est une méthode constante qui porte le même nom que l'attribut (personnellement j'aurais plutôt mis un "get" devant pour ne pas confondre avec l'attribut, mais bon). Je vous rappelle qu'une méthode constante est une méthode qui s'interdit de modifier les attributs de la classe. Ainsi, vous êtes assuré que la méthode ne fait que lire l'attribut et qu'elle ne le modifie pas.<br>
Exemple : <span class="courrier">text()</span></span></li>
<li><span class="vertf"><strong>Un accesseur pour le modifier</strong> : c'est une méthode qui se présente sous la forme setAttribut(). Elle modifie la valeur de l'attribut.<br>
Exemple : <span class="courrier">setText()</span></span></li>
</ul><br>
Cette technique, même si elle paraît un peu lourde parce qu'il faut créer 2 méthodes pour chaque attribut, a l'avantage d'être parfaitement sûre. Grâce à ça, Qt peut vérifier que la valeur que vous essayez de donner est valide.<br>
Cela permet d'éviter par exemple que vous ne donniez à une barre de progression la valeur "150%", alors que la valeur d'une barre de progression doit être comprise entre 0 et 100%.<br>
<br>
<div class="centre"><img src="./cpp_files/103026.png" alt="Barre de progression"></div><br>
<br>
Voyons voir sans plus tarder quelques propriétés des boutons que nous pouvons nous amuser à modifier à l'aide des accesseurs <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Quelques exemples de propriétés des boutons</h3><br>
<br>
Il existe un grand nombre de propriétés éditables pour chaque widget, y compris le bouton. Nous n'allons pas toutes les voir ici, ni même plus tard d'ailleurs, je vous apprendrai à lire la doc pour toutes les découvrir <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Cependant, je tiens à vous montrer les plus intéressantes d'entre elles pour que vous puissiez commencer à vous faire la main, et surtout pour que vous preniez l'habitude d'utiliser les accesseurs de Qt.<br>
<br>
<h4>text : le texte</h4><br>
<br>
Cette propriété est probablement la plus importante : elle permet de modifier le texte présent sur le bouton.<br>
En général, on définit le texte du bouton au moment de sa création car le constructeur accepte que l'on donne le texte du bouton dès sa création.<br>
<br>
Toutefois, pour une raison ou une autre, vous pourriez être amené à modifier le texte présent sur le bouton au cours de l'exécution du programme. C'est là qu'il devient pratique d'avoir accès à l'attribut "text" du bouton <span class="italique">via </span>ses accesseurs.<br>
<br>
Pour chaque attribut, la documentation de Qt nous dit à quoi il sert et quels sont ses accesseurs. Voyez par exemple <a href="http://doc.trolltech.com/qabstractbutton.html#text-prop">ce que ça donne pour l'attribut text des boutons</a>.<br>
<br>
On vous indique de quel type est l'attribut. Ici, text est de type QString, comme tous les attributs qui stockent du texte avec Qt. En effet, Qt n'utilise pas la classe "string" standard du C++ mais sa propre version de la gestion des chaînes de caractères. En gros, <span class="italique">QString </span>c'est un <span class="italique">string </span>amélioré.<br>
<br>
Puis, on vous explique en quelques mots à quoi sert cet attribut (<span class="italique">in english of course</span>, il n'est jamais trop tard pour reprendre des cours d'anglais quel que soit votre âge <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ).<br>
<br>
Enfin, on vous indique les accesseurs qui permettent de lire et de modifier l'attribut. Dans le cas présent, il s'agit de :<br>
<br>
<ul>
<li><span class="courrier">QString text () const</span> : c'est l'accesseur qui permet de <strong>lire l'attribut</strong>. Il retourne un QString, ce qui est logique puisque l'attribut est de type QString. Vous noterez la présence du mot-clé "const" qui indique que c'est une méthode constante qui ne modifie aucun attribut.</li>
<li><span class="courrier">void setText ( const QString &amp; text )</span> : c'est l'accesseur qui permet de <strong>modifier l'attribut</strong>. Il prend un paramètre : le texte que vous voulez mettre sur le bouton.</li>
</ul><br>
<div class="rmq information">A la longue, vous ne devriez pas avoir besoin de la doc pour savoir quels sont les accesseurs d'un attribut. Ca suit toujours le même schéma :<br>
<span class="courrier">attribut()</span> : permet de lire l'attribut.<br>
<span class="courrier">setAttribut()</span> : permet de modifier l'attribut.</div><br>
<br>
Essayons donc de modifier le texte du bouton après sa création :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
 
 
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
 
    <span class="n">QPushButton</span> <span class="n">bouton</span><span class="p">(</span><span class="s">"Salut les Zéros, la forme ?"</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">bouton</span><span class="p">.</span><span class="n">setText</span><span class="p">(</span><span class="s">"Pimp mon bouton !"</span><span class="p">);</span></span>
 
    <span class="n">bouton</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<div class="rmq information">Vous aurez noté que la méthode setText attend un QString et qu'on lui envoie une bête chaîne de caractères entre guillemets. En fait, ça fonctionne comme la classe string : les chaînes de caractères entre guillemets sont automatiquement converties en QString. Heureusement d'ailleurs, sinon ça serait lourd de devoir créer un objet de type QString juste pour ça !</div><br>
Résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/103034.png" alt="Un bouton dont le texte a été modifié"></div><br>
<br>
Le résultat n'est peut-être pas très impressionnant, mais ça montre bien ce qui se passe :<br>
<br>
<ol class="liste_1">
<li>On crée le bouton et on lui donne le texte "Salut les Zéros, la forme ?" à l'aide du constructeur.</li>
<li>On modifie le texte présent sur le bouton pour afficher "Pimp mon bouton !".</li></ol><br>
Au final, c'est "Pimp mon bouton !" qui s'affiche.<br>
Pourquoi ? Parce que le nouveau texte a "écrasé" l'ancien. C'est exactement comme si on faisait :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... Lorsqu'on affiche x, il vaut 2.<br>
C'est pareil pour le bouton. Au final, c'est le tout dernier texte qui sera affiché.<br>
<br>
Bien entendu, ce qu'on vient de faire est complètement inutile : autant donner le bon texte directement au bouton lors de l'appel du constructeur. Toutefois, setText() se révèlera utile plus tard lorsque vous voudrez modifier le contenu du bouton au cours de l'exécution. Par exemple, lorsque l'utilisateur aura donné son nom, le bouton pourra changer de texte pour dire "Bonjour M. Dupont !".<br>
<br>
<h4>toolTip : l'infobulle</h4><br>
<br>
Il est courant d'afficher une petite aide sous la forme d'une infobulle qui apparaît lorsqu'on pointe sur un élément avec la souris.<br>
<br>
L'infobulle peut afficher un court texte d'aide. On la définit à l'aide de la propriété toolTip.<br>
Pour modifier l'infobulle, la méthode à appeler est donc... setToolTip ! Bah vous voyez, c'est facile quand on a compris comment Qt était organisé <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
 
 
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
 
    <span class="n">QPushButton</span> <span class="n">bouton</span><span class="p">(</span><span class="s">"Pimp mon bouton !"</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">bouton</span><span class="p">.</span><span class="n">setToolTip</span><span class="p">(</span><span class="s">"Texte d'aide"</span><span class="p">);</span></span>
 
    <span class="n">bouton</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/103215.png" alt="Infobulle"><br>
<span class="italique">Une infobulle</span></div><br>
<br>
<h4>font : la police</h4><br>
<br>
Avec la propriété font, les choses se compliquent. En effet, jusqu'ici on avait juste eu à envoyer une chaîne de caractères en paramètres, qui était en fait convertie en objet de type QString.<br>
<br>
La propriété font est un peu plus complexe car elle contient 3 informations :<br>
<br>
<ul>
<li>Le nom de la police de caractères utilisée (Times New Roman, Arial, Comic Sans MS...)</li>
<li>La taille du texte en pixels (12, 16, 18...)</li>
<li>Le style du texte (gras, italique...)</li>
</ul><br>
La signature de la méthode setFont est :<br>
<br>
<span class="courrier">void setFont ( const QFont &amp; )</span><br>
<br>
Cela veut dire que setFont attend un objet de type QFont !<br>
<br>
<div class="rmq information">Je rappelle, pour ceux qui auraient oublié la signification des symboles, que :<br>
<ul>
<li><strong>const </strong>: signifie que l'objet que l'on envoie en paramètre ne sera pas modifié par la fonction</li>
<li><strong>&amp;</strong> : signifie que la fonction attend une référence vers l'objet. En C, il aurait fallu envoyer un pointeur, mais comme en C++ on dispose des références (qui sont plus simples à utiliser), on en profite <img src="./cpp_files/smile.png" alt=":)" class="smilies"></li>
</ul></div><br>
Bon, comment on fait pour lui donner un objet de type QFont nous ?<br>
Eh bien c'est simple : il... suffit de créer un objet de type QFont !<br>
<br>
La doc nous indique <a href="http://doc.trolltech.com/qfont.html">tout ce que nous avons besoin de savoir sur QFont</a>, en particulier les informations qu'il faut donner à son constructeur. Je n'attends pas de vous encore que vous soyez capable de lire la doc de manière autonome, je vais donc vous mâcher le travail (mais profitez-en parce que ça ne durera pas éternellement <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies"> ).<br>
<br>
Pour faire simple, le constructeur de QFont attend 4 paramètres. Voici son prototype :<br>
<br>
<span class="courrier">QFont ( const QString &amp; family, int pointSize = -1, int weight = -1, bool italic = false )</span><br>
<br>
<div class="rmq information">En fait, avec Qt il y a rarement un seul constructeur par classe. Les développeurs de Qt profitent des fonctionnalités du C++ et ont donc tendance à beaucoup surcharger les constructeurs. Certaines classes possèdent même plusieurs dizaines de constructeurs différents !<br>
Pour QFont, celui que je vous montre là est néanmoins le principal et le plus utilisé. Et le plus simple aussi, tant qu'à faire.</div><br>
<br>
Seul le premier argument est obligatoire : il s'agit du nom de la police à utiliser. Les autres, comme vous pouvez le voir, possèdent des valeurs par défaut donc nous ne sommes pas obligés de les indiquer.<br>
Dans l'ordre, les paramètres signifient :<br>
<br>
<ul>
<li>family : le nom de la police de caractères à utiliser.</li>
<li>pointSize : la taille des caractères en pixels.</li>
<li>weight : le niveau d'épaisseur du trait (gras). Cette valeur peut être comprise entre 0 et 99 (du plus fin au plus gras). Vous pouvez aussi utiliser la constante QFont::Bold qui correspond à une épaisseur de 75.</li>
<li>italic : un booléen pour dire si le texte doit être affiché en italique ou non.</li>
</ul><br>
On va faire quelques tests. Tout d'abord, il va falloir créer un objet de type QFont :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QFont</span> <span class="n">maPolice</span><span class="p">(</span><span class="s">"Courier"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
J'ai appelé cet objet maPolice.<br>
Maintenant, je dois envoyer l'objet maPolice de type QFont à la méthode setFont de mon bouton (suivez, suivez !) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">bouton</span><span class="p">.</span><span class="n">setFont</span><span class="p">(</span><span class="n">maPolice</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
En résumé, j'ai donc dû écrire 2 lignes pour changer la police :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QFont</span> <span class="n">maPolice</span><span class="p">(</span><span class="s">"Courier"</span><span class="p">);</span>
<span class="n">bouton</span><span class="p">.</span><span class="n">setFont</span><span class="p">(</span><span class="n">maPolice</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est un peu fastidieux. Il existe une solution plus maligne, si on ne compte pas se resservir de la police plus tard, c'est de définir l'objet de type QFont au moment de l'appel à la méthode setFont. Ca nous évite d'avoir à donner un nom bidon à l'objet comme on l'a fait ici (maPolice), c'est plus court, ça va plus vite, bref c'est mieux en général <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">bouton</span><span class="p">.</span><span class="n">setFont</span><span class="p">(</span><span class="n">QFont</span><span class="p">(</span><span class="s">"Courier"</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voilà, en imbriquant comme ça ça marche très bien. La méthode setFont veut un objet de type QFont ? Qu'à cela ne tienne, on lui en crée un à la volée !<br>
<br>
Voici le résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/103219.png" alt="Un bouton écrit avec la police Courier"></div><br>
<br>
Maintenant, on peut exploiter un peu plus le constructeur de QFont en utilisant une autre police plus fantaisiste et en augmentant la taille des caractères :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">bouton</span><span class="p">.</span><span class="n">setFont</span><span class="p">(</span><span class="n">QFont</span><span class="p">(</span><span class="s">"Comic Sans MS"</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/103217.png" alt="Un bouton en Comic Sans MS en grand"></div><br>
<br>
Et voilà le même avec du gras et de l'italique !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">bouton</span><span class="p">.</span><span class="n">setFont</span><span class="p">(</span><span class="n">QFont</span><span class="p">(</span><span class="s">"Comic Sans MS"</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">QFont</span><span class="o">::</span><span class="n">Bold</span><span class="p">,</span> <span class="kc">true</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/103218.png" alt="Un bouton en Comic Sans MS en grand, gras, italique"></div><br>
<br>
Bref, si vous avez compris le <a href="http://www.siteduzero.com/tuto-3-13047-1-nouveautes-pour-les-fonctions.html#ss_part_1">principe des paramètres par défaut</a> (et j'espère que vous avez compris depuis le temps ! <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies"> ), ça ne devrait vous poser aucun problème.<br>
<br>
<h4>cursor : le curseur de la souris</h4><br>
<br>
Avec la propriété cursor, vous pouvez déterminer quel curseur de la souris doit s'afficher lorsqu'on pointe sur le bouton.<br>
Le plus simple est d'utiliser une des <a href="http://doc.trolltech.com/qt.html#CursorShape-enum">constantes de curseurs prédéfinis</a> parmi la liste qui s'offre à vous.<br>
<br>
Ce qui peut donner par exemple, si on veut qu'une main s'affiche :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">bouton</span><span class="p">.</span><span class="n">setCursor</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">PointingHandCursor</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/103245.png" alt="Curseur de la souris modifié sur le bouton"></div><br>
<br>
<h4>icon : l'icône du bouton</h4><br>
<br>
Après tout ce qu'on vient de voir, rajouter une icône au bouton va vous paraître très simple : la méthode setIcon attend juste un objet de type QIcon.<br>
Un QIcon peut se construire très facilement en donnant le nom du fichier image à charger.<br>
<br>
Prenons par exemple ce petit smiley souriant :  <img src="./cpp_files/smile.png" alt=":)" class="smilies"> <br>
Il s'agit d'une image au format PNG que sait lire Qt.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">bouton</span><span class="p">.</span><span class="n">setIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"smile.png"</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq attention">Attention, sous Windows pour que cela fonctionne, votre icône smile.png doit se trouver dans le même dossier que l'exécutable (ou dans un sous-dossier si vous écrivez "dossier/smile.png").<br>
Sous Linux, il faut que votre icône soit dans votre répertoire HOME. Si vous voulez utiliser le chemin de votre application, comme cela se fait sous Windows par défaut, écrivez :<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QIcon</span><span class="p">(</span><span class="n">QCoreApplication</span><span class="o">::</span><span class="n">applicationDirPath</span><span class="p">()</span> <span class="o">+</span> <span class="s">"/smile.png"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
Cela aura pour effet d'afficher l'icône à condition que celle-ci se trouve dans le même répertoire que l'exécutable.</div><br>
<br>
Si vous avez fait ce qu'il fallait, l'icône devrait alors apparaître comme ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/103247.png" alt="Un bouton avec une icône"></div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11258">Qt et l'héritage</h2>
		<div class="ss_part_texte">
		On aurait pu continuer à faire joujou longtemps avec les propriétés de notre bouton, mais il faut savoir s'arrêter au bout d'un moment et reprendre les choses sérieuses.<br>
<br>
Quelles choses sérieuses ?<br>
Si je vous dis "héritage", ça ne vous rappelle rien ? J'espère que ça ne vous donne pas des boutons en tout cas (oh oh oh), parce que si vous n'avez pas compris le <a href="http://www.siteduzero.com/tuto-3-22800-1-l-heritage.html">principe de l'héritage</a> vous ne pourrez pas aller plus loin.<br>
<br>
<br>
<h3>De l'héritage en folie</h3><br>
<br>
L'héritage est probablement LA notion la plus intéressante de la programmation orientée objet. Le fait de pouvoir créer une classe de base, réutilisée par des sous-classes filles, qui ont elles-mêmes leurs propres sous-classes filles, ça donne à une bibliothèque comme Qt une puissance infinie (voire plus, même).<br>
<br>
En fait... quasiment toutes les classes de Qt font appel à l'héritage.<br>
<br>
Pour vous faire une idée, la documentation vous donne la <a href="http://doc.trolltech.com/hierarchy.html">hiérarchie complète des classes</a>. Chaque classe "à gauche" de cette liste à puces est une classe de base, et les classes qui sont décalées vers la droite sont des sous-classes.<br>
<br>
Vous pouvez par exemple voir au début :<br>
<br>
<ul>
<li>QAbstractExtensionFactory <ul>
<li>QExtensionFactory</li>
</ul></li>
<li>QAbstractExtensionManager<ul>
<li>QExtensionManager</li>
</ul></li>
</ul><br>
<br>
QAbstractExtensionFactory et QAbstractExtensionManager sont des classes dites "de base". Elles n'ont pas de classes parentes.<br>
En revanche, QExtensionFactory et QExtensionManager sont des classes-filles, qui héritent respectivement de QAbstractExtensionFactory et QAbstractExtensionManager.<br>
<br>
Sympa hein ? <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Descendez plus bas sur la <a href="http://doc.trolltech.com/hierarchy.html">page de la hiérarchie</a> à la recherche de la classe QObject.<br>
Regardez un peu toutes ses classes filles.<br>
Descendez.<br>
Encore.<br>
Encore.<br>
Encore.<br>
<br>
C'est bon vous avez pas trop pris peur ? <img src="./cpp_files/rire.gif" alt=":lol:" class="smilies"> <br>
Vous avez dû voir que certaines classes étaient carrément des sous-sous-sous-sous-sous-classes.<br>
<br>
<div class="rmq question">Wouaw mais comment je vais m'y retrouver là-dedans moi ? C'est pas possible je vais jamais m'en sortir !</div><br>
C'est ce qu'on a tendance à se dire la première fois. En fait, vous allez petit à petit comprendre qu'au contraire tous ces héritages sont là pour vous simplifier la vie. Si ce n'était pas aussi bien architecturé, alors <span class="italique">là</span> vous ne vous en seriez jamais sortis !<br>
<br>
<br>
<h3>QObject : une classe de base incontournable</h3><br>
<br>
<a href="http://doc.trolltech.com/qobject.html">QObject</a> est la classe de base de tous les objets sous Qt.<br>
QObject ne correspond à rien de particulier, mais elle propose quelques fonctionnalités "de base" qui peuvent être utiles à toutes les autres classes.<br>
<br>
Cela peut surprendre d'avoir une classe de base qui ne sait rien faire de particulier, mais en fait c'est ce qui donne beaucoup de puissance à la bibliothèque. Par exemple, il suffit de définir une fois dans QObject une méthode <span class="courrier">objectName()</span> qui contient le nom de l'objet, et ainsi toutes les autres classes de Qt en héritent et possèderont donc cette méthode.<br>
D'autre part, le fait d'avoir une classe de base comme QObject est indispensable pour réaliser le mécanisme des <strong>signaux et des slots</strong> qu'on verra dans le prochain chapitre. Ce mécanisme permet de faire en sorte par exemple que si un bouton est cliqué, alors une autre fenêtre s'ouvre (on dit qu'il envoie un signal à un autre objet).<br>
<br>
Bref, tout cela doit vous sembler encore un peu abstrait et je le comprends parfaitement.<br>
Je pense qu'un petit schéma simplifié des héritages de Qt s'impose. Cela devrait vous permettre de mieux visualiser la hiérarchie des classes :<br>
<br>
<div class="centre"><img src="./cpp_files/103326.png" alt="Héritage sous Qt"></div><br>
<br>
Soyons clairs : je n'ai pas tout mis. J'ai juste mis quelques exemples, mais s'il fallait faire le schéma complet ça prendrait une place énorme vous vous en doutez !<br>
<br>
On voit sur ce schéma que QObject est la classe mère principale, dont héritent toutes les autres classes. Comme je l'ai dit, elle propose quelques fonctionnalités qui se révèlent utiles pour toutes les classes, mais nous ne les verrons pas ici.<br>
<br>
Certaines classes comme QSound (gestion du son) héritent directement de QObject.<br>
<br>
Toutefois, comme je l'ai dit on s'intéresse plus particulièrement à la création de GUI, c'est-à-dire de fenêtres. Or, <span class="souligne">dans une fenêtre tout est considéré comme un widget </span>(même la fenêtre est un widget).<br>
C'est pour cela qu'il existe une classe de base QWidget pour tous les widgets. Elle contient énormément de propriétés communes à tous les widgets, comme :<br>
<br>
<ul>
<li>La largeur</li>
<li>La hauteur</li>
<li>La position en abscisse (x)</li>
<li>La position en ordonnée (y)</li>
<li>La police de caractères utilisée (eh oui, la méthode setFont est définie dans QWidget, et comme QPushButton en hérite, il possède lui aussi cette méthode)</li>
<li>Le curseur de la souris (pareil, rebelotte, setCursor est en fait défini dans QWidget et non dans QPushButton, car il est aussi susceptible de servir sur tous les autres widgets)</li>
<li>L'infobulle (toolTip)</li>
<li>etc.</li>
</ul><br>
Vous commencez à percevoir un peu l'intérêt de l'héritage ?<br>
Grâce à cette technique, il leur a suffi de définir <strong>une fois</strong> toutes les propriétés de base des widgets (largeur, hauteur...). Tous les widgets héritent de QWidget, donc ils possèdent tous ces propriétés. Vous savez donc par exemple que vous pouvez retrouver la méthode setCursor dans la classe QProgressBar.<br>
<br>
<br>
<h3>Les classes abstraites</h3><br>
<br>
Vous avez pu remarquer sur mon schéma que j'ai écrit la classe QAbstractButton en rouge... Pourquoi ?<br>
Il existe en fait un grand nombre de classes abstraites sous Qt, qui contiennent toutes le mot "Abstract" dans leur nom.<br>
<br>
Les classes dites "abstraites" sont des classes qu'on ne peut pas instancier. C'est-à-dire... qu'on n'a pas le droit de créer d'objet à partir d'elles. Ainsi, on ne peut pas faire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QAbstractButton</span> <span class="n">bouton</span><span class="p">();</span> <span class="c">// Interdit car classe abstraite</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Mais alors... à quoi ça sert de faire une classe si on ne peut pas créer d'objets à partir d'elle ?</div><br>
Une classe abstraite sert de classe de base pour d'autres sous-classes. Ici, QAbstractButton définit un certain nombre de propriétés communes à tous les types de boutons (boutons classiques, cases à cocher, cases radio...). Par exemple, parmi les propriétés communes on trouve :<br>
<br>
<ul>
<li><strong>text </strong>: le texte affiché</li>
<li><strong>icon </strong>: l'icône affichée à côté du texte du bouton</li>
<li><strong>shortcut </strong>: le raccourci clavier pour activer le bouton</li>
<li><strong>down </strong>: indique si le bouton est enfoncé ou non</li>
<li>etc.</li>
</ul><br>
Bref, encore une fois tout ça n'est défini qu'une fois dans QAbstractButton, et on le retrouve ensuite automatiquement dans QPushButton, QCheckBox, etc.<br>
<br>
<div class="rmq question">Dans ce cas, pourquoi QObject et QWidget ne sont pas des classes abstraites elles aussi ? Après tout, elles ne représentent rien de particulier et servent juste de classes de base !</div><br>
Oui, vous avez tout à fait raison, leur rôle est d'être des classes de base.<br>
Mais... pour un certain nombre de raisons pratiques (qu'on ne détaillera pas ici), il est possible de les instancier quand même, donc de créer par exemple un objet de type QWidget.<br>
<br>
Si on affiche un QWidget, qu'est-ce qui apparaît ? Une fenêtre !<br>
En fait, un widget qui ne se trouve pas à l'intérieur d'un autre widget est considéré comme une fenêtre. Ce qui explique pourquoi, en l'absence d'autre information, Qt décide de créer une fenêtre.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11257">Un widget peut en contenir un autre</h2>
		<div class="ss_part_texte">
		Nous attaquons maintenant une notion importante, pas très compliquée, qui est celle des <strong>widgets conteneurs</strong>.<br>
<br>
<br>
<h3>Contenant et contenu</h3><br>
<br>
Il faut savoir qu'un widget peut en contenir un autre. Par exemple, une fenêtre (un QWidget) peut contenir 3 boutons (QPushButton), une case à cocher (QCheckBox), une barre de progression (QProgressBar), etc.<br>
<br>
Ce n'est pas là de l'héritage, juste une histoire de contenant et de contenu.<br>
Prenons un exemple :<br>
<br>
<div class="centre"><img src="./cpp_files/103335.png" alt="Widgets conteneurs"></div><br>
<br>
Sur cette capture, la fenêtre contient 3 widgets :<br>
<br>
<ul>
<li>Un bouton OK</li>
<li>Un bouton Annuler</li>
<li>Un conteneur avec des onglets</li>
</ul><br>
Le conteneur avec des onglets est, comme son nom l'indique, un conteneur. Il contient à son tour des widgets :<br>
<br>
<ul>
<li>2 boutons</li>
<li>Une checkbox</li>
<li>Une barre de progression</li>
</ul><br>
Les widgets sont donc imbriqués les uns dans les autres de cette manière :<br>
<br>
<ul>
<li>QWidget (la fenêtre)<br>
<ul>
<li>QPushButton</li>
<li>QPushButton</li>
<li>QTabWidget (le conteneur à onglets)<br>
<ul>
<li>QPushButton</li>
<li>QPushButton</li>
<li>QCheckBox</li>
<li>QProgressBar</li>
</ul></li>
</ul></li>
</ul><br>
<div class="rmq erreur">Attention : ne confondez pas ceci avec l'héritage ! Dans cette partie, je suis en train de vous montrer qu'un widget peut en contenir d'autres. Le gros schéma qu'on a vu un peu plus haut n'a rien à voir avec la notion de widget conteneur.<br>
Ici, on découvre qu'un widget peut en contenir d'autres, indépendamment du fait que ce soit une classe mère ou une classe fille.</div><br>
<br>
<h3>Créer une fenêtre contenant un bouton</h3><br>
<br>
On ne va pas commencer par faire une fenêtre aussi compliquée que celle que nous venons de voir. Pour le moment on va s'entraîner à faire quelque chose de simple : créer une fenêtre qui contient un bouton.<br>
<br>
<div class="rmq question">Mais... c'est pas ce qu'on a fait tout le temps jusqu'ici ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"></div><br>
Non, ce qu'on a fait jusqu'ici c'était juste afficher un bouton. Automatiquement, Qt a créé une fenêtre autour car on ne peut pas avoir de bouton qui "flotte" seul sur l'écran.<br>
<br>
L'avantage de créer une fenêtre <span class="italique">puis </span>de mettre un bouton dedans, c'est que :<br>
<br>
<ul>
<li>On pourra mettre d'autres widgets à l'intérieur de la fenêtre à l'avenir.</li>
<li>On pourra placer le bouton où on veut dans la fenêtre avec les dimensions qu'on veut (jusqu'ici le bouton avait toujours la même taille que la fenêtre).</li>
</ul><br>
Voilà comment il faut faire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
 
 
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
 
    <span class="c1">// Création d'un widget qui servira de fenêtre</span>
    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">setFixedSize</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
 
    <span class="c1">// Création du bouton, ayant pour parent la "fenetre"</span>
    <span class="n">QPushButton</span> <span class="n">bouton</span><span class="p">(</span><span class="s">"Pimp mon bouton !"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
    <span class="c1">// Customisation du bouton</span>
    <span class="n">bouton</span><span class="p">.</span><span class="n">setFont</span><span class="p">(</span><span class="n">QFont</span><span class="p">(</span><span class="s">"Comic Sans MS"</span><span class="p">,</span> <span class="mi">14</span><span class="p">));</span>
    <span class="n">bouton</span><span class="p">.</span><span class="n">setCursor</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">PointingHandCursor</span><span class="p">);</span>
    <span class="n">bouton</span><span class="p">.</span><span class="n">setIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"smile.png"</span><span class="p">));</span>
 
    <span class="c1">// Affichage de la fenêtre</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... et le résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/103348.png" alt="Fenêtre avec bouton"></div><br>
<br>
Qu'est-ce qu'on a fait ?<br>
<br>
<ol class="liste_1">
<li>On a créé une fenêtre à l'aide d'un objet de type QWidget.</li>
<li>On a dimensionné notre widget (donc notre fenêtre) avec la méthode setFixedSize. La taille de la fenêtre sera fixée : on ne pourra pas la redimensionner.</li>
<li>On a créé un bouton, mais avec cette fois une nouveauté au niveau du constructeur : on a indiqué un pointeur vers le widget parent (en l'occurence la fenêtre).</li>
<li>On a customisé un peu le bouton pour la forme.</li>
<li>On a déclenché l'affichage de la fenêtre (et donc du bouton qu'elle contenait).</li></ol><br>
Tous les widgets possèdent un constructeur surchargé qui permet d'indiquer quel est le parent du widget que l'on crée. Il suffit de donner un pointeur pour que Qt sache "qui contient qui".<br>
Le paramètre "&amp;fenetre" du constructeur permet donc d'indiquer que la fenêtre est le parent de notre bouton :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QPushButton</span> <span class="n">bouton</span><span class="p">(</span><span class="s">"Pimp mon bouton !"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si vous voulez placer le bouton ailleurs dans la fenêtre, utilisez la méthode move :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">bouton</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/103350.png" alt="Fenêtre avec bouton centré"></div><br>
<br>
A noter aussi la méthode setGeometry, qui prend 4 paramètres :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">bouton</span><span class="p">.</span><span class="n">setGeometry</span><span class="p">(</span><span class="n">abscisse</span><span class="p">,</span> <span class="n">ordonnee</span><span class="p">,</span> <span class="n">largeur</span><span class="p">,</span> <span class="n">hauteur</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La méthode setGeometry permet donc, en plus de déplacer le widget, de lui donner une dimension bien précise.<br>
<br>
<br>
<h3>Tout widget peut en contenir d'autres</h3><br>
<br>
... même les boutons !<br>
Quel que soit le widget, son constructeur accepte en dernier paramètre un pointeur vers un autre widget pour indiquer quel est le parent.<br>
<br>
On peut faire le test si vous voulez en plaçant un bouton... dans notre bouton !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
 
 
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
 
    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">setFixedSize</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
 
    <span class="n">QPushButton</span> <span class="n">bouton</span><span class="p">(</span><span class="s">"Pimp mon bouton !"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
    <span class="n">bouton</span><span class="p">.</span><span class="n">setFont</span><span class="p">(</span><span class="n">QFont</span><span class="p">(</span><span class="s">"Comic Sans MS"</span><span class="p">,</span> <span class="mi">14</span><span class="p">));</span>
    <span class="n">bouton</span><span class="p">.</span><span class="n">setCursor</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">PointingHandCursor</span><span class="p">);</span>
    <span class="n">bouton</span><span class="p">.</span><span class="n">setIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"smile.png"</span><span class="p">));</span>
    <span class="n">bouton</span><span class="p">.</span><span class="n">setGeometry</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">70</span><span class="p">);</span>
 
    <span class="c1">// Création d'un autre bouton ayant pour parent le premier bouton</span>
<span class="ln-xtra">    <span class="n">QPushButton</span> <span class="n">autreBouton</span><span class="p">(</span><span class="s">"Autre bouton"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bouton</span><span class="p">);</span></span>
    <span class="n">autreBouton</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
 
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat : notre bouton est placé à l'intérieur de l'autre bouton !<br>
<br>
<div class="centre"><img src="./cpp_files/103612.png" alt="Un bouton dans un bouton"></div><br>
<br>
Cet exemple montre qu'il est donc possible de placer un widget dans n'importe quel autre widget, même un bouton. Bien entendu, comme le montre ma capture d'écran, ce n'est pas très malin de faire ça, mais ça prouve que Qt est très flexible <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<h3>Des includes "oubliés"</h3><br>
<br>
Dans le code source précédent, nous avons utilisé les classes QWidget, QFont et QIcon pour créer des objets.<br>
Normalement, nous devrions faire un include des fichiers headers de ces classes en plus de QPushButton et QApplication pour que le compilateur les connaisse :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
<span class="cp">#include &lt;QWidget&gt;</span>
<span class="cp">#include &lt;QFont&gt;</span>
<span class="cp">#include &lt;QIcon&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq question">Ah ben oui ! Si on n'a pas inclus le header de la classe QWidget, comment est-ce qu'on a pu créer tout à l'heure un objet "fenetre" de type QWidget sans que le compilateur ne hurle à la mort ?</div><br>
Coup de bol. En fait, on avait inclus QPushButton. Et comme QPushButton hérite de QWidget, il avait lui-même inclus QWidget dans son header.<br>
Quant à QFont et QIcon, ils étaient inclus eux aussi car indirectement utilisés par QPushButton.<br>
<br>
Bref, des fois comme ça ça marche et on a de la chance. Normalement, si on faisait <span class="italique">très</span> bien les choses, on devrait faire un include par classe utilisée.<br>
<br>
C'est un peu lourd et il m'arrive d'en oublier. Comme ça marche, en général je ne me pose pas trop de questions.<br>
Toutefois, si vous voulez être sûr d'inclure une bonne fois pour toutes toutes les classes du module "Qt GUI", il vous suffit de faire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QtGui&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le header "QtGui" inclut à son tour <span class="souligne">toutes</span> les classes du module GUI, donc QWidget, QPushButton, QFont, etc.<br>
Attention toutefois, la compilation sera un peu ralentie du coup.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11256">Hériter un widget</h2>
		<div class="ss_part_texte">
		Bon résumons !<br>
<br>
Jusqu'ici dans ce chapitre, nous avons :<br>
<br>
<ul>
<li>Appris à lire et modifier les propriétés d'un widget, en voyant quelques exemples de propriétés des boutons.</li>
<li>Découvert de quelle façon étaient architecturées les classes de Qt, avec les multiples héritages.</li>
<li>Découvert la notion de widget conteneur (un widget peut en contenir d'autres). Pour nous entraîner, nous avons créé une fenêtre puis inséré un bouton à l'intérieur.</li>
</ul><br>
Nous allons ici aller plus loin dans la personnalisation des widgets en "inventant" un nouveau type de widget. En fait, nous allons créer une nouvelle classe qui va hériter de QWidget et représenter notre fenêtre. Créer une classe pour gérer la fenêtre va peut-être vous paraître un peu lourd au premier abord, mais c'est pourtant comme ça qu'on fait à chaque fois que l'on crée des GUI en POO. Ca nous donnera une plus grande souplesse par la suite.<br>
<br>
L'héritage que l'on va faire sera donc le suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/103509.png" alt="MaFenetre hérite de QWidget"></div><br>
<br>
Allons-y <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Qui dit nouvelle classe dit 2 nouveaux fichiers :<br>
<br>
<ul>
<li>MaFenetre.h : contiendra la définition de la classe</li>
<li>MaFenetre.cpp : contiendra l'implémentation des méthodes</li>
</ul><br>
<h3>Edition des fichiers</h3><br>
<br>
<h4>MaFenetre.h</h4><br>
<br>
Voici le code du fichier MaFenetre.h, nous allons le commenter tout de suite après :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef DEF_MAFENETRE</span>
<span class="cp">#define DEF_MAFENETRE</span>
<span class="cp"> </span>
<span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QWidget&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
 
<span class="k">class</span> <span class="nc">MaFenetre</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span> <span class="c1">// On hérite de QWidget (IMPORTANT)</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="n">MaFenetre</span><span class="p">();</span>
 
    <span class="k">private</span><span class="o">:</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">m_bouton</span><span class="p">;</span> 
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Quelques petites explications :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef DEF_MAFENETRE</span>
<span class="cp">#define DEF_MAFENETRE</span>
 
<span class="c1">// Contenu</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Là, nous protégeons le header contre les inclusions infinies grâce à cette bonne vieille méthode du #ifndef.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QWidget&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Comme nous allons hériter de QWidget, il est nécessaire d'inclure la définition de cette classe.<br>
Par ailleurs, nous allons utiliser un QPushButton, donc on inclut le header là aussi.<br>
Quant à QApplication, on ne l'utilise pas ici, mais on en aura besoin dans le chapitre suivant, je prépare un peu le terrain <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">MaFenetre</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span> <span class="c1">// On hérite de QWidget (IMPORTANT)</span>
<span class="p">{</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est le début de la définition de la classe. Si vous vous souvenez de l'héritage, ce que j'ai fait là ne devrait pas trop vous choquer. Le ": public QWidget" signifie que notre classe hérite de QWidget. Nous récupérons donc automatiquement toutes les propriétés de QWidget.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">public</span><span class="o">:</span>
<span class="n">MaFenetre</span><span class="p">();</span>
 
<span class="k">private</span><span class="o">:</span>
<span class="n">QPushButton</span> <span class="o">*</span><span class="n">m_bouton</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le contenu de la classe est très simple.<br>
<br>
Nous écrivons le prototype du constructeur. C'est un prototype minimal (MaFenetre()), mais cela nous suffira. Le constructeur est public, car s'il était privé on ne pourrait jamais créer d'objet à partir de cette classe <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Nous créons un attribut "m_bouton" de type QPushButton. Notez que celui-ci est un pointeur, il faudra donc le "construire" de manière dynamique avec l'aide du mot-clé <span class="courrier">new</span>. Tous les attributs devant être privés, nous avons fait précéder cette ligne d'un "private:" qui interdira aux utilisateurs de la classe de modifier directement le bouton.<br>
<br>
<br>
<h4>MaFenetre.cpp</h4><br>
<br>
Le fichier .cpp contient l'implémentation des méthodes de la classe. Comme notre classe ne contient qu'une méthode (le constructeur), le fichier .cpp ne sera donc pas long à écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "MaFenetre.h"</span>
 
<span class="n">MaFenetre</span><span class="o">::</span><span class="n">MaFenetre</span><span class="p">()</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">setFixedSize</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
 
    <span class="c1">// Construction du bouton</span>
    <span class="n">m_bouton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Pimp mon bouton !"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
 
    <span class="n">m_bouton</span><span class="o">-&gt;</span><span class="n">setFont</span><span class="p">(</span><span class="n">QFont</span><span class="p">(</span><span class="s">"Comic Sans MS"</span><span class="p">,</span> <span class="mi">14</span><span class="p">));</span>
    <span class="n">m_bouton</span><span class="o">-&gt;</span><span class="n">setCursor</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">PointingHandCursor</span><span class="p">);</span>
    <span class="n">m_bouton</span><span class="o">-&gt;</span><span class="n">setIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"smile.png"</span><span class="p">));</span>
    <span class="n">m_bouton</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Quelques explications :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "MaFenetre.h"</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est obligatoire pour inclure les définitions de la classe.<br>
Tout ça ne devrait pas être nouveau pour vous, nous avons fait ça de nombreuses fois dans la partie précédente du cours <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">MaFenetre</span><span class="o">::</span><span class="n">MaFenetre</span><span class="p">()</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">()</span>
<span class="p">{</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
L'en-tête du constructeur. Il ne faut pas oublier de le faire précéder d'un "MaFenetre::" pour que le compilateur sache à quelle classe celui-ci se rapporte.<br>
Le ": QWidget()" sert à appeler le constructeur de QWidget en premier lieu. Parfois, on en profitera pour envoyer au constructeur de QWidget quelques paramètres, mais là on va se contenter du constructeur par défaut.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">setFixedSize</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Rien d'extraordinaire : on définit la taille de la fenêtre de manière fixée, pour interdire son redimensionnement.<br>
Vous noterez qu'on n'a pas eu besoin d'écrire fenetre.setFixedSize(300, 150);. Pourquoi ? Parce qu'<span class="italique">on est dans la classe</span>. On ne fait qu'appeler une des méthodes de la classe (setFixedSize), méthode qui appartient à QWidget, et donc qui appartient aussi à notre classe puisqu'on hérite de QWidget <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
J'avoue j'avoue, ce n'est pas évident de bien se repérer au début. Pourtant, vous pouvez me croire, tout ceci est logique mais ça vous paraîtra plus clair à force de pratiquer. Pas de panique donc si vous vous dites "oh mon dieu j'aurais jamais pu deviner ça <img src="./cpp_files/huh.png" alt=":o" class="smilies"> ". Faites-moi confiance c'est tout <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">m_bouton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Pimp mon bouton !"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est la ligne la plus délicate de ce constructeur.<br>
Ici nous construisons le bouton. En effet, dans le header nous n'avons fait que créer le pointeur, mais il ne pointait vers rien jusqu'ici !<br>
Le new permet d'appeler le constructeur de la classe QPushButton et d'affecter une adresse au pointeur.<br>
<br>
Autre détail un tout petit peu délicat : le mot-clé <span class="italique">this</span>. Je vous en avais parlé dans la partie précédente du cours, en vous disant "faites-moi confiance, même si ça vous paraît inutile maintenant, ça vous sera indispensable plus tard".<br>
<br>
Bonne nouvelle : c'est maintenant que vous découvrez un cas où le mot-clé this nous est indispensable ! En effet, le second paramètre du constructeur doit être un pointeur vers le widget parent. Quand nous faisions tout dans le main, c'était simple : il suffisait de donner le pointeur vers l'objet fenetre. Mais là, <strong>nous sommes dans la fenêtre</strong> ! En effet, nous écrivons la classe MaFenetre. C'est donc "moi", la fenêtre, qui sers de widget parent. Pour donner le pointeur vers moi, il suffit d'écrire le mot-clé this.<br>
<br>
<h4>Et toujours... main.cpp</h4><br>
<br>
Bien entendu, que serait un programme sans son main ?<br>
Ne l'oublions pas celui-là !<br>
<br>
La bonne nouvelle, c'est que comme bien souvent dans les gros programmes, notre main va être tout petit. Ridiculement petit. Microscopique. Microbique même.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include "MaFenetre.h"</span>
 
 
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
 
    <span class="n">MaFenetre</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On n'a besoin d'inclure que 2 headers car nous n'utilisons que 2 classes : QApplication et MaFenetre.<br>
<br>
Le contenu du main est très simple : on crée un objet de type MaFenetre, et on l'affiche par un appel à la méthode "show()". C'est tout <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Lors de la création de l'objet fenetre, le constructeur de la classe MaFenetre est appelé. Dans son constructeur, la fenêtre définit toute seule ses dimensions et les widgets qu'elle contient (en l'occurence, juste un bouton).<br>
<br>
<br>
<h3>La destruction automatique des widgets enfants</h3><br>
<br>
<div class="rmq question">Minute papillon ! On a créé dynamiquement un objet de type QPushButton dans le constructeur de la classe MaFenetre... mais on n'a pas détruit cet objet avec un delete !</div><br>
<br>
En effet, tout objet créé dynamiquement avec un new implique forcément un delete quelque part. Vous avez bien retenu la leçon.<br>
<span class="italique">Normalement</span>, on devrait écrire le destructeur de MaFenetre, qui contiendrait ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">MaFenetre</span><span class="o">::~</span><span class="n">MaFenetre</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">delete</span> <span class="n">m_bouton</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
C'est comme ça qu'on doit faire en temps normal. Toutefois, Qt supprimera automatiquement le bouton lors de la destruction de la fenêtre (à la fin du main).<br>
En effet, <strong>quand on supprime un widget parent (ici notre fenêtre), Qt supprime automatiquement tous les widgets qui se trouvent à l'intérieur</strong> (tous les widgets enfants). C'est un des avantages d'avoir dit que le QPushButton avait pour "parent" la fenêtre. Dès qu'on supprime la fenêtre, hop, Qt supprime tout ce qu'elle contient, et donc fait le delete nécessaire du bouton.<br>
<br>
Qt nous simplifie la vie en nous évitant d'avoir à écrire tous les delete des widgets enfants. N'oubliez pas néanmoins que tout new implique normalement un delete. Ici, on profite du fait que Qt le fasse pour nous.<br>
<br>
<h3>Compilation</h3><br>
<br>
Pour la compilation, il ne faudra pas se contenter de faire un make comme les autres fois ! En effet, qu'est-ce que je vous avais dit ?<br>
"<span class="italique">A chaque fois que la liste des fichiers de votre projet change, vous devez refaire <span class="courrier">qmake -project</span> et <span class="courrier">qmake</span> pour que le compilateur sache qu'il doit compiler les nouveaux fichiers</span>".<br>
<br>
Pensez donc à taper dans l'ordre :<br>
<br>
<ol class="liste_1">
<li>qmake -project</li>
<li>qmake</li>
<li>make (ou mingw32-make sous Windows)</li></ol><br>
Si vous ne le faites pas, vous aurez une erreur de linker à coup sûr et la compilation échouera.<br>
<br>
Le résultat, si tout va bien, devrait être le même que tout à l'heure :<br>
<br>
<div class="centre"><img src="./cpp_files/103350.png" alt="Fenêtre avec bouton centré"></div><br>
<br>
<div class="rmq question">QUOI ? TOUT CE BAZAR POUR FAIRE LA MÊME CHOSE AU FINAL ??? <img src="./cpp_files/mechant.png" alt=":colere2:" class="smilies"> </div><br>
<br>
Mais non mais non <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
En fait, on vient de créer des fondements beaucoup plus solides pour notre fenêtre en faisant ce qu'on vient de faire. On a déjà un peu plus découpé notre code (et avoir un code modulaire, c'est bien !) et on pourra par la suite plus facilement rajouter de nouveaux widgets et surtout... gérer les évènements des widgets !<br>
<br>
Mais tout ça, vous le découvrirez... dans le prochain chapitre !<br>
<br>
<div class="rmq information">Petit exercice : essayez de modifier (ou de surcharger) le constructeur de la classe MaFenetre pour qu'on puisse lui envoyer en paramètre la largeur et la hauteur de la fenêtre à créer.<br>
Ainsi, vous pourrez alors définir les dimensions de la fenêtre lors de sa création dans le main.</div>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Nous avançons dans notre découverte de Qt, c'est bien ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Vous commencez à mieux maîtriser le concept de widget et vous avez appris à organiser votre code de manière modulaire afin de servir de base solide pour les chapitres à venir.<br>
<br>
Le programme de la suite ? Les signaux et les slots !<br>
Nous allons faire en sorte que notre programme réagisse lorsqu'on clique sur le bouton !
	</div>
	
	<hr>
	<h1 id="chap_11268">Les signaux et les slots</h1>
	<div id="chap_intro">
	Nous commençons à maîtriser petit à petit la création d'une fenêtre. Dans le chapitre précédent, nous avons posé de solides bases pour développer par la suite notre application. Nous avons réalisé une classe personnalisée, héritant de QWidget.<br>
<br>
Nous allons maintenant découvrir le mécanisme des <strong>signaux et des slots</strong>, un principe propre à Qt qui est clairement un de ses points forts. Il s'agit d'une technique séduisante pour gérer les évènements au sein d'une fenêtre.<br>
Par exemple, si on clique sur un bouton, on voudrait qu'une fonction soit appelée pour réagir au clic. C'est précisément ce que nous apprendrons à faire dans ce chapitre, qui va enfin rendre votre application dynamique <img src="./cpp_files/smile.png" alt=":)" class="smilies">
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11267">Le principe des signaux et slots</h2>
		<div class="ss_part_texte">
		Le principe est plutôt simple à comprendre : une application de type GUI réagit à partir d'évènements. C'est ce qui rend votre fenêtre dynamique.<br>
Ceux d'entre vous qui ont déjà essayé la bibliothèque SDL se souviennent peut-être de la gestion des évènements : interception des touches du clavier, des déplacements de la souris, du joystick, etc.<br>
<br>
Ce que Qt propose, c'est la même chose mais à plus haut niveau : c'est donc beaucoup plus facile à gérer.<br>
<br>
On parle de signaux et de slots, mais qu'est-ce que c'est concrètement ? C'est un concept inventé par Qt. Voici une petite définition en guise d'introduction :<br>
<br>
<ul>
<li><strong>Un signal</strong> : c'est un message envoyé par un widget lorsqu'un évènement se produit.<br>
<span class="italique">Exemple : on a cliqué sur un bouton.</span></li>
<li><strong>Un slot</strong> : c'est la fonction qui est appelée lorsqu'un évènement s'est produit. On dit que le signal appelle le slot. Concrètement, un slot est une méthode d'une classe.<br>
<span class="italique">Exemple : le slot quit() de la classe QApplication, qui provoque l'arrêt du programme.</span></li>
</ul><br>
<br>
Les signaux et les slots sont considérés par Qt comme des éléments d'une classe à part entière, en plus des attributs et des méthodes.<br>
<br>
Voici un schéma qui montre ce qu'un objet pouvait contenir avant Qt, ainsi que ce qu'il peut contenir maintenant qu'on utilise Qt :<br>
<br>
<div class="centre"><img src="./cpp_files/103700.png" alt="Un objet avec des signaux et des slots"><br>
<br>
<span class="italique">Qt rajoute des éléments appelés "Signaux" et "Slots" aux objets</span></div><br>
<br>
Avant Qt, un objet était constitué d'attributs et de méthodes. C'est tout.<br>
Qt rajoute en plus la possibilité d'utiliser ce qu'il appelle des signaux et des slots pour gérer les évènements.<br>
<br>
Un signal est un message envoyé par l'objet (par exemple "on a cliqué sur le bouton").<br>
Un slot est une... méthode. En fait, <span class="souligne">c'est une méthode classique comme toutes les autres</span>, à la différence près qu'elle a le droit d'être connectée à un signal.<br>
<br>
Avec Qt, on dit que l'<strong>on connecte des signaux et des slots entre eux</strong>. Supposons que vous ayez deux objets, chacun ayant ses propres attributs, méthodes, signaux et slots (je n'ai pas représenté les attributs et les méthodes sur mon schéma pour simplifier) :<br>
<br>
<div class="centre"><img src="./cpp_files/103701.png" alt="Des signaux et des slots"></div><br>
<br>
Sur le schéma ci-dessus, on a connecté le signal 1 de l'objet 1 avec le slot 2 de l'objet 2.<br>
<br>
<div class="rmq information">Il est possible de connecter un signal à plusieurs slots. Ainsi, un clic sur un bouton pourrait appeler non pas une mais plusieurs méthodes. <span class="souligne">Attention</span>, si un signal est connecté à plusieurs slots, il est impossible de prédire dans quel ordre Qt appellera les slots.<br>
<br>
Comble du raffinement, il est aussi possible de connecter un signal à un autre signal. Le signal d'un bouton peut donc provoquer la création du signal d'un autre widget, qui peut à son tour appeler des slots (voire appeler d'autres signaux pour provoquer une réaction en chaîne !). C'est un peu particulier et on ne verra pas ça dans ce chapitre.</div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11266">Connexion d'un signal à un slot simple</h2>
		<div class="ss_part_texte">
		Voyons un cas très concret. Je vais prendre 2 objets, l'un de type QPushButton, et l'autre de type QApplication. Dans le schéma ci-dessous, ce que vous voyez sont de <span class="italique">vrais signaux et slots</span> que vous allez pouvoir utiliser :<br>
<br>
<div class="centre"><img src="./cpp_files/103834.png" alt="Signaux et slots en pratique"></div><br>
<br>
Regardez attentivement ce schéma. Nous avons d'un côté notre bouton appelé "m_bouton" (de type QPushButton), et de l'autre notre application (de type QApplication, utilisé dans le main).<br>
<br>
Nous voudrions par exemple connecter le signal "bouton cliqué" au slot "quitter l'application". Ainsi, un clic sur le bouton provoquerait l'arrêt de l'application.<br>
<br>
Pour ce faire, nous devons utiliser une méthode statique de la classe QObject : connect().<br>
<br>
<br>
<h3>Le principe de la méthode connect()</h3><br>
<br>
connect() est une méthode statique. Vous vous souvenez ce que ça veut dire ?<br>
Une méthode statique est une méthode d'une classe que l'on peut appeler sans créer d'objet. C'est en fait  exactement comme une fonction classique du langage C.<br>
<br>
<div class="rmq information">Si vous avez un trou de mémoire, allez vite relire le chapitre traitant des <a href="http://www.siteduzero.com/tuto-3-22840-1-elements-statiques-et-constants.html#ss_part_2">méthodes statiques</a> !</div><br>
<br>
Pour appeler une méthode statique, il faut faire précéder son nom du nom de la classe dans laquelle elle est déclarée. Comme connect() appartient à la classe QObject, il faut donc écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><div class="flot_droite"><img src="./cpp_files/103834.png" alt="Signaux et slots en pratique"></div><br>
<br>
La méthode connect prend 4 arguments :<br>
<br>
<ul>
<li><span class="bleu">Un pointeur vers l'objet qui émet le signal.</span></li>
<li><span class="vertf">Le nom du signal que l'on souhaite "intercepter".</span></li>
<li><span class="orange">Un pointeur vers l'objet qui contient le slot récepteur.</span></li>
<li><span class="rouge">Le nom du slot qui doit s'exécuter lorsque le signal se produit.</span></li>
</ul><br>
Pour que vous puissiez vous repérer, j'ai remis ci-contre le schéma qu'on a vu un peu plus haut. Les couleurs sont les mêmes, cela devrait vous permettre de bien visualiser à quoi correspond chaque attribut.<br>
<br>
<br>
Il existe aussi une méthode disconnect() permettant de casser la connexion entre 2 objets, mais on n'en parlera pas ici car on en a rarement besoin.<br>
<br>
<h3>Utilisation de la méthode connect() pour quitter</h3><br>
<br>
Revenons au code, et plus précisément au constructeur de MaFenetre (fichier MaFenetre.cpp). Ajoutez cette ligne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "MaFenetre.h"</span>
 
<span class="n">MaFenetre</span><span class="o">::</span><span class="n">MaFenetre</span><span class="p">()</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">setFixedSize</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
 
    <span class="n">m_bouton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Quitter"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">m_bouton</span><span class="o">-&gt;</span><span class="n">setFont</span><span class="p">(</span><span class="n">QFont</span><span class="p">(</span><span class="s">"Comic Sans MS"</span><span class="p">,</span> <span class="mi">14</span><span class="p">));</span>
    <span class="n">m_bouton</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
 
    <span class="c1">// Connexion du clic du bouton à la fermeture de l'application</span>
<span class="ln-xtra">    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">m_bouton</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span></span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<div class="rmq information">connect() est une méthode de la classe QObject. Comme notre classe MaFenetre hérite de QObject indirectement, elle possède elle aussi cette méthode. Cela signifie que dans ce cas, et <span class="souligne">dans ce cas uniquement</span>, on peut enlever le préfixe <span class="courrier">QObject::</span> devant le connect() pour appeler la méthode statique.<br>
J'ai choisi de conserver ce préfixe dans le cours pour rappeler qu'il s'agit d'une méthode statique, mais sachez donc qu'il n'a rien d'obligatoire si la méthode est appelée depuis une classe fille de QObject.</div><br>
<br>
Etudions attentivement cette ligne et plus particulièrement les paramètres que l'on envoie à connect() :<br>
<br>
<ul>
<li><strong>m_bouton</strong> : c'est un pointeur vers le bouton qui va émettre le signal. Facile.</li>
<li><strong>SIGNAL(clicked())</strong> : là c'est assez perturbant comme façon d'envoyer un paramètre. En fait, SIGNAL() est une macro du préprocesseur. Qt transformera ça en un code "acceptable" pour la compilation. Le but de cette technique est de vous faire écrire un code court et compréhensible. Ne cherchez pas à comprendre comment Qt fait pour transformer le code, on s'en fout <img src="./cpp_files/langue.png" alt=":p" class="smilies"></li>
<li><strong>qApp</strong> : c'est un pointeur vers l'objet de type QApplication que nous avons créé dans le main. D'où sort ce pointeur ? Euh... joker <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
En fait, Qt crée automatiquement un pointeur appelé qApp vers l'objet de type QApplication que nous avons créé. Ce pointeur est défini dans le header &lt;QApplication&gt;, que nous avons inclus dans "MaFenetre.h".</li>
<li><strong>SLOT(quit())</strong> : c'est le slot qui doit être appelé lorsqu'on a cliqué sur le bouton. Là encore, il faut utiliser la macro SLOT() pour que Qt traduise ce code "bizarre" en quelque chose de compilable.</li>
</ul><br>
Le slot quit() de notre objet de type QApplication est un <strong>slot prédéfini</strong>. Il en existe d'autres, comme aboutQt() qui affiche une fenêtre "A propos de Qt".<br>
Parfois, pour ne pas dire souvent, les slots prédéfinis par Qt ne nous suffiront pas. Nous apprendrons dans la suite de ce chapitre à créer les nôtres.<br>
<br>
Testons notre code ! La fenêtre qui s'ouvre est la suivante :<br>
<br>
<div class="centre"><img src="./cpp_files/103717.png" alt="La fenêtre avec le bouton quitter"></div><br>
<br>
Rien de bien extraordinaire à première vue. Sauf que... si vous cliquez sur le bouton "Quitter", le programme s'arrête !<br>
Hourra, on vient de réussir à connecter notre premier signal à un slot ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<br>
<br>
<h3>Utilisation de la méthode connect() pour afficher "A propos"</h3><br>
<br>
On peut faire un autre essai pour se faire un peu plus la main si vous voulez. Je vous ai parlé d'un autre slot de QApplication : aboutQt().<br>
Je vous propose de créer un second bouton qui se chargera d'afficher la fenêtre "A propos de Qt".<br>
<br>
Je vous laisse rédiger le code tous seuls comme des grands.<br>
<br>
<br>
...<br>
<br>
<br>
...<br>
<br>
C'est bon ?<br>
Voici le code final <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "MaFenetre.h"</span>
 
<span class="n">MaFenetre</span><span class="o">::</span><span class="n">MaFenetre</span><span class="p">()</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">setFixedSize</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
 
    <span class="n">m_quitter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Quitter"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">m_quitter</span><span class="o">-&gt;</span><span class="n">setFont</span><span class="p">(</span><span class="n">QFont</span><span class="p">(</span><span class="s">"Comic Sans MS"</span><span class="p">,</span> <span class="mi">14</span><span class="p">));</span>
    <span class="n">m_quitter</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">m_quitter</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>
 
    <span class="n">m_aPropos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"A propos"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">m_aPropos</span><span class="o">-&gt;</span><span class="n">setFont</span><span class="p">(</span><span class="n">QFont</span><span class="p">(</span><span class="s">"Comic Sans MS"</span><span class="p">,</span> <span class="mi">14</span><span class="p">));</span>
    <span class="n">m_aPropos</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">90</span><span class="p">);</span>
    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">m_aPropos</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">aboutQt</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous noterez que j'ai pris la liberté de nommer les boutons avec des noms un peu plus compréhensibles.<br>
Bien entendu, le fichier MaFenetre.h a un peu changé lui aussi du coup pour déclarer les attributs "m_quitter" et "m_aPropos", mais vous êtes assez grands pour le faire sans moi <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Le résultat est une fenêtre qui affiche 2 boutons :<br>
<br>
<div class="centre"><img src="./cpp_files/103721.png" alt="Le bouton A propos"></div><br>
<br>
Le bouton "Quitter" ferme toujours l'application.<br>
Quant à "A propos", il provoque l'ouverture de la fenêtre "A propos de Qt".<br>
<br>
<div class="centre"><img src="./cpp_files/103722.png" alt="Le bouton A propos a ouvert une fenêtre"></div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11270">Des paramètres dans les signaux et slots</h2>
		<div class="ss_part_texte">
		La méthode statique <span class="courrier">connect()</span> est assez originale, vous l'avez vu. Il s'agit justement d'une des particularités de Qt que l'on ne retrouve pas dans les autres bibliothèques.<br>
Ces autres bibliothèques, comme wxWidgets par exemple, utilisent à la place de nombreuses macros et se servent du mécanisme un peu complexe et délicat des pointeurs de fonction (pour indiquer l'adresse de la fonction à appeler en mémoire).<br>
<br>
Il y a d'autres avantages à utiliser la méthode connect() avec Qt. On va ici découvrir que <strong>les signaux et les slots peuvent s'échanger des paramètres</strong> !<br>
<br>
<br>
<h3>Dessin de la fenêtre</h3><br>
<br>
Dans un premier temps, nous allons placer de nouveaux widgets dans notre fenêtre.<br>
Vous pouvez enlever les boutons, on ne va plus s'en servir ici.<br>
<br>
A la place, je souhaite vous faire utiliser 2 nouveaux widgets :<br>
<br>
<ul>
<li><strong>QSlider </strong>: un curseur qui permet de définir une valeur.</li>
<li><strong>QLCDNumber </strong>: un widget qui affiche un nombre.</li>
</ul><br>
<br>
On va aller un peu plus vite, je vous donne le code directement pour créer ça.<br>
Tout d'abord, le header :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef DEF_MAFENETRE</span>
<span class="cp">#define DEF_MAFENETRE</span>
<span class="cp"> </span>
<span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QWidget&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
<span class="cp">#include &lt;QLCDNumber&gt;</span>
<span class="cp">#include &lt;QSlider&gt;</span>
 
<span class="k">class</span> <span class="nc">MaFenetre</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="n">MaFenetre</span><span class="p">();</span>
 
    <span class="k">private</span><span class="o">:</span>
    <span class="n">QLCDNumber</span> <span class="o">*</span><span class="n">m_lcd</span><span class="p">;</span>
    <span class="n">QSlider</span> <span class="o">*</span><span class="n">m_slider</span><span class="p">;</span> 
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
J'ai donc enlevé les boutons comme vous pouvez le voir, et rajouté un QLCDNumber et un QSlider.<br>
Surtout, n'oubliez pas d'inclure le header de ces classes pour pouvoir les utiliser. J'ai gardé l'include du QPushButton ici, ça ne fait pas de mal de le laisser mais si vous ne comptez pas le réutiliser vous pouvez le virer sans crainte.<br>
<br>
Et le fichier .cpp :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "MaFenetre.h"</span>
 
<span class="n">MaFenetre</span><span class="o">::</span><span class="n">MaFenetre</span><span class="p">()</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">setFixedSize</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
 
    <span class="n">m_lcd</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLCDNumber</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="n">m_lcd</span><span class="o">-&gt;</span><span class="n">setSegmentStyle</span><span class="p">(</span><span class="n">QLCDNumber</span><span class="o">::</span><span class="n">Flat</span><span class="p">);</span>
    <span class="n">m_lcd</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
 
    <span class="n">m_slider</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QSlider</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Horizontal</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">m_slider</span><span class="o">-&gt;</span><span class="n">setGeometry</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
Les détails ne sont pas très importants. J'ai modifié le type d'afficheur LCD pour qu'il soit plus lisible (avec setSegmentStyle). Quant au slider, j'ai rajouté un paramètre pour qu'il apparaisse horizontalement (sinon il est vertical).<br>
<br>
Voilà qui est fait. Avec ce code, cette petite fenêtre devrait s'afficher :<br>
<br>
<div class="centre"><img src="./cpp_files/103727.png" alt="Un afficheur LCD"></div><br>
<br>
<h3>Connexion avec des paramètres</h3><br>
<br>
Maintenant... connexiooooon !<br>
C'est là que les choses deviennent intéressantes. On veut que l'afficheur LCD change de valeur en fonction de la position du curseur du slider.<br>
<br>
On dispose du signal et du slot suivant :<br>
<br>
<ul>
<li><strong>Le signal valueChanged(int) du QSlider</strong> : il est émis dès que l'on change la valeur du curseur du slider en le déplaçant. La particularité de ce signal est qu'il envoie un paramètre de type int (la nouvelle valeur du slider).</li>
<li><strong>Le slot display(int) du QLCDNumber</strong> : il affiche la valeur qui lui est passée en paramètre.</li>
</ul><br>
La connexion se fait avec le code suivant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">m_slider</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">valueChanged</span><span class="p">(</span><span class="kt">int</span><span class="p">)),</span> <span class="n">m_lcd</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">display</span><span class="p">(</span><span class="kt">int</span><span class="p">)));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Bizarre n'est-ce pas ? <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Il suffit d'indiquer le type du paramètre envoyé, ici un int, sans donner de nom à ce paramètre. Qt fait automatiquement la connexion entre le signal et le slot et "transmet" le paramètre au slot.<br>
<br>
Le transfert de paramètre se fait comme ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/103836.png" alt="Connexion int à int"></div><br>
<br>
Ici il n'y a qu'un paramètre à transmettre, c'est donc simple. Sachez toutefois qu'il pourrait très bien y avoir plusieurs paramètres.<br>
<br>
<div class="rmq attention">Le type des paramètres doivent correspondre absolument !<br>
Vous ne pouvez pas connecter un signal qui envoie <span class="courrier">(int, double)</span> à un slot qui reçoit <span class="courrier">(int, int)</span>. C'est un des avantages du mécanisme des signaux et des slots : il respecte le type des paramètres. Veillez donc à ce que les signatures soient identiques entre votre signal et votre slot.<br>
En revanche, un signal peut envoyer plus de paramètres à un slot que celui-ci ne peut en recevoir. Dans ce cas, les paramètres supplémentaires seront ignorés.</div><br>
<br>
Résultat : quand on change la valeur du slider, le LCD affiche la valeur correspondante !<br>
<br>
<div class="centre"><img src="./cpp_files/103731.png" alt="Un afficheur LCD génère des évènements"></div><br>
<br>
<div class="rmq question">Mais comment je sais moi quels sont les signaux et les slots que proposent chacune des classes ? Et aussi, comment je sais qu'un signal envoie un int en paramètre ?</div><br>
<br>
La réponse devrait vous paraître simple les amis : <strong>la doc, la doc, la doc</strong> ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Si vous regardez la <a href="http://doc.trolltech.com/qlcdnumber.html">documentation de la classe QLCDNumber</a>, vous pouvez voir au début la liste de ses propriétés (attributs) et ses méthodes. Un peu plus bas, vous avez la liste des slots ("Public Slots") et des signaux ("Signals") qu'elle possède !<br>
<br>
<div class="rmq information">Les signaux et les slots sont <strong>hérités </strong>comme les attributs et méthodes. Et ça, c'est génial, bien qu'un peu déroutant au début.<br>
Vous noterez donc qu'en plus des <a href="http://doc.trolltech.com/qlcdnumber.html#public-slots">slots propres à QLCDNumber</a>, celui-ci propose de nombreux autres slots qui ont été définis dans sa classe parente QWidget, et même des slots issus de QObject ! Vous pouvez par exemple lire :<br>
<ul>
<li>19 public slots inherited from QWidget</li>
<li>1 public slot inherited from QObject</li>
</ul><br>
N'hésitez pas à consulter les slots (ou signaux) qui sont hérités des classes parentes. Parfois on va vous demander d'utiliser un signal ou un slot que vous ne verrez pas dans la page de documentation de la classe : vérifiez donc si celui-ci n'est pas défini dans une classe parente !</div><br>
<br>
<h3>Exercice</h3><br>
<br>
Pour vous entraîner, je vous propose de réaliser une petite variation du code source précédent.<br>
Au lieu d'afficher le nombre avec un QLCDNumber, affichez-le sous la forme d'une jolie barre de progression comme ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/103737.png" alt="Slider et progressbar"></div><br>
<br>
Je ne vous donne que 3 indications qui devraient vous suffire :<br>
<br>
<ul>
<li>La barre de progression est gérée par un QProgressBar</li>
<li>Il faut donner des dimensions à la barre de progression pour qu'elle apparaisse correctement, à l'aide de la méthode setGeometry() que l'on a déjà vue auparavant.</li>
<li>Le slot récepteur du QProgressBar est <span class="courrier">setValue(int)</span>. Il s'agit d'<a href="http://doc.trolltech.com/qprogressbar.html#public-slots">un de ses slots</a>, mais la documentation vous indique qu'il y en a d'autres. Par exemple, reset() remet à zéro la barre de progression. Pourquoi ne pas ajouter un bouton qui remettrait à zéro la barre de progression ?</li>
</ul><br>
C'est tout. Bon courage <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11269">Créer ses propres signaux et slots</h2>
		<div class="ss_part_texte">
		Voici maintenant une partie très intéressante, bien que plus délicate. Nous allons créer nos propres signaux et slots.<br>
<br>
En effet, si en général les signaux et slots par défaut suffisent, il n'est pas rare que l'on se dise "<span class="italique">Zut, le signal (ou le slot) dont j'ai besoin n'existe pas</span>". C'est dans un cas comme celui-là qu'il devient indispensable de créer son widget personnalisé.<br>
<br>
<div class="rmq information">Pour pouvoir créer son propre signal ou slot dans une classe, il faut que celle-ci dérive directement ou indirectement de QObject. C'est le cas de notre classe MaFenetre : elle hérite de QWidget, qui hérite de QObject. On a donc le droit de créer des signaux et des slots dans MaFenetre.</div><br>
<br>
Nous allons commencer par créer notre propre slot, puis nous verrons comment créer notre propre signal.<br>
<br>
<br>
<h3>Créer son propre slot</h3><br>
<br>
Je vous rappelle tout d'abord qu'un slot n'est rien d'autre qu'une méthode que l'on peut connecter à un signal.<br>
Nous allons donc créer une méthode, mais en suivant quelques règles un peu particulières...<br>
<br>
<h4>Le but du jeu</h4><br>
<br>
Pour nous entraîner, nous allons inventer un cas où le slot dont on a besoin n'existe pas.<br>
Je vous propose de conserver le QSlider (je l'aime bien celui-là <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ) et de ne garder que ça sur la fenêtre. Nous allons <strong>faire en sorte que le QSlider contrôle la largeur de la fenêtre</strong>.<br>
<br>
Votre fenêtre doit ressembler à cela :<br>
<br>
<div class="centre"><img src="./cpp_files/103759.png" alt="Fenêtre avec slider"></div><br>
<br>
Nous voulons que le signal valueChanged(int) du QSlider puisse être connecté à un slot de notre fenêtre (de type MaFenetre). Ce nouveau slot aura pour rôle de modifier la largeur de la fenêtre.<br>
Comme <a href="http://doc.trolltech.com/qwidget.html#public-slots">il n'existe pas de slot "changerLargeur" dans la classe QWidget</a>, nous allons devoir le créer.<br>
<br>
Pour créer ce slot, il va falloir modifier un peu notre classe MaFenetre. Commençons par le header.<br>
<br>
<h4>Le header (MaFenetre.h)</h4><br>
<br>
Dès que l'on doit créer un signal ou un slot personnalisé, il est nécessaire de définir une macro dans le header de la classe.<br>
<br>
Cette macro porte le nom de Q_OBJECT (tout en majuscules) et doit être placée tout au début de la déclaration de la classe :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">MaFenetre</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
<span class="ln-xtra">    <span class="n">Q_OBJECT</span></span>
 
    <span class="k">public</span><span class="o">:</span>
    <span class="n">MaFenetre</span><span class="p">();</span>
 
    <span class="k">private</span><span class="o">:</span>
    <span class="n">QSlider</span> <span class="o">*</span><span class="n">m_slider</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Pour le moment, notre classe ne définit qu'un attribut (le QSlider, privé) et une méthode (le constructeur, public).<br>
<br>
La macro Q_OBJECT "prépare" en quelque sorte le compilateur à accepter un nouveau mot-clé : "slot". Nous allons maintenant pouvoir créer une section "slots", comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">MaFenetre</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>
 
    <span class="k">public</span><span class="o">:</span>
    <span class="n">MaFenetre</span><span class="p">();</span>
 
<span class="ln-xtra">    <span class="k">public</span> <span class="nl">slots:</span></span>
<span class="ln-xtra">    <span class="kt">void</span> <span class="n">changerLargeur</span><span class="p">(</span><span class="kt">int</span> <span class="n">largeur</span><span class="p">);</span></span>
 
    <span class="k">private</span><span class="o">:</span>
    <span class="n">QSlider</span> <span class="o">*</span><span class="n">m_slider</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous noterez la nouvelle section "public slots". Je rends toujours mes slots publics. On peut aussi les mettre privés mais ils seront quand même accessibles de l'extérieur car Qt a besoin de pouvoir appeler un slot depuis n'importe quel autre widget.<br>
<br>
A part ça, le prototype de notre slot-méthode est tout à fait classique. Il ne nous reste plus qu'à l'implémenter dans le .cpp.<br>
<br>
<br>
<h4>L'implémentation (MaFenetre.cpp)</h4><br>
<br>
L'implémentation est d'une simplicité redoutable. Regardez :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">MaFenetre</span><span class="o">::</span><span class="n">changerLargeur</span><span class="p">(</span><span class="kt">int</span> <span class="n">largeur</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setFixedSize</span><span class="p">(</span><span class="n">largeur</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le slot prend en paramètre un entier : la nouvelle largeur de la fenêtre.<br>
Il se contente d'appeler la méthode setFixedSize de la fenêtre et de lui envoyer la nouvelle largeur qu'il a reçue.<br>
<br>
<br>
<h4>Connexion</h4><br>
<br>
Bien, voilà qui est fait. Enfin presque : il faut encore connecter notre QSlider au slot de notre fenêtre. Où va-t-on faire ça ? Dans le constructeur de la fenêtre (toujours dans MaFenetre.cpp) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></td><td class="code"><div class="syntax"><pre><span class="n">MaFenetre</span><span class="o">::</span><span class="n">MaFenetre</span><span class="p">()</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">setFixedSize</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
 
    <span class="n">m_slider</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QSlider</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Horizontal</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">m_slider</span><span class="o">-&gt;</span><span class="n">setRange</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">600</span><span class="p">);</span>
    <span class="n">m_slider</span><span class="o">-&gt;</span><span class="n">setGeometry</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
 
<span class="ln-xtra">    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">m_slider</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">valueChanged</span><span class="p">(</span><span class="kt">int</span><span class="p">)),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">changerLargeur</span><span class="p">(</span><span class="kt">int</span><span class="p">)));</span></span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
J'ai volontairement modifié les différentes valeurs que peut prendre notre slider pour le limiter entre 200 et 600 avec la méthode <span class="courrier">setRange()</span>. Ainsi, on est sûr que notre fenêtre ne pourra ni être plus petite que 200 pixels de largeur, ni être plus grande que 600 pixels de largeur.<br>
<br>
La connexion se fait entre le signal <span class="courrier">valueChanged(int)</span> de notre QSlider, et le slot <span class="courrier">changerLargeur(int)</span> de notre classe MaFenetre. Vous voyez là encore un exemple où <span class="italique">this </span>est indispensable : il faut pouvoir indiquer un pointeur vers l'objet actuel (la fenêtre) et seul <span class="italique">this </span>peut faire ça !<br>
<br>
Schématiquement, on a réalisé la connexion suivante :<br>
<br>
<div class="centre"><img src="./cpp_files/103835.png" alt="Connexion entre le slider et la fenêtre"></div><br>
<br>
<h4>Compilation</h4><br>
<br>
Avec toutes les nouveautés que nous venons d'utiliser par rapport au C++, la compilation par un make ne suffira pas.<br>
<br>
Je vous avais dit qu'il fallait refaire un qmake à chaque fois que les fichiers du projet changeaient. En fait j'ai un peu menti <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Comme vous utilisez la macro Q_OBJECT, Qt a besoin d'appeler un pré-compilateur qui lui est propre appelé le <strong>moc </strong>(Meta-Object Compiler).<br>
<br>
Rassurez-vous, vous n'avez rien à faire de spécial. Relancez juste un qmake avant de faire votre make, et Qt fera le travail de "traduction" du slot en quelque chose de compréhensible pour le compilateur C++.<br>
Vous noterez que le qmake a provoqué la création d'un fichier intermédiaire moc_MaFenetre.cpp, ce qui est parfaitement normal. Ce fichier fournit des informations indispensables au compilateur.<br>
<br>
Vous pouvez ensuite faire un make, la compilation devrait bien se passer.<br>
<br>
<div class="rmq erreur">Souvenez-vous ! Si jamais lors de la compilation vous rencontrez l'erreur suivante :<br>
<span class="courrier">undefined reference to 'vtable for MaFenetre'</span><br>
... cela signifie que vous n'avez pas fait de qmake avant. Si le moc ne s'est pas exécuté auparavant, la compilation échouera.</div><br>
<br>
Vous pouvez enfin admirer le résultat. Ouf ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="centre"><img src="./cpp_files/103760.png" alt="Le slider élargit la fenêtre"></div><br>
<br>
Amusez-vous à redimensionner la fenêtre comme bon vous semblera avec le slider. Comme nous avons fixé les limites du slider entre 200 et 600, la largeur de la fenêtre restera comprise entre 200 et 600 pixels.<br>
<br>
<br>
<h4>Exercice : redimensionner la fenêtre en hauteur</h4><br>
<br>
Voici un petit exercice, mais qui va vous forcer à travailler (bande de fainéants, vous me regardez faire depuis tout à l'heure <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ).<br>
Je vous propose de créer un second QSlider, vertical cette fois, qui contrôlera la hauteur de la fenêtre. Pensez à bien définir des limites appropriées pour les valeurs de ce nouveau slider.<br>
<br>
Vous devriez obtenir un résultat qui ressemblera à ça :<br>
<br>
<div class="centre"><img src="./cpp_files/103802.png" alt="Un slider vertical"></div><br>
<br>
Si vous voulez "conserver" la largeur pendant que vous modifiez la hauteur, et inversement, vous aurez besoin d'utiliser les méthodes accesseur width() (largeur actuelle) et height() (hauteur actuelle).<br>
Vous comprendrez très certainement l'intérêt de ces informations lorsque vous coderez. Au boulot !<br>
<br>
<br>
<h3>Créer son propre signal</h3><br>
<br>
Il est plus rare d'avoir à créer son signal que son slot, mais cela peut arriver.<br>
<br>
Je vous propose de réaliser le programme suivant : si le slider horizontal arrive à sa valeur maximale (600 dans notre cas), alors on émet un signal "agrandissementMax". Notre fenêtre doit pouvoir émettre l'information comme quoi elle est agrandie au maximum.<br>
Après, nous connecterons ce signal à un slot pour vérifier que notre programme réagit correctement.<br>
<br>
<br>
<h4>Le header (MaFenetre.h)</h4><br>
<br>
Commençons par changer le header :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">MaFenetre</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>
 
    <span class="k">public</span><span class="o">:</span>
    <span class="n">MaFenetre</span><span class="p">();</span>
 
    <span class="k">public</span> <span class="nl">slots:</span>
    <span class="kt">void</span> <span class="n">changerLargeur</span><span class="p">(</span><span class="kt">int</span> <span class="n">largeur</span><span class="p">);</span>
 
<span class="ln-xtra">    <span class="nl">signals:</span></span>
<span class="ln-xtra">    <span class="kt">void</span> <span class="n">agrandissementMax</span><span class="p">();</span></span>
 
    <span class="k">private</span><span class="o">:</span>
    <span class="n">QSlider</span> <span class="o">*</span><span class="n">m_slider</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On a ajouté une section "signals". Les signaux se présentent en pratique sous forme de méthodes (comme les slots) à la différence près qu'on ne les implémente pas dans le .cpp. En effet, c'est Qt qui le fait pour nous. Si vous tentez d'implémenter un signal, vous aurez une erreur du genre "<span class="courrier">Multiple definition of...</span>".<br>
<br>
Un signal peut passer un ou plusieurs paramètres. Dans notre cas, il n'en envoie aucun.<br>
Un signal doit toujours renvoyer void.<br>
<br>
<br>
<h4>L'implémentation (MaFenetre.cpp)</h4><br>
<br>
Maintenant que notre signal est défini, il faut que notre classe puisse l'émettre à un moment.<br>
Quand est-ce qu'on sait que la fenêtre a été agrandie au maximum ? Dans le slot changerLargeur ! Il suffit de tester dans ce slot si la largeur correspond au maximum (600), et d'émettre alors le signal "<span class="italique">Youhou, j'ai été agrandie au maximum !</span>".<br>
<br>
Retournons dans MaFenetre.cpp et implémentons ce test qui émet le signal depuis changerLargeur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">MaFenetre</span><span class="o">::</span><span class="n">changerLargeur</span><span class="p">(</span><span class="kt">int</span> <span class="n">largeur</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setFixedSize</span><span class="p">(</span><span class="n">largeur</span><span class="p">,</span> <span class="n">height</span><span class="p">());</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">largeur</span> <span class="o">==</span> <span class="mi">600</span><span class="p">)</span>
    <span class="p">{</span>
<span class="ln-xtra">        <span class="n">emit</span> <span class="n">agrandissementMax</span><span class="p">();</span></span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notre méthode s'occupe toujours de redimensionner la fenêtre, mais vérifie en plus si la largeur a atteint le maximum (600). Si c'est le cas, elle émet le signal agrandissementMax().<br>
Pour émettre un signal, on utilise le mot-clé <span class="courrier">emit</span>, là encore un terme inventé par Qt qui n'existe pas en C++. L'avantage est que c'est très lisible, on comprend "<span class="italique">Emettre le signal agrandissementMax()</span>".<br>
<br>
<div class="rmq information">Ici, notre signal n'envoie pas de paramètres. Toutefois, sachez que si vous voulez envoyer un paramètre c'est très simple. Il suffit d'appeler votre signal comme ceci : <span class="courrier">emit monSignal(parametre1, parametre2, ...);</span></div><br>
<br>
<h4>Connexion</h4><br>
<br>
Il ne nous reste plus qu'à connecter notre nouveau signal à un slot. Vous pouvez connecter ce signal au slot que vous voulez. Personnellement, je propose de le connecter à l'application (à l'aide du pointeur global qApp) pour provoquer l'arrêt du programme.<br>
Ca n'a pas trop de sens je suis d'accord, mais c'est juste pour s'entraîner et vérifier que ça fonctionne. Vous aurez l'occasion de faire des connexions plus logiques plus tard, je ne m'en fais pas pour ça <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Dans le constructeur de MaFenetre, je rajoute donc :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">agrandissementMax</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous pouvez tester le résultat : normalement le programme s'arrête quand la fenêtre est agrandie au maximum.<br>
<br>
Le schéma des signaux qu'on vient d'émettre et connecter est le suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/103878.png" alt="Echange de signaux entre objets"></div><br>
<br>
Dans l'ordre, voici ce qui s'est passé :<br>
<br>
<ol class="liste_1">
<li>Le signal valueChanged du slider a appelé le slot changerLargeur de la fenêtre.</li>
<li>Le slot a fait ce qu'il avait à faire (changer la largeur de la fenêtre) et a vérifié si la fenêtre était arrivée à sa taille maximale. Lorsque cela a été le cas, le signal personnalisé agrandissementMax() a été émis.</li>
<li>Le signal agrandissementMax() de la fenêtre était connecté au slot quit() de l'application, ce qui a provoqué la fermeture du programme.</li></ol><br>
Et voilà comment le déplacement du slider peut, par réaction en chaîne, provoquer la fermeture du programme !<br>
Bien entendu, ce schéma peut être aménagé et complexifié selon les besoins de votre application.<br>
<br>
Maintenant que vous savez créer vos propres slots et signaux, vous avez toute la souplesse nécessaire pour <strong>faire ce que vous voulez</strong> ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Eh ben dites donc les amis, que de nouveautés dans ce chapitre décidément !<br>
<br>
Les signaux et les slots, c'est vraiment ce qui fait la force de Qt... mais ses détracteurs disent que c'est une erreur d'avoir voulu "modifier" le langage C++. En effet, la compilation est plus lourde car il y a des étapes de pré-compilation à effectuer impérativement si on veut que le code soit compilable. C'est un point de vue qui se défend.<br>
<br>
L'avantage de ce système, et ça personne ne le discute, c'est qu'il est robuste. On dispose d'une extraordinaire souplesse pour faire communiquer des objets entre eux :<br>
<br>
<ul>
<li>Un signal peut appeler le slot d'un autre objet pour l'informer d'un évènement.</li>
<li>Un signal peut appeler plusieurs slots d'objets différents si nécessaire pour faire plusieurs traitements.</li>
<li>Un signal peut être connecté à un autre signal directement, qui lui-même peut être raccordé à un autre signal (réaction en chaîne) ou appeler un slot.</li>
<li>La connexion entre un signal et un slot permet d'échanger un ou plusieurs paramètres.</li>
<li>L'échange de paramètres entre le signal et le slot est sécurisé : Qt vérifie que la signature du signal correspond bien à celle du slot.</li>
</ul><br>
Les autres bibliothèques, comme wxWidgets, utilisent un ensemble de macros, moins lisibles mais qui ne nécessitent pas l'utilisation d'outils intermédiaires comme le moc.<br>
<br>
Bref, profitez à fond des signaux et des slots, avec ça vous pouvez vraiment faire ce que vous voulez <img src="./cpp_files/heureux.png" alt=":D" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11282">Les boîtes de dialogue usuelles</h1>
	<div id="chap_intro">
	Après un chapitre sur les signaux et les slots riche en nouveaux concepts, on relâche ici un peu la pression.<br>
Nous allons découvrir les <strong>boîtes de dialogue usuelles</strong>, aussi appelées "<span class="italique">common dialogs</span>" par nos amis anglophones.<br>
<br>
Qu'est-ce qu'une boîte de dialogue usuelle ? C'est une fenêtre qui sert à remplir une fonction bien précise. Par exemple, on connaît la boîte de dialogue "message" qui affiche un message et ne vous laisse d'autre choix que de cliquer sur le bouton OK. Ou encore la boîte de dialogue "ouvrir un fichier", "enregistrer un fichier", "sélectionner une couleur", etc.<br>
On ne s'amuse pas à recréer "à la main" ces fenêtres à chaque fois. On profite de fonctions système pour ouvrir des boîtes de dialogue pré-construites.<br>
<br>
Qt s'adapte à l'OS pour afficher une boîte de dialogue qui corresponde aux formes habituelles de votre OS.<br>
<br>
En clair : attendez-vous à un chapitre simple qui vous donnera de nombreux outils pour pouvoir interagir avec l'utilisateur de votre programme !
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11281">Afficher un message</h2>
		<div class="ss_part_texte">
		Le premier type de boîte de dialogue que nous allons voir est le plus courant : la boîte de dialogue "afficher un message".<br>
<br>
Nous allons créer un bouton sur notre fenêtre de type MaFenetre qui appellera un slot personnalisé. Ce slot ouvrira la boîte de dialogue. En clair, un clic sur le bouton doit pouvoir ouvrir la boîte de dialogue.<br>
<br>
Les boîtes de dialogue "afficher un message" sont contrôlées par la classe <strong>QMessageBox</strong>. Vous pouvez commencer par faire l'include correspondant dans "MaFenetre.h" pour ne pas l'oublier : <span class="courrier">#include &lt;QMessageBox&gt;</span>.<br>
<br>
<br>
<h3>Quelques rappels et préparatifs</h3><br>
<br>
Pour que l'on soit sûr de travailler ensemble sur le même code, je vous donne le code source des fichiers MaFenetre.h et MaFenetre.cpp sur lesquels je vais travailler. Ils ont été simplifiés au maximum histoire d'éviter le superflu.<br>
<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="syntax"><pre><span class="c1">// MaFenetre.h</span>
<span class="cp"> </span>
<span class="cp">#ifndef DEF_MAFENETRE</span>
<span class="cp">#define DEF_MAFENETRE</span>
<span class="cp"> </span>
<span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QWidget&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
<span class="cp">#include &lt;QMessageBox&gt;</span>
 
<span class="k">class</span> <span class="nc">MaFenetre</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>
 
    <span class="k">public</span><span class="o">:</span>
    <span class="n">MaFenetre</span><span class="p">();</span>
 
    <span class="k">public</span> <span class="nl">slots:</span>
    <span class="kt">void</span> <span class="n">ouvrirDialogue</span><span class="p">();</span>
 
    <span class="k">private</span><span class="o">:</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">m_boutonDialogue</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp"> </span>
<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="syntax"><pre><span class="c1">// MaFenetre.cpp</span>
<span class="cp"> </span>
<span class="cp">#include "MaFenetre.h"</span>
 
<span class="n">MaFenetre</span><span class="o">::</span><span class="n">MaFenetre</span><span class="p">()</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">setFixedSize</span><span class="p">(</span><span class="mi">230</span><span class="p">,</span> <span class="mi">120</span><span class="p">);</span>
 
    <span class="n">m_boutonDialogue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Ouvrir la boîte de dialogue"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">m_boutonDialogue</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
 
    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">m_boutonDialogue</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">ouvrirDialogue</span><span class="p">()));</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="n">MaFenetre</span><span class="o">::</span><span class="n">ouvrirDialogue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Vous insérerez le code d'ouverture des boîtes de dialogue ici</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est très simple. Nous avons créé un bouton dans la boîte de dialogue qui appelle le slot personnalisé <span class="courrier">ouvrirDialogue()</span>. C'est dans ce slot que nous nous chargerons d'ouvrir une boîte de dialogue.<br>
<br>
Au cas où certains se poseraient la question, notre main.cpp n'a pas changé. Allez, je vous le redonne. Je suis trop sympa je sais, ne me remerciez pas  <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="syntax"><pre><span class="c1">// main.cpp</span>
<span class="cp"> </span>
<span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include "MaFenetre.h"</span>
 
 
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
 
    <span class="n">MaFenetre</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
<h3>Ouvrir une boîte de dialogue avec une méthode statique</h3><br>
<br>
Bien, place à l'action maintenant !<br>
<br>
La classe QMessageBox permet de créer des objets de type QMessageBox (comme toute classe qui se respecte <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ) mais on utilise majoritairement ses méthodes statiques pour des raisons de simplicité. Nous commencerons donc par découvrir les méthodes statiques, qui se comportent je le rappelle comme de simples fonctions. Elles ne nécessiteront pas de créer d'objet.<br>
<br>
<br>
<h4>QMessageBox::information</h4><br>
<br>
La méthode statique <span class="courrier">information()</span> permet d'ouvrir une boîte de dialogue constituée d'une icône "information".<br>
Son prototype est le suivant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">StandardButton</span> <span class="n">information</span> <span class="p">(</span> <span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">title</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">text</span><span class="p">,</span> <span class="n">StandardButtons</span> <span class="n">buttons</span> <span class="o">=</span> <span class="n">Ok</span><span class="p">,</span> <span class="n">StandardButton</span> <span class="n">defaultButton</span> <span class="o">=</span> <span class="n">NoButton</span> <span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Seuls les 3 premiers paramètres sont obligatoires, les autres ayant comme vous le voyez une valeur par défaut.<br>
Ces 3 premiers paramètres sont :<br>
<br>
<ul>
<li><strong>parent </strong>: un pointeur vers la fenêtre parente (qui doit être de type QWidget ou hériter de QWidget). Vous pouvez envoyer NULL en paramètre si vous ne voulez pas que votre boîte de dialogue ait une fenêtre parente, mais ce sera plutôt rare.</li>
<li><strong>title </strong>: le titre de la boîte de dialogue (affiché en haut de la fenêtre).</li>
<li><strong>text </strong>: le texte affiché au sein de la boîte de dialogue.</li>
</ul><br>
<br>
Testons donc un code très simple. Voici le code du slot ouvrirDialogue() :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">MaFenetre</span><span class="o">::</span><span class="n">ouvrirDialogue</span><span class="p">()</span>
<span class="p">{</span>
<span class="ln-xtra">    <span class="n">QMessageBox</span><span class="o">::</span><span class="n">information</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Titre de la fenêtre"</span><span class="p">,</span> <span class="s">"Bonjour et bienvenue à tous les Zéros !"</span><span class="p">);</span></span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
L'appel de la méthode statique se fait donc comme celui d'une fonction classique, à la différence près qu'il faut mettre en préfixe le nom de la classe dans laquelle elle est définie (d'où le "<span class="courrier">QMessageBox::</span>" avant).<br>
<br>
Le résultat est une boîte de dialogue comme vous avez l'habitude d'en voir, constituée d'un bouton OK :<br>
<br>
<div class="centre"><img src="./cpp_files/104038.png" alt="Boîte de dialogue information"></div><br>
<br>
<div class="rmq information">Vous noterez que lorsque la boîte de dialogue est ouverte, on ne peut plus accéder à sa fenêtre parente qui est derrière. On dit que la boîte de dialogue est une <strong>fenêtre modale</strong> : c'est une fenêtre qui "bloque" temporairement son parent en attente d'une réponse de l'utilisateur.<br>
A l'inverse, on dit qu'une fenêtre est <strong>non modale</strong> quand on peut toujours accéder à la fenêtre derrière. C'est le cas en général des boîtes de dialogue "Rechercher un texte" dans les éditeurs de texte.</div><br>
<br>
<br>
Comble du raffinement (j'aime bien cette expression <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ), il est même possible de mettre en forme son message à l'aide de balises (X)HTML pour ceux qui connaissent. Si vous ne connaissez pas, il est toujours temps d'<a href="http://www.siteduzero.com/tuto-3-6-0-apprenez-a-creer-votre-site-web.html">apprendre le HTML</a>, j'ai fait un tuto il faut en profiter <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Exemple de boîte de dialogue "enrichie" avec du code HTML :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QMessageBox</span><span class="o">::</span><span class="n">information</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Titre de la fenêtre"</span><span class="p">,</span> <span class="s">"Bonjour et bienvenue à &lt;strong&gt;tous les Zéros !&lt;/strong&gt;"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/104039.png" alt="Boîte de dialogue information avec HTML"></div><br>
<br>
<br>
<h4>QMessageBox::warning</h4><br>
<br>
Si la boîte de dialogue "information" sert à informer l'utilisateur par un message, la boîte de dialogue warning le met en garde contre quelque chose. Elle est généralement accompagné d'un "ding" caractéristique.<br>
<br>
Elle s'utilise de la même manière que QMessageBox::information, mais cette fois l'icône change :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QMessageBox</span><span class="o">::</span><span class="n">warning</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Titre de la fenêtre"</span><span class="p">,</span> <span class="s">"Attention, vous êtes peut-être un Zéro !"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/104040.png" alt="Boîte de dialogue attention"></div><br>
<br>
<br>
<h4>QMessageBox::critical</h4><br>
<br>
Quand c'est trop tard et qu'une erreur s'est produite, il ne vous reste plus qu'à utiliser la méthode statique critical() :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QMessageBox</span><span class="o">::</span><span class="n">critical</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Titre de la fenêtre"</span><span class="p">,</span> <span class="s">"Vous n'êtes pas un Zéro, sortez d'ici ou j'appelle la police !"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/104041.png" alt="Boîte de dialogue erreur critique"></div><br>
<br>
<h4>QMessageBox::question</h4><br>
<br>
Si vous avez une question à poser à l'utilisateur, c'est la boîte de dialogue qu'il vous faut !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QMessageBox</span><span class="o">::</span><span class="n">question</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Titre de la fenêtre"</span><span class="p">,</span> <span class="s">"Dites voir, je me posais la question comme ça, êtes-vous vraiment un Zéro ?"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/104042.png" alt="Boîte de dialogue question"></div><br>
<br>
<div class="rmq question">C'est bien joli mais... comment peut-on répondre à la question avec un simple bouton OK ?</div><br>
<br>
Par défaut, c'est toujours un bouton OK qui s'affiche. Mais dans certains cas, comme lorsqu'on pose une question, il faudra afficher d'autres boutons pour que la boîte de dialogue ait du sens.<br>
<br>
<br>
<h3>Personnaliser les boutons de la boîte de dialogue</h3><br>
<br>
Pour personnaliser les boutons de la boîte de dialogue, il faut utiliser le 4ème paramètre de la méthode statique. Ce paramètre accepte une combinaison de valeurs prédéfinies, séparées par un OR (la barre verticale |). On appelle cela des <span class="italique">flags</span>.<br>
Si vous avez déjà travaillé avec la SDL, vous connaissez cela. Sinon, vous vous y habituerez vite vous verrez, c'est juste une façon pratique d'envoyer des options à une fonction.<br>
<br>
<div class="rmq information">Pour ceux qui se poseraient la question, le 5ème et dernier paramètre de la fonction permet d'indiquer quel est le bouton par défaut. On change rarement cette valeur car Qt choisit généralement le bouton qui convient le mieux par défaut.</div><br>
<br>
La <a href="http://doc.trolltech.com/qmessagebox.html#StandardButton-enum">liste des flags disponibles</a> est donnée par la documentation. Vous avez du choix comme vous pouvez le voir.<br>
Si on veut placer les boutons "Oui" et "Non", il nous suffit de combiner les valeurs "QMessageBox::Yes" et  "QMessageBox::No"<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QMessageBox</span><span class="o">::</span><span class="n">question</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Titre de la fenêtre"</span><span class="p">,</span> <span class="s">"Dites voir, je me posais la question comme ça, êtes-vous vraiment un Zéro ?"</span><span class="p">,</span> <span class="n">QMessageBox</span><span class="o">::</span><span class="n">Yes</span> <span class="o">|</span> <span class="n">QMessageBox</span><span class="o">::</span><span class="n">No</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les boutons apparaissent alors :<br>
<br>
<div class="centre"><img src="./cpp_files/104052.png" alt="Boîte de dialogue question en anglais"></div><br>
<br>
<br>
<div class="rmq question">Horreur ! Malédiction ! Enfer et damnation !<br>
L'anglais me poursuit, les boutons sont écrits en anglais. Catastrophe qu'est-ce que je vais faire au secouuuuuurs !!!</div><br>
<br>
En effet, les boutons sont écrits en anglais. Mais ce n'est pas grave du tout, les applications Qt peuvent être facilement traduites, je vous en avais parlé en introduction de cette partie.<br>
<br>
On ne va pas rentrer dans les détails du fonctionnement de la traduction, on aura l'occasion d'en reparler plus longuement plus tard. Je vais vous donner un code à placer dans le fichier main.cpp, et vous allez l'utiliser gentiment <span class="souligne">sans poser de questions</span>.<br>
Attention, j'ai dit : sans poser de question. On n'aime pas trop les gens qui posent des questions ici. Un accident est si vite arrivé... <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> <br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="syntax"><pre><span class="c1">// main.cpp</span>
<span class="cp"> </span>
<span class="cp">#include &lt;QApplication&gt;</span>
<span class="ln-xtra"><span class="cp">#include &lt;QTranslator&gt;</span></span>
<span class="ln-xtra"><span class="cp">#include &lt;QLocale&gt;</span></span>
<span class="ln-xtra"><span class="cp">#include &lt;QLibraryInfo&gt;</span></span>
<span class="cp">#include "MaFenetre.h"</span>
 
 
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
 
<span class="ln-xtra">    <span class="n">QString</span> <span class="n">locale</span> <span class="o">=</span> <span class="n">QLocale</span><span class="o">::</span><span class="n">system</span><span class="p">().</span><span class="n">name</span><span class="p">().</span><span class="n">section</span><span class="p">(</span><span class="sc">'_'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">QTranslator</span> <span class="n">translator</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">translator</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="s">"qt_"</span><span class="p">)</span> <span class="o">+</span> <span class="n">locale</span><span class="p">,</span> <span class="n">QLibraryInfo</span><span class="o">::</span><span class="n">location</span><span class="p">(</span><span class="n">QLibraryInfo</span><span class="o">::</span><span class="n">TranslationsPath</span><span class="p">));</span></span>
<span class="ln-xtra">    <span class="n">app</span><span class="p">.</span><span class="n">installTranslator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">translator</span><span class="p">);</span></span>
 
    <span class="n">MaFenetre</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les lignes ajoutées ont été surlignées. Il y a plusieurs includes et quelques lignes de code supplémentaires dans le main.<br>
Normalement, votre application devrait maintenant afficher des boutons en français :<br>
<br>
<div class="centre"><img src="./cpp_files/104051.png" alt="Boîte de dialogue question en français"></div><br>
<br>
Et voilà le travail ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<div class="rmq question">C'est cool, mais comment je fais pour savoir sur quel bouton l'utilisateur a cliqué ? Hein, hein ?</div><br>
Quoi ? Encore une question ?<br>
Vous savez, vous réduisez votre espérance de vie avec toutes les questions que vous posez aujourd'hui. Enfin moi j'dis ça comme ça <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
Bon ok, cette question est pertinente, je peux y répondre. Je dois y répondre même. Alors allons-y !<br>
<br>
<br>
<h3>Récupérer la valeur de retour de la boîte de dialogue</h3><br>
<br>
Les méthodes statiques que nous venons de voir retournent un entier (int). On peut tester facilement la signification de ce nombre à l'aide des valeurs prédéfinies par Qt (comme quoi les énumérations c'est pratique !).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">MaFenetre</span><span class="o">::</span><span class="n">ouvrirDialogue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">reponse</span> <span class="o">=</span> <span class="n">QMessageBox</span><span class="o">::</span><span class="n">question</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Interrogatoire"</span><span class="p">,</span> <span class="s">"Dites voir, je me posais la question comme ça, êtes-vous vraiment un Zéro ?"</span><span class="p">,</span> <span class="n">QMessageBox</span><span class="o">::</span><span class="n">Yes</span> <span class="o">|</span> <span class="n">QMessageBox</span><span class="o">::</span><span class="n">No</span><span class="p">);</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">reponse</span> <span class="o">==</span> <span class="n">QMessageBox</span><span class="o">::</span><span class="n">Yes</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">QMessageBox</span><span class="o">::</span><span class="n">information</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Interrogatoire"</span><span class="p">,</span> <span class="s">"Alors bienvenue chez les Zéros !"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">reponse</span> <span class="o">==</span> <span class="n">QMessageBox</span><span class="o">::</span><span class="n">No</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">QMessageBox</span><span class="o">::</span><span class="n">critical</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Interrogatoire"</span><span class="p">,</span> <span class="s">"Tricheur ! Menteur ! Voleur ! Ingrat ! Lâche ! Traître !</span><span class="se">\n</span><span class="s">Sors d'ici ou j'appelle la police !"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voici un schéma de ce qui peut se passer :<br>
<br>
<div class="centre"><img src="./cpp_files/104055.png" alt="Traitement du retour de la boîte de dialogue"></div><br>
<br>
C'est ma foi clair, non ? <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<div class="rmq information">Petite précision quand même : le type de retour exact de la méthode n'est pas int mais QMessageBox::StandardButton. Or, il s'agit là d'une énumération, et comme vous le savez probablement, une énumération n'est rien d'autre que le <span class="souligne">remplacement de nombres par des mots plus lisibles</span>. Utiliser un int revient donc strictement au même.<br>
Si un rappel sur les énumérations s'impose parce que je viens de vous parler en chinois, relisez donc le <a href="http://www.siteduzero.com/tuto-3-4350-1-creez-vos-propres-types-de-variables.html#ss_part_4">cours sur les énumérations</a> issu du tutoriel du langage C.</div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11280">Saisir une information</h2>
		<div class="ss_part_texte">
		Les boîtes de dialogues précédentes étaient un peu limitées car, à part présenter différents boutons, on ne pouvait pas trop interagir avec l'utilisateur.<br>
<br>
Si vous souhaitez que votre utilisateur saisisse une information, ou encore fasse un choix parmi une liste, les boîtes de dialogue de saisie sont idéales. Elles sont gérées par la classe <strong>QInputDialog</strong>, que je vous conseille d'inclure dès maintenant dans MaFenetre.h.<br>
<br>
Les boîtes de dialogue "saisir une information" peuvent être de 4 types. Nous allons les voir dans l'ordre :<br>
<br>
<ol class="liste_I">
<li>Saisir un texte</li>
<li>Saisir un entier</li>
<li>Saisir un nombre décimal (double)</li>
<li>Choisir un élément parmi une liste</li></ol><br>
Chacune de ces fonctionnalités est assurée par une méthode statique différente.<br>
<br>
<br>
<h3>Saisir un texte (QInputDialog::getText)</h3><br>
<br>
La méthode statique getText() ouvre une boîte de dialogue qui permet à l'utilisateur de saisir un texte.<br>
Son prototype est :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QString</span> <span class="n">QInputDialog</span><span class="o">::</span><span class="n">getText</span> <span class="p">(</span> <span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">title</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">label</span><span class="p">,</span> <span class="n">QLineEdit</span><span class="o">::</span><span class="n">EchoMode</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">QLineEdit</span><span class="o">::</span><span class="n">Normal</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">text</span> <span class="o">=</span> <span class="n">QString</span><span class="p">(),</span> <span class="kt">bool</span> <span class="o">*</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">WindowFlags</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous pouvez tout d'abord constater que la méthode retourne un QString, c'est-à-dire une chaîne de caractères de Qt.<br>
Les paramètres signifient, dans l'ordre :<br>
<br>
<ul>
<li><strong>parent </strong>: pointeur vers la fenêtre parente. Peut être mis à NULL pour ne pas indiquer de fenêtre parente.</li>
<li><strong>title </strong>: titre de la fenêtre affiché en haut.</li>
<li><strong>label </strong>: texte affiché dans la fenêtre.</li>
<li><strong>mode </strong>: mode d'édition du texte. Permet de dire si on veut que les lettres s'affichent quand on tape, ou si elles doivent être remplacées par des astérisques (pour les mots de passe) ou si aucune lettre ne doit s'afficher. Toutes les options sont dans <a href="http://doc.trolltech.com/qlineedit.html#EchoMode-enum">la doc</a>. Par défaut, les lettres s'affichent normalement (QLineEdit::Normal).</li>
<li><strong>text </strong>: le texte par défaut dans la zone de saisie.</li>
<li><strong>ok </strong>: un pointeur vers un booléen pour que Qt puisse vous dire si l'utilisateur a cliqué sur OK ou sur Annuler.</li>
<li><strong>f</strong> = quelques flags (options) permettant d'indiquer si la fenêtre est modale (bloquante) ou pas. Les valeurs possibles sont détaillées par <a href="http://doc.trolltech.com/qt.html#WindowType-enum">la doc</a>.</li>
</ul><br>
Heureusement, comme vous pouvez le constater en lisant le prototype, certains paramètres possèdent des valeurs par défaut ce qui fait qu'ils ne sont pas obligatoires.<br>
<br>
Reprenons notre code de tout à l'heure et cette fois, au lieu d'afficher une QMessageBox, nous allons afficher une QInputDialog lorsqu'on clique sur le bouton de la fenêtre.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">MaFenetre</span><span class="o">::</span><span class="n">ouvrirDialogue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QString</span> <span class="n">pseudo</span> <span class="o">=</span> <span class="n">QInputDialog</span><span class="o">::</span><span class="n">getText</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Pseudo"</span><span class="p">,</span> <span class="s">"Quel est votre pseudo ?"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
En une ligne, je crée un QString et je lui affecte directement la valeur retournée par la méthode getText(). J'aurais aussi bien pu faire la même chose en deux lignes, mais ç'aurait été plus long et je suis une feignasse <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
La boîte de dialogue devrait ressembler à cela :<br>
<br>
<div class="centre"><img src="./cpp_files/104067.png" alt="Saisie de texte"></div><br>
<br>
On peut aller plus loin et vérifier si le bouton OK a été actionné, et si c'est le cas on peut alors afficher le pseudo de l'utilisateur dans une QMessageBox.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">MaFenetre</span><span class="o">::</span><span class="n">ouvrirDialogue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="n">QString</span> <span class="n">pseudo</span> <span class="o">=</span> <span class="n">QInputDialog</span><span class="o">::</span><span class="n">getText</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Pseudo"</span><span class="p">,</span> <span class="s">"Quel est votre pseudo ?"</span><span class="p">,</span> <span class="n">QLineEdit</span><span class="o">::</span><span class="n">Normal</span><span class="p">,</span> <span class="n">QString</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">);</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">ok</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pseudo</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">QMessageBox</span><span class="o">::</span><span class="n">information</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Pseudo"</span><span class="p">,</span> <span class="s">"Bonjour "</span> <span class="o">+</span> <span class="n">pseudo</span> <span class="o">+</span> <span class="s">", ça va ?"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">QMessageBox</span><span class="o">::</span><span class="n">critical</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Pseudo"</span><span class="p">,</span> <span class="s">"Vous n'avez pas voulu donner votre nom... snif."</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ici, on crée un booléen qui va recevoir l'information "<span class="italique">Le bouton OK a-t-il été cliqué ?</span>".<br>
<br>
Pour pouvoir l'utiliser dans la méthode getText, il faut donner tous les paramètres avant qu'on ne souhaite pourtant pas changer ! C'est un des défauts des paramètres par défaut en C++ : si le paramètre que vous voulez renseigner est tout à la fin (à droite), il faudra alors absolument renseigner tous les paramètres qui sont avant !<br>
J'ai donc envoyé des valeurs par défaut aux paramètres qui étaient avant, à savoir <strong>mode </strong>et <strong>text</strong>.<br>
<br>
Comme j'ai donné un pointeur vers mon booléen à la méthode, celle-ci va le remplir pour indiquer si oui ou non le bouton a été cliqué.<br>
<br>
Je peux ensuite faire un test, d'où la présence de mon if. Je vérifie 2 choses :<br>
<br>
<ul>
<li>Si le bouton OK a été cliqué</li>
<li>Et si le texte n'est pas vide (la méthode isEmpty de QString sert à faire ça, vous ne pouviez pas la connaître, sauf en lisant la <a href="http://doc.trolltech.com/qstring.html">doc de QString</a> bien sûr <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ).</li>
</ul><br>
Si un pseudo a été entré et que l'utilisateur a cliqué sur OK, alors une boîte de dialogue lui souhaite la bienvenue. Sinon, une erreur est affichée.<br>
<br>
Ce schéma présente ce qui peut se produire :<br>
<br>
<div class="centre"><img src="./cpp_files/104070.png" alt="Schéma des possibilités de réaction du programme getText"></div><br>
<br>
<strong>Exercice</strong> : essayez d'afficher le pseudo de l'utilisateur quelque part sur la fenêtre mère, par exemple sur le bouton.<br>
<br>
<br>
<h3>Saisir un entier (QInputDialog::getInteger)</h3><br>
<br>
La méthode getInteger devrait vous paraître simple maintenant que vous connaissez getText. Son prototype est :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">QInputDialog</span><span class="o">::</span><span class="n">getInteger</span> <span class="p">(</span> <span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">title</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">label</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minValue</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2147483647</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxValue</span> <span class="o">=</span> <span class="mi">2147483647</span><span class="p">,</span> <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">WindowFlags</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Elle retourne un int comme prévu.<br>
Vous noterez les paramètres value (valeur par défaut), minValue (valeur minimale autorisée), maxValue (valeur maximale autorisée) et step, le pas d'incrémentation lorsqu'on clique sur les petites flèches (vous allez voir).<br>
<br>
Testons ça avec les paramètres obligatoires, ça sera suffisant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">entier</span> <span class="o">=</span> <span class="n">QInputDialog</span><span class="o">::</span><span class="n">getInteger</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Nombre"</span><span class="p">,</span> <span class="s">"Entrez un nombre entier"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/104072.png" alt="Saisie de nombre entier"></div><br>
<br>
Les petites flèches à droite permettent à l'utilisateur d'incrémenter (ou de décrémenter) le nombre affiché. Le rôle du paramètre step est d'indiquer la valeur du pas d'incrémentation. Par défaut il est de 1.<br>
Par exemple si je clique sur la flèche vers le haut alors que le nombre saisi est 12 et que j'ai mis un pas d'incrémentation de 10, le nombre deviendra 22.<br>
<br>
Le nombre saisi est retourné par la méthode dans un entier, à vous de le traiter pour faire ce que bon vous semblera avec <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Saisir un nombre décimal (QInputDialog::getDouble)</h3><br>
<br>
La saisie d'un double est pratiquement identique à celle d'un entier, à la différence près qu'il y a un paramètre qui permet d'indiquer le nombre maximal de chiffres après la virgule autorisés (paramètre <span class="italique">decimals</span>).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">double</span> <span class="n">QInputDialog</span><span class="o">::</span><span class="n">getDouble</span> <span class="p">(</span> <span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">title</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">label</span><span class="p">,</span> <span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">double</span> <span class="n">minValue</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2147483647</span><span class="p">,</span> <span class="kt">double</span> <span class="n">maxValue</span> <span class="o">=</span> <span class="mi">2147483647</span><span class="p">,</span> <span class="kt">int</span> <span class="n">decimals</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">WindowFlags</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Petit test :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="kt">double</span> <span class="n">nombreDecimal</span> <span class="o">=</span> <span class="n">QInputDialog</span><span class="o">::</span><span class="n">getDouble</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Nombre"</span><span class="p">,</span> <span class="s">"Entrez un nombre décimal"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/104071.png" alt="Saisie de nombre décimal"></div><br>
<br>
<br>
<h3>Choix d'un élément parmi une liste (QInputDialog::getItem)</h3><br>
<br>
<br>
Si l'utilisateur doit faire son choix dans une liste, cette méthode permet d'afficher les choix possibles dans une boîte de dialogue avec un menu déroulant.<br>
<br>
Son prototype est :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QString</span> <span class="n">QInputDialog</span><span class="o">::</span><span class="n">getItem</span> <span class="p">(</span> <span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">title</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">label</span><span class="p">,</span> <span class="k">const</span> <span class="n">QStringList</span> <span class="o">&amp;</span> <span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">editable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">WindowFlags</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Il y a quelques nouveaux paramètres que je dois expliquer :<br>
<br>
<ul>
<li><strong>list </strong>: la liste des choix possibles, envoyée via un objet de type QStringList (liste de chaînes) à construire au préalable.</li>
<li><strong>current </strong>: le numéro du choix qui doit être sélectionné par défaut.</li>
<li><strong>editable </strong>: un booléen qui indique si l'utilisateur a le droit d'entrer sa propre réponse (comme avec getText) ou s'il est obligé de faire un choix parmi la liste.</li>
</ul><br>
Toute la "difficulté", vous l'aurez compris, consiste à créer cette liste de choix. La doc nous dit qu'il faut envoyer un objet de type QStringList, allons donc voir la <a href="http://doc.trolltech.com/qstringlist.html">doc de QStringList</a> !<br>
<br>
Hmm...<br>
Hmm hmm...<br>
<br>
Intéressant. Bon le constructeur ne permet pas d'envoyer un nombre infini de chaînes à la liste, par contre on peut voir dans la doc que l'opérateur &lt;&lt; est surchargé. Cela va nous permettre de "remplir" notre liste de chaînes très facilement !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">MaFenetre</span><span class="o">::</span><span class="n">ouvrirDialogue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QStringList</span> <span class="n">pays</span><span class="p">;</span>
    <span class="n">pays</span> <span class="o">&lt;&lt;</span> <span class="s">"France"</span> <span class="o">&lt;&lt;</span> <span class="s">"Belgique"</span> <span class="o">&lt;&lt;</span> <span class="s">"Suisse"</span> <span class="o">&lt;&lt;</span> <span class="s">"Canada (québec)"</span> <span class="o">&lt;&lt;</span> <span class="s">"Maroc"</span> <span class="o">&lt;&lt;</span> <span class="s">"Autre"</span><span class="p">;</span>
    <span class="n">QInputDialog</span><span class="o">::</span><span class="n">getItem</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Votre pays"</span><span class="p">,</span> <span class="s">"De quel pays es-tu, cher Zéro ?"</span><span class="p">,</span> <span class="n">pays</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq attention">Pensez à inclure le header de la classe QStringList avant de vous en servir, sinon le compilateur vous dira que la classe QStringList est indéfinie !</div><br>
<br>
<div class="centre"><img src="./cpp_files/104090.png" alt="Choix parmi une liste"></div><br>
<br>
Et voilà, obstacle surmonté avec succès <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<div class="rmq information">Si, pour une raison ou une autre, vous ne souhaitez pas utiliser l'opérateur surchargé &lt;&lt;, il existe des méthodes qui permettent d'ajouter des éléments un à un. Ces méthodes ne sont pas dans la classe <a href="http://doc.trolltech.com/qstringlist.html">QStringList</a>, mais dans sa classe mère <a href="http://doc.trolltech.com/qlist.html">QList</a>. On peut par exemple citer <span class="courrier">append()</span> qui permet d'ajouter un élément à la fin de la liste.<br>
Je dis ça pour vous rappeler de <span class="souligne">toujours regarder les méthodes de la classe mère</span> si ce que vous cherchez n'est pas dans la liste des méthodes propres à votre classe.</div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11279">Sélectionner une police</h2>
		<div class="ss_part_texte">
		La boîte de dialogue "Sélectionner une police" est une des boîtes de dialogue standard les plus connues. Nul doute que vous l'avez déjà rencontrée dans l'un de vos programmes favoris.<br>
<br>
<div class="centre"><img src="./cpp_files/104201.png" alt="Fenêtre sélection de police"></div><br>
<br>
La boîte de dialogue de sélection de police est gérée par la classe <strong>QFontDialog</strong>. Celle-ci propose en gros une seule méthode statique surchargée (il y a plusieurs façons de l'utiliser), comme vous pouvez le constater sur la <a href="http://doc.trolltech.com/qfontdialog.html#static-public-members">doc de QFontDialog</a>.<br>
<br>
Prenons le prototype le plus compliqué, juste pour la forme <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QFont</span> <span class="n">getFont</span> <span class="p">(</span> <span class="kt">bool</span> <span class="o">*</span> <span class="n">ok</span><span class="p">,</span> <span class="k">const</span> <span class="n">QFont</span> <span class="o">&amp;</span> <span class="n">initial</span><span class="p">,</span> <span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">caption</span> <span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les paramètres se comprennent normalement assez facilement.<br>
<br>
On retrouve notre pointeur vers un booléen "ok" qui permet de savoir si l'utilisateur a cliqué sur OK ou a annulé.<br>
On peut spécifier une police par défaut (initial), il faudra envoyer un objet de type QFont. Voilà justement que la classe QFont réapparaît <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Enfin, la chaîne caption correspond au message qui sera affiché en haut de la fenêtre.<br>
<br>
Enfin, et surtout, la méthode retourne un objet de type QFont correspondant à la police qui a été choisie.<br>
<br>
Testons ! Histoire d'aller un peu plus loin, je propose que la police que nous aurons sélectionnée soit immédiatement appliquée au texte de notre bouton, par l'intermédiaire de la méthode setFont() que nous avons appris à utiliser il y a quelques chapitres.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">MaFenetre</span><span class="o">::</span><span class="n">ouvrirDialogue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
 
    <span class="n">QFont</span> <span class="n">police</span> <span class="o">=</span> <span class="n">QFontDialog</span><span class="o">::</span><span class="n">getFont</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ok</span><span class="p">,</span> <span class="n">m_boutonDialogue</span><span class="o">-&gt;</span><span class="n">font</span><span class="p">(),</span> <span class="k">this</span><span class="p">,</span> <span class="s">"Choisissez une police"</span><span class="p">);</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="n">ok</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_boutonDialogue</span><span class="o">-&gt;</span><span class="n">setFont</span><span class="p">(</span><span class="n">police</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La méthode getFont prend comme police par défaut celle qui est utilisée par notre bouton m_boutonDialogue (rappelez-vous, font() est une méthode accesseur qui renvoie un QFont).<br>
On teste si l'utilisateur a bien validé la fenêtre, et si c'est le cas on applique la police qui vient d'être choisie à notre bouton.<br>
<br>
C'est l'avantage de travailler avec les classes de Qt : elles sont cohérentes. La méthode getFont renvoie un QFont, et ce QFont nous pouvons l'envoyer à notre tour à notre bouton pour qu'il change d'apparence.<br>
<br>
Le résultat ? Le voici :<br>
<br>
<div class="centre"><img src="./cpp_files/104107.png" alt="Choix de police"></div><br>
<br>
Attention le bouton ne se redimensionne pas tout seul. Vous pouvez le rendre plus large de base si vous voulez, ou bien le redimensionner après le choix de la police.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11278">Sélectionner une couleur</h2>
		<div class="ss_part_texte">
		Dans la même veine que la sélection de police, on connaît probablement tous la boîte de dialogue "Sélection de couleur".<br>
<br>
<div class="centre"><img src="./cpp_files/104200.png" alt="Fenêtre sélection de couleur"></div><br>
<br>
Utilisez la classe <strong>QColorDialog </strong>et sa méthode statique <span class="courrier">getColor()</span>.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QColor</span> <span class="n">QColorDialog</span><span class="o">::</span><span class="n">getColor</span> <span class="p">(</span> <span class="k">const</span> <span class="n">QColor</span> <span class="o">&amp;</span> <span class="n">initial</span> <span class="o">=</span> <span class="n">Qt</span><span class="o">::</span><span class="n">white</span><span class="p">,</span> <span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Elle retourne un objet de type QColor. Vous pouvez préciser une couleur par défaut, en envoyant un objet de type QColor ou en utilisant une des <a href="http://doc.trolltech.com/qt.html#GlobalColor-enum">constantes prédéfinies de couleur</a>. En l'absence de paramètre, c'est la couleur blanche qui sera sélectionnée comme nous l'indique le prototype.<br>
<br>
Si on veut tester le résultat en appliquant la nouvelle couleur au bouton, c'est un petit peu compliqué. En effet, il n'existe pas de méthode setColor pour les widgets, mais une méthode setPalette qui sert à indiquer une palette de couleurs. Je vous laisse vous renseigner plus amplement si vous le désirez sur la <a href="http://doc.trolltech.com/qpalette.html">classe QPalette</a> qui est intéressante.<br>
<br>
Le code que je vous propose ci-dessous ouvre une boîte de dialogue de sélection de couleur, puis crée une palette dont la couleur du texte correspond à la couleur qu'on vient de sélectionner, et applique enfin cette palette au bouton :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">MaFenetre</span><span class="o">::</span><span class="n">ouvrirDialogue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QColor</span> <span class="n">couleur</span> <span class="o">=</span> <span class="n">QColorDialog</span><span class="o">::</span><span class="n">getColor</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">white</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
 
    <span class="n">QPalette</span> <span class="n">palette</span><span class="p">;</span>
    <span class="n">palette</span><span class="p">.</span><span class="n">setColor</span><span class="p">(</span><span class="n">QPalette</span><span class="o">::</span><span class="n">ButtonText</span><span class="p">,</span> <span class="n">couleur</span><span class="p">);</span>
    <span class="n">m_boutonDialogue</span><span class="o">-&gt;</span><span class="n">setPalette</span><span class="p">(</span><span class="n">palette</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je ne vous demande pas ici de comprendre comment fonctionne QPalette, qui est d'ailleurs une classe que je ne détaillerai pas plus dans le cours. A vous de vous renseigner sur elle si elle vous intéresse.<br>
<br>
Le résultat de l'application est le suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/104199.png" alt="Sélectionner une couleur"></div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11277">Sélection d'un fichier ou d'un dossier</h2>
		<div class="ss_part_texte">
		Allez, plus que la sélection de fichiers et de dossiers et on aura fait le tour d'à peu près toutes les boîtes de dialogue usuelles qui existent ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
La sélection de fichiers et de dossiers est gérée par la <a href="http://doc.trolltech.com/qfiledialog.html">classe QFileDialog</a> qui propose elle aussi des méthodes statiques faciles à utiliser.<br>
<br>
Cette section sera divisée en 3 parties :<br>
<br>
<ul>
<li>Sélection d'un dossier existant</li>
<li>Ouverture d'un fichier</li>
<li>Enregistrement d'un fichier</li>
</ul><br>
<h3>Sélection d'un dossier existant (QFileDialog::getExistingDirectory)</h3><br>
<br>
Bon je ne vous donne plus le prototype, vous devriez être assez grands pour le retrouver dans la doc <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
On peut utiliser la méthode statique aussi simplement que comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QString</span> <span class="n">dossier</span> <span class="o">=</span> <span class="n">QFileDialog</span><span class="o">::</span><span class="n">getExistingDirectory</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Elle retourne un QString contenant le chemin complet vers le dossier demandé.<br>
La fenêtre qui s'ouvre devrait ressembler à cela :<br>
<br>
<div class="centre"><img src="./cpp_files/104212.png" alt="Sélectionner un dossier"></div><br>
<br>
<br>
<h3>Ouverture d'un fichier (QFileDialog::getOpenFileName)</h3><br>
<br>
La célèbre boîte de dialogue "Ouverture d'un fichier" est gérée par getOpenFileName().<br>
Sans paramètres particuliers, la boîte de dialogue permet d'ouvrir n'importe quel fichier.<br>
<br>
Vous pouvez néanmoins créer un filtre (4ème paramètre) pour afficher par exemple uniquement les images.<br>
<br>
Ce code demande d'ouvrir un fichier image. Le chemin vers le fichier est stocké dans un QString, que l'on affiche ensuite via une QMessageBox :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">MaFenetre</span><span class="o">::</span><span class="n">ouvrirDialogue</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QString</span> <span class="n">fichier</span> <span class="o">=</span> <span class="n">QFileDialog</span><span class="o">::</span><span class="n">getOpenFileName</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Ouvrir un fichier"</span><span class="p">,</span> <span class="n">QString</span><span class="p">(),</span> <span class="s">"Images (*.png *.gif *.jpg *.jpeg)"</span><span class="p">);</span>
    <span class="n">QMessageBox</span><span class="o">::</span><span class="n">information</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Fichier"</span><span class="p">,</span> <span class="s">"Vous avez sélectionné :</span><span class="se">\n</span><span class="s">"</span> <span class="o">+</span> <span class="n">fichier</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le troisième paramètre de getOpenFileName est le nom du répertoire par défaut dans lequel l'utilisateur est placé. J'ai laissé la valeur par défaut (QString(), ce qui est équivalent à écrire ""), donc la boîte de dialogue affichera par défaut le répertoire dans lequel est situé le programme.<br>
<br>
Grâce au 4ème paramètre j'ai choisi de filtrer les fichiers. Seules les images de type PNG, GIF, JPG et JPEG s'afficheront.<br>
<br>
Résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/104233.png" alt="Ouvrir un fichier"></div><br>
<br>
La fenêtre bénéficie de toutes les options que propose votre OS, dont l'affichage des images sous forme de miniatures.<br>
Lorsque vous cliquez sur "Ouvrir", le chemin est enregistré dans un QString qui s'affiche ensuite dans une boîte de dialogue :<br>
<br>
<div class="centre"><img src="./cpp_files/104234.png" alt="Le fichier sélectionné"></div><br>
<br>
<div class="rmq information">Le principe de cette boîte de dialogue est de vous donner le chemin complet vers le fichier, <span class="souligne">mais pas de vous ouvrir ce fichier</span>. C'est à vous ensuite de faire les opérations nécessaires pour ouvrir le fichier et l'afficher dans votre programme.</div><br>
<br>
A noter aussi la fonction getOpenFileNames (notez le "s" à la fin) qui autorise la sélection de plusieurs fichiers. La principale différence est qu'au lieu de retourner un QString, elle retourne un QStringList (liste de chaînes). Tiens, comme on se retrouve !<br>
<br>
<br>
<h3>Enregistrement d'un fichier (QFileDialog::getSaveFileName)</h3><br>
<br>
C'est le même principe que la méthode précédente, à la différence près que la personne peut cette fois spécifier un nom de fichier qui n'existe pas pour l'enregistrement. Le bouton "Ouvrir" est remplacé par "Enregistrer".<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QString</span> <span class="n">fichier</span> <span class="o">=</span> <span class="n">QFileDialog</span><span class="o">::</span><span class="n">getSaveFileName</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Enregistrer un fichier"</span><span class="p">,</span> <span class="n">QString</span><span class="p">(),</span> <span class="s">"Images (*.png *.gif *.jpg *.jpeg)"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/104237.png" alt="Enregistrer un fichier"></div>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Je vous avais promis un chapitre simple, vous avez eu un chapitre simple !<br>
<br>
En effet, les méthodes statiques ne sont rien d'autre que des "fonctions" comme en langage C, elles ne nécessitent donc pas de créer d'objets. Comme quoi, parfois le modèle objet est inadapté et ici c'était clairement le cas. Pour la plupart des classes que nous avons vues, on peut s'en sortir sans créer le moindre objet.<br>
<br>
Ces considérations mises à part, le modèle objet reste quoiqu'il en soit très pratique lorsqu'on crée des GUI comme on le fait là. Et je peux vous dire qu'on n'a pas fini de tout découvrir <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
A titre informatif, il existe quelques autres boîtes de dialogue usuelles un peu plus rares et surtout un peu plus complexes à utiliser. Je pense notamment à :<br>
<br>
<ul>
<li><strong>QProgressDialog</strong> : affiche une boîte de dialogue avec une barre de progression et un bouton "Annuler". Cela permet de faire patienter l'utilisateur le temps qu'une longue opération s'exécute. Cette classe est très intéressante mais il vaut mieux qu'on la voie en pratique si on a l'occasion, car Qt cherche à estimer le temps restant pour savoir s'il doit afficher ou non la fenêtre. C'est plus intéressant de le voir dans un cas très concret donc.</li>
<li><strong>QWizard</strong> : affiche un assistant, avec les boutons "Suivant", "Précédent", "Terminer"... Là encore il vaut mieux avoir un projet concret pour apprendre à utiliser cette classe car elle est assez complexe.</li>
</ul><br>
Ceci étant, vous pouvez aussi lire la documentation si vous en avez besoin maintenant, il y a tout ce qu'il faut dessus.<br>
<br>
<div class="rmq question">Mais... mais... je sais pas lire une doc moi, je sais pas où chercher l'information dont j'ai besoin, je suis perdu j'y comprends rien <img src="./cpp_files/triste.png" alt=":(" class="smilies"></div><br>
Ah ouais ? C'est ce qu'on va voir !<br>
On vous a pas encore fait de tuto pour vous apprendre à lire une doc à ce que je sache ? Alors c'est le moment d'apprendre !
	</div>
	
	<hr>
	<h1 id="chap_11290">Apprendre à lire la documentation de Qt</h1>
	<div id="chap_intro">
	Voilà le chapitre le plus important de toute la partie sur Qt : celui qui va vous apprendre à <strong>lire la documentation de Qt</strong>.<br>
<br>
<div class="rmq question">Pourquoi est-ce que c'est si important de savoir lire la documentation ?</div><br>
<br>
Parce que la documentation, c'est la bible du programmeur. Elle explique toutes les possibilités d'un langage ou d'une bibliothèque.<br>
La documentation de Qt contient la liste des fonctionnalités de Qt. <span class="souligne">Toute</span> la liste.<br>
<br>
La documentation, c'est donc ce qu'il y a de plus complet mais... ça n'a rien à voir avec un tutoriel du Site du Zéro.<br>
<br>
Déjà, il faudra vous y faire : la doc n'est disponible qu'en anglais (c'est valable pour Qt et pour la quasi-totalité des autres docs). Il faudra donc faire l'effort de lire de l'anglais, même si vous y êtes allergiques. En programmation, on peut rarement s'en sortir si on ne lit pas un minimum d'anglais technique.<br>
<br>
D'autre part, la documentation est construite de manière assez déroutante quand on débute. Il faut être capable de "lire" et naviguer dans une documentation.<br>
C'est précisément ce que ce chapitre va vous apprendre à faire <img src="./cpp_files/smile.png" alt=":)" class="smilies">
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11289">Où trouver la doc ?</h2>
		<div class="ss_part_texte">
		On vous dit que Qt propose une superbe documentation très complète qui vous explique tout son fonctionnement.<br>
Oui, mais où peut-on trouver cette documentation au juste ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"><br>
<br>
Il y a en fait 2 moyens d'accéder à la doc :<br>
<br>
<ul>
<li>si vous avez internet : vous pouvez aller sur le <strong>site de Trolltech</strong> (l'entreprise qui édite Qt) ;</li>
<li>si vous n'avez pas internet : vous pouvez utiliser le programme <strong>Qt Assistant</strong> qui contient toute la doc.</li>
</ul><br>
<br>
<h3>Avec internet : sur le site de Trolltech</h3><br>
<br>
Personnellement, si j'ai accès à internet, j'ai tendance à préférer utiliser cette méthode pour lire la documentation. Il suffit d'aller sur le site web de Trolltech, section documentation. L'adresse est simple à retenir :<br>
<br>
<div class="centre"><span class="gros"><a href="http://doc.trolltech.com/">http://doc.trolltech.com</a></span></div><br>
<br>
<div class="rmq information">Je vous conseille très fortement d'ajouter ce site dans vos <strong>favoris</strong>, et de faire en sorte qu'il soit visible !<br>
Si vous ne faites pas un raccourci visible vers la doc, vous serez moins tentés d'y aller... or le but c'est justement que vous preniez le réflexe d'y aller <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
Un des principaux avantages à aller chercher la doc sur internet, c'est que l'on est assuré d'avoir la doc la plus à jour. En effet, s'il y a des nouveautés ou des erreurs, on est certain en allant sur le net d'en avoir la dernière version.<br>
<br>
Lorsque vous arrivez sur la doc, la page suivante s'affiche :<br>
<br>
<div class="centre"><a href="http://doc.trolltech.com/"><img src="./cpp_files/111573.png" alt="Versions de Qt"></a></div><br>
<br>
C'est la liste des produits de Trolltech. Dans le lot on trouve Qt bien évidemment, mais aussi Qtopia, une version "light" de Qt pour les appareils mobiles, Qt Jambi, une version de Qt pour le langage Java, etc.<br>
<br>
Nous nous intéressons au premier cadre en haut à gauche intitulé Qt.<br>
Vous pouvez voir la liste des différentes versions de Qt, depuis Qt 2.3.<br>
<br>
Sélectionnez la version de Qt qui correspond à celle que vous avez installée. Vous pouvez retrouver le numéro de votre version dans le raccourci du menu Démarrer par exemple.<br>
Dans mon cas, j'ai la version 4.3.2, je vais donc ouvrir Qt 4.3 (la version 4.3.2 n'est en général qu'une correction de bugs de la 4.3, c'est un sous-numéro de version).<br>
<br>
Voici la page qui devrait s'afficher maintenant :<br>
<br>
<div class="centre"><img src="./cpp_files/111576.png" alt="Accueil de la doc Qt"></div><br>
<br>
C'est l'accueil de la doc pour votre version de Qt.<br>
<br>
<div class="rmq information">Si vous le voulez, vous pouvez mettre directement cette page en favoris, car tant que vous n'installez pas une nouvelle version de Qt sur votre PC, il est inutile d'aller lire les docs des autres versions.</div><br>
<br>
Nous allons détailler les différentes sections de cette page.<br>
Mais avant... voyons voir comment accéder à la doc quand on n'a pas internet !<br>
<br>
<h3>Sans internet : avec Qt Assistant</h3><br>
<br>
Si vous n'avez pas internet, pas de panique !<br>
Qt a installé toute la documentation sur votre disque dur. Vous pouvez y accéder grâce au programme "Assistant" que vous retrouverez par exemple dans le menu Démarrer :<br>
<br>
<div class="centre"><img src="./cpp_files/111568.png" alt="Ouvrir Qt Assistant"></div><br>
<br>
Qt Assistant se présente sous la forme d'un mini-navigateur qui contient la documentation de Qt :<br>
<br>
<div class="centre"><img src="./cpp_files/111566.png" alt="Qt Assistant"></div><br>
<br>
<div class="rmq information">Vous ne disposez que de la documentation de Qt correspondant à la version que vous avez installée (c'est logique dans un sens). Si vous voulez lire la documentation d'anciennes versions de Qt (ou de futures versions en cours de développement) il faut obligatoirement aller sur internet.</div><br>
<br>
Le logiciel Qt Assistant vous permet d'ouvrir plusieurs onglets différents en cliquant sur le bouton "+".<br>
Vous pouvez aussi effectuer une recherche grâce au menu à gauche de l'écran et rajouter des pages en favoris.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11288">Les différentes sections de la doc</h2>
		<div class="ss_part_texte">
		Lorsque vous arrivez à l'accueil de la doc, la page suivante s'affiche comme nous l'avons vu :<br>
<br>
<div class="centre"><img src="./cpp_files/111576.png" alt="Accueil de la doc Qt"></div><br>
<br>
C'est le sommaire de la doc. Il est découpé en plusieurs sections (une par cadre). Que signifient-elles ?<br>
Analysons-les une à une...<br>
<br>
<h3>Getting Started</h3><br>
<br>
Getting Started contient des informations vous permettant de débuter avec Qt. C'est là-dedans que tout débutant devrait commencer par jeter un oeil. On trouve dans cette section :<br>
<br>
<ul>
<li><strong>What's new in Qt 4.x</strong> : qu'est-ce qu'il y a de nouveau dans votre version de Qt par rapport aux précédentes ? Cette page intéressera surtout ceux qui connaissent Qt depuis quelques temps et qui sont curieux de voir ce qui a été ajouté depuis les versions précédentes. Je vous conseille d'y jeter un oeil, c'est plutôt bien illustré et clair et ça vous donne une idée des fonctionnalités sur lesquelles Trolltech travaille.</li>
<li><strong>How to Learn Qt</strong> : comment apprendre Qt ? Cette page vous donnera une série de conseils pour apprendre Qt dans les meilleures conditions. On vous conseillera notamment de suivre un tutoriel (ils ne parlent pas des tutoriels du SdZ hélas <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ).</li>
<li><strong>Installation</strong> : comment installer Qt. A ce stade du cours vous devriez déjà l'avoir fait, donc ça ne devrait pas vous avoir posé de problème.</li>
<li><strong>Tutorial and Examples</strong> : le tutoriel officiel de Qt et une série de programmes d'exemple avec leur code source. C'est une section <span class="souligne">TRES intéressante</span>, je vous recommande d'y jeter un oeil. J'ai moi-même débuté avec Qt grâce à leur tutoriel qui est bien fait. Ce tutoriel permet en revanche seulement de démarrer et n'ira pas autant dans le détail que le tutoriel du Site du Zéro. Lorsque vous serez un peu plus expérimentés, je vous recommande de regarder les programmes d'exemple aussi, à partir d'un moment on apprend beaucoup mieux en lisant le code source des programmes <img src="./cpp_files/smile.png" alt=":)" class="smilies"></li>
<li><strong>Porting from Qt 3 and Qt 4</strong> : quels sont les changements majeurs entre Qt 3 et Qt 4 ? Il s'agit de 2 "grandes" versions de Qt très différentes. Cette section n'est destinée qu'aux anciens développeurs qui utilisaient Qt 3 et qui veulent passer à Qt 4. A priori, elle ne vous concerne donc absolument pas. Allez zou, on passe !</li>
</ul><br>
<br>
<h3>General</h3><br>
<br>
Ici, on trouvera des informations très générales relatives à Qt et Trolltech. Ce sont des pages "à propos" qui ne devraient pas vraiment vous intéresser.<br>
<br>
Notez qu'on vous informe de la différence entre la version commerciale de Qt et la version open-source. Pour résumer simplement : seule la version open-source est gratuite, mais elle implique que vous publiiez le code source de votre programme si vous le distribuez au public.<br>
<br>
Jetez un oeil aussi à la FAQ (Frequently Asked Questions, les questions fréquemment posées), vous seriez surpris du nombre de petites choses que l'on peut apprendre sur ce genre de pages.<br>
<br>
<br>
<h3>Developer Resources</h3><br>
<br>
Cette section un peu technique indique aux développeurs comment participer à Qt (en rapportant des bugs) et propose des articles et des forums pour ceux qui veulent aller plus loin. C'est encore un peu tôt pour vous, nous n'irons pas dans le détail de cette section.<br>
<br>
<br>
<h3>API Reference</h3><br>
<br>
Contient la liste des classes de Qt. C'est probablement LA section la plus importante. C'est en passant par là que vous pourrez savoir tout ce que vous voulez sur une classe précise.<br>
<br>
C'est en général à ça que sert la doc. Vous connaissez la classe que vous voulez utiliser, mais vous ne savez pas vous en servir complètement. Vous lisez donc son mode d'emploi.<br>
<br>
<div class="rmq question">C'est bien beau tout ça, mais si je ne connais pas le nom de la classe que je veux utiliser ? Si je sais par exemple que je veux créer un menu dans ma fenêtre, comment je fais pour retrouver le nom de la classe qui correspond ?</div><br>
<br>
C'est la question que l'on se pose le plus souvent quand on débute. Ce n'est pas toujours facile de retrouver la classe que l'on cherche dans une doc.<br>
Dans ce cas, soit vous faites une "recherche" dans la doc comme on va le voir, soit vous découvrez le nom de la classe dans un tutoriel (mon tutoriel est fait pour ça, il vous montre les classes et vous apprend à les utiliser un peu, mais si vous voulez aller dans le détail il faudra lire la doc).<br>
<br>
La section API Reference propose les liens suivants :<br>
<br>
<ul>
<li><strong><a href="http://doc.trolltech.com/classes.html">All Classes</a></strong> : affiche TOUTES les classes de Qt, triées par ordre alphabétique. Notez que comme toutes les classes de Qt commencent par la lettre Q, on considère que c'est la seconde lettre qui détermine l'ordre alphabétique. Ainsi, QWidget se trouvera dans la section de la lettre "W".</li>
<li><strong><a href="http://doc.trolltech.com/mainclasses.html">Main Classes</a></strong> : c'est une version épurée de "All Classes" qui ne contient que les classes les plus fréquemment utilisées. Je vous conseille de commencer par cette section, amplement suffisante dans un premier temps. Inutile de vous assommer directement avec la liste de toutes les classes <img src="./cpp_files/langue.png" alt=":p" class="smilies"></li>
<li><strong><a href="http://doc.trolltech.com/groups.html">Grouped Classes</a></strong> : ici, les classes sont groupées par thèmes. C'est une section TRES intéressante pour vous qui débutez. Justement, si vous recherchez une classe dont vous ne connaissez pas le nom, c'est là qu'il faut aller.</li>
<li><strong><a href="http://doc.trolltech.com/annotated.html">Annotated Classes</a></strong> : contient toutes les classes (comme All Classes) mais avec une courte description devant chacune d'elles. C'est pratique pour retrouver une classe, mais pas autant que la section "Grouped Classes" dont je viens de vous parler <img src="./cpp_files/clin.png" alt=";)" class="smilies"></li>
<li><strong><a href="http://doc.trolltech.com/modules.html">Qt Classes by Module</a></strong> : les classes sont triées suivant les grands modules de Qt. Comme je vous l'avais dit, nous nous intéresserons surtout au plus gros module dédié à la création d'interfaces graphiques, à savoir QtGui.</li>
<li><strong><a href="http://doc.trolltech.com/hierarchy.html">Inheritance Hierarchy</a></strong> : hiérarchie des classes sous forme de liste à puces. On peut voir qui hérite de qui, qui est le "parent" de qui. Ce n'est pas très exploitable à mon avis, je vous conseille de voir le "Class Chart" (plus bas).</li>
<li><strong><a href="http://doc.trolltech.com/functions.html">All Functions</a></strong> : liste toutes les fonctions (méthodes) utilisées par toutes les classes de Qt. A utiliser si vous vous souvenez du nom d'une fonction mais pas du nom de la classe.</li>
<li><strong><a href="http://doc.trolltech.com/qtopiacore.html">Qtopia Core</a></strong> : documentation de la version "light" de Qt destinée aux appareils mobiles (téléphones portables par exemple). Ca ne nous intéresse pas ici.</li>
<li><strong><a href="http://doc.trolltech.com/overviews.html">All Overviews and HOWTOs</a></strong> : liste de tous les articles de la doc de Qt. Il y a beaucoup de choses dedans et c'est un peu fouilli et inexploitable si vous voulez mon avis, vous pouvez accéder à ces articles par d'autres moyens plus "logiques" depuis l'accueil de la doc.</li>
<li><strong><a href="http://doc.trolltech.com/gallery.html">Qt Widget Gallery</a></strong> : une galerie des principaux widgets de Qt. Vous pouvez comparer l'apparence des widgets en fonction des systèmes d'exploitation. Si vous cliquez par exemple sur "Windows Vista Style Widget Gallery", vous aurez un très bon aperçu de la plupart des widgets que Qt propose (avec des captures d'écran faites sous Vista). Je vous rappelle que tous ces widgets fonctionnent sur tous les autres OS, c'est juste l'apparence qui change à chaque fois.</li>
<li><strong><a href="http://doc.trolltech.com/extras/qt43-class-chart.pdf">Class Chart</a></strong> : un diagramme de toutes les classes de Qt qui permet de voir la relation d'héritage entre chacune des classes. Ce diagramme (au format PDF) fait peur au premier abord, mais il est en fait vraiment intéressant. Vous voyez qui hérite de qui. Vous constatez par exemple comme je vous l'ai dit que la plupart des classes héritent directement ou indirectement de QObject.<br>
Par exemple, on voit que QPushButton hérite des propriétés de QAbstractButton, qui hérite de QWidget, qui hérite de QObject ! Ah les joies du C++ <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Je vous aurais bien conseillé de l'imprimer et de l'afficher dans votre chambre, mais c'est un peu trop gros pour être imprimé sur une feuille A4. Quoi qu'il en soit, ça peut être intéressant pour se repérer parmi les classes de Qt.</li>
</ul><br>
<br>
Voici le diagramme des classes au format PNG (au lieu de PDF) pour ceux qui aimeraient y jeter un coup d'oeil :<br>
<br>
<div class="centre"><a href="http://uploads.siteduzero.com/files/112001_113000/112310.png"><img src="./cpp_files/112310.png" alt="Qt Diagramme des Classes"></a></div><br>
<br>
Ne vous laissez pas impressionner hein, avec un peu de méthode on s'y retrouve tout à fait <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Notez que les classes sont colorées d'un fond de couleur différent en fonction du module auquel elles appartiennent. Les classes de QtGui sont colorées en vert clair sur ce schéma. On voit d'un seul coup d'oeil que ce sont les plus nombreuses.<br>
<br>
<h3>Core Features</h3><br>
<br>
Vous trouverez ici des articles sur les plus importantes fonctionnalités de Qt. C'est un peu comme un tutoriel à thèmes.<br>
<br>
Par exemple, il y a une section qui explique le fonctionnement des signaux et des slots avec Qt. Je vous ai déjà fait un tuto à ce sujet, mais sachez pour information que quand moi j'ai débuté avec Qt, j'ai lu cet article qui m'a permis de comprendre ce que c'était et comment ça fonctionnait.<br>
<br>
A vous de voir si un de ces thèmes vous intéresse plus particulièrement. Par exemple si vous voulez en savoir plus sur la gestion du dessin avec Qt, allez dans "Paint System". Si vous êtes intéressés par l'accessibilité, regardez du côté de "Accessibility". Si vous voulez traduire votre programme en plusieurs langues, la section "Internationalization" vous donnera de précieux conseils.<br>
<br>
<h3>Key Technologies</h3><br>
<br>
C'est un peu comme la section précédente : il s'agit de tutoriels à thèmes.<br>
Ici, vous trouverez notamment un article sur la gestion de la fenêtre principale d'un programme (Main Window Architecture), ou encore sur la programmation Modèle / Vue dont on reparlera dans un prochain chapitre.<br>
<br>
On retrouve plus particulièrement une introduction à chacun des principaux modules de Qt, à l'exception de Qt GUI qui fait déjà l'objet d'un tutoriel dans la section "Getting Started".<br>
Si vous voulez démarrer avec le module réseau de Qt par exemple, il faut lire "Network Module". Si vous comptez faire appel à des bases de données depuis votre programme, consultez "SQL Module".<br>
<br>
<h3>Add-ons &amp; Services</h3><br>
<br>
On vous propose ici des services autour de Qt, à savoir :<br>
<br>
<ul>
<li>du support</li>
<li>des formations</li>
<li>etc.</li>
</ul><br>
<br>
Bref autant le dire, des choses qui intéressent des entreprises qui ont le moyen de payer pour ça.<br>
<br>
On trouvera aussi un lien vers http://qt-apps.org, un site sur lequel vous trouverez des applications réalisées avec Qt ainsi que de nouveaux widgets que vous pouvez librement utiliser dans vos applications.<br>
<br>
<br>
<h3>Tools</h3><br>
<br>
Comme vous le savez déjà, Qt est pré-installé avec un certain nombre d'outils que je vous avais présentés.<br>
On trouve ici des tutoriels pour savoir utiliser chacun de ces logiciels :<br>
<br>
<ul>
<li><strong>Qt Designer :</strong> le logiciel qui permet de dessiner à la souris une interface graphique ;</li>
<li><strong>Qt Assistant :</strong> le logiciel qui contient la documentation dont j'ai parlé au début du chapitre ;</li>
<li><strong>Qt Linguist :</strong> le logiciel qui permet de traduire une application de Qt vers une autre langue ;</li>
<li><strong>qmake :</strong> l'utilitaire indispensable pour compiler une application Qt. Il propose beaucoup d'options et nous n'en avons vu qu'une petite partie pour le moment (la partie essentielle). Vous pourrez en apprendre plus sur la syntaxe des fichiers de projet .pro.<br>
Vous aurez peut-être besoin de lire cette section lorsque vous ferez des programmes un peu plus complexes ;</li>
<li><strong>All Tools :</strong> la liste de tous les outils proposés par Qt (y compris les précédents que je viens de citer).</li>
</ul><br>
<br>
<h3>Licenses &amp; Credits</h3><br>
<br>
Voilà une section contenant des informations légales à propos de Qt. Vous y trouverez notamment un exemplaire de la GNU GPL, la licence libre qui vous autorise à utiliser librement et gratuitement Qt à condition que vous fassiez à votre tour un programme libre.<br>
<br>
Bref, ce n'est pas une section très lisible par les programmeurs, il faut plutôt réserver ça aux juristes <img src="./cpp_files/langue.png" alt=":p" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11287">Comprendre la documentation d'une classe</h2>
		<div class="ss_part_texte">
		Voilà la section la plus importante et la plus intéressante de ce chapitre : nous allons étudier la documentation d'une classe de Qt au hasard.<br>
Chaque classe possède sa propre page, plus ou moins longue selon la complexité de la classe. Vous pouvez donc retrouver tout ce dont vous avez besoin de savoir sur une classe en lisant une seule page.<br>
<br>
Bon, j'ai dit qu'on allait prendre une classe de Qt au hasard. Alors, voyons voir... sur qui ça va tomber... ah ! Je sais :<br>
<br>
<div class="centre"><span class="gros"><a href="http://doc.trolltech.com/qlineedit.html">QLineEdit</a></span></div><br>
<br>
<div class="rmq information">Lorsque vous connaissez le nom de la classe et que vous voulez lire sa documentation, vous pouvez passer par le lien "All Classes" depuis le sommaire, ou encore taper directement dans votre navigateur <span class="courrier"><a href="http://doc.trolltech.com/nomdelaclasse.html">http://doc.trolltech.com/nomdelaclasse.html</a></span> (exemple : <span class="courrier"><a href="http://doc.trolltech.com/qlineedit.html">http://doc.trolltech.com/qlineedit.html</a></span>).</div><br>
<br>
Vous devriez avoir une longue page qui s'affiche sous vos yeux ébahis, et qui commence par quelque chose comme ça :<br>
<br>
<div class="centre"><a href="http://doc.trolltech.com/qlineedit.html"><img src="./cpp_files/112335.png" alt="Qt Documentation de classe"></a></div><br>
<br>
Chaque documentation de classe suit exactement la même structure. Vous retrouverez donc les mêmes sections, les mêmes titres, etc.<br>
<br>
Analysons à quoi correspond chacune de ces sections ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3><a href="http://doc.trolltech.com/qlineedit.html">Introduction</a></h3><br>
<br>
Au tout début, vous pouvez lire une très courte introduction qui explique en quelques mots à quoi sert la classe.<br>
<br>
<div class="flot_droite"><img src="./cpp_files/112338.png" alt="QLineEdit"></div>Ici, nous avons : "<span class="italique">The QLineEdit widget is a one-line text editor.</span>", ce qui signifie, si vous avez bien révisé votre anglais, que ce widget est un éditeur de texte sur une ligne, comme le montre la capture d'écran ci-contre.<br>
<br>
Le lien "<a href="http://doc.trolltech.com/qlineedit.html#details">More...</a>" vous amène vers une description plus détaillée de la classe. En général, il s'agit d'un mini-tutoriel pour apprendre à utiliser la classe. Je vous recommande de toujours lire cette introduction quand vous travaillez avec une classe que vous ne connaissiez pas jusqu'alors.<br>
Ça vous fera gagner beaucoup de temps car vous saurez "par où commencer" et "quelles sont les principales méthodes de la classe".<br>
<br>
Ensuite, on vous donne le header à inclure pour pouvoir utiliser la classe dans votre code, en l'occurrence il s'agit de :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QLineEdit&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Puis, vous avez une information très importante à côté de laquelle on passe souvent : la classe dont hérite votre classe. Ici, on voit que QWidget est le parent de QLineEdit. Donc QLineEdit récupère toutes les propriétés de QWidget. Ça a son importance comme nous allons le voir...<br>
<br>
<br>
Voilà pour l'intro ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Maintenant, voyons voir les sections qui suivent...<br>
<br>
<br>
<h3><a href="http://doc.trolltech.com/qlineedit.html#public-types">Public Types</a></h3><br>
<br>
Les classes définissent parfois des types de données personnalisés, sous la forme de ce qu'on appelle des énumérations (j'en ai parlé dans mon cours de C pour ceux qui auraient un trou de mémoire !).<br>
<br>
Ici, QLineEdit définit l'énumération EchoMode qui propose plusieurs valeurs : Normal, NoEcho, Password, etc.<br>
<br>
<div class="rmq information">Une énumération ne s'utilise pas "telle quelle". C'est juste une liste de valeurs, que vous pouvez renvoyer à une méthode spécifique qui en a besoin. Dans le cas de QLineEdit, c'est la méthode <span class="code2 cpp"><span class="n">setEchoMode</span><span class="p">(</span><span class="n">EchoMode</span><span class="p">)</span>
</span> qui en a besoin, car elle n'accepte que des données de type EchoMode..<br>
Pour envoyer la valeur "Password", il faudra écrire : <span class="code2 cpp"><span class="n">setEchoMode</span><span class="p">(</span><span class="n">QLineEdit</span><span class="o">::</span><span class="n">Password</span><span class="p">)</span>
</span>.</div><br>
<br>
<br>
<h3><a href="http://doc.trolltech.com/qlineedit.html#properties">Properties</a></h3><br>
<br>
Vous avez là toutes les propriétés d'une classe que vous pouvez lire et modifier.<br>
<br>
<div class="rmq question">Euh, ce ne sont pas des attributs ça par hasard ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"></div><br>
<br>
Si. Mais la doc ne vous affiche que les attributs pour lesquels Qt définit des accesseurs. Il y a de nombreux attributs "internes" à chaque classe que la doc ne vous montre pas car ils ne vous concernent pas.<br>
<br>
Toutes les propriétés sont donc des attributs intéressants de la classe que vous pouvez lire et modifier. Comme je vous l'avais dit dans un chapitre précédent, Qt suit cette convention pour le nom des accesseurs :<br>
<br>
<ul>
<li><strong>propriete()</strong> : c'est la méthode accesseur qui vous permet de lire la propriété ;</li>
<li><strong>setPropriete()</strong> : c'est la méthode accesseur qui vous permet de modifier la propriété.</li>
</ul><br>
<br>
Prenons par exemple la propriété text. C'est la propriété qui stocke le texte rentré par l'utilisateur dans le champ de texte QLineEdit.<br>
<br>
Comme indiqué dans la doc, text est de type QString. Vous devez donc récupérer la valeur dans un QString.<br>
Pour récupérer le texte entré par l'utilisateur dans une variable <span class="courrier">contenu</span>, on fera donc :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QLineEdit</span> <span class="n">monChamp</span><span class="p">(</span><span class="s">"Contenu du champ"</span><span class="p">);</span>
<span class="n">QString</span> <span class="n">contenu</span> <span class="o">=</span> <span class="n">monChamp</span><span class="p">.</span><span class="n">text</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Pour modifier le texte présent dans le champ, on écrira :<br>
<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QLineEdit</span> <span class="n">monChamp</span><span class="p">;</span>
<span class="n">monChamp</span><span class="p">.</span><span class="n">setText</span><span class="p">(</span><span class="s">"Entrez votre nom ici"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous remarquerez que dans la doc, la propriété text est un lien. <a href="http://doc.trolltech.com/qlineedit.html#text-prop">Cliquez dessus</a>. Cela vous amènera plus bas sur la même page vers une description de la propriété (que fait-elle ? à quoi sert-elle ?).<br>
On vous y donne aussi le prototype des accesseurs :<br>
<br>
<ul>
<li><span class="code2 cpp"><span class="n">QString</span> <span class="n">text</span> <span class="p">()</span> <span class="k">const</span>
</span></li>
<li><span class="code2 cpp"><span class="kt">void</span> <span class="n">setText</span> <span class="p">(</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="p">)</span>
</span></li>
</ul><br>
<br>
Et enfin, parfois vous verrez comme là une mention "See also" (voir aussi) qui vous invite à aller voir d'autres propriétés ou méthodes de la classe qui ont un rapport avec celle que vous êtes en train de lire. Ici, on vous dit que les méthodes insert() et clear() pourraient vous intéresser. En effet, par exemple clear() vide le contenu du champ de texte, c'est donc une méthode intéressante en rapport avec la propriété qu'on était en train de lire.<br>
<br>
<br>
<div class="rmq erreur">TRES IMPORTANT : dans la liste des propriétés en haut de la page, notez les mentions "<span class="italique">56 properties inherited from QWidget</span>", et "<span class="italique">1 property inherited from QObject</span>". Comme QLineEdit hérite de QWidget, qui lui-même hérite de QObject, il possède du coup  toutes les propriétés et toutes les méthodes de ses classes parentes !<br>
<br>
En clair, les propriétés que vous voyez là ne sont qu'un tout petit bout des possibilités offertes par QLineEdit. Si vous cliquez sur le lien QWidget, on vous amène vers la <a href="http://doc.trolltech.com/qwidget.html#properties">liste des propriétés de QWidget</a>. <span class="souligne">Vous disposez aussi de toutes ces propriétés dans un QLineEdit</span> !<br>
Vous pouvez donc utiliser la propriété width (largeur) qui est définie dans QWidget pour modifier la largeur de votre QLineEdit. Toute la puissance de l'héritage est là ! Tous les widgets possèdent donc ces propriétés "de base", ils n'ont plus qu'à définir des propriétés qui leur sont spécifiques.<br>
<br>
J'insiste bien dessus car au début je me disais souvent : "<span class="italique">Mais pourquoi il y a aussi peu de choses dans cette classe ?</span>". En fait, il ne faut pas s'y fier et toujours regarder les classes parentes dont hérite la classe qui vous intéresse. Tout ce que les classes parentes possèdent, vous y avez accès aussi.</div><br>
<br>
<h3><a href="http://doc.trolltech.com/qlineedit.html#public-functions">Public Functions</a></h3><br>
<br>
C'est bien souvent la section la plus importante. Vous y trouverez toutes les méthodes publiques (parce que les privées ne vous concernent pas) de la classe. On trouve dans le lot :<br>
<br>
<ul>
<li>le (ou les) constructeur(s) de la classe. Très intéressant pour savoir comment créer un objet à partir de cette classe ;</li>
<li>les accesseurs de la classe (comme text() et setText() qu'on vient de voir), basés sur les attributs ;</li>
<li>et enfin d'autres méthodes publiques qui ne sont ni des constructeurs ni des accesseurs et qui effectuent diverses opérations sur l'objet. Par exemple : home(), qui ramène le curseur au début du champ de texte.</li>
</ul><br>
<br>
Cliquez sur le nom d'une méthode pour en savoir plus sur son rôle et son fonctionnement.<br>
<br>
<br>
<h4>Lire et comprendre le prototype</h4><br>
<br>
A chaque fois, il faut que vous lisiez attentivement le prototype de la méthode, c'est très important ! Le prototype à lui seul vous donne une grosse quantité d'informations sur la méthode.<br>
<br>
Prenons l'exemple du constructeur. On voit qu'on a 2 prototypes :<br>
<br>
<ul>
<li><span class="code2 cpp"><span class="n">QLineEdit</span> <span class="p">(</span> <span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span>
</span></li>
<li><span class="code2 cpp"><span class="n">QLineEdit</span> <span class="p">(</span> <span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">contents</span><span class="p">,</span> <span class="n">QWidget</span> <span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span>
</span></li>
</ul><br>
<br>
Vous noterez que certains paramètres sont facultatifs.<br>
Si vous cliquez sur un de ces constructeurs, par exemple <a href="http://doc.trolltech.com/qlineedit.html#QLineEdit-2">le second</a>, on vous explique la signification de chacun de ces paramètres.<br>
<br>
On apprend que parent est un pointeur vers le widget qui "contiendra" notre QLineEdit (par exemple une fenêtre), et que contents est le texte qui doit être écrit dans le QLineEdit par défaut.<br>
<br>
Cela veut dire, si on prend en compte que le paramètre parent est facultatif, qu'on peut créer un objet de type QLineEdit de 4 façons différentes :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QLineEdit</span> <span class="n">monChamp</span><span class="p">();</span> <span class="c1">// Appel du premier constructeur</span>
<span class="n">QLineEdit</span> <span class="n">monChamp</span><span class="p">(</span><span class="n">fenetre</span><span class="p">);</span> <span class="c1">// Appel du premier constructeur</span>
<span class="n">QLineEdit</span> <span class="n">monChamp</span><span class="p">(</span><span class="s">"Entrez un texte"</span><span class="p">);</span> <span class="c1">// Appel du second constructeur</span>
<span class="n">QLineEdit</span> <span class="n">monChamp</span><span class="p">(</span><span class="s">"Entrez un texte"</span><span class="p">,</span> <span class="n">fenetre</span><span class="p">);</span> <span class="c1">// Appel du second constructeur</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est fou tout ce qu'un prototype peut raconter hein ? <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<br>
<h4>Quand la méthode attend un paramètre d'un type que vous ne connaissez pas...</h4><br>
<br>
<div class="rmq question">Je viens de voir la méthode <a href="http://doc.trolltech.com/qlineedit.html#alignment-prop">setAlignement</a>, mais elle demande un paramètre de type Qt::Alignment. Comment je lui donne ça moi, je connais pas les Qt::Alignment !</div><br>
<br>
Pas de panique. Il vous arrivera très souvent de tomber sur une méthode qui attend un paramètre d'un type qui vous est inconnu. Par exemple, vous n'avez jamais entendu parler de Qt::Alignment. Qu'est-ce que c'est que ce type ?<br>
<br>
La solution pour savoir <span class="italique">comment envoyer un paramètre de type Qt::Alignment</span> consiste à cliquer dans la doc sur le lien <a href="http://doc.trolltech.com/qt.html#AlignmentFlag-enum">Qt::Alignment</a> (eh oui, ce n'est pas un lien par hasard !).<br>
Ce lien vous amènera vers une page qui vous explique ce qu'est le type Qt::Alignment.<br>
<br>
Il peut y avoir 2 types différents :<br>
<br>
<ul>
<li><strong>Les énumérations</strong> : Qt::Alignment en est une. Les énumérations sont très simples à utiliser, c'est une série de valeurs. Il suffit d'écrire la valeur que l'on veut, comme le donne la <a href="http://doc.trolltech.com/qt.html#AlignmentFlag-enum">documentation de Qt::Alignment</a>, par exemple Qt::AlignCenter. La méthode pourra donc être appelée comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">monChamp</span><span class="p">.</span><span class="n">setAlignment</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">AlignCenter</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
</li>
<li><strong>Les classes</strong> : parfois, la méthode attend un objet issu d'une classe précise pour travailler. Là c'est un peu plus compliqué : il va falloir créer un objet de cette classe et l'envoyer à la méthode.<br>
<br>
Prenons par exemple <a href="http://doc.trolltech.com/qlineedit.html#setValidator">setValidator</a>, qui attend un pointeur vers un QValidator. La méthode setValidator vous dit qu'elle permet de vérifier si l'utilisateur a rentré un texte valide, ce qui peut être utile si vous voulez vérifier que l'utilisateur a bien rentré un nombre entier et non pas "<span class="italique">Bonjour ça va ?</span>" quand vous lui demandez son âge...<br>
Si vous cliquez sur le lien <a href="http://doc.trolltech.com/qvalidator.html">QValidator</a>, on vous emmène vers la page qui explique comment utiliser la classe QValidator. Lisez le texte d'introduction pour comprendre ce que cette classe est censée faire, puis regardez les constructeurs afin de savoir comment créer un objet de type QValidator.<br>
<br>
Parfois, comme là, c'est même un peu plus délicat. QValidator est une classe abstraite (c'est ce que vous dit l'intro de sa doc), ce qui signifie qu'on ne peut pas créer d'objet de type QValidator et qu'il faut utiliser une de ses classes filles <img src="./cpp_files/huh.png" alt=":o" class="smilies"><br>
Au tout début, la page de la doc de QValidator vous dit "<span class="italique">Inherited by QDoubleValidator, QIntValidator, and QRegExpValidator</span>". Cela signifie que ces classes héritent de QValidator et que vous pouvez les utiliser aussi. En effet, une classe fille est compatible avec la classe mère, comme nous l'avons déjà vu dans le <a href="http://www.siteduzero.com/tuto-3-22800-1-l-heritage.html#ss_part_2">chapitre sur l'héritage</a>.<br>
<br>
Nous, nous voulons autoriser uniquement la personne à rentrer un nombre entier, nous allons donc utiliser <a href="http://doc.trolltech.com/qintvalidator.html">QIntValidator</a>. Il faut créer un objet de type QIntValidator. Regardez ses constructeurs et choisissez celui qui vous convient.<br>
<br>
Au final (ouf !), pour utiliser setValidator, on peut faire comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QValidator</span> <span class="o">*</span><span class="n">validator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QIntValidator</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
<span class="n">monChamp</span><span class="p">.</span><span class="n">setValidator</span><span class="p">(</span><span class="n">validator</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... pour s'assurer que la personne ne rentrera qu'un nombre compris entre 0 et 150 ans (ça laisse de la marge <img src="./cpp_files/hihi.png" alt="^^" class="smilies"> ).</li>
</ul><br>
<br>
La morale de l'histoire, c'est qu'il ne faut pas avoir peur d'aller lire la documentation d'une classe dont a besoin la classe sur laquelle vous travaillez, et même des fois là d'aller voir les classes filles.<br>
<br>
Ça peut faire un peu peur au début, mais c'est une gymnastique de l'esprit à acquérir. N'hésitez donc pas à sauter de lien en lien dans la doc pour arriver enfin à envoyer à cette $%@#$#% de méthode un objet du type qu'elle attend ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<h3><a href="http://doc.trolltech.com/qlineedit.html#public-slots">Public Slots</a></h3><br>
<br>
Les slots sont des méthodes comme les autres, à la différence près qu'on peut aussi les connecter à un signal comme on l'a vu dans le chapitre sur les signaux et les slots.<br>
Notez que rien ne vous interdit d'appeler un slot directement, comme si c'était une méthode comme une autre.<br>
<br>
Par exemple, le <a href="http://doc.trolltech.com/qlineedit.html#undo">slot undo()</a> annule la dernière opération de l'utilisateur.<br>
<br>
Vous pouvez l'appeler comme une bête méthode :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">monChamp</span><span class="p">.</span><span class="n">undo</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... mais la particularité du fait que undo() soit un slot, c'est que vous pouvez aussi le connecter à un autre widget. Par exemple, on peut imaginer un menu Edition / Annuler dont le signal "cliqué" sera connecté au slot "undo" du champ de texte <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="rmq erreur">Tous les slots offerts par QLineEdit ne sont pas dans cette liste. Je me permets de vous rappeler une fois de plus qu'il faut penser à regarder les mentions comme "<span class="italique">19 public slots inherited from QWidget</span>", qui vous invitent à aller voir les slots de QWidget auxquels vous avez aussi accès.<br>
C'est ainsi que vous découvrez que vous disposez du slot <span class="courrier">hide()</span> qui permet de masquer votre QLineEdit.</div><br>
<br>
<h3><a href="http://doc.trolltech.com/qlineedit.html#signals">Signals</a></h3><br>
<br>
C'est la liste des signaux que peut envoyer un QLineEdit.<br>
Un signal est un évènement qui s'est produit et que l'on peut connecter à un slot (le slot pouvant appartenir à cet objet ou à un autre).<br>
<br>
Par exemple, le signal textChanged() est émis à chaque fois que l'utilisateur modifie le texte à l'intérieur du QLineEdit. Si vous le voulez, vous pouvez connecter ce signal à un slot pour qu'une action soit effectuée à chaque fois que le texte est modifié.<br>
<br>
Attention encore une fois à bien regarder les signaux hérités de QWidget et QObject, car ils appartiennent aussi à la classe QLineEdit. Je sais que je suis lourd à force de répéter ça, inutile de me le dire, je le fais exprès pour que ça rentre <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<br>
<h3><a href="http://doc.trolltech.com/qlineedit.html#protected-functions">Protected Functions</a></h3><br>
<br>
Ce sont des méthodes protégées. Elles ne sont ni public, ni private, mais protected.<br>
Comme on l'a vu dans le chapitre sur l'héritage, ce sont des méthodes privées (auxquelles vous ne pouvez pas accéder directement en tant qu'utilisateur de la classe) mais qui seront héritées et donc réutilisables si vous créez une classe basée sur QLineEdit.<br>
<br>
Il est très fréquent d'hériter des classes de Qt, on l'a d'ailleurs déjà fait avec QWidget pour créer une fenêtre personnalisée. Si vous héritez de QLineEdit, sachez donc que vous disposerez aussi de ces méthodes.<br>
<br>
<br>
<h3>Additional Inherited Members</h3><br>
<br>
Si des éléments hérités n'ont pas été listés jusqu'ici, on les retrouvera dans cette section à la fin.<br>
Par exemple, la classe QLineEdit ne définit pas de méthodes statiques, mais elle en possède quelques-unes héritées de QWidget et QObject.<br>
<br>
Je vous rappelle qu'une méthode statique est une méthode qui peut être appelée sans avoir eu à créer d'objet. C'est un peu comme une fonction.<br>
<br>
Il n'y a rien de bien intéressant avec QLineEdit, mais sachez par exemple que la classe QString possède de nombreuses méthodes statiques, comme number() qui convertit le nombre donné en une chaîne de caractères de type QString.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QString</span> <span class="n">maChaine</span> <span class="o">=</span> <span class="n">QString</span><span class="o">::</span><span class="n">number</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Une méthode statique s'appelle comme ceci : <span class="code2 cpp"><span class="n">NomDeLaClasse</span><span class="o">::</span><span class="n">nomDeLaMethode</span><span class="p">()</span>
</span>.<br>
On a déjà vu tout ça dans les chapitres précédents, je ne fais ici que des rappels <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Ce chapitre était absolument nécessaire car je suis convaincu que vous ne pouvez pas passer à côté de la doc.<br>
<br>
Toutes les informations dont vous avez besoin y sont, le tout est d'être capable de les retrouver et de les comprendre. C'est, je l'espère, ce que ce chapitre vous aura aidés à faire. Il s'agissait de faire une sorte de "guide" pour rassurer les débutants qui n'ont jamais vraiment touché à une documentation.<br>
<br>
Le concept pour apprendre un langage ou une bibliothèque est donc le suivant :<br>
<br>
<ol class="liste_1">
<li>d'abord on lit des tutoriels qui nous permettent de savoir comment débuter et dans quelle direction chercher ;</li>
<li>et ensuite on consulte la doc pour connaître le détail des fonctions et des classes.</li></ol><br>
Il n'existe pas de tutoriel qui vous apprendra tout de A à Z sur une bibliothèque comme Qt par exemple. Ca n'aurait pas de sens et ce serait complètement stupide de chercher à faire ça étant donné que cela représenterait un travail énorme qui deviendrait obsolète dès la prochaine mise à jour de Qt.<br>
<br>
Le but de mon tutoriel n'est donc pas de "tout vous apprendre" mais de vous apprendre à apprendre. Bien sûr, je ne vous lâche pas dans la nature comme ça : j'ai encore beaucoup de choses à vous expliquer dans ce tutoriel. Mais pensez à lire la doc en parallèle de mes cours, et une fois que vous aurez fini de lire ma prose, ayez le réflexe de consulter la doc à chaque fois que vous en avez besoin.<br>
<br>
C'est un vrai réflexe de programmeur <img src="./cpp_files/smile.png" alt=":)" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11302">Positionner ses widgets avec les layouts</h1>
	<div id="chap_intro">
	Comme vous le savez, une fenêtre peut contenir toutes sortes de widgets : des boutons, des champs de texte, des cases à cocher...<br>
<br>
Placer ces widgets sur la fenêtre est une science à part entière. Je veux dire par là qu'il faut vraiment y aller avec méthode, si on ne veut pas que la fenêtre ressemble rapidement à un champ de bataille <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Comment bien placer les widgets sur la fenêtre ?<br>
Comment gérer les redimensionnements de la fenêtre ?<br>
Comment s'adapter automatiquement à toutes les résolutions d'écran ?<br>
<br>
On distingue 2 techniques différentes pour positionner des widgets :<br>
<br>
<ul>
<li><strong>Le positionnement absolu</strong> : c'est celui que nous avons vu jusqu'ici, avec l'appel à la méthode <span class="italique">setGeometry </span>(ou <span class="italique">move</span>)... Ce positionnement est très précis, car on place les widgets au pixel près, mais cela comporte un certain nombre de défauts comme nous allons le voir.</li>
<li><strong>Le positionnement relatif</strong> : c'est le plus flexible et c'est celui que je vous recommande d'utiliser autant que possible. Nous allons l'étudier dans ce chapitre.</li>
</ul>
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11301">Le positionnement absolu et ses défauts</h2>
		<div class="ss_part_texte">
		Nous allons commencer par voir le code Qt de base que nous allons utiliser dans ce chapitre, puis nous ferons quelques rappels sur le positionnement absolu que vous avez déjà utilisé sans savoir exactement ce que c'était <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Le code Qt de base</h3><br>
<br>
Dans les chapitres précédents, nous avions créé un projet Qt constitué de 3 fichiers :<br>
<br>
<ul>
<li><strong>main.cpp</strong> : contenait le main qui se chargeait juste d'ouvrir la fenêtre principale.</li>
<li><strong>MaFenetre.h</strong> : contenait l'en-tête de notre classe MaFenetre qui héritait de QWidget.</li>
<li><strong>MaFenetre.cpp</strong> : contenait l'implémentation des méthodes de MaFenetre, notamment du constructeur.</li>
</ul><br>
<br>
C'est l'architecture que l'on utilisera dans la plupart de nos projets Qt.<br>
<br>
Toutefois, pour ce chapitre nous n'avons pas besoin d'une architecture aussi complexe, et nous allons faire comme dans les tous premiers chapitre Qt : nous allons juste utiliser un main (1 seul fichier : main.cpp).<br>
<br>
Voici le code de votre projet, sur lequel nous allons commencer :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="n">QPushButton</span> <span class="n">bouton</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
    <span class="n">bouton</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="mi">70</span><span class="p">,</span> <span class="mi">60</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est très simple : nous créons une fenêtre, et nous affichons un bouton que nous plaçons aux coordonnées (70, 60) sur la fenêtre.<br>
<br>
Le résultat est le suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/115689.png" alt="Notre fenêtre simple"></div><br>
<br>
<br>
<h3>Les défauts du positionnement absolu</h3><br>
<br>
Dans le code précédent, nous avons positionné notre bouton de manière absolue en faisant <span class="code2 cpp"><span class="n">bouton</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="mi">70</span><span class="p">,</span> <span class="mi">60</span><span class="p">);</span>
</span><br>
Le bouton a été très précisément placé 70 pixels sur la droite et 60 pixels plus bas.<br>
<br>
Le problème... c'est que ce n'est pas flexible du tout. Imaginez que l'utilisateur s'amuse à redimensionner la fenêtre :<br>
<br>
<div class="centre"><img src="./cpp_files/115690.png" alt="Un bouton coupé en deux"><br>
<span class="italique">C'est moche, non ?</span></div><br>
<br>
Le bouton ne bouge pas de place. Du coup, si on réduit la taille de la fenêtre, il sera coupé en deux, et pourra même disparaître si on réduit trop la taille.<br>
<br>
<div class="rmq question">Dans ce cas, pourquoi ne pas empêcher l'utilisateur de redimensionner la fenêtre ? On avait fait ça grâce à <span class="courrier">setFixedSize</span> dans les chapitres précédents...</div><br>
<br>
Oui, vous pouvez faire cela. C'est d'ailleurs ce que font le plus souvent les développeurs de logiciels qui positionnent leurs widgets en absolu. Cependant, l'utilisateur apprécie aussi de pouvoir redimensionner sa fenêtre. Ce n'est qu'une demi-solution.<br>
<br>
D'ailleurs, il y a un autre problème que <span class="courrier">setFixedSize </span>ne peut pas régler : le cas des résolutions d'écran plus petites que la vôtre. Imaginez que vous placiez un bouton 1200 pixels sur la droite parce que vous avez une grande résolution (1600 x 1200), et que l'utilisateur soit dans une résolution plus petite que vous (1024 x 768). Il ne pourra jamais voir le bouton, parce qu'il ne pourra jamais agrandir autant sa fenêtre !<br>
<br>
<br>
<div class="rmq question">Alors quoi ? Le positionnement absolu c'est mal ? Où veux-tu en venir ?<br>
Et surtout, comment peut-on faire autrement ?</div><br>
<br>
Non, le positionnement absolu ce n'est pas "mal". Il sert parfois quand on a vraiment besoin de positionner au pixel près. Vous pouvez l'utiliser dans certains de vos projets, mais autant que possible, préférez l'autre méthode : le positionnement relatif.<br>
<br>
Le positionnement relatif, cela consiste à expliquer comment les widgets sont agencés les uns par rapport aux autres, plutôt que d'utiliser une position en pixels. Par exemple, on peut dire "Le bouton 1 est en-dessous du bouton 2, qui est à gauche du bouton 3".<br>
<br>
Le positionnement relatif est géré par ce qu'on appelle les <span class="italique">layouts </span>avec Qt. <span class="souligne">Ce sont des conteneurs de widgets</span>.<br>
C'est justement l'objet principal de ce chapitre <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11300">L'architecture des classes de layout</h2>
		<div class="ss_part_texte">
		Pour positionner intelligemment nos widgets, nous allons utiliser des classes de Qt gérant les layouts.<br>
Il existe par exemple des classes gérant le positionnement horizontal et vertical des widgets (ce que nous allons étudier en premier), ou encore le positionnement sous forme de grille.<br>
<br>
Pour que vous y voyiez plus clair, je vous propose de regarder ce schéma de mon cru :<br>
<br>
<div class="centre"><img src="./cpp_files/115810.png" alt="Layouts avec Qt"></div><br>
<br>
Ce sont les classes gérant les layouts de Qt.<br>
Toutes les classes héritent de la classe de base QLayout.<br>
<br>
On compte donc en gros les classes :<br>
<br>
<ul>
<li>QBoxLayout</li>
<li>QHBoxLayout</li>
<li>QVBoxLayout</li>
<li>QGridLayout</li>
<li>QFormLayout</li>
<li>QStackedLayout</li>
</ul><br>
<br>
Nous allons étudier chacune de ces classes dans ce chapitre, à l'exception de QStackedLayout (gestion des widgets sur plusieurs pages) qui est un peu trop complexe pour qu'on puisse travailler dessus ici. On utilisera plutôt des widgets qui le réutilisent, comme QWizard qui permet de créer des assistants.<br>
<br>
<div class="rmq question">Euh... Mais pourquoi tu as écrit <span class="italique">QLayout </span>en italique, et pourquoi tu as grisé la classe ? <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> </div><br>
<br>
QLayout est ce qu'on appelle une classe abstraite. Je ne vous en ai pas trop parlé jusqu'ici.<br>
En fait, une classe abstraite est une classe "de base" qu'on ne peut pas instancier. C'est-à-dire qu'<span class="souligne">on ne peut pas créer d'objets de type QLayout</span>, il faut forcément créer un objet à partir d'une des classes filles (QBoxLayout, QGridLayout...).<br>
<br>
<br>
<div class="rmq question">A quoi ça sert de créer une classe qui ne nous permette pas de créer d'objet ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"></div><br>
<br>
Ca sert pour le programmeur, pour avoir juste une classe "de base".<br>
Cependant, comme ça n'a pas de sens de créer d'objet de type QLayout, la classe a été définie comme étant abstraite.<br>
<br>
<br>
Je ne vais pas rentrer dans les détails de "<span class="italique">comment faire pour créer une classe abstraite en C++</span>". Ce serait un peu trop compliqué et hors-sujet.<br>
<br>
Tout ce que vous avez besoin de retenir, c'est que <span class="souligne">vous pouvez créer des objets de type QBoxLayout, QGridLayout, etc, mais pas d'objets de type QLayout</span>. En quelque sorte, QLayout sert de "modèle" de base pour les autres classes mais on ne peut rien faire avec elle seule <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11299">Les layouts horizontaux et verticaux</h2>
		<div class="ss_part_texte">
		Attaquons sans plus tarder l'étude de nos premiers layouts (les plus simples), vous allez mieux comprendre à quoi tout cela sert <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Nous allons travailler sur 2 classes :<br>
<br>
<ul>
<li><a href="http://doc.trolltech.com/qhboxlayout.html">QHBoxLayout</a></li>
<li><a href="http://doc.trolltech.com/qvboxlayout.html">QVBoxLayout</a></li>
</ul><br>
<br>
QHBoxLayout et QVBoxLayout héritent de <a href="http://doc.trolltech.com/qboxlayout.html">QBoxLayout</a>. Ce sont des classes très similaires (la doc Qt parle de "<span class="italique">convenience classes</span>", des classes qui sont là pour vous aider à aller plus vite mais qui sont en fait quasiment identiques à QBoxLayout).<br>
Nous n'allons pas utiliser QBoxLayout, mais juste ses classes filles QHBoxLayout et QVBoxLayout (ça revient au même).<br>
<br>
<br>
<h3>Le layout horizontal</h3><br>
<br>
L'utilisation d'un layout se fait en 3 temps :<br>
<br>
<ol class="liste_1">
<li>On crée les widgets</li>
<li>On crée le layout et on place les widgets dedans</li>
<li>On dit à la fenêtre d'utiliser le layout qu'on a créé</li></ol><br>
<br>
<h4>1/ Créer les widgets</h4><br>
<br>
Pour les besoins de ce tutoriel, nous allons créer plusieurs boutons de type QPushButton :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3</pre></td><td class="code"><div class="syntax"><pre><span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
<span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"les"</span><span class="p">);</span>
<span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Zéros"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous remarquerez que j'utilise des pointeurs. En effet, j'aurais très bien pu faire sans pointeurs comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3</pre></td><td class="code"><div class="syntax"><pre><span class="n">QPushButton</span> <span class="n">bouton1</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
<span class="n">QPushButton</span> <span class="n">bouton2</span><span class="p">(</span><span class="s">"les"</span><span class="p">);</span>
<span class="n">QPushButton</span> <span class="n">bouton3</span><span class="p">(</span><span class="s">"Zéros"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... cette méthode a l'air plus simple, mais vous verrez que c'est plus pratique de travailler directement avec des pointeurs par la suite <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
La différence entre ces 2 codes, c'est que bouton1 est un pointeur dans le premier code, tandis que c'est un objet dans le second code.<br>
<br>
On va donc utiliser la première méthode avec les pointeurs.<br>
<br>
Bon, on a 3 boutons, c'est bien. Mais les plus perspicaces d'entre vous auront remarqué qu'on n'a pas indiqué quelle était la fenêtre parente, comme on aurait fait avant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On n'a pas fait comme ça, et c'est fait exprès justement. Nous n'allons pas placer les boutons dans la fenêtre directement, mais dans un conteneur : le layout.<br>
<br>
<br>
<h4>2/ Créer le layout et placer les widgets dedans</h4><br>
<br>
Créons justement ce layout, un layout horizontal :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QHBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QHBoxLayout</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le constructeur de cette classe est simple, on n'a pas besoin d'indiquer de paramètre.<br>
<br>
Maintenant que notre layout est créé, rajoutons nos widgets à l'intérieur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3</pre></td><td class="code"><div class="syntax"><pre><span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton1</span><span class="p">);</span>
<span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton2</span><span class="p">);</span>
<span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton3</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La méthode addWidget du layout attend que vous lui donniez en paramètre un pointeur vers le widget à ajouter au conteneur. Voilà pourquoi je vous ai fait utiliser des pointeurs (sinon il aurait fallu écrire <span class="code2 cpp"><span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bouton1</span><span class="p">);</span>
</span> à chaque fois).<br>
<br>
<br>
<h4>3/ Indiquer à la fenêtre d'utiliser le layout</h4><br>
<br>
Maintenant, dernière chose : il faut placer le layout dans la fenêtre. Il faut dire à la fenêtre : "<span class="italique">tu vas utiliser ce layout, qui contient mes widgets</span>".<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">fenetre</span><span class="p">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La méthode setLayout de la fenêtre attend un pointeur vers le layout à utiliser.<br>
Et voilà, notre fenêtre contient maintenant notre layout, qui contient les widgets. Le layout se chargera d'organiser les widgets horizontalement tout seul.<br>
<br>
<br>
<h3>Résumé du code</h3><br>
<br>
Voici le code complet de notre fichier main.cpp :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
<span class="ln-xtra"><span class="cp">#include &lt;QHBoxLayout&gt;</span></span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"les"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Zéros"</span><span class="p">);</span>

<span class="ln-xtra">    <span class="n">QHBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QHBoxLayout</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton1</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton2</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton3</span><span class="p">);</span></span>
<span class="ln-xtra">    </span>
<span class="ln-xtra">    <span class="n">fenetre</span><span class="p">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span></span>
    
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
J'ai surligné les principales nouveautés.<br>
En particulier, comme d'hab' lorsque vous utilisez une nouvelle classe Qt, pensez à l'inclure au début de votre code : <span class="code2 cpp"><span class="cp">#include &lt;QHBoxLayout&gt;</span>
</span><br>
<br>
<br>
<h3>Résultat</h3><br>
<br>
Voilà à quoi ressemble la fenêtre maintenant que l'on utilise un layout horizontal :<br>
<br>
<div class="centre"><img src="./cpp_files/115821.png" alt="Layout horizontal"></div><br>
<br>
Les boutons sont automatiquement disposés de manière horizontale ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
L'intérêt principal du layout, c'est son comportement face aux redimensionnements de la fenêtre.<br>
Essayons de l'élargir :<br>
<br>
<div class="centre"><img src="./cpp_files/115823.png" alt="Layout horizontal agrandi"></div><br>
<br>
Les boutons continuent de prendre l'espace en largeur.<br>
<br>
On peut aussi l'agrandir en hauteur :<br>
<br>
<div class="centre"><img src="./cpp_files/115822.png" alt="Layout horizontal agrandi"></div><br>
<br>
On remarque que les widgets restent centrés verticalement.<br>
Vous pouvez aussi essayer de réduire la taille de la fenêtre. On vous interdira de la réduire si les boutons ne peuvent plus être affichés, ce qui vous garantit que les boutons ne risquent plus de disparaître comme avant ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<br>
<h3>Schéma des conteneurs</h3><br>
<br>
En résumé, la fenêtre contient le layout qui contient les widgets. Le layout se charge d'organiser les widgets.<br>
Schématiquement, ça se passe donc comme ça :<br>
<br>
<div class="centre"><img src="./cpp_files/115829.png" alt="Schéma des layouts"><br>
<span class="italique">Le layout est invisible à l'affichage</span></div><br>
<br>
On vient de voir le layout QHBoxLayout qui organise les widgets horizontalement.<br>
<br>
Il y en a un autre qui les organise verticalement (c'est quasiment la même chose) : QVBoxLayout.<br>
<br>
<br>
<h3>Le layout vertical</h3><br>
<br>
Pour utiliser un layout vertical, il suffit de remplacer QHBoxLayout par QVBoxLayout dans le code précédent. Oui oui, c'est aussi simple que ça <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
<span class="ln-xtra"><span class="cp">#include &lt;QVBoxLayout&gt;</span></span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"les"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Zéros"</span><span class="p">);</span>

<span class="ln-xtra">    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span></span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton1</span><span class="p">);</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton2</span><span class="p">);</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton3</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
N'oubliez pas d'inclure QVBoxLayout.<br>
<br>
Compilez et exécutez ce code, et admirez le résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/115830.png" alt="Layout vertical"></div><br>
<br>
Amusez-vous à redimensionner la fenêtre. Vous voyez là encore que la layout adapte les widgets qu'il contient à toutes les dimensions. Il empêche en particulier la fenêtre de devenir trop petite, ce qui aurait empêché l'affichage des boutons.<br>
<br>
<br>
<h3>La suppression automatique des widgets</h3><br>
<br>
<div class="rmq question">Eh ! Je viens de me rendre compte que tu fais des new dans tes codes, mais il n'y a pas de delete ! Si tu alloues des objets sans les supprimer, ils vont pas rester en mémoire ?</div><br>
<br>
Si, mais comme je vous l'avais dit plus tôt, Qt est intelligent <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
En fait, les widgets sont placés dans un layout, qui est lui-même placé dans la fenêtre. Lorsque la fenêtre est supprimée (ici à la fin du programme), tous les widgets contenus dans son layout sont supprimés par Qt. <span class="souligne">C'est donc Qt qui se charge de faire les delete pour nous</span>.<br>
<br>
<br>
Bien, vous devriez commencer à comprendre comment fonctionnent les layouts <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Comme on l'a vu au début du chapitre, il y a de nombreux layouts, qui ont chacun leurs spécificités ! Intéressons-nous maintenant au puissant (mais complexe) QGridLayout.<br>

		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11298">Le layout de grille</h2>
		<div class="ss_part_texte">
		Les layouts horizontaux et verticaux sont gentils, mais il ne permettent pas de créer des dispositions très complexes sur votre fenêtre.<br>
<br>
C'est là qu'entre en jeu <a href="http://doc.trolltech.com/qgridlayout.html">QGridLayout</a>, qui est en fait un peu un assemblage de QHBoxLayout et QVBoxLayout. Il s'agit d'une disposition en grille, comme un tableau avec des lignes et des colonnes.<br>
<br>
<br>
<h3>Schéma de la grille</h3><br>
<br>
Il faut imaginer que votre fenêtre peut être découpée sous la forme d'une grille avec une infinité de cases, comme ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/115888.png" alt="Grille"></div><br>
<br>
Si on veut placer un widget en haut à gauche, il faudra le placer à la case de coordonnées (0, 0).<br>
Si on veut en placer un autre en-dessous, il faudra utiliser les coordonnées (1, 0).<br>
Ainsi de suite <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Utilisation basique de la grille</h3><br>
<br>
Essayons d'utiliser un QGridLayout simplement pour commencer (oui parce qu'on peut aussi l'utiliser de manière compliquée <img src="./cpp_files/hihi.png" alt="^^" class="smilies"> ).<br>
<br>
Nous allons placer un bouton en haut à gauche, un à sa droite et un en-dessous.<br>
La seule différence réside en fait dans l'appel à la méthode addWidget. Celle-ci accepte 2 paramètres supplémentaires : les coordonnées où placer le widget sur la grille.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
<span class="cp">#include &lt;QGridLayout&gt;</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"les"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Zéros"</span><span class="p">);</span>

    <span class="n">QGridLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QGridLayout</span><span class="p">;</span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/115892.png" alt="Boutons disposés selon une grille"></div><br>
<br>
Si vous comparez avec le schéma de la grille que j'ai fait plus haut, vous voyez que les boutons ont bien été disposés selon les bonnes coordonnées.<br>
<br>
<div class="rmq question">D'ailleurs en parlant du schéma plus haut, il y a un truc que je comprends pas, c'est tous ces points de suspension "..." là. Ca veut dire que la taille de la grille est infinie ? Dans ce cas, comment je fais pour placer un bouton en bas à droite ?</div><br>
<br>
Qt "sait" quel est le widget à mettre en bas à droite en fonction des coordonnées des autres widgets. Le widget qui a les coordonnées les plus élevées sera placé en bas à droite.<br>
<br>
<br>
Petit test, rajoutons un bouton aux coordonnées (1, 1) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
<span class="cp">#include &lt;QGridLayout&gt;</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"les"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Zéros"</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton4</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"!!!"</span><span class="p">);</span></span>

    <span class="n">QGridLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QGridLayout</span><span class="p">;</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/115895.png" alt="Bouton en bas à droite"></div><br>
<br>
Si on veut, on peut aussi décaler le bouton encore plus en bas à droite dans une nouvelle ligne et une nouvelle colonne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/115896.png" alt="Bouton en bas à droite"></div><br>
<br>
C'est compris ? <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Un widget qui occupe plusieurs cases</h3><br>
<br>
L'avantage de la disposition en grille, c'est qu'on peut faire en sorte qu'un widget occupe plusieurs cases à la fois. On parle de <strong>spanning</strong> (ceux qui font du HTML doivent avoir entendu parler des attributs <span class="italique">rowspan </span>et <span class="italique">colspan </span>sur les tableaux).<br>
<br>
Pour faire cela, il faut appeler une version surchargée de addWidget qui accepte 2 paramètres supplémentaires : le rowSpan et le columnSpan.<br>
<br>
<ul>
<li>rowSpan : nombre de lignes qu'occupe le widget (par défaut 1)</li>
<li>columnSpan : nombre de colonnes qu'occupe le widget (par défaut 1)</li>
</ul><br>
<br>
Imaginons un widget placé en haut à gauche, aux coordonnées (0, 0). Si on lui donne un rowSpan de 2, il occupera alors l'espace suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/116329.png" alt="rowSpan"></div><br>
<br>
Si on lui donne un columnSpan de 3, il occupera cet espace :<br>
<br>
<div class="centre"><img src="./cpp_files/116330.png" alt="columnSpan"></div><br>
<br>
<div class="rmq information">L'espace pris par le widget au final dépend de la nature du widget (les boutons s'agrandissent en largeur mais pas en hauteur par exemple), et dépend du nombre de widgets sur la grille. En pratiquant vous allez rapidement comprendre comment ça fonctionne.</div><br>
<br>
Essayons de faire en sorte que le bouton "Zéros" prenne 2 colonnes de largeur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
<span class="cp">#include &lt;QGridLayout&gt;</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"les"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Zéros"</span><span class="p">);</span>

    <span class="n">QGridLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QGridLayout</span><span class="p">;</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span></span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notez la ligne : <span class="code2 cpp"><span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><br>
Les 2 derniers paramètres correspondent respectivement au rowSpan et au columnSpan. Le rowSpan est ici de 1, c'est la valeur par défaut on ne change donc rien, mais le columnSpan est de 2.<br>
<br>
Le bouton va donc "occuper" 2 colonnes :<br>
<br>
<div class="centre"><img src="./cpp_files/116063.png" alt="Spanning du bouton"></div><br>
<br>
<div class="rmq information">Essayez en revanche de monter le columnSpan à 3 : vous ne verrez aucun changement.<br>
En effet, il aurait fallu qu'il y ait un troisième widget sur la première ligne pour que le columnSpan puisse fonctionner.</div><br>
<br>
Faites des tests avec le spanning pour vous assurer que vous avez bien compris comment ça marche <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11304">Le layout de formulaire</h2>
		<div class="ss_part_texte">
		Le layout de formulaire <a href="http://doc.trolltech.com/qformlayout.html">QFormLayout</a> est un layout assez récent spécialement fait pour les fenêtres qui contiennent des formulaires.<br>
<br>
Un formulaire est en général une suite de libellés ("Votre prénom :") associés à des champs de formulaire (zone de texte par exemple) :<br>
<br>
<div class="centre"><img src="./cpp_files/116123.png" alt="Formulaire"></div><br>
<br>
Normalement, pour écrire du texte dans la fenêtre, on utilise le widget QLabel (libellé), dont on parlera plus en détail dans le prochain chapitre.<br>
<br>
L'avantage du layout que nous allons utiliser, c'est qu'il simplifie notre travail en créant automatiquement des QLabel pour nous.<br>
<br>
<div class="rmq information">Vous noterez d'ailleurs que la disposition correspond à celle d'un QGridLayout à 2 colonnes et plusieurs lignes. En effet, le QFormLayout n'est en fait rien d'autre qu'une version spéciale du QGridLayout pour les formulaires, avec quelques particularités : il s'adapte en fonction des habitudes des OS, pour certains les libellés sont alignés à gauche, pour d'autres ils sont alignés à droite, etc.</div><br>
<br>
<br>
L'utilisation d'un QFormLayout est très simple. La différence, c'est qu'au lieu d'utiliser une méthode addWidget, nous allons utiliser une méthode addRow qui prend 2 paramètres :<br>
<br>
<ul>
<li>Le texte du libellé</li>
<li>Un pointeur vers le champ du formulaire</li>
</ul><br>
<br>
Pour faire simple, nous allons créer 3 champs de formulaire de type "Zone de texte à une ligne" (QLineEdit), puis nous allons les placer dans un QFormLayout au moyen de la méthode addRow :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QLineEdit&gt;</span>
<span class="cp">#include &lt;QFormLayout&gt;</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">nom</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span>
    <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">prenom</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span>
    <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">age</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span>

    <span class="n">QFormLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFormLayout</span><span class="p">;</span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre nom"</span><span class="p">,</span> <span class="n">nom</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre prénom"</span><span class="p">,</span> <span class="n">prenom</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre âge"</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span></span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/116124.png" alt="Layout de formulaire"></div><br>
<br>
Sympa, non ? <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
On peut aussi définir des raccourcis clavier pour accéder rapidement aux champs du formulaire. Pour ce faire, placez un symbole "&amp;" devant la lettre du libellé que vous voulez transformer en raccourci.<br>
<br>
Explication en image (euh, en code) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3</pre></td><td class="code"><div class="syntax"><pre><span class="n">layout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre &amp;nom"</span><span class="p">,</span> <span class="n">nom</span><span class="p">);</span>
<span class="n">layout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre &amp;prénom"</span><span class="p">,</span> <span class="n">prenom</span><span class="p">);</span>
<span class="n">layout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre â&amp;ge"</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La lettre "p" est désormais un raccourci vers le champ du prénom.<br>
"n" pour le champ nom.<br>
"g" pour le champ âge.<br>
<br>
L'utilisation du raccourci dépend de votre système d'exploitation. Sous Windows, il faut faire Alt puis la touche raccourci.<br>
Lorsque vous appuyez sur Alt, les lettres raccourcis apparaissent soulignées :<br>
<br>
<div class="centre"><img src="./cpp_files/116128.png" alt="Raccourcis dans un form layout"></div><br>
<br>
Faites Alt + N pour accéder directement au champ du nom ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="rmq information">Souvenez-vous de ce symbole &amp;, il est très souvent utilisé en GUI Design (design de fenêtre) pour indiquer quelle lettre sert de raccourci. On le réutilisera notamment pour avoir des raccourcis dans les menus de la fenêtre.<br>
<br>
Ah, et si vous voulez par contre vraiment afficher un symbole &amp; dans un libellé, tapez-en deux : "&amp;&amp;". <br>
Exemple : "<span class="courrier">Bonnie &amp;&amp; Clyde</span>".</div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11303">Combiner les layouts</h2>
		<div class="ss_part_texte">
		Avant de terminer ce chapitre, il me semble important que nous jetions un oeil aux <strong>layouts combinés</strong>, une fonctionnalité qui va vous faire comprendre toute la puissance des layouts.<br>
Commençons comme il se doit par une question que vous devriez vous poser :<br>
<br>
<div class="rmq question">Les layouts c'est bien joli, mais c'est pas un peu limité ? Si je veux faire une fenêtre un peu complexe, ce n'est pas à grands coups de QVBoxLayout ou même de QGridLayout que je vais m'en sortir !</div><br>
<br>
C'est vrai que mettre ses widgets les uns en-dessous des autres peut sembler limité. Même la grille fait un peu "rigide", je reconnais.<br>
Mais rassurez-vous, tout a été pensé. La magie apparaît lorsque nous commençons à combiner les layouts, c'est-à-dire à <span class="souligne">placer un layout dans un autre layout</span>.<br>
<br>
<br>
<h3>Un cas concret</h3><br>
<br>
Prenons par exemple notre joli formulaire. Supposons que l'on veuille ajouter un bouton "Quitter". Si vous voulez placer ce bouton en bas du formulaire, comment faire ?<br>
<br>
Il va falloir d'abord créer un layout vertical (QVBoxLayout), et placer à l'intérieur notre layout de formulaire <span class="italique">puis </span>notre bouton "Quitter".<br>
<br>
Cela donne le schéma suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/116277.png" alt="Schéma des layouts combinés"></div><br>
<br>
On voit que notre QVBoxLayout contient 2 choses, dans l'ordre :<br>
<br>
<ol class="liste_1">
<li>Un QFormLayout (qui contient lui-même d'autres widgets)</li>
<li>Un QPushButton</li></ol><br>
<br>
Un layout peut donc contenir aussi bien des layouts que des widgets.<br>
<br>
<br>
<h3>Utilisation de addLayout</h3><br>
<br>
Pour insérer un layout dans un autre, on utilise addLayout au lieu de addWidget (c'est logique me direz-vous <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ).<br>
<br>
Voici un bon petit code pour se faire la main :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QLineEdit&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
<span class="cp">#include &lt;QVBoxLayout&gt;</span>
<span class="cp">#include &lt;QFormLayout&gt;</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="c">// Création du layout de formulaire et de ses widgets</span>

    <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">nom</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span>
    <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">prenom</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span>
    <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">age</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span>

    <span class="n">QFormLayout</span> <span class="o">*</span><span class="n">formLayout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFormLayout</span><span class="p">;</span>
    <span class="n">formLayout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre &amp;nom"</span><span class="p">,</span> <span class="n">nom</span><span class="p">);</span>
    <span class="n">formLayout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre &amp;prénom"</span><span class="p">,</span> <span class="n">prenom</span><span class="p">);</span>
    <span class="n">formLayout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre â&amp;ge"</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>


    <span class="c">// Création du layout principal de la fenêtre (vertical)</span>

    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layoutPrincipal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
<span class="ln-xtra">    <span class="n">layoutPrincipal</span><span class="o">-&gt;</span><span class="n">addLayout</span><span class="p">(</span><span class="n">formLayout</span><span class="p">);</span> <span class="c">// Ajout du layout de formulaire</span></span>

    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">boutonQuitter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Quitter"</span><span class="p">);</span>
    <span class="n">QWidget</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">boutonQuitter</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="o">&amp;</span><span class="n">app</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>
<span class="ln-xtra">    <span class="n">layoutPrincipal</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">boutonQuitter</span><span class="p">);</span> <span class="c">// Ajout du bouton</span></span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layoutPrincipal</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
J'ai surligné les ajouts au layout vertical principal :<br>
<br>
<ul>
<li>L'ajout du sous-layout de formulaire (addLayout)</li>
<li>L'ajout du bouton (addWidget)</li>
</ul><br>
<br>
Vous remarquerez que je fais les choses un peu dans l'ordre inverse : d'abord je crée les widgets et layouts "enfants" (le QFormLayout), et ensuite je crée le layout principal (le QVBoxLayout) et j'y ajoute le layout enfant que j'ai créé.<br>
<br>
Au final, la fenêtre qui apparaît est la suivante :<br>
<br>
<div class="centre"><img src="./cpp_files/116278.png" alt="Layouts combinés"></div><br>
<br>
On ne le voit pas, mais la fenêtre contient d'abord un QVBoxLayout, qui contient lui-même un layout de formulaire et un bouton :<br>
<br>
<div class="centre"><img src="./cpp_files/116279.png" alt="Layouts combinés (schéma)"></div><br>
<br>
<br>
<h3>Exercice</h3><br>
<br>
Essayez d'obtenir le rendu suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/116280.png" alt="Exercice des layouts"></div><br>
<br>
<br>
Si vous voulez mettre plusieurs boutons en bas sur la même ligne, vous pouvez créer un QHBoxLayout et ajouter ce QHBoxLayout au QVBoxLayout !<br>
Vous pouvez aussi utiliser plus simplement un QGridLayout en utilisant un columnSpan. En effet, un QGridLayout n'est rien d'autre qu'un assemblage de QVBoxLayout et de QHBoxLayout.<br>
<br>
Plusieurs méthodes sont donc possibles, libre à vous d'utiliser un QGridLayout ou des QVBoxLayout et QHBoxLayout.<br>
<br>
Ce ne devrait pas être un exercice difficile si vous avez bien suivi ce chapitre. Ce sera en tout cas l'occasion de vous assurer que vous avez bien compris <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="rmq information">Dans mon exemple, les boutons "Aide" et "Envoyer" ne font rien (je n'ai pas géré de signaux et de slots pour eux). Le résultat que vous devez obtenir est juste visuel, n'essayez pas de tenter d'envoyer le formulaire sur internet et de le stocker dans une base de données, il est un peu trop tôt encore <img src="./cpp_files/langue.png" alt=":p" class="smilies"></div>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Les layouts sont la base du positionnement de widgets en GUI Design. Ils nous donnent un maximum de flexibilité pour que nos fenêtres s'adaptent à toutes les conditions.<br>
<br>
Bien entendu, je vous mentirais si je vous disais qu'absolument tout le monde les utilise. Pour certains logiciels simples, il n'est parfois pas nécessaire de recourir aux layouts. Il est néanmoins recommandé de s'en servir autant que possible.<br>
<br>
Nous n'avons pas pu absolument <span class="italique">tout </span>voir à propos des layouts. La différence, c'est que maintenant je vous ai appris à vous servir de la doc et vous pouvez aller compléter ce que vous savez si besoin est.<br>
<br>
<div class="rmq information">Je vous recommande de lire leur page d'<a href="http://doc.trolltech.com/layout.html">explication générale sur les layouts</a> puis de regarder les différentes classes de layouts. <span class="souligne">N'oubliez pas de consulter les classes parentes</span> à chaque fois, ce sont souvent elles qui contiennent les méthodes et attributs qui semblent manquer.<br>
Jetez un oeil aux "stretch factors", qui permettent de définir des tailles proportionnelles pour les widgets, ainsi qu'à l'alignement des widgets.</div><br>
<br>
Dans le prochain chapitre, nous passerons en revue la plupart des widgets courants et simples. En effet, cela fait un moment que je vous fais utiliser pour le besoin du cours quelques widgets comme les boutons et les champs de texte, mais il est maintenant temps de faire un tour d'horizon plus général pour que vous sachiez quels sont les principaux widgets qui peuvent peupler une fenêtre.
	</div>
	
	<hr>
	<h1 id="chap_11316">Les principaux widgets</h1>
	<div id="chap_intro">
	Voilà un moment que nous avons commencé à nous intéresser à Qt, je vous parle en long en large et en travers de widgets, mais jusqu'ici nous n'avions toujours pas pris le temps de faire un tour d'horizon rapide de ce qui existait.<br>
<br>
C'était voulu. Je voulais dans un premier temps vous faire manipuler un ou deux widgets simples pour vous faire comprendre les concepts de base comme :<br>
<ul>
<li>La création de la fenêtre</li>
<li>Les signaux et les slots</li>
<li>Les layouts</li>
</ul><br>
Il est maintenant temps de faire une "pause" et de regarder ce qui existe comme widgets. Nous étudierons cependant seulement les principaux widgets ici.<br>
<br>
Pourquoi ne les verrons-nous pas tous ? Parce qu'il existe un grand nombre de widgets et que certains sont rarement utilisés. D'autres sont parfois tellement complexes qu'ils nécessiteront un chapitre entier pour les étudier.<br>
<br>
Néanmoins, avec ce que vous allez voir, vous aurez largement de quoi faire pour être capables de créer la quasi-totalité des fenêtres que vous voulez ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<div class="rmq information">Pour information, je me base sur la page "<a href="http://doc.trolltech.com/gallery-windowsvista.html">liste des widgets</a>" (ici avec l'apparence de vista, mais peu importe l'apparence, ça sera adapté à votre OS).<br>
Je ne compte pas remplacer la doc. Je vous inviterai donc à consulter la doc à chaque fois pour en savoir plus. Mon rôle sera surtout de vous introduire à utiliser de manière basique ces widgets. Je vous fais confiance, je sais que vous saurez en faire une utilisation plus avancée si besoin est. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div>
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11315">Les fenêtres</h2>
		<div class="ss_part_texte">
		Avec Qt, tout élément de la fenêtre est appelé un <strong>widget</strong>. <span class="souligne">La fenêtre elle-même est considérée comme un widget.</span><br>
<br>
Dans le code, les widgets sont des classes qui héritent toujours de <a href="http://doc.trolltech.com/qwidget.html">QWidget</a> (directement ou indirectement). C'est donc une classe de base très importante, et vous aurez probablement très souvent besoin de lire la doc de cette classe.<br>
<br>
<br>
<h3>Quelques rappels sur l'ouverture d'une fenêtre</h3><br>
<br>
Cela fait plusieurs chapitres que l'on crée une fenêtre dans nos programmes à l'aide d'un objet de type QWidget. Cela signifie-t-il que QWidget = Fenêtre ?<br>
<br>
Non. En fait, <span class="souligne">un widget qui n'est contenu dans aucun autre widget est considéré comme une fenêtre</span>.<br>
Donc quand on fait juste ce code très simple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QWidget&gt;</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... cela affiche une fenêtre (vide) :<br>
<br>
<div class="centre"><img src="./cpp_files/116448.png" alt="Fenêtre vide"></div><br>
<br>
C'est comme cela que Qt fonctionne. C'est un peu déroutant au début, mais après on apprécie au contraire que ça ait été pensé comme ça.<br>
<br>
<br>
<div class="rmq question">Donc si je comprends bien, il n'y a pas de classe QFenetre ou quelque chose du genre ?</div><br>
<br>
Tout à fait, il n'y a pas de classe du genre "QFenetre" car n'importe quel widget peut servir de fenêtre. Si vous vous souvenez bien, on avait créé un bouton dans les premiers exemples du cours sur Qt. On avait demandé à afficher ce bouton.<br>
Comme le bouton n'avait pas de parent, une fenêtre avait été ouverte :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>
 
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
 
    <span class="n">QPushButton</span> <span class="n">bouton</span><span class="p">(</span><span class="s">"Salut les Zéros, la forme ?"</span><span class="p">);</span>
    <span class="n">bouton</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
 
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/116449.png" alt="Fenêtre bouton"></div><br>
<br>
Dans la pratique, on ne crée pas de fenêtre-bouton comme là. On crée d'abord une fenêtre, et on place ensuite des widgets à l'intérieur (ces widgets étant parfois organisés grâce aux layouts comme on l'a vu).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QWidget&gt;</span>
<span class="cp">#include &lt;QPushButton&gt;</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>
<span class="ln-xtra">    <span class="n">QPushButton</span> <span class="n">bouton</span><span class="p">(</span><span class="s">"Salut les Zéros, la forme ?"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span></span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Note : je n'ai pas utilisé de layouts dans ce code pour le rendre court et simple. Le bouton est donc positionné de manière absolue au coin en haut à gauche, de coordonnées (0, 0).</div><br>
<br>
<div class="centre"><img src="./cpp_files/116450.png" alt="Fenêtre bouton"></div><br>
<br>
Le QPushButton a donc pour parent un QWidget, car on a indiqué en second paramètre de son constructeur un pointeur vers le QWidget : <span class="code2 cpp"><span class="o">&amp;</span><span class="n">fenetre</span>
</span>.<br>
Le QWidget n'a pas de parent car on n'a pas envoyé de pointeur vers un autre widget dans son constructeur, donc c'est une fenêtre.<br>
<br>
<div class="rmq erreur">Ne confondez pas :<br>
<ul>
<li><strong>En termes C++</strong> : une classe parente est une classe mère (quand on fait un héritage).</li>
<li><strong>En termes Qt</strong> : un widget parent est un widget qui en contient d'autres. Un widget fils est un widget qui n'en contient aucun autre.</li>
</ul><br>
Ici, je suis en train de parler de widgets parents en termes Qt.</div><br>
<br>
<br>
<h3>Quelques classes particulières pour les fenêtres</h3><br>
<br>
Résumons ce que je viens de dire : tout widget peut servir de fenêtre.<br>
C'est le widget qui n'a pas de parent qui sera considéré comme étant la fenêtre.<br>
<br>
A ce titre, un QPushButton ou un QLineEdit peuvent être considérés comme des fenêtres s'ils n'ont pas de widget parent.<br>
<br>
Toutefois, il y a 2 classes de widgets que j'aimerais mettre en valeur :<br>
<br>
<ul>
<li><strong>QMainWindow </strong>: c'est un widget spécial qui permet de créer la fenêtre principale de l'application. Une fenêtre principale peut contenir des menus, une barre d'outils, une barre d'état, etc.</li>
<li><strong>QDialog </strong>: c'est une classe de base utilisée par toutes les classes de boîtes de dialogue qu'on a vues il y a quelques chapitres. On peut aussi s'en servir directement pour ouvrir des boîtes de dialogue personnalisées.</li>
</ul><br>
<br>
La fenêtre principale QMainWindow mérite un chapitre entier à elle toute seule. Et elle en aura un. Nous pourrons alors tranquillement passer en revue la gestion des menus, de la barre d'outils et de la barre d'état.<br>
<br>
La fenêtre QDialog peut être utilisée pour ouvrir une boîte de dialogue personnalisée générique. Une boîte de dialogue est une fenêtre généralement de petite taille dans laquelle il y a peu d'informations.<br>
La classe QDialog hérite de QWidget comme tout widget qui se respecte, et elle y est même très similaire. Elle y ajoute peu de choses, parmi lesquelles la gestion des <span class="italique">fenêtres modales</span> (une fenêtre par-dessus toutes les autres qui doit être remplie avant de pouvoir accéder aux autres fenêtres de l'application).<br>
<br>
<br>
Nous allons ici étudier ce que l'on peut faire d'intéressant avec la classe de base QWidget qui permet déjà de réaliser la plupart des fenêtres que l'on veut.<br>
Nous verrons ensuite ce qu'on peut faire avec les fenêtres de type QDialog. Quant à QMainWindow, ce sera pour un autre chapitre comme je vous l'ai dit. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Une fenêtre avec QWidget</h3><br>
<br>
Pour commencer, je vous invite à ouvrir la <a href="http://doc.trolltech.com/qwidget.html">doc de QWidget</a> en même temps que vous lisez ce chapitre.<br>
<br>
Vous remarquerez que QWidget est la classe mère d'un grrrrand nombre d'autres classes. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Les QWidget disposent de beaucoup de propriétés et de méthodes. Donc tous les widgets disposent de ces propriétés et méthodes.<br>
<br>
On peut découper les propriétés en 2 catégories :<br>
<br>
<ul>
<li>Celles qui valent pour tous les types de widgets et pour les fenêtres</li>
<li>Celles qui n'ont de sens que pour les fenêtres</li>
</ul><br>
Jetons un oeil à celles qui me semblent les plus intéressantes. Pour avoir la liste complète, il faudra recourir à la doc, je ne compte pas tout répéter ici ! <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<br>
<h4>Les propriétés utilisables pour tous les types de widgets, y compris les fenêtres</h4><br>
<br>
Je vous fais une liste rapide pour extraire quelques propriétés qui pourraient vous intéresser. Pour savoir comment vous servir de toutes ces propriétés, lisez le prototype que vous donne la doc.<br>
<br>
<div class="rmq information">N'oubliez pas qu'on peut modifier une propriété en appelant une méthode du même nom commençant par "set". Par exemple, si la propriété est cursor, la méthode sera setCursor().</div><br>
<br>
<ul>
<li><strong>cursor </strong>: curseur de la souris à afficher lors du survol du widget. La méthode setCursor attend que vous lui envoyiez un objet de type QCursor. Certains curseurs classiques (comme le sablier) sont prédéfinis dans une énumération. La doc vous fait un lien vers cette énumération.</li>
<li><strong>enabled </strong>: indique si le widget est activé, si on peut le modifier. Un widget désactivé est généralement grisé. Si vous appliquez setEnabled(false) à toute la fenêtre, c'est toute la fenêtre qui deviendra inutilisable.</li>
<li><strong>height </strong>: hauteur du widget.</li>
<li><strong>size </strong>: dimensions du widget. Vous devrez indiquer la largeur et la hauteur.</li>
<li><strong>visible </strong>: contrôle la visibilité du widget.</li>
<li><strong>width </strong>: largeur.</li>
</ul><br>
<br>
N'oubliez pas : pour modifier une de ces propriétés, préfixez la méthode par un "set". Exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">maFenetre</span><span class="p">.</span><span class="n">setWidth</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ces propriétés sont donc valables pour tous les widgets, y compris les fenêtres. Si vous appliquez un setWidth sur un bouton, ça modifiera la largeur du bouton. Si vous appliquez cela sur une fenêtre, c'est la largeur de la fenêtre qui sera modifiée.<br>
<br>
<br>
<h4>Les propriétés utilisables uniquement sur les fenêtres</h4><br>
<br>
Ces propriétés sont faciles à reconnaître, elles commencent toutes par "window".<br>
Elles n'ont de sens que si elles sont appliquées aux fenêtres.<br>
<br>
<ul>
<li><strong>windowFlags </strong>: une série d'options contrôlant le comportement de la fenêtre. Il faut consulter l'énumération <a href="http://doc.trolltech.com/qt.html#WindowType-enum">Qt::WindowType</a> pour savoir les différents types disponibles. Vous pouvez aussi consulter l'exemple Window Flags du programme "Qt Examples and Demos".<br>
<br>
Par exemple pour afficher une fenêtre de type "Outil" avec une petite croix et pas de possibilité d'agrandissement ou de réduction :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">fenetre</span><span class="p">.</span><span class="n">setWindowFlags</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Tool</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/116466.png" alt="Window flags"><br>
<span class="italique">Une fenêtre de type "Tool"</span></div><br>
<br>
C'est par là aussi qu'on passe pour que la fenêtre reste par-dessus toutes les autres fenêtres du système (avec le flag Qt::WindowStaysOnTopHint).<br>
<br>
</li>
<li><strong>windowIcon </strong>: l'icône de la fenêtre. Il faut envoyer un objet de type QIcon, qui lui-même accepte un nom de fichier à charger. Cela donne le code suivant pour charger le fichier <a href="http://uploads.siteduzero.com/files/116001_117000/116470.png">icone.png</a> situé dans le même dossier que l'application :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">fenetre</span><span class="p">.</span><span class="n">setWindowIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"icone.png"</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/116468.png" alt="Icône de fenêtre"><br>
<span class="italique">Une icône pour la fenêtre</span></div><br>
<br>
</li>
<li><strong>windowOpacity </strong>: contrôle la transparence de la fenêtre (ne fonctionne pas sur tous les OS). La valeur à envoyer est un nombre décimal compris entre 0 (transparent) et 1 (complètement opaque).<br>
Ici, avec la valeur 0.8 :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">fenetre</span><span class="p">.</span><span class="n">setWindowOpacity</span><span class="p">(</span><span class="mf">0.8</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/116471.png" alt="Transparence"><br>
<span class="italique">Une fenêtre transparente</span></div><br>
<br>
</li>
<li><strong>windowTitle </strong>: le titre de la fenêtre, affiché en haut.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">fenetre</span><span class="p">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s">"Le Programme du Zéro v0.0"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><br>
<img src="./cpp_files/116472.png" alt="Titre de la fenêtre"><br>
<span class="italique">Une fenêtre avec un titre</span></div><br>
</li>
</ul><br>
<br>
<h3>Une fenêtre avec QDialog</h3><br>
<br>
<a href="http://doc.trolltech.com/qdialog.html">QDialog</a> est un widget spécialement créé pour générer des fenêtres de type "boîte de dialogue".<br>
<br>
<div class="rmq question">Quelle est la différence avec une fenêtre créée à partir d'un QWidget ? <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> </div><br>
<br>
En général les QDialog sont des petites fenêtres secondaires : des boîtes de dialogue.<br>
Elles proposent le plus souvent un choix simple entre :<br>
<br>
<ul>
<li>Valider</li>
<li>Annuler</li>
</ul><br>
Les QDialog sont rarement utilisées pour gérer la fenêtre principale. Pour la fenêtre principale on préfère utiliser QWidget, ou carrément QMainWindow si on a besoin de l'artillerie lourde.<br>
<br>
Les QDialog peuvent être de 2 types :<br>
<br>
<ul>
<li><strong>Modales </strong>: on ne peut pas accéder aux autres fenêtres de l'application lorsqu'elles sont ouvertes.</li>
<li><strong>Non modales</strong> : on peut toujours accéder aux autres fenêtres.</li>
</ul><br>
Par défaut, les QDialog sont modales.<br>
Elles disposent en effet d'une méthode exec() qui ouvre la boîte de dialogue de manière modale. Il s'avère d'ailleurs qu'exec() est un slot (très pratique pour effectuer une connexion ça !).<br>
<br>
Je vous propose d'essayer de pratiquer de la manière suivante : nous allons ouvrir une fenêtre principale QWidget qui contiendra un bouton. Lorsqu'on cliquera sur ce bouton, il ouvrira une fenêtre secondaire de type QDialog.<br>
<br>
<br>
Notre objectif est d'ouvrir une fenêtre secondaire après un clic sur un bouton de la fenêtre principale.<br>
La fenêtre secondaire, de type QDialog, affichera juste une image pour cet exemple.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>
        <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Ouvrir la fenêtre"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>


<span class="ln-xtra">    <span class="n">QDialog</span> <span class="n">secondeFenetre</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span></span>
        <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
        <span class="n">QLabel</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLabel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">secondeFenetre</span><span class="p">);</span>
        <span class="n">image</span><span class="o">-&gt;</span><span class="n">setPixmap</span><span class="p">(</span><span class="n">QPixmap</span><span class="p">(</span><span class="s">"icone.png"</span><span class="p">));</span>
        <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
        <span class="n">secondeFenetre</span><span class="p">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>


<span class="ln-xtra">    <span class="n">QWidget</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">bouton</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="o">&amp;</span><span class="n">secondeFenetre</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">exec</span><span class="p">()));</span></span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<div class="rmq information">Mon code est indenté de manière bizarroïde je sais. Je trouve que c'est plus lisible : vous pouvez mieux voir comme cela à quelles fenêtres se rapportent les opérations que je fais.<br>
Vous voyez ainsi immédiatement que dans la première fenêtre je n'ai fait que placer un bouton, tandis que dans la seconde j'ai mis un QLabel affichant une image que j'ai placée dans un QVBoxLayout.<br>
<br>
D'autre part, j'ai tout fait dans le main pour cet exemple, mais dans la pratique, comme nous le verrons dans les TP, on a en général un fichier .cpp par fenêtre, c'est plus facile à gérer.</div><br>
<br>
Au départ, la fenêtre principale s'affiche, comme ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/116899.png" alt="QDialog"></div><br>
<br>
Si vous cliquez sur le bouton, la boîte de dialogue s'ouvre :<br>
<br>
<div class="centre"><img src="./cpp_files/116900.png" alt="QDialog"></div><br>
<br>
Comme elle est modale, vous remarquerez que vous ne pouvez pas accéder à la fenêtre principale tant qu'elle est ouverte.<br>
<br>
Bon intéressons-nous au code. J'ai surligné les 2 lignes qui me paraissaient les plus pertinentes :<br>
<br>
<ul>
<li><strong>Ligne 12</strong> : la création de la QDialog. Rien de bien extraordinaire à première vue, mais si vous regardez bien vous devriez voir que j'ai mentionné dans le constructeur l'adresse de la fenêtre parente. Cela permet à la QDialog de savoir quelle est la fenêtre qui l'a appelée. Entre autres choses, la QDialog se placera automatiquement de manière centrée par rapport à sa fenêtre mère.</li>
<li><strong>Ligne 20</strong> : je connecte le clic sur le bouton à la méthode exec() de la QDialog pour ouvrir la boîte de dialogue (de manière modale).</li>
</ul><br>
Cela devrait vous donner des bases suffisantes pour désormais savoir comment ouvrir des fenêtres secondaires de type QDialog. Nous n'avons cependant pas tout vu sur cette classe : on peut rendre les QDialog non modales ou encore utiliser les slots accept() et reject() pour les connecter respectivement à des boutons "OK" et "Annuler" et ainsi informer la fenêtre parente afin qu'elle sache si l'opération a été validée ou refusée par l'utilisateur.<br>
<br>
Pour savoir faire tout cela, vous savez ce qu'il vous reste à faire. Tout est dans la doc. <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11314">Les boutons</h2>
		<div class="ss_part_texte">
		Nous allons maintenant étudier la catégorie des widgets "boutons". Nous allons passer en revue :<br>
<br>
<ul>
<li><strong>QPushButton </strong>: un bouton classique, que vous avez déjà largement eu l'occasion de manipuler.</li>
<li><strong>QRadioButton </strong>: un bouton "radio", pour un choix à faire parmi une liste.</li>
<li><strong>QCheckBox </strong>: une case à cocher (on considère que c'est un bouton en GUI Design).</li>
</ul><br>
<br>
Tous ces widgets héritent de <a href="http://doc.trolltech.com/qabstractbutton.html">QAbstractButton</a> qui lui-même hérite de QWidget, qui finalement hérite de QObject :<br>
<br>
<div class="centre"><img src="./cpp_files/116334.png" alt="Schéma héritage des boutons"></div><br>
<br>
Comme l'indique son nom, QAbstractButton est une classe abstraite. Si vous vous souvenez des épisodes précédents de notre passionnant feuilleton, une classe abstraite est une classe... qu'on ne peut pas instancier, bravo ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
On ne peut donc pas créer d'objets de type QAbstractButton, il faut forcément utiliser une des classes filles. QAbstractButton sert donc juste de modèle de base pour ses classes filles.<br>
<br>
<br>
<h3>QPushButton : un bouton</h3><br>
<br>
Le <a href="http://doc.trolltech.com/qpushbutton.html">QPushButton</a> est l'élément le plus classique et le plus commun des fenêtres :<br>
<br>
<div class="centre"><img src="./cpp_files/116331.png" alt="QPushButton"></div><br>
<br>
Je ne vous fais pas l'offense de vous expliquer à quoi sert un bouton <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Commençons par un rappel important, indiqué par la doc : QPushButton hérite de <a href="http://doc.trolltech.com/qabstractbutton.html">QAbstractButton</a>. Et c'est vraiment une info importante, car vous serez peut-être surpris de voir que QPushButton contient peu de méthodes qui lui sont propres. C'est normal, une grande partie d'entre elles se trouvent dans sa classe parente QAbstractButton.<br>
<br>
<div class="rmq attention">Il faudra donc absolument consulter aussi QAbstractButton, et même sa classe mère <a href="http://doc.trolltech.com/qwidget.html">QWidget</a> (et éventuellement aussi QObject mais c'est plus rare), si vous voulez connaître toutes les possibilités offertes au final par un QPushButton.<br>
Par exemple, <a href="http://doc.trolltech.com/qwidget.html#enabled-prop">setEnabled</a> permet d'activer / désactiver le bouton, et cette propriété se trouve dans QWidget.</div><br>
<br>
<br>
<h4>Les signaux du bouton</h4><br>
<br>
Un bouton émet un signal clicked() quand on l'active. C'est le signal le plus communément utilisé.<br>
<br>
On note aussi les signaux pressed() (bouton enfoncé) et released() (bouton relâché), mais ils sont plus rares.<br>
<br>
<br>
<h4>Les boutons à 2 états</h4><br>
<br>
Un bouton peut parfois avoir 2 états : enfoncé et relâché (normal).<br>
<br>
Pour activer un bouton à 2 états, utilisez setCheckable(true) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Bouton"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
<span class="n">bouton</span><span class="o">-&gt;</span><span class="n">setCheckable</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Désormais, un clic sur le bouton le laissera enfoncé, et un nouveau clic le rétablira dans son état normal. Utilisez les signaux pressed() et released() pour récupérer les changements d'état du bouton.<br>
<br>
<div class="centre"><img src="./cpp_files/116476.png" alt="Bouton checked"><br>
<span class="italique">A gauche un bouton normal, à droite un bouton pressé</span></div><br>
<br>
<br>
<h3>QCheckBox : une case à cocher</h3><br>
<br>
Une case à cocher <a href="http://doc.trolltech.com/qcheckbox.html#details">QCheckBox</a> est généralement associée à un texte de libellé comme ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/116477.png" alt="Case à cocher"></div><br>
<br>
On définit le libellé de la case lors de l'appel du constructeur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QWidget&gt;</span>
<span class="cp">#include &lt;QCheckBox&gt;</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>
<span class="ln-xtra">    <span class="n">QCheckBox</span> <span class="o">*</span><span class="n">checkbox</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="s">"J'aime les frites"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span></span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La case à cocher émet le signal stateChanged(bool) lorsqu'on modifie son état. Le booléen en paramètre nous permet de savoir si la case est maintenant cochée ou décochée.<br>
<br>
Si vous voulez vérifier à un autre moment si la case est cochée, appelez isChecked() qui renvoie un booléen.<br>
<br>
On peut aussi faire des cases à cocher à 3 états (le troisième état étant l'état grisé). Renseignez-vous sur la propriété tristate pour savoir faire cela. Notez que ce type de case à cocher est relativement rare.<br>
<br>
Enfin, sachez que si vous avez plusieurs cases à cocher, vous pouvez les regrouper au sein d'une <a href="http://doc.trolltech.com/qgroupbox.html">QGroupBox</a>.<br>
<br>
<br>
<h3>QRadioButton : les boutons radio</h3><br>
<br>
C'est une case à cocher particulière : une seule case peut être cochée à la fois parmi une liste.<br>
<br>
<div class="centre"><img src="./cpp_files/116482.png" alt="Radio button"></div><br>
<br>
Les radio buttons qui ont le même widget parent sont mutuellement exclusifs. Si vous en cochez un, les autres seront automatiquement décochés.<br>
<br>
En général, on place les radio buttons dans une QGroupBox. Utiliser des QGroupBox différentes vous permet de séparer les groupes de radio buttons.<br>
<br>
Voici un exemple d'utilisation d'une QGroupBox (qui contient un layout, qui contient les QRadioButton) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">QGroupBox</span> <span class="o">*</span><span class="n">groupbox</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QGroupBox</span><span class="p">(</span><span class="s">"Votre plat préféré"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>

    <span class="n">QRadioButton</span> <span class="o">*</span><span class="n">steacks</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QRadioButton</span><span class="p">(</span><span class="s">"Les steacks"</span><span class="p">);</span>
    <span class="n">QRadioButton</span> <span class="o">*</span><span class="n">hamburgers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QRadioButton</span><span class="p">(</span><span class="s">"Les hamburgers"</span><span class="p">);</span>
    <span class="n">QRadioButton</span> <span class="o">*</span><span class="n">nuggets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QRadioButton</span><span class="p">(</span><span class="s">"Les nuggets"</span><span class="p">);</span>

    <span class="n">steacks</span><span class="o">-&gt;</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">vbox</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
    <span class="n">vbox</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">steacks</span><span class="p">);</span>
    <span class="n">vbox</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">hamburgers</span><span class="p">);</span>
    <span class="n">vbox</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">nuggets</span><span class="p">);</span>

    <span class="n">groupbox</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">vbox</span><span class="p">);</span>
    <span class="n">groupbox</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">J'en profite pour signaler que vous pouvez inclure QtGui pour automatiquement inclure tous les widgets : <span class="code2 cpp"><span class="cp">#include &lt;QtGui&gt;</span>
</span><br>
C'est un peu bourrin mais ça marche. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Cela vous évite d'avoir à rajouter un nouveau widget à la liste des includes à chaque fois. Attention par contre, la compilation sera un peu plus longue.</div><br>
<br>
Les radio buttons sont placés dans un layout qui est lui-même placé dans la groupbox, qui est elle-même placée dans la fenêtre. Pfiou ! Le concept des widgets conteneurs est ici utilisé à fond !<br>
Et encore, je n'ai pas fait de layout pour la fenêtre (la flême, et je ne voulais pas trop encombrer le code), ce qui fait que la taille initiale de la fenêtre est un peu petite, mais ce n'est pas grave c'est pour l'exemple.<br>
<br>
Voilà le résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/116489.png" alt="Plusieurs radio buttons"></div><br>
<br>
<span class="italique">Nota </span>: j'ai une nourriture plus équilibrée que ne le laisse suggérer cette dernière capture d'écran quand même, je vous rassure. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11313">Les afficheurs</h2>
		<div class="ss_part_texte">
		Parmi les widgets afficheurs, on compte principalement :<br>
<br>
<ul>
<li><strong>QLabel </strong>: le plus important, un widget permettant d'afficher du texte ou une image.</li>
<li><strong>QProgressBar </strong>: une barre de progression.</li>
</ul><br>
<br>
Etudions-les en choeur, sans heurts, dans la joie et la bonne humeur. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
<br>
<h3>QLabel : afficher du texte ou une image</h3><br>
<br>
C'est vraiment LE widget de base pour afficher du texte à l'intérieur de la fenêtre. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Nous l'avons déjà utilisé indirectement auparavant, via les cases à cocher ou encore les layouts de formulaire.<br>
<br>
Voici un libellé :<br>
<br>
<div class="centre"><img src="./cpp_files/116494.png" alt="QLabel"></div><br>
<br>
... du moins, UN des types de libellés possibles comme nous allons le voir.<br>
<br>
<div class="rmq information"><a href="http://doc.trolltech.com/qlabel.html">QLabel</a> hérite de <a href="http://doc.trolltech.com/qframe.html">QFrame</a>, qui est un widget de base permettant d'afficher des bordures. Renseignez-vous auprès de QFrame pour savoir gérer les différents types de bordure.<br>
Par défaut, un QLabel n'a pas de bordure.</div><br>
<br>
Un QLabel peut afficher plusieurs types d'éléments :<br>
<br>
<ul>
<li>Du texte simple,</li>
<li>Du texte enrichi (gras, italique, souligné, coloré, avec des liens...),</li>
<li>Une image,</li>
<li>Et même une image animée !</li>
</ul><br>
Nous allons étudier chacun de ces types de contenu, à l'exception de l'image animée qui sort un peu du cadre du chapitre. Et puis de toute façon, ça ne sert qu'à afficher en pratique des GIF animés, ça nous sera donc peu utile.<br>
<br>
<br>
<h4>Afficher un texte simple</h4><br>
<br>
Rien de plus simple, on utilise setText() :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">label</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="s">"Bonjour les Zéros !"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Mais on peut aussi afficher un texte simple dès l'appel au constructeur comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

<span class="ln-xtra">    <span class="n">QLabel</span> <span class="o">*</span><span class="n">label</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLabel</span><span class="p">(</span><span class="s">"Bonjour les Zéros !"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span></span>
    <span class="n">label</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le résultat est le même que la capture d'écran que je vous ai montrée plus haut :<br>
<br>
<div class="centre"><img src="./cpp_files/116494.png" alt="QLabel"></div><br>
<br>
Vous pouvez jeter aussi un oeil à la propriété alignment qui permet de définir l'alignement du texte dans le libellé.<br>
<br>
<br>
<h4>Afficher un texte enrichi</h4><br>
<br>
Vous pouvez envoyer du texte enrichi (formaté) au QLabel, avec du HTML :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="n">QLabel</span> <span class="o">*</span><span class="n">label</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLabel</span><span class="p">(</span><span class="s">"Bonjour les &lt;strong&gt;Zéros&lt;/strong&gt; !&lt;br /&gt;Etes-vous allés sur le &lt;a href=</span><span class="se">\"</span><span class="s">http://www.siteduzero.com</span><span class="se">\"</span><span class="s">&gt;Site du Zéro&lt;/a&gt; aujourd'hui ?"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
    <span class="n">label</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Magie, magie, le texte est correctement mis en forme !<br>
<br>
<div class="centre"><img src="./cpp_files/116498.png" alt="Label avec du HTML"></div><br>
<br>
C'est beau la technologie quand même. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
Et encore, vous n'avez pas tout vu !<br>
<br>
<br>
<h4>Afficher une image</h4><br>
<br>
Vous pouvez demander à ce que le QLabel affiche une image.<br>
Comme il n'y a pas de constructeur qui accepte une image en paramètre, on va appeler le constructeur qui prend juste un pointeur vers la fenêtre parente.<br>
<br>
Nous demanderons ensuite à ce que le libellé affiche une image à l'aide de setPixmap().<br>
Cette méthode attend un objet de type <a href="http://doc.trolltech.com/qpixmap.html">QPixmap</a>. Après lecture de la doc sur QPixmap, il s'avère que cette classe a un constructeur qui accepte le nom du fichier à charger sous forme de chaîne de caractères.<br>
<br>
Nous allons donc afficher notre belle icône de tout à l'heure, mais cette fois en grand et dans la fenêtre :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="n">QLabel</span> <span class="o">*</span><span class="n">label</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLabel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
    <span class="n">label</span><span class="o">-&gt;</span><span class="n">setPixmap</span><span class="p">(</span><span class="n">QPixmap</span><span class="p">(</span><span class="s">"icone.png"</span><span class="p">));</span>
    <span class="n">label</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
L'icône doit se trouver dans le même dossier que l'exécutable pour que cela fonctionne.<br>
<br>
Et voilà le résultat !<br>
<br>
<div class="centre"><img src="./cpp_files/116509.png" alt="Une image dans un label"></div><br>
<br>
<br>
<h3>QProgressBar : une barre de progression</h3><br>
<br>
Les barres de progression sont gérées par <a href="http://doc.trolltech.com/qprogressbar.html">QProgressBar</a>. Cela permet d'indiquer à l'utilisateur l'avancement des opérations.<br>
<br>
<div class="centre"><img src="./cpp_files/116522.png" alt="QProgressBar"></div><br>
<br>
Voici quelques propriétés utiles de la barre de progression :<br>
<br>
<ul>
<li><strong>maximum </strong>: la valeur maximale que peut prendre la barre de progression.</li>
<li><strong>minimum </strong>: la valeur minimale que peut prendre la barre de progression.</li>
<li><strong>value </strong>: la valeur actuelle de la barre de progression.</li>
</ul><br>
On utilisera donc setValue pour changer la valeur de la barre de progression. Par défaut les valeurs sont comprises entre 0 et 100%.<br>
<br>
<div class="rmq information">Qt ne peut pas deviner où en sont vos opérations. C'est à vous de calculer le pourcentage d'avancement de vos opérations. La QProgressBar se contente juste d'afficher le résultat.</div><br>
<br>
Une QProgressBar envoie un signal valueChanged() lorsque sa valeur a été modifiée.<br>
<br>
A part ça, rien de bien spécial à signaler. Je vous avais déjà fait manipuler les barres de progression dans le chapitre sur les signaux et les slots pour tester la connexion entre les widgets.<br>
<br>

		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11312">Les champs</h2>
		<div class="ss_part_texte">
		Nous allons maintenant faire le tour des widgets qui permettent d'entrer des données. C'est la catégorie de widgets la plus importante.<br>
<br>
Encore une fois, on ne verra pas tout, mais les principaux d'entre eux :<br>
<br>
<ul>
<li><strong>QLineEdit </strong>: champ de texte à une seule ligne.</li>
<li><strong>QTextEdit </strong>: champ de texte à plusieurs lignes pouvant afficher du texte mis en forme.</li>
<li><strong>QSpinBox </strong>: champ de texte adapté à la saisie de nombre entiers.</li>
<li><strong>QDoubleSpinBox </strong>: champ de texte adapté à la saisie de nombre décimaux.</li>
<li><strong>QSlider </strong>: un curseur qui permet de sélectionner une valeur.</li>
<li><strong>QComboBox </strong>: une liste déroulante.</li>
</ul><br>
<br>
<h3>QLineEdit : champ de texte à une seule ligne</h3><br>
<br>
Nous avons utilisé ce widget comme classe d'exemple lors du chapitre sur la lecture de la doc de Qt, vous vous souvenez ?<br>
<br>
Un <a href="http://doc.trolltech.com/qlineedit.html">QLineEdit</a> est un champ de texte sur une seule ligne :<br>
<br>
<div class="centre"><img src="./cpp_files/116574.png" alt="QLineEdit"></div><br>
<br>
Son utilisation est dans la plupart des cas assez simple. Voici quelques propriétés à connaître :<br>
<br>
<ul>
<li><strong>text </strong>: permet de récupérer / modifier le texte contenu dans le champ.</li>
<li><strong>alignment </strong>: l'alignement du texte à l'intérieur.</li>
<li><strong>echoMode </strong>: type d'affichage du texte. Il faudra utiliser l'énumération EchoMode pour indiquer le type d'affichage. Par défaut les lettres entrées s'affichent, mais on peut aussi faire en sorte que les lettres soient masquées pour les mots de passe.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">lineEdit</span><span class="o">-&gt;</span><span class="n">setEchoMode</span><span class="p">(</span><span class="n">QLineEdit</span><span class="o">::</span><span class="n">Password</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/116575.png" alt="Line edit mot de passe"></div><br>
<br>
</li>
<li><strong>inputMask </strong>: permet de définir un masque de saisie, pour obliger l'utilisateur à rentrer une chaîne précise (par exemple un numéro de téléphone ne doit pas contenir de lettres). Vous pouvez aussi jeter un oeil aux <span class="italique">validators </span>qui sont un autre moyen de valider la saisie de l'utilisateur.</li>
<li><strong>maxLength </strong>: le nombre de caractères maximum qui peuvent être entrés.</li>
<li><strong>readOnly </strong>: le contenu du champ de texte ne peut être modifié. Cette propriété ressemble à enabled (définie dans QWidget), mais avec readOnly on peut quand même copier-coller le contenu du QLineEdit, tandis qu'avec enabled le champ est complètement grisé et on ne peut pas récupérer son contenu.</li>
</ul><br>
<br>
On note aussi plusieurs slots qui permettent de couper / copier / coller / vider / annuler le champ de texte.<br>
<br>
Enfin, certains signaux comme returnPressed() (l'utilisateur a appuyé sur Entrée) ou textChanged() (l'utilisateur a modifié le texte) peuvent être utiles dans certains cas.<br>
<br>
<br>
<h3>QTextEdit : champ de texte à plusieurs lignes</h3><br>
<br>
Ce type de champ est similaire à celui qu'on vient de voir, à l'exception du fait qu'il gère l'édition sur plusieurs lignes et, en particulier, qu'il autorise l'affichage de texte enrichi (HTML).<br>
<br>
Voici un <a href="http://doc.trolltech.com/qtextedit.html">QTextEdit</a> :<br>
<br>
<div class="centre"><img src="./cpp_files/116577.png" alt="QTextEdit"></div><br>
<br>
Il y a un certains nombre de choses que l'on pourrait voir sur les QTextEdit mais ce serait un peu trop long pour ce chapitre qui est plutôt là pour faire une revue rapide des widgets.<br>
<br>
Notez les propriétés plainText et html qui permettent respectivement de récupérer &amp; modifier le contenu sous forme de texte simple et sous forme de texte enrichi en HTML. Tout dépend de l'utilisation que vous en faites, normalement dans la plupart des cas vous utiliserez plutôt plainText.<br>
<br>
<div class="rmq information">Si vous vous intéressez à l'utilisation du HTML avec Qt, je vous invite à consulter la <a href="http://doc.trolltech.com/richtext-html-subset.html">liste des balises HTML et propriétés CSS supportées</a>. Vous remarquerez qu'un grand nombre d'éléments sont supportés.</div><br>
<br>
<br>
<h3>QSpinBox : champ de texte de saisie d'entiers</h3><br>
<br>
Une <a href="http://doc.trolltech.com/qspinbox.html">QSpinBox</a> est un champ de texte (type QLineEdit) qui permet d'entrer uniquement un nombre entier et qui dispose de petits boutons pour augmenter ou diminuer la valeur :<br>
<br>
<div class="centre"><img src="./cpp_files/116583.png" alt="SpinBox"></div><br>
<br>
QSpinBox hérite de <a href="http://doc.trolltech.com/qabstractspinbox.html">QAbstractSpinBox</a> (tiens, encore une classe abstraite !). Vérifiez donc aussi la doc de QAbstractSpinBox pour connaître toutes les propriétés de la spinbox.<br>
<br>
Voici quelques propriétés intéressantes :<br>
<br>
<ul>
<li><strong>accelerated </strong>: permet d'autoriser la spinbox a accélérer la vitesse d'augmentation du nombre si on appuie longtemps sur le bouton.</li>
<li><strong>minimum </strong>: valeur minimale que peut prendre la spinbox.</li>
<li><strong>maximum </strong>: valeur maximale que peut prendre la spinbox.</li>
<li><strong>singleStep </strong>: pas d'incrémentation (par défaut de 1). Si vous voulez que les boutons fassent augmenter la spinbox de 100 en 100, c'est cette propriété qu'il faut modifier !</li>
<li><strong>value </strong>: valeur contenue dans la spinbox.</li>
<li><strong>prefix </strong>: texte à afficher avant le nombre.</li>
<li><strong>suffix </strong>: texte à afficher après le nombre.</li>
</ul><br>
<h3>QDoubleSpinBox : champ de texte de saisie de nombres décimaux</h3><br>
<br>
Le <a href="http://doc.trolltech.com/qdoublespinbox.html">QDoubleSpinBox</a> est très similaire au QSpinBox, à la différence près qu'il travaille sur des nombres décimaux (des double) :<br>
<br>
<div class="centre"><img src="./cpp_files/116584.png" alt="DoubleSpinBox"></div><br>
<br>
On retrouve la plupart des propriétés de QSpinBox. On peut rajouter la propriété <strong>decimals </strong>qui gère le nombre de chiffres après la virgule affichés par le QDoubleSpinBox.<br>
<br>
<br>
<h3>QSlider : un curseur pour sélectionner une valeur</h3><br>
<br>
Un <a href="http://doc.trolltech.com/qslider.html">QSlider</a> se présente sous la forme d'un curseur permettant de sélectionner une valeur numérique :<br>
<br>
<div class="centre"><img src="./cpp_files/116591.png" alt="QSlider"></div><br>
<br>
QSlider hérite de <a href="http://doc.trolltech.com/qabstractslider.html">QAbstractSlider</a> (damned, encore une classe abstraite !) qui propose déjà un grand nombre de fonctionnalités de base.<br>
<br>
Beaucoup de propriétés sont les mêmes que QSpinBox, je ne les relisterai donc pas ici.<br>
Notons la propriété <strong>orientation </strong>qui permet de définir l'orientation du slider (verticale ou horizontale).<br>
<br>
Jetez un oeil en particulier à ses signaux, car on connecte en général le signal valueChanged(int) au slot d'autre widget pour répercuter la saisie de l'utilisateur.<br>
Nous avions d'ailleurs manipulé ce widget lors du chapitre sur les signaux et les slots.<br>
<br>
<br>
<h3>QComboBox : une liste déroulante</h3><br>
<br>
Une <a href="http://doc.trolltech.com/qcombobox.html">QComboBox</a> est une liste déroulante :<br>
<br>
<div class="centre"><img src="./cpp_files/116598.png" alt="QComboBox"></div><br>
<br>
On ajoute des valeurs à la liste déroulante avec la méthode addItem :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="n">QComboBox</span> <span class="o">*</span><span class="n">liste</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QComboBox</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">liste</span><span class="o">-&gt;</span><span class="n">addItem</span><span class="p">(</span><span class="s">"Paris"</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">liste</span><span class="o">-&gt;</span><span class="n">addItem</span><span class="p">(</span><span class="s">"Londres"</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">liste</span><span class="o">-&gt;</span><span class="n">addItem</span><span class="p">(</span><span class="s">"Singapour"</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">liste</span><span class="o">-&gt;</span><span class="n">addItem</span><span class="p">(</span><span class="s">"Tokyo"</span><span class="p">);</span></span>
    <span class="n">liste</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On dispose de propriétés permettant de contrôler le fonctionnement de la QComboBox :<br>
<br>
<ul>
<li><strong>count </strong>: nombre d'éléments dans la liste déroulante.</li>
<li><strong>currentIndex </strong>: numéro d'indice de l'élément actuellement sélectionné. Les indices commencent à 0. Ainsi, si currentItem renvoie 2, c'est que "Singapour" a été sélectionné dans l'exemple précédent.</li>
<li><strong>currentText </strong>: texte correspondant à l'élément sélectionné. Si on a sélectionné "Singapour", cette propriété contient donc "Singapour".</li>
<li><strong>editable </strong>: indique si le widget autorise l'ajout de valeurs personnalisées ou non. Par défaut, l'ajout de nouvelles valeurs est interdit.<br>
Si le widget est éditable, l'utilisateur pourra rentrer de nouvelles valeurs dans la liste déroulante. Elle se comportera donc aussi comme un champ de texte. L'ajout d'une nouvelle valeur se fait par appui sur la touche "Entrée". Les nouvelles valeurs sont placées par défaut à la fin de la liste.</li>
</ul><br>
<br>
La QComboBox émet des signaux comme currentIndexChanged() qui indique qu'un nouvel élément a été sélectionné et highlighted() qui indique l'élément survolé par la souris (ces signaux peuvent envoyer un int pour donner l'indice de l'élément ou un QString pour le texte).<br>
<br>
<div class="rmq information">A noter aussi le widget fils <a href="http://doc.trolltech.com/qfontcombobox.html">QFontComboBox</a> qui permet de sélectionner une police parmi une liste proposant une prévisualisation de la police.</div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11311">Les conteneurs</h2>
		<div class="ss_part_texte">
		Normalement, n'importe quel widget peut en contenir d'autres.<br>
Cependant, certains widgets ont été vraiment créés spécialement pour pouvoir en contenir d'autres :<br>
<br>
<ul>
<li>QFrame : un widget pouvant avoir une bordure.</li>
<li>QGroupBox : un widget (que nous avons déjà utilisé) adapté à la gestion des groupes de cases à cocher et de boutons radio.</li>
<li>QTabWidget : un widget gérant plusieurs pages d'onglets.</li>
</ul><br>
<br>
Nous allons apprendre à les manipuler, en nous intéressant en particulier à celui qui propose des onglets qui est un petit peu délicat. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<h3>QFrame : une bordure</h3><br>
<br>
<a href="http://doc.trolltech.com/qframe.html">QFrame</a> est très proche de QWidget. En fait, la seule nouveauté c'est qu'il peut générer une bordure. C'est donc un QWidget basique avec une bordure.<br>
<br>
<div class="centre"><img src="./cpp_files/116622.png" alt="QFrame"></div><br>
<br>
QFrame est une classe de base pour de nombreux widgets qui peuvent avoir une bordure, comme les QLabel. Tout ce que nous allons faire avec les QFrame ici, tous les widgets qui en héritent peuvent le faire aussi.<br>
<br>
<div class="rmq information">Dans la doc de <a href="http://doc.trolltech.com/qframe.html">QFrame</a>, regardez au début le paragraphe "Inherited by...". C'est la liste des classes qui héritent de QFrame, et qui disposent donc aussi des fonctionnalités de QFrame.</div><br>
<br>
Un QFrame possède quelques propriétés pour gérer la forme de la bordure :<br>
<br>
<ul>
<li><strong>frameShape </strong>: le type de bordure. Il faut utiliser une énumération définie par QFrame pour sélectionner la bordure. Consultez la doc pour avoir la liste des types de bordure.<br>
De manière générale je recommande d'utiliser QFrame::StyledPanel (comme sur ma capture d'écran) car cela crée une bordure dans un style adapté à votre OS. Notez aussi QFrame::HLine et QFrame::VLine, un peu particuliers, qui ne créent pas un rectangle mais juste une ligne horizontale ou verticale. Très utile pour séparer les éléments dans sa fenêtre.</li>
<li><strong>frameShadow </strong>: l'ombre de la bordure. Par défaut il n'y en a pas, mais vous pouvez définir une ombre qui donne l'impression que le widget est surélevé ou enfoncé.<br>
Regardez les énumérations définies par QFrame pour avoir la liste des possibilités.</li>
<li><strong>lineWidth </strong>: l'épaisseur de la ligne de la bordure.</li>
<li><strong>midLineWidth </strong>: l'épaisseur de la ligne intermédiaire (utilisé uniquement pour certaines bordure complexes avec une ombre).</li>
</ul><br>
<br>
Testons la propriété frameShape :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3</pre></td><td class="code"><div class="syntax"><pre><span class="n">QFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFrame</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
<span class="n">frame</span><span class="o">-&gt;</span><span class="n">setFrameShape</span><span class="p">(</span><span class="n">QFrame</span><span class="o">::</span><span class="n">StyledPanel</span><span class="p">);</span>
<span class="n">frame</span><span class="o">-&gt;</span><span class="n">setGeometry</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">90</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/116623.png" alt="Frame"></div><br>
<br>
Dans la pratique, le QFrame sert à contenir d'autres widgets (à moins que vous aimiez dessiner des rectangles partout pour le plaisir). Il est donc probable que vous définissiez un layout pour le QFrame et que vous placiez des widgets à l'intérieur.<br>
Allez je me fends d'un petit exemple, ça vous rappellera le chapitre sur les layouts :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>


    <span class="n">QFrame</span> <span class="o">*</span><span class="n">frame</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFrame</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">setFrameShape</span><span class="p">(</span><span class="n">QFrame</span><span class="o">::</span><span class="n">StyledPanel</span><span class="p">);</span>
    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">setGeometry</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">90</span><span class="p">);</span>


    <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">lineEdit</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">(</span><span class="s">"Entrez votre nom"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Cliquez ici"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Ou là..."</span><span class="p">);</span>

    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">vbox</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
    <span class="n">vbox</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">lineEdit</span><span class="p">);</span>
    <span class="n">vbox</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton1</span><span class="p">);</span>
    <span class="n">vbox</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton2</span><span class="p">);</span>

    <span class="n">frame</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">vbox</span><span class="p">);</span>


    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/116624.png" alt="Frame et layout"></div><br>
<br>
On n'a rien fait de bien nouveau. Le QFrame contient un layout vertical qui organise ses widgets enfants : un QLineEdit et deux QPushButton.<br>
Le QFrame lui-même est placé de manière absolue sur la fenêtre (ses coordonnées sont définies dans setGeometry). Je fais ça pour simplifier l'exemple, mais dans la pratique le QFrame devrait être lui-même placé dans un autre layout (le layout principal de la fenêtre).<br>
<br>
<br>
<h3>QGroupBox : un groupe de widgets</h3><br>
<br>
Nous avons déjà utilisé <a href="http://doc.trolltech.com/qgroupbox.html">QGroupBox</a> en pratique plus haut, lorsque nous avons utilisé les boutons radio. Je ne vais donc pas trop m'éterniser dessus.<br>
<br>
<div class="centre"><img src="./cpp_files/116625.png" alt="QGroupBox"></div><br>
<br>
Un QGroupBox propose de créer une bordure comme QFrame, mais il a en plus l'avantage de permettre de définir un titre pour le conteneur.<br>
<br>
<div class="rmq attention">QGroupBox <span class="souligne">n'hérite pas</span> de QFrame. On n'a donc pas le choix dans le type de bordure, mais on a une propriété <strong>flat </strong>qui permet d'aplatir la bordure.</div><br>
<br>
Le titre du conteneur est défini via sa propriété <strong>title</strong>, ou directement lors de l'appel au constructeur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QGroupBox</span> <span class="o">*</span><span class="n">groupBox</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QGroupBox</span><span class="p">(</span><span class="s">"Titre du QGroupBox"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<strong>Exercice</strong> : essayez d'adapter l'exemple précédent sur QFrame pour utiliser cette fois un QGroupBox. C'est facile, mais attention aux propriétés spécifiques au QFrame qui ne sont ici plus valables.<br>
<br>
Le résultat devrait être le suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/116626.png" alt="QGroupBox et layout"></div><br>
<br>
Il est aussi possible d'ajouter une case à cocher devant le QGroupBox. Pour cela, mettez sa propriété checkable à true :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">groupBox</span><span class="o">-&gt;</span><span class="n">setCheckable</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Lorsque la case est cochée, les widgets à l'intérieur sont activés. Lorsqu'elle est décochée, les widgets sont désactivés. Essayez.<br>
<br>
<br>
<h3>QTabWidget : des pages d'onglets</h3><br>
<br>
Le <a href="http://doc.trolltech.com/qtabwidget.html">QTabWidget</a> propose une gestion de plusieurs pages de widgets, organisées sous forme d'onglets :<br>
<br>
<div class="centre"><img src="./cpp_files/116627.png" alt="QTabWidget"></div><br>
<br>
Ce widget-conteneur est sensiblement plus difficile à utiliser que les autres. En effet, il ne peut contenir qu'un widget par page.<br>
<br>
<div class="rmq question">Quoi ? On ne peut pas afficher plus d'un widget par page ???<br>
Mais c'est tout nul !</div><br>
<br>
Sauf... qu'un widget peut en contenir d'autres ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Et si on utilise un layout pour organiser le contenu de ce widget, on peut arriver rapidement à une super présentation. Le tout est de savoir combiner tout ce qu'on a appris jusqu'ici.<br>
<br>
<br>
D'après le texte d'introduction de la doc de QTabWidget, ce conteneur doit être utilisé de la façon suivante :<br>
<br>
<ol class="liste_1">
<li>Créer un QTabWidget.</li>
<li>Créer un QWidget pour chacune des pages (chacun des onglets) du QTabWidget, <span class="souligne">sans leur indiquer de widget parent</span>.</li>
<li>Placer des widgets enfants dans chacun de ces QWidget pour peupler le contenu de chaque page. Utiliser un layout pour positionner les widgets de préférence.</li>
<li>Appeler plusieurs fois addTab() pour créer les pages d'onglets en indiquant l'adresse du QWidget qui contient la page à chaque fois.</li></ol><br>
<br>
Bon, c'est un peu plus délicat comme vous pouvez le voir, mais il faut bien un peu de difficulté, ce chapitre était trop facile. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Si on fait tout dans l'ordre, vous allez voir que l'on n'aura pas de problème.<br>
Je vous propose de lire ce code que j'ai créé qui montre un exemple d'utilisation du QTabWidget. Il est un peu long mais il est commenté et vous devriez arriver à le digérer. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="n">fenetre</span><span class="p">;</span>

    <span class="c">// 1 : Créer le QTabWidget</span>
    <span class="n">QTabWidget</span> <span class="o">*</span><span class="n">onglets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTabWidget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fenetre</span><span class="p">);</span>
    <span class="n">onglets</span><span class="o">-&gt;</span><span class="n">setGeometry</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">160</span><span class="p">);</span>

    <span class="c">// 2 : Créer les pages, en utilisant un widget parent pour contenir chacune des pages</span>
    <span class="n">QWidget</span> <span class="o">*</span><span class="n">page1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QWidget</span><span class="p">;</span>
    <span class="n">QWidget</span> <span class="o">*</span><span class="n">page2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QWidget</span><span class="p">;</span>
    <span class="n">QLabel</span> <span class="o">*</span><span class="n">page3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLabel</span><span class="p">;</span> <span class="c">// Comme un QLabel est aussi un QWidget (il en hérite), on peut aussi s'en servir de page</span>


    <span class="c">// 3 : Créer le contenu des pages de widgets</span>

        <span class="c">// Page 1</span>

        <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">lineEdit</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">(</span><span class="s">"Entrez votre nom"</span><span class="p">);</span>
        <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Cliquez ici"</span><span class="p">);</span>
        <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Ou là..."</span><span class="p">);</span>

        <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">vbox1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
        <span class="n">vbox1</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">lineEdit</span><span class="p">);</span>
        <span class="n">vbox1</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton1</span><span class="p">);</span>
        <span class="n">vbox1</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton2</span><span class="p">);</span>

        <span class="n">page1</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">vbox1</span><span class="p">);</span>


        <span class="c">// Page 2</span>

        <span class="n">QProgressBar</span> <span class="o">*</span><span class="n">progress</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QProgressBar</span><span class="p">;</span>
        <span class="n">progress</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
        <span class="n">QSlider</span> <span class="o">*</span><span class="n">slider</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QSlider</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">Horizontal</span><span class="p">);</span>
        <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Valider"</span><span class="p">);</span>

        <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">vbox2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
        <span class="n">vbox2</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">progress</span><span class="p">);</span>
        <span class="n">vbox2</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">slider</span><span class="p">);</span>
        <span class="n">vbox2</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton3</span><span class="p">);</span>

        <span class="n">page2</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">vbox2</span><span class="p">);</span>


        <span class="c">// Page 3 (je ne vais afficher qu'une image ici, pas besoin de layout)</span>

        <span class="n">page3</span><span class="o">-&gt;</span><span class="n">setPixmap</span><span class="p">(</span><span class="n">QPixmap</span><span class="p">(</span><span class="s">"icone.png"</span><span class="p">));</span>
        <span class="n">page3</span><span class="o">-&gt;</span><span class="n">setAlignment</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">AlignCenter</span><span class="p">);</span>


    <span class="c">// 4 : ajouter les onglets au QTabWidget, en indiquant la page qu'ils contiennent</span>
    <span class="n">onglets</span><span class="o">-&gt;</span><span class="n">addTab</span><span class="p">(</span><span class="n">page1</span><span class="p">,</span> <span class="s">"Coordonnées"</span><span class="p">);</span>
    <span class="n">onglets</span><span class="o">-&gt;</span><span class="n">addTab</span><span class="p">(</span><span class="n">page2</span><span class="p">,</span> <span class="s">"Progression"</span><span class="p">);</span>
    <span class="n">onglets</span><span class="o">-&gt;</span><span class="n">addTab</span><span class="p">(</span><span class="n">page3</span><span class="p">,</span> <span class="s">"Image"</span><span class="p">);</span>


    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous devriez retrouver chacune des étapes que j'ai mentionnées plus haut :<br>
<br>
<ol class="liste_1">
<li>Je crée d'abord le QTabWidget que je positionne ici de manière absolue sur la fenêtre (mais je pourrais aussi utiliser un layout).</li>
<li>Ensuite, je crée les pages pour chacun de mes onglets. Ces pages sont matérialisées par des QWidget.<br>
Vous noterez que pour la dernière page je n'utilise pas un QWidget mais un QLabel. Ca revient au même et c'est compatible car QLabel hérite de QWidget. Sur la dernière page, je me contenterai d'afficher une image.</li>
<li>Je crée ensuite le contenu de chacune de ces pages que je dispose à l'aide de layouts verticaux (sauf pour la page 3 qui n'est constituée que d'un widget). Là il n'y a rien de nouveau.</li>
<li>Enfin, j'ajoute les onglets avec la méthode addTab(). Je dois indiquer le libellé de l'onglet ainsi qu'un pointeur vers le "widget-page" de cette page.</li></ol><br>
<br>
Résultat, on a un super système d'onglets à 3 pages avec tout plein de widgets dedans !<br>
<br>
<br>
<div class="centre"><img src="./cpp_files/116637.png" alt="Onglet 1"><br>
<span class="italique">Page 1</span><br>
<br>
<img src="./cpp_files/116638.png" alt="Onglet  2"><br>
<span class="italique">Page 2</span><br>
<br>
<img src="./cpp_files/116639.png" alt="Onglet 3"><br>
<span class="italique">Page 3</span></div><br>
<br>
Je vous conseille de vous entraîner à créer vous aussi un QTabWidget. C'est un bon exercice, et c'est l'occasion de réutiliser la plupart des widgets que l'on a vus dans ce chapitre. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
Il faut pratiquer et pratiquer. Ce qu'on fait là ne devrait pas être bien compliqué si vous avez correctement suivi le cours jusqu'ici. Mais il faut quand même pratiquer pour faire des erreurs et se rendre compte qu'on n'avait pas parfaitement tout compris.<br>
C'est à partir de ce moment-là seulement que vous commencerez à maîtriser les widgets. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Pfiou !<br>
<br>
Il s'agit peut-être du chapitre le plus long que j'aie jamais écrit... mais je tenais à le faire. En fait, c'est un peu paradoxal car tout cela se trouve dans la doc et je vous ai déjà appris à lire la doc, mais j'estimais qu'il devait quand même forcément y avoir un tour d'horizon des principaux widgets dans mon tutoriel, sinon j'aurais eu l'impression d'avoir été incomplet.<br>
<br>
Servez-vous de ce chapitre pour vous faire une idée de ce qui existe, mais ensuite je vous conseille très fortement de passer plus de temps sur la doc que sur ce chapitre. En effet, nous sommes loin d'avoir vu toutes les fonctionnalités de ces widgets, de même que nous n'avons pas vu tous les widgets qui existent !<br>
<br>
J'ai réservé les widgets les plus complexes pour de futurs chapitres, qui introduiront pour l'occasion un concept de programmation important lorsqu'on programme des GUI : le modèle MVC.<br>
<br>
<br>
Bon, vous pensez pas qu'il serait temps de pratiquer tout ce qu'on a appris avec un petit TP là ? <img src="./cpp_files/smile.png" alt=":)" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11324">TP : ZeroClassGenerator</h1>
	<div id="chap_intro">
	Je pense que le moment est bien choisi pour vous exercer avec un petit TP. En effet, vous avez déjà vu suffisamment de choses sur Qt pour être en mesure de faire déjà des programmes intéressants.<br>
<br>
Quand je me suis dit "<span class="italique">Je vais leur faire faire un TP</span>", les idées de sujet ne manquaient pas... mais elles étaient toutes un peu "bateau". J'ai pensé à une calculatrice par exemple, et en effet pourquoi pas, mais ce n'était pas très original.<br>
<br>
Finalement, après réflexion, j'ai trouvé une idée qui sort un peu de l'ordinaire et qui pourra même vous être utile à vous, programmeurs. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Notre programme s'intitulera le <strong>ZeroClassGenerator</strong>... un programme qui génère le code de base des classes C++ automatiquement en fonction des options que vous choisissez !
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11323">Notre objectif</h2>
		<div class="ss_part_texte">
		Ne vous laissez pas impressionner par le nom "<strong>ZeroClassGenerator</strong>". Ce TP ne sera pas bien difficile et réutilisera toutes les connaissances que vous avez apprises pour les mettre à profit dans un projet concret.<br>
<br>
Ce TP est volontairement modulaire : je vais vous proposer de réaliser un programme de base assez simple, que je vous laisserai coder et que je corrigerai ensuite avec vous. Puis, je vous proposerai un certain nombre d'améliorations intéressantes (non corrigées) pour lesquelles il faudra vous creuser un peu plus les méninges si vous êtes motivés. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Notre ZeroClassGenerator est <span class="souligne">un programme qui génère le code de base des classes C++</span>. Qu'est-ce que ça veut dire ?<br>
<br>
<br>
<h3>Un générateur de classe C++</h3><br>
<br>
Ce programme est un outil graphique qui va créer automatiquement le code source d'une classe en fonction des options que vous aurez choisies.<br>
<br>
Vous n'avez jamais remarqué que les classes avaient en général une structure de base similaire qu'il fallait réécrire à chaque fois ? C'est un peu laborieux parfois. Par exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_MAGICIEN</span>
<span class="cp">#define HEADER_MAGICIEN</span>

<span class="k">class</span> <span class="nc">Magicien</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Personnage</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Magicien</span><span class="p">();</span>
        <span class="o">~</span><span class="n">Magicien</span><span class="p">();</span>


    <span class="k">protected</span><span class="o">:</span>


    <span class="k">private</span><span class="o">:</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Rien que ça, ça serait bien si on avait un programme capable de générer le squelette de la classe, de définir les portées public, protected et private, de définir un constructeur par défaut et un destructeur, etc.<br>
<br>
Nous allons réaliser un GUI (une fenêtre) contenant plusieurs options. Plutôt que de faire une longue liste, je vous propose une capture d'écran du programme final à réaliser :<br>
<br>
<div class="centre"><img src="./cpp_files/116941(1).png" alt="ZeroClassGenerator"></div><br>
<br>
La fenêtre principale est en haut à gauche, en arrière-plan. L'utilisateur renseigne obligatoirement le champ "Nom", pour indiquer le nom de la classe. Il peut aussi donner le nom de la classe mère.<br>
<br>
On propose quelques cases à cocher pour choisir des options comme "Protéger le header contre les inclusions multiples" (la fameuse technique du #ifndef, pratique mais un peu lourde à écrire à chaque fois). Il faudra que le nom du define soit généré automatiquement à partir du nom de la classe, et mis en majuscules. Pour la mise en majuscules, renseignez-vous auprès de la doc de la classe <a href="http://doc.trolltech.com/qstring.html">QString</a> qui propose plein de choses.<br>
<br>
Enfin, on donne la possibilité d'ajouter des commentaires en haut du fichier pour indiquer quel est l'auteur, quelle est la date de création et quel est le rôle de la classe. C'est une bonne habitude en effet que de commenter un peu le début de ses classes pour que l'on ait une idée de ce à quoi elle sert.<br>
<br>
<br>
Lorsqu'on clique sur le bouton "Générer" en bas, une nouvelle fenêtre s'ouvre (une QDialog). Elle affiche le code généré dans un QTextEdit, et vous pouvez à partir de là copier/coller ce code dans votre IDE comme Code::Blocks.<br>
<br>
C'est un début, et je vous proposerai à la fin du chapitre des améliorations intéressantes à ajouter à ce programme. Essayez déjà de réaliser ça correctement, ça représente un peu de travail je peux vous le dire !<br>
<br>
<br>
<h3>Quelques conseils techniques</h3><br>
<br>
Avant de vous lâcher tels des fauves dans la jungle, je voudrais vous donner quelques conseils techniques pour vous guider un peu. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h4>Architecture du projet</h4><br>
<br>
Je vous recommande de faire une classe par fenêtre. Comme on a 2 fenêtres, et qu'on met toujours le main à part, ça fait 5 fichiers :<br>
<br>
<ul>
<li><strong>main.cpp</strong> : contiendra uniquement le main qui ouvre la fenêtre principale (très court).</li>
<li><strong>FenPrincipale.h</strong> : header de la fenêtre principale.</li>
<li><strong>FenPrincipale.cpp</strong> : l'implémentation des méthodes de la fenêtre principale.</li>
<li><strong>FenCodeGenere.h</strong> : le header de la fenêtre secondaire qui affiche le code généré.</li>
<li><strong>FenCodeGenere.cpp</strong> : ... et l'implementation de ses méthodes.</li>
</ul><br>
<br>
Pour la fenêtre principale, vous pourrez hériter de QWidget comme on l'a toujours fait, ça me semble le meilleur choix.<br>
Pour la fenêtre secondaire, je vous conseille d'hériter de QDialog. La fenêtre principale ouvrira la QDialog en appelant sa méthode exec().<br>
<br>
<br>
<h4>La fenêtre principale</h4><br>
<br>
Je vous conseille très fortement d'utiliser des layouts. Mon layout principal, si vous regardez bien ma capture d'écran, est un layout vertical. Il contient des QGroupBox.<br>
A l'intérieur des QGroupBox, j'utilise à nouveau des layouts. Je vous laisse le choix du layout qui vous semble le plus adapté à chaque fois.<br>
<br>
Pour le QGroupBox "Ajouter des commentaires", il faudra ajouter une case à cocher. Si cette case est cochée, les commentaires seront ajoutés. Sinon, on ne mettra pas de commentaires. Renseignez-vous sur l'utilisation des cases à cocher dans les QGroupBox.<br>
<br>
<div class="rmq information">Pour le champ "Date de création", je vous propose d'utiliser un <a href="http://doc.trolltech.com/qdateedit.html">QDateEdit</a>. Ce widget n'a pas été vu dans le chapitre précédent mais je vous fais confiance, il est proche de la QSpinBox et après lecture de la doc vous devriez savoir vous en servir sans problème.</div><br>
<br>
Vous "dessinerez" le contenu de la fenêtre dans le constructeur de FenPrincipale. Pensez à faire de vos champ de formulaire des attributs de la classe (les QLineEdit, QCheckbox...), afin que toutes les autres méthodes de la classe aient accès à leur valeur.<br>
<br>
Lors d'un clic sur le bouton "Générer !", appelez un slot personnalisé. Dans ce slot personnalisé (qui ne sera rien d'autre qu'une méthode de FenPrincipale), vous récupèrerez toutes les infos contenues dans les champs de la fenêtre pour générer le code dans une chaîne de caractères (de type QString de préférence).<br>
C'est là qu'il faudra un peu réfléchir sur la génération du code, mais c'est tout à fait faisable. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Une fois le code généré, votre slot appellera la méthode exec() d'un objet de type FenCodeGenere que vous aurez créé pour l'occasion. La fenêtre du code généré s'affichera alors...<br>
<br>
<br>
<h4>La fenêtre du code généré</h4><br>
<br>
Beaucoup plus simple, cette fenêtre est constituée d'un QTextEdit et d'un bouton de fermeture.<br>
<br>
Pour le QTextEdit, essayez de définir une police à pas fixe (comme "Courier") pour que ça ressemble à du code (parce que le Times New Roman pour rédiger du code c'est moche <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ). Personnellement, j'ai rendu le QTextEdit en mode readOnly pour qu'on ne puisse pas modifier son contenu (juste le copier), mais vous faites comme vous voulez.<br>
<br>
Vous connecterez le bouton "Fermer" à un slot spécial de la QDialog qui demande la fermeture et qui indique que tout s'est bien passé. Je vous laisse trouver dans la doc duquel il s'agit. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<div class="rmq question">Minute euh... Comment je passe le code généré (de type QString si j'ai bien compris) à la seconde fenêtre de type QDialog ?</div><br>
<br>
Le mieux est de passer cette QString en paramètre du constructeur. Votre fenêtre récupèrera ainsi le code et n'aura plus qu'à l'afficher dans son QTextEdit !<br>
<br>
<br>
<br>
Allez hop hop hop, au boulot, à vos éditeurs ! Vous aurez besoin de lire la doc plusieurs fois pour trouver la bonne méthode à appeler à chaque fois, donc n'ayez pas peur d'y aller.<br>
<br>
On se retrouve dans la partie suivante pour la... correction !
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11322">Correction</h2>
		<div class="ss_part_texte">
		Ding !<br>
<br>
C'est l'heure de ramasser les copies. <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> <br>
<br>
Bien que je vous aie donné quelques conseils techniques, je vous ai volontairement laissé le choix pour certains petits détails (comme "quelles cases sont cochées par défaut"). Vous pouviez même présenter la fenêtre un peu différemment si vous vouliez.<br>
Tout ça pour dire que ma correction n'est pas la correction ultime. Si vous avez fait différemment, ce n'est pas grave. Si vous n'avez pas réussi, ce n'est pas grave non plus, pas de panique : prenez le temps de bien lire mon code et d'essayer de comprendre ce que je fais. Vous devrez être capable par la suite de refaire ce TP sans regarder la correction. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>main.cpp</h3><br>
<br>
Comme prévu, ce fichier est tout bête et ne mérite même pas d'explication. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include "FenPrincipale.h"</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">FenPrincipale</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je signale juste qu'on aurait pu charger la langue française comme on l'avait fait dans le chapitre sur les boîtes de dialogue, afin que les menus contextuels et certains boutons automatiques soient traduits en français. Mais c'est du détail, ça ne se verra pas vraiment sur ce projet.<br>
<br>
<br>
<h3>FenPrincipale.h</h3><br>
<br>
La fenêtre principale hérite de QWidget comme prévu. Elle utilise la macro Q_OBJECT car nous définissons un slot personnalisé :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_FENPRINCIPALE</span>
<span class="cp">#define HEADER_FENPRINCIPALE</span>

<span class="cp">#include &lt;QtGui&gt;</span>

<span class="k">class</span> <span class="nc">FenPrincipale</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>


    <span class="k">public</span><span class="o">:</span>
        <span class="n">FenPrincipale</span><span class="p">();</span>

    <span class="k">private</span> <span class="nl">slots:</span>
        <span class="kt">void</span> <span class="n">genererCode</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">nom</span><span class="p">;</span>
        <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">classeMere</span><span class="p">;</span>
        <span class="n">QCheckBox</span> <span class="o">*</span><span class="n">protections</span><span class="p">;</span>
        <span class="n">QCheckBox</span> <span class="o">*</span><span class="n">genererConstructeur</span><span class="p">;</span>
        <span class="n">QCheckBox</span> <span class="o">*</span><span class="n">genererDestructeur</span><span class="p">;</span>
        <span class="n">QGroupBox</span> <span class="o">*</span><span class="n">groupCommentaires</span><span class="p">;</span>
        <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">auteur</span><span class="p">;</span>
        <span class="n">QDateEdit</span> <span class="o">*</span><span class="n">date</span><span class="p">;</span>
        <span class="n">QTextEdit</span> <span class="o">*</span><span class="n">role</span><span class="p">;</span>
        <span class="n">QPushButton</span> <span class="o">*</span><span class="n">generer</span><span class="p">;</span>
        <span class="n">QPushButton</span> <span class="o">*</span><span class="n">quitter</span><span class="p">;</span>

<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
Ce qui est intéressant, ce sont tous les champs de formulaire que j'ai mis en tant qu'attributs (privés) de la classe. Il faudra les initialiser dans le constructeur. L'avantage d'avoir défini les champs en attributs, c'est que toutes les méthodes de la classe y auront accès, et ça nous sera bien utile pour récupérer les valeurs des champs dans notre méthode qui génèrera le code source.<br>
<br>
Notre classe est constituée de 2 méthodes, ce qui est ici largement suffisant :<br>
<br>
<ul>
<li><strong>FenPrincipale()</strong> : c'est le constructeur. Il initialisera les champs de la fenêtre, jouera avec les layouts et placera les champs à l'intérieur. Il fera des connexions entre les widgets et indiquera la taille de la fenêtre, son titre, son icône...</li>
<li><strong>genererCode()</strong> : c'est une méthode (plus précisément un slot) qui sera connectée au signal "Le bouton Générer a été cliqué". Dès qu'on cliquera sur le bouton, cette méthode sera appelée.<br>
J'ai mis le slot en privé car il n'y a pas de raison qu'une autre classe l'appelle, mais j'aurais aussi bien pu le mettre public.</li>
</ul><br>
<br>
<h3>FenPrincipale.cpp</h3><br>
<br>
Bon là c'est le plus gros morceau. Il n'y a que 2 méthodes mais elles sont grosses, ne vous laissez pas impressionner pour autant.<br>
Prenez le temps de bien les comprendre. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>
<span class="cp">#include "FenCodeGenere.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>

    <span class="c">// Groupe : Définition de la classe</span>
    <span class="n">nom</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span>
    <span class="n">classeMere</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span>

    <span class="n">QFormLayout</span> <span class="o">*</span><span class="n">definitionLayout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFormLayout</span><span class="p">;</span>
    <span class="n">definitionLayout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"&amp;Nom :"</span><span class="p">,</span> <span class="n">nom</span><span class="p">);</span>
    <span class="n">definitionLayout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Classe &amp;mère :"</span><span class="p">,</span> <span class="n">classeMere</span><span class="p">);</span>

    <span class="n">QGroupBox</span> <span class="o">*</span><span class="n">groupDefinition</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QGroupBox</span><span class="p">(</span><span class="s">"Définition de la classe"</span><span class="p">);</span>
    <span class="n">groupDefinition</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">definitionLayout</span><span class="p">);</span>


    <span class="c">// Groupe : Options</span>

    <span class="n">protections</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="s">"Protéger le &amp;header contre les inclusions multiples"</span><span class="p">);</span>
    <span class="n">protections</span><span class="o">-&gt;</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
    <span class="n">genererConstructeur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="s">"Générer un &amp;constructeur par défaut"</span><span class="p">);</span>
    <span class="n">genererDestructeur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="s">"Générer un &amp;destructeur"</span><span class="p">);</span>

    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">optionsLayout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
    <span class="n">optionsLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">protections</span><span class="p">);</span>
    <span class="n">optionsLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">genererConstructeur</span><span class="p">);</span>
    <span class="n">optionsLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">genererDestructeur</span><span class="p">);</span>

    <span class="n">QGroupBox</span> <span class="o">*</span><span class="n">groupOptions</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QGroupBox</span><span class="p">(</span><span class="s">"Options"</span><span class="p">);</span>
    <span class="n">groupOptions</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">optionsLayout</span><span class="p">);</span>



    <span class="c">// Groupe : Commentaires</span>

    <span class="n">auteur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span>
    <span class="n">date</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QDateEdit</span><span class="p">;</span>
    <span class="n">date</span><span class="o">-&gt;</span><span class="n">setDate</span><span class="p">(</span><span class="n">QDate</span><span class="o">::</span><span class="n">currentDate</span><span class="p">());</span>
    <span class="n">role</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTextEdit</span><span class="p">;</span>

    <span class="n">QFormLayout</span> <span class="o">*</span><span class="n">commentairesLayout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFormLayout</span><span class="p">;</span>
    <span class="n">commentairesLayout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"&amp;Auteur :"</span><span class="p">,</span> <span class="n">auteur</span><span class="p">);</span>
    <span class="n">commentairesLayout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Da&amp;te de création :"</span><span class="p">,</span> <span class="n">date</span><span class="p">);</span>
    <span class="n">commentairesLayout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"&amp;Rôle de la classe :"</span><span class="p">,</span> <span class="n">role</span><span class="p">);</span>

    <span class="n">groupCommentaires</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QGroupBox</span><span class="p">(</span><span class="s">"Ajouter des commentaires"</span><span class="p">);</span>
    <span class="n">groupCommentaires</span><span class="o">-&gt;</span><span class="n">setCheckable</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
    <span class="n">groupCommentaires</span><span class="o">-&gt;</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
    <span class="n">groupCommentaires</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">commentairesLayout</span><span class="p">);</span>


    <span class="c">// Layout : boutons du bas (générer, quitter...)</span>
    <span class="n">generer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"&amp;Générer !"</span><span class="p">);</span>
    <span class="n">quitter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"&amp;Quitter"</span><span class="p">);</span>

    <span class="n">QHBoxLayout</span> <span class="o">*</span><span class="n">boutonsLayout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QHBoxLayout</span><span class="p">;</span>
    <span class="n">boutonsLayout</span><span class="o">-&gt;</span><span class="n">setAlignment</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">AlignRight</span><span class="p">);</span>

    <span class="n">boutonsLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">generer</span><span class="p">);</span>
    <span class="n">boutonsLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">quitter</span><span class="p">);</span>


    <span class="c">// Définition du layout principal, du titre de la fenêtre, etc.</span>

    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layoutPrincipal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
    <span class="n">layoutPrincipal</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">groupDefinition</span><span class="p">);</span>
    <span class="n">layoutPrincipal</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">groupOptions</span><span class="p">);</span>
    <span class="n">layoutPrincipal</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">groupCommentaires</span><span class="p">);</span>
    <span class="n">layoutPrincipal</span><span class="o">-&gt;</span><span class="n">addLayout</span><span class="p">(</span><span class="n">boutonsLayout</span><span class="p">);</span>

    <span class="n">setLayout</span><span class="p">(</span><span class="n">layoutPrincipal</span><span class="p">);</span>
    <span class="n">setWindowTitle</span><span class="p">(</span><span class="s">"Zero Class Generator"</span><span class="p">);</span>
    <span class="n">setWindowIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"icone.png"</span><span class="p">));</span>
    <span class="n">resize</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">450</span><span class="p">);</span>


    <span class="c">// Connexions des signaux et des slots</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">quitter</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">generer</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">genererCode</span><span class="p">()));</span>

<span class="p">}</span>


<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">genererCode</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">// On vérifie que le nom de la classe n'est pas vide, sinon on arrête</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nom</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">().</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">QMessageBox</span><span class="o">::</span><span class="n">critical</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Erreur"</span><span class="p">,</span> <span class="s">"Veuillez entrer au moins un nom de classe"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span> <span class="c">// Arrêt de la méthode</span>
    <span class="p">}</span>

    <span class="c">// Si tout va bien, on génère le code</span>
    <span class="n">QString</span> <span class="n">code</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">groupCommentaires</span><span class="o">-&gt;</span><span class="n">isChecked</span><span class="p">())</span> <span class="c">// On a demandé à inclure les commentaires</span>
    <span class="p">{</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s">"/*</span><span class="se">\n</span><span class="s">Auteur : "</span> <span class="o">+</span> <span class="n">auteur</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">()</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s">"Date de création : "</span> <span class="o">+</span> <span class="n">date</span><span class="o">-&gt;</span><span class="n">date</span><span class="p">().</span><span class="n">toString</span><span class="p">()</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s">"Rôle :</span><span class="se">\n</span><span class="s">"</span> <span class="o">+</span> <span class="n">role</span><span class="o">-&gt;</span><span class="n">toPlainText</span><span class="p">()</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">*/</span><span class="se">\n\n\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">protections</span><span class="o">-&gt;</span><span class="n">isChecked</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s">"#ifndef HEADER_"</span> <span class="o">+</span> <span class="n">nom</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">().</span><span class="n">toUpper</span><span class="p">()</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s">"#define HEADER_"</span> <span class="o">+</span> <span class="n">nom</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">().</span><span class="n">toUpper</span><span class="p">()</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n\n\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">code</span> <span class="o">+=</span> <span class="s">"class "</span> <span class="o">+</span> <span class="n">nom</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">classeMere</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">().</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s">" : public "</span> <span class="o">+</span> <span class="n">classeMere</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">code</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\n</span><span class="s">{</span><span class="se">\n</span><span class="s">    public:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">genererConstructeur</span><span class="o">-&gt;</span><span class="n">isChecked</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s">"        "</span> <span class="o">+</span> <span class="n">nom</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">()</span> <span class="o">+</span> <span class="s">"();</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">genererDestructeur</span><span class="o">-&gt;</span><span class="n">isChecked</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s">"        ~"</span> <span class="o">+</span> <span class="n">nom</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">()</span> <span class="o">+</span> <span class="s">"();</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">code</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">    protected:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">code</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\n\n</span><span class="s">    private:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">code</span> <span class="o">+=</span> <span class="s">"};</span><span class="se">\n\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">protections</span><span class="o">-&gt;</span><span class="n">isChecked</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="s">"#endif</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="c">// On crée puis affiche la fenêtre qui affichera le code généré, qu'on lui envoie en paramètre</span>
    <span class="n">FenCodeGenere</span> <span class="o">*</span><span class="n">fenetreCode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FenCodeGenere</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">fenetreCode</span><span class="o">-&gt;</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Vous noterez que j'appelle directement la méthode connect(), au lieu d'écrire QWidget::connect(). En effet, si on est dans une classe qui hérite de QWidget (et c'est le cas), on peut se passer de mettre le préfixe "QWidget::".</div><br>
<br>
Pour le constructeur, je pense ne rien avoir à ajouter, je ne fais rien de bien nouveau. Il faut juste être organisé parce qu'il y a pas mal de lignes pour générer la fenêtre.<br>
<br>
Par contre, le slot genererCode a demandé du travail, même s'il n'est pas si compliqué que ça au final. Il récupère la valeur des champs de la fenêtre (via des méthodes comme text() pour les QLineEdit). J'ai dû lire la doc plusieurs fois pour chacun de ces widgets afin de savoir comment récupérer le texte, la valeur (si la case est cochée ou pas), etc. Là, c'est juste de la lecture de la doc.<br>
<br>
Une QString <span class="italique">code </span>se génère en fonction des choix que vous avez fait.<br>
Une erreur se produit et la méthode s'arrête s'il n'y a pas au moins un nom de classe défini.<br>
<br>
Tout à la fin de genererCode(), on n'a plus qu'à appeler la fenêtre secondaire et à lui envoyer le code généré :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">FenCodeGenere</span> <span class="o">*</span><span class="n">fenetreCode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FenCodeGenere</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
<span class="n">fenetreCode</span><span class="o">-&gt;</span><span class="n">exec</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le code est envoyé lors de la construction de l'objet. La fenêtre sera affichée lors de l'appel à exec().<br>
 <br>
<br>
<h3>FenCodeGenere.h</h3><br>
<br>
La fenêtre du code généré est beaucoup plus simple que sa parente :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_FENCODEGENERE</span>
<span class="cp">#define HEADER_FENCODEGENERE</span>

<span class="cp">#include &lt;QtGui&gt;</span>

<span class="k">class</span> <span class="nc">FenCodeGenere</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QDialog</span>
<span class="p">{</span>
	<span class="k">public</span><span class="o">:</span>
		<span class="n">FenCodeGenere</span><span class="p">(</span><span class="n">QString</span> <span class="o">&amp;</span><span class="n">code</span><span class="p">,</span> <span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span><span class="p">);</span>

	<span class="k">private</span><span class="o">:</span>
        <span class="n">QTextEdit</span> <span class="o">*</span><span class="n">codeGenere</span><span class="p">;</span>
        <span class="n">QPushButton</span> <span class="o">*</span><span class="n">fermer</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Il y a juste un constructeur et deux petits widgets de rien du tout. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>FenCodeGenere.cpp</h3><br>
<br>
Le constructeur prend 2 paramètres :<br>
<br>
<ul>
<li>Une référence vers la QString qui contient le code.</li>
<li>Un pointeur vers la fenêtre parente.</li>
</ul><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenCodeGenere.h"</span>

<span class="n">FenCodeGenere</span><span class="o">::</span><span class="n">FenCodeGenere</span><span class="p">(</span><span class="n">QString</span> <span class="o">&amp;</span><span class="n">code</span><span class="p">,</span> <span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">QDialog</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">codeGenere</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTextEdit</span><span class="p">();</span>
    <span class="n">codeGenere</span><span class="o">-&gt;</span><span class="n">setPlainText</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
    <span class="n">codeGenere</span><span class="o">-&gt;</span><span class="n">setReadOnly</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
    <span class="n">codeGenere</span><span class="o">-&gt;</span><span class="n">setFont</span><span class="p">(</span><span class="n">QFont</span><span class="p">(</span><span class="s">"Courier"</span><span class="p">));</span>
    <span class="n">codeGenere</span><span class="o">-&gt;</span><span class="n">setLineWrapMode</span><span class="p">(</span><span class="n">QTextEdit</span><span class="o">::</span><span class="n">NoWrap</span><span class="p">);</span>

    <span class="n">fermer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Fermer"</span><span class="p">);</span>

    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layoutPrincipal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
    <span class="n">layoutPrincipal</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">codeGenere</span><span class="p">);</span>
    <span class="n">layoutPrincipal</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">fermer</span><span class="p">);</span>

    <span class="n">resize</span><span class="p">(</span><span class="mi">350</span><span class="p">,</span> <span class="mi">450</span><span class="p">);</span>
    <span class="n">setLayout</span><span class="p">(</span><span class="n">layoutPrincipal</span><span class="p">);</span>

    <span class="n">connect</span><span class="p">(</span><span class="n">fermer</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">accept</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est un rappel, mais je pense qu'il ne fera pas de mal : le paramètre <span class="italique">parent </span>est transféré au constructeur de la classe-mère QDialog dans cette ligne :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">FenCodeGenere</span><span class="o">::</span><span class="n">FenCodeGenere</span><span class="p">(</span><span class="n">QString</span> <span class="o">&amp;</span><span class="n">code</span><span class="p">,</span> <span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">QDialog</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Schématiquement, le transfert se fait comme ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/117103.png" alt="Héritage et passage de paramètre"></div><br>
<br>
Je pense que s'il y avait juste ça vous comprendrez tous :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">FenCodeGenere</span><span class="o">::</span><span class="n">FenCodeGenere</span><span class="p">(</span><span class="n">QString</span> <span class="o">&amp;</span><span class="n">code</span><span class="p">,</span> <span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La nouveauté (enfin, on en a parlé dans le chapitre sur l'héritage quand même <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ), c'est qu'on appelle aussi le constructeur de la classe-mère QDialog et on lui transfère le paramètre parent avec le code <span class="code2 cpp"><span class="o">:</span> <span class="n">QDialog</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
</span><br>
<br>
<br>
<div class="rmq question">Pourquoi avoir appelé le constructeur de QDialog et pourquoi lui avoir envoyé en paramètre un pointeur vers la fenêtre mère ?</div><br>
<br>
Même si ce n'est pas obligatoire en fait, il est conseillé lors de la création d'une QDialog d'indiquer quelle est la fenêtre mère. La QDialog se centre automatiquement par rapport à la fenêtre mère, entre autres choses.<br>
<br>
<br>
<h3>Télécharger le projet</h3><br>
<br>
Vous pouvez aussi télécharger le projet zippé :<br>
<br>
<div class="centre"><span class="gros"><a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/cpp/zeroclassgenerator.zip">Télécharger le projet ZeroClassGenerator (25 Ko)</a></span></div><br>
<br>
Ce zip contient :<br>
<br>
<ul>
<li>Les fichiers source .cpp et .h</li>
<li>Le projet .cbp pour ceux qui utilisent Code::Blocks</li>
<li>L'exécutable Windows et son icône. Attention, il faudra mettre les DLL de Qt dans le même dossier si vous voulez que le programme puisse s'exécuter.</li>
</ul>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11321">Des idées d'améliorations</h2>
		<div class="ss_part_texte">
		Vous pensiez en avoir fini ?<br>
Que nenni ! Un tel TP n'attend qu'une seule chose : être amélioré !<br>
<br>
Voici une liste de suggestions qui me passent par la tête pour améliorer le ZeroCodeGenerator, mais vous pouvez inventer les vôtres :<br>
<br>
<ul>
<li>Lorsqu'on coche "Protéger le header contre les inclusions multiples", un define (aussi appelé "header guard") est généré. Par défaut, ce header guard est de la forme HEADER_NOMCLASSE. Pourquoi ne pas l'afficher en temps réel dans un libellé lorsqu'on tape le nom de la classe ? Ou, mieux, affichez-le en temps réel dans un QLineEdit pour que la personne puisse le modifier si elle le désire.<br>
Le but est de vous faire travailler les signaux et les slots.<br>
<br>
<div class="centre"><img src="./cpp_files/117461.png" alt="ZeroClassGenerator et header guard"></div><br>
</li>
<li>Ajoutez d'autres options de génération de code. Par exemple, vous pouvez proposer d'inclure le texte légal d'une licence libre (comme la GPL) dans les commentaires d'en-tête si la personne fait un logiciel libre, vous pouvez demander quels headers inclure, la liste des attributs, générer automatiquement les accesseurs pour ces attributs, etc. Attention, il faudra peut-être utiliser des widgets de liste un peu plus complexes, comme le <a href="http://doc.trolltech.com/qlistwidget.html">QListWidget</a>. Je ne vous l'ai pas encore présenté, mais rien ne vous interdit de prendre de l'avance. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></li>
<li>Pour le moment on ne génère que le code du fichier .h. Même s'il y a moins de travail, ça serait bien de générer aussi le .cpp. Je vous propose d'utiliser un QTabWidget (des onglets) pour afficher le code .h et le .cpp dans la boîte de dialogue du code généré.<br>
<br>
<div class="centre"><img src="./cpp_files/117466.png" alt="ZeroClassGenerator et onglets"></div><br>
</li>
<li>On ne peut que voir et copier / coller le code généré. C'est bien, mais comme vous je pense que si on pouvait enregistrer le résultat dans des fichiers ce serait du temps de gagné pour l'utilisateur. Je vous propose d'ajouter dans la QDialog un bouton pour sauvegarder dans des fichiers.<br>
Ce bouton ouvrira une fenêtre qui demandera dans quel dossier enregistrer les fichiers .h et .cpp. Le nom de ces fichiers sera automatiquement généré en fonction du nom de la classe.<br>
Pour l'enregistrement dans des fichiers, regardez du côté de la classe <a href="http://doc.trolltech.com/qfile.html">QFile</a>. Bon courage. <img src="./cpp_files/smile.png" alt=":)" class="smilies"></li>
<li>C'est un détail, mais les menus contextuels (quand on fait un clic droit sur un champ de texte par exemple) sont en anglais. Je vous avais parlé dans un des chapitres précédents d'une technique permettant de les avoir en français, un code à placer au début du main(). Je vous laisse le retrouver !</li>
<li>On vérifie si le nom de la classe n'est pas vide, mais on ne vérifie pas s'il contient des caractères invalides (comme un espace, des accents, des guillemets...). Il faudrait afficher une erreur si le nom de la classe n'est pas valide.<br>
Pour valider le texte saisi, vous avez 2 techniques : utiliser un inputMask(), ou un validator(). L'inputMask est peut-être le plus simple des deux, mais ça vaut le coup d'avoir pratiqué les deux. Pour savoir faire ça, direction la <a href="http://doc.trolltech.com/qlineedit.html">doc de QLineEdit</a>.</li>
</ul><br>
Voilà pour un petit début d'idées d'améliorations. Il y a déjà de quoi faire pour que vous ne puissiez pas dormir pendant quelques nuits, gnark gnark gnark.  <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> <br>
<br>
Comme toujours pour les TP, si vous êtes bloqués rendez-vous sur les forums du Site du Zéro pour demander de l'aide. Bon courage à tous !
		</div>
		<hr>
		
	<div id="chap_conclusion">
	J'espère que le sujet de ce TP vous a plu, j'ai essayé de trouver quelque chose d'original et d'éviter les sujets habituels comme "Faire une calculatrice".<br>
Ceci étant, si vous avez envie de faire une calculatrice, surtout foncez ! Plus vous pratiquez, plus vous progressez (même si vous êtes parfois confrontés à des difficultés). C'est une règle immuable.<br>
<br>
Parmi les TP sur lesquels vous pourriez vous entraîner à votre niveau, je vous suggère de regarder du côté de ce qu'on avait fait dans le cours de C en console. C'est l'occasion idéale de faire évoluer ces programmes de la console au GUI :<br>
<br>
<ul>
<li><a href="http://www.siteduzero.com/tuto-3-2702-1-tp-plus-ou-moins-votre-premier-jeu.html">Le jeu du Plus ou Moins</a> : faites deviner un nombre à l'utilisateur. Ce devrait être assez simple à réaliser, et ça vous fera pratiquer un peu plus.</li>
<li><a href="http://www.siteduzero.com/tuto-3-4842-1-tp-realisation-d-un-pendu.html">Le jeu du Pendu</a> : un peu plus complexe mais toujours très intéressant, le Pendu sous forme de GUI peut être un très bon exercice.<br>
Ci-dessous, un exemple de jeu de pendu sous forme de GUI, ici réalisé en Java par cysboy <a href="http://www.siteduzero.com/tuto-3-2000-0-programmation-en-java.html">dans son tutoriel</a> (même si c'est du Java, ça ne change rien, c'est pour vous donner une idée de l'interface à réaliser) :<br>
<br>
<div class="centre"><a href="http://uploads.siteduzero.com/files/117001_118000/117458.jpg"><img src="./cpp_files/117458.jpg" alt="Pendu"></a></div><br>
</li>
</ul><br>
<br>
Amusez-vous bien. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11334">La fenêtre principale</h1>
	<div id="chap_intro">
	Intéressons-nous maintenant à la fenêtre principale de vos applications.<br>
Pour le moment, nous avons créé des fenêtres plutôt basiques en héritant de QWidget. C'est en effet largement suffisant pour de petites applications, mais au bout d'un moment on a besoin de plus d'outils.<br>
<br>
La classe QMainWindow a été spécialement créée pour gérer la fenêtre principale de votre application quand celle-ci est complexe. Parmi les fonctionnalités offertes par QMainWindow, on trouve :<br>
<br>
<ul>
<li>Les menus</li>
<li>La barre d'outils</li>
<li>Les docks</li>
<li>La barre d'état</li>
</ul><br>
A la fin de ce chapitre, vous pourrez vraiment faire tout ce que vous voulez de votre fenêtre principale !
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11333">Présentation de QMainWindow</h2>
		<div class="ss_part_texte">
		La classe QMainWindow hérite directement de QWidget. C'est un widget généralement utilisé une seule fois par programme, et qui sert uniquement à créer la fenêtre principale de l'application.<br>
<br>
Certaines applications simples n'ont pas besoin de recourir à la QMainWindow. On va supposer ici que vous vous attaquez à un programme complexe et d'envergure. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<br>
<h3>Structure de la QMainWindow</h3><br>
<br>
Avant toute chose, il me semble indispensable de vous présenter l'organisation d'une QMainWindow.<br>
Commençons par analyser le schéma ci-dessous :<br>
<br>
<div class="centre"><a href="http://doc.trolltech.com/qmainwindow.html"><img src="./cpp_files/117473.png" alt="Layout de la QMainWindow"><br>
<span class="italique">Schéma honteusement recopié de la doc de QMainWindow <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"></span></a></div><br>
<br>
Une fenêtre principale peut être constituée de tout cela. Et j'ai bien dit <span class="italique">peut</span>, car rien ne vous oblige à utiliser à chaque fois chacun de ces éléments.<br>
<br>
Détaillons les éléments :<br>
<br>
<ul>
<li><strong>Menu Bar</strong> : c'est la barre de menus. C'est là que vous allez pouvoir créer votre menu Fichier, Edition, Affichage, Aide, etc.</li>
<li><strong>Toolbars </strong>: les barres d'outils. Dans un éditeur de texte, on a par exemple des icônes pour créer un nouveau fichier, pour enregistrer, etc.</li>
<li><strong>Dock Widgets</strong> : plus complexes et plus rarement utilisés, ces docks sont des conteneurs que l'on place autour de la fenêtre principale. Ils peuvent contenir des outils, par exemple les différents types de pinceaux que l'on peut utiliser quand on fait un logiciel de dessin.</li>
<li><strong>Central Widget</strong> : c'est le coeur de la fenêtre, là où il y aura le contenu proprement dit.</li>
<li><strong>Status Bar</strong> : la barre d'état. Elle affiche en général l'état du programme (Prêt / Enregistrement en cours, etc.).</li>
</ul><br>
<br>
<h3>Exemple de QMainWindow</h3><br>
<br>
Pour imaginer ces éléments en pratique, je vous propose de prendre pour exemple le programme Qt Designer :<br>
<br>
<div class="centre"><img src="./cpp_files/117474.png" alt="Qt Designer et MainWindow"></div><br>
<br>
Vous repérez en haut la <strong>barre de menus</strong> : File, Edit, Form...<br>
<br>
En dessous, on a la <strong>barre d'outils</strong>, avec les icônes pour créer un nouveau projet, ouvrir un projet, enregistrer, annuler...<br>
<br>
Autour (sur la gauche et la droite), on a les fameux <strong>docks</strong>. Ils servent ici à sélectionner le widget que l'on veut utiliser, ou à éditer les propriétés du widget par exemple.<br>
<br>
Au centre, dans la partie grise où il n'y a rien, c'est la <strong>zone centrale</strong>. Lorsqu'un document est ouvert, cette zone l'affiche. La zone centrale peut afficher un ou plusieurs documents à la fois, comme on le verra plus loin.<br>
<br>
Enfin, en bas il y a normalement la <strong>barre de statut</strong>, mais Qt Designer n'en utilise pas vraiment visiblement (en tout cas rien n'est affiché en bas).<br>
<br>
Je vous propose de passer en revue chacune de ces sections dans ce chapitre. Nous commencerons par parler du "<strong>Central Widget</strong>", car c'est quand même lui le plus important et c'est le seul véritablement indispensable. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
<br>
<h3>Le code de base</h3><br>
<br>
Pour suivre ce chapitre, il va falloir créer un projet en même temps que moi. Nous allons créer notre propre classe de fenêtre principale qui héritera de QMainWindow, car c'est comme cela qu'on fait dans 99,99 % des cas.<br>
<br>
Notre projet contiendra 3 fichiers :<br>
<br>
<ul>
<li><strong>main.cpp</strong> : la fonction main().</li>
<li><strong>FenPrincipale.h</strong> : définition de notre classe FenPrincipale, qui héritera de QMainWindow.</li>
<li><strong>FenPrincipale.cpp</strong> : implémentation des méthodes de la fenêtre principale.</li>
</ul><br>
<br>
<h4>main.cpp</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span>
<span class="cp">#include "FenPrincipale.h"</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">FenPrincipale</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>FenPrincipale.h</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_FENPRINCIPALE</span>
<span class="cp">#define HEADER_FENPRINCIPALE</span>

<span class="cp">#include &lt;QtGui&gt;</span>

<span class="k">class</span> <span class="nc">FenPrincipale</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QMainWindow</span>
<span class="p">{</span>
	<span class="k">public</span><span class="o">:</span>
		<span class="n">FenPrincipale</span><span class="p">();</span>

	<span class="k">private</span><span class="o">:</span>

<span class="p">};</span>


<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
<h4>FenPrincipale.cpp</h4><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>

<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Résultat</h4><br>
<br>
Si tout va bien, ce code devrait avoir pour effet d'afficher une fenêtre vide, toute bête :<br>
<br>
<div class="centre"><img src="./cpp_files/117478.png" alt="QMainWindow vide"></div><br>
<br>
Si c'est ce qui s'affiche chez vous, c'est bon, nous pouvons commencer. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11332">La zone centrale (SDI et MDI)</h2>
		<div class="ss_part_texte">
		La zone centrale de la fenêtre principale est prévue pour contenir un et un seul widget.<br>
C'est comme pour les onglets. On y insère un QWidget (ou une de ses classes filles) et on s'en sert comme conteneur pour mettre d'autres widgets à l'intérieur si besoin est.<br>
<br>
Nous allons refaire la manipulation ici pour s'assurer que tout le monde comprend comment cela fonctionne.<br>
<br>
<br>
Sachez tout d'abord qu'on distingue 2 types de QMainWindow :<br>
<br>
<ul>
<li><strong>Les SDI</strong> (Single Document Interface) : elles ne peuvent afficher qu'un document à la fois. C'est le cas de Bloc-Notes par exemple :<br>
<br>
<div class="centre"><img src="./cpp_files/117481.png" alt="Programme SDI : bloc-notes"></div><br>
<br>
</li>
<li><strong>Les MDI</strong> (Multiple Document Interface) : elles peuvent afficher plusieurs documents à la fois. Elles affichent des sous-fenêtres dans la zone centrale. C'est le cas par exemple de Qt Designer :<br>
<br>
<div class="centre"><img src="./cpp_files/117482.png" alt="Programme MDI : Qt Designer"></div></li>
</ul><br>
<br>
<br>
<h3>Définition de la zone centrale (type SDI)</h3><br>
<br>
On utilise la méthode <span class="code2 cpp"><span class="n">setCentralWidget</span><span class="p">()</span>
</span> de la QMainWindow pour indiquer quel widget contiendra la zone centrale. Faisons cela dans le constructeur de FenPrincipale :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QWidget</span> <span class="o">*</span><span class="n">zoneCentrale</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QWidget</span><span class="p">;</span>
    <span class="n">setCentralWidget</span><span class="p">(</span><span class="n">zoneCentrale</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Visuellement, ça ne change rien pour le moment. Par contre ce qui est intéressant, c'est qu'on a maintenant un QWidget qui sert de conteneur pour les autres widgets de la zone centrale de la fenêtre.<br>
<br>
On peut donc y insérer des widgets au milieu :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QWidget</span> <span class="o">*</span><span class="n">zoneCentrale</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QWidget</span><span class="p">;</span>

<span class="ln-xtra">    <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">nom</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">prenom</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">age</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span></span>
<span class="ln-xtra"> </span>
<span class="ln-xtra">    <span class="n">QFormLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFormLayout</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre nom"</span><span class="p">,</span> <span class="n">nom</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre prénom"</span><span class="p">,</span> <span class="n">prenom</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addRow</span><span class="p">(</span><span class="s">"Votre âge"</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span></span>
<span class="ln-xtra"> </span>
<span class="ln-xtra">    <span class="n">zoneCentrale</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span></span>

    <span class="n">setCentralWidget</span><span class="p">(</span><span class="n">zoneCentrale</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous noterez que j'ai repris le code du chapitre sur les layouts. J'ai un poil dans la main aujourd'hui, pas envie d'inventer de nouveaux exemples surtout que ça fait exactement la même chose. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
<div class="centre"><img src="./cpp_files/117479.png" alt="Layout dans une QMainWindow"></div><br>
<br>
Bon, je reconnais qu'on ne fait rien de bien excitant pour le moment. Mais maintenant vous savez au moins comment définir un widget central pour une QMainWindow, et ça mine de rien c'est important. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Définition de la zone centrale (type MDI)</h3><br>
<br>
Les choses se compliquent un peu (mais pas trop <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ) si vous voulez créer un programme MDI... par exemple un éditeur de texte qui peut gérer plusieurs documents à la fois.<br>
Nous allons utiliser pour cela une <a href="http://doc.trolltech.com/qmdiarea.html">QMdiArea</a>, qui est une sorte de gros widget conteneur capable d'afficher plusieurs sous-fenêtres.<br>
<br>
On peut se servir du QMdiArea comme de widget conteneur pour la zone centrale :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QMdiArea</span> <span class="o">*</span><span class="n">zoneCentrale</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QMdiArea</span><span class="p">;</span>
    <span class="n">setCentralWidget</span><span class="p">(</span><span class="n">zoneCentrale</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La fenêtre est maintenant prête à accepter des sous-fenêtres :<br>
<br>
<div class="centre"><img src="./cpp_files/117487.png" alt="QMdiArea"></div><br>
<br>
<div class="rmq information">Si le fond gris par défaut ne vous plaît pas, vous pouvez changer le fond (en mettant une autre couleur ou une image) en appelant setBackground().</div><br>
<br>
On crée ces sous-fenêtres en appelant la méthode <span class="code2 cpp"><span class="n">addSubWindow</span><span class="p">()</span>
</span> du QMdiArea. Cette méthode attend en paramètre le widget que la sous-fenêtre doit afficher à l'intérieur.<br>
Là encore, vous pouvez créer un QWidget générique qui contiendra d'autres widgets, eux-mêmes organisés selon un layout. <br>
<br>
On va faire plus simple dans notre exemple : on va faire en sorte que les sous-fenêtres contiennent juste un QTextEdit (pour notre éditeur de texte) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QMdiArea</span> <span class="o">*</span><span class="n">zoneCentrale</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QMdiArea</span><span class="p">;</span>

    <span class="n">QTextEdit</span> <span class="o">*</span><span class="n">zoneTexte1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTextEdit</span><span class="p">;</span>
    <span class="n">QTextEdit</span> <span class="o">*</span><span class="n">zoneTexte2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTextEdit</span><span class="p">;</span>

<span class="ln-xtra">    <span class="n">QMdiSubWindow</span> <span class="o">*</span><span class="n">sousFenetre1</span> <span class="o">=</span> <span class="n">zoneCentrale</span><span class="o">-&gt;</span><span class="n">addSubWindow</span><span class="p">(</span><span class="n">zoneTexte1</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">QMdiSubWindow</span> <span class="o">*</span><span class="n">sousFenetre2</span> <span class="o">=</span> <span class="n">zoneCentrale</span><span class="o">-&gt;</span><span class="n">addSubWindow</span><span class="p">(</span><span class="n">zoneTexte2</span><span class="p">);</span></span>

    <span class="n">setCentralWidget</span><span class="p">(</span><span class="n">zoneCentrale</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat, on a une fenêtre principale qui contient plusieurs sous-fenêtres à l'intérieur :<br>
<br>
<div class="centre"><img src="./cpp_files/117488.png" alt="MDI Subwindows"></div><br>
<br>
Ces fenêtres peuvent êtres réduites ou agrandies à l'intérieur même de la fenêtre principale.<br>
On peut leur définir un titre et une icône avec les bonnes vieilles méthodes setWindowTitle, setWindowIcon, etc.<br>
<br>
C'est quand même dingue tout ce qu'on peut faire en quelques lignes de code avec Qt ! <img src="./cpp_files/huh.png" alt=":o" class="smilies"><br>
<br>
<div class="rmq information">Sur cet exemple, j'ai créé des "fenêtres-zones_de_texte", un peu comme j'avais fait des "fenêtres-boutons" dans les premiers chapitres sur Qt.<br>
Bien sûr, dans la pratique, les sous-fenêtres seront peut-être un peu plus complexes. On n'utilisera pas un QTextEdit directement mais plutôt un QWidget qui contiendra un layout qui contiendra des widgets. Bref, vous m'avez compris. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div><br>
<br>
Vous remarquerez que addSubWindow() renvoie un pointeur sur une QMdiSubWindow : ce pointeur représente la sous-fenêtre qui a été créée. Ça peut être une bonne idée de garder ce pointeur pour la suite. Vous pourrez ainsi supprimer la fenêtre en appelant removeSubWindow().<br>
Sinon, sachez que vous pouvez retrouver à tout moment la liste des sous-fenêtres créées en appelant subWindowList(). Cette méthode renvoie la liste des QMdiSubWindow contenues dans la QMdiArea.<br>
<br>
<br>
...<br>
<br>
Ça va vous vous y retrouvez ? <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Allez un petit schéma pour être sûr que vous avez compris :<br>
<br>
<div class="centre"><img src="./cpp_files/117493.png" alt="Schéma des sous-fenêtres"></div><br>
<br>
On a donc une zone centrale QMdiArea qui contient plusieurs sous-fenêtres, représentées par des QMdiSubWindow. Chacune de ces sous-fenêtres est indépendante et peut contenir ses propres widgets.<br>
<br>
<br>
Notons que ce type de fenêtre MDI est de moins en moins utilisée. On a plutôt tendance aujourd'hui à recourir aux onglets lorsque plusieurs documents sont ouverts.<br>
Ça tombe bien, les QMdiArea de Qt peuvent changer de mode d'affichage en une seule ligne grâce à setViewMode(). Par exemple, avec ce code :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">zoneCentrale</span><span class="o">-&gt;</span><span class="n">setViewMode</span><span class="p">(</span><span class="n">QMdiArea</span><span class="o">::</span><span class="n">TabbedView</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... les sous-fenêtres seront organisées sous forme d'onglets :<br>
<br>
<div class="centre"><img src="./cpp_files/117494.png" alt="MDI avec onglets"></div><br>
<br>
<div class="rmq question">Ça ne revient pas au même qu'un QTabWidget ça ?  <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> </div><br>
<br>
Si, en effet, on peut faire pareil avec un QTabWidget. L'avantage là c'est que Qt gère chaque onglet comme une fenêtre, et vous pouvez proposer à l'utilisateur de passer en un clic du mode de vue MDI classique au mode onglets. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>

		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11338">Les menus</h2>
		<div class="ss_part_texte">
		La QMainWindow peut afficher une barre de menus, comme par exemple : Fichier, Edition, Affichage, Aide...<br>
Comment fait-on pour les créer ?<br>
<br>
<br>
<h3>Créer un menu pour la fenêtre principale</h3><br>
<br>
La barre de menus est accessible depuis la méthode menuBar(). Cette méthode renvoie un pointeur sur un QMenuBar, qui vous propose une méthode addMenu(). Cette méthode renvoie un pointeur sur le QMenu créé.<br>
<br>
Puisqu'un petit code vaut tous les discours du monde, voici comment faire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuFichier</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Fichier"</span><span class="p">);</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuEdition</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Edition"</span><span class="p">);</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuAffichage</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Affichage"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Avec ça, nous avons créé 3 menus dont nous gardons les pointeurs (menuFichier, menuEdition, menuAffichage). Vous noterez qu'on utilise ici aussi le symbole &amp; pour définir des raccourcis clavier (les lettres F, E et A seront donc des raccourcis vers leurs menus respectifs).<br>
<br>
Nous avons maintenant 3 menus sur notre fenêtre :<br>
<br>
<div class="centre"><img src="./cpp_files/117656.png" alt="Menus"></div><br>
<br>
Mais... ces menus n'affichent rien ! En effet, ils ne contiennent pour le moment aucun élément.<br>
<br>
<br>
<h3>Création d'actions pour les menus</h3><br>
<br>
Un <strong>élément de menu</strong> est représenté par une <strong>action</strong>. C'est la classe <a href="http://doc.trolltech.com/qaction.html">QAction</a> qui gère ça.<br>
<br>
<div class="rmq question">Pourquoi avoir créé une classe QAction au lieu de... je sais pas moi... QSubMenu pour dire "sous-menu" ?</div><br>
<br>
En fait, les QAction sont des éléments de menu génériques. Ils peuvent être utilisés à la fois pour les menus et pour la barre d'outils.<br>
Par exemple, imaginons l'élément "Nouveau" qui permet de créer un nouveau document. On peut en général y accéder depuis 2 endroits différents :<br>
<br>
<ul>
<li>Le menu Fichier / Nouveau.</li>
<li>Le bouton de la barre d'outils "Nouveau", généralement représenté par une icône de document vide.</li>
</ul><br>
Une seule QAction peut servir à définir ces 2 éléments à la fois.<br>
Les développeurs de Qt se sont en effet rendus compte que les actions des menus étaient souvent dupliquées dans la barre d'outils, d'où la création de la classe QAction que nous réutiliserons lorsque nous créerons la barre d'outils.<br>
<br>
Pour créer une action vous avez 2 possibilités :<br>
<br>
<ul>
<li>Soit vous la créez d'abord, puis vous créez l'élément de menu qui correspond.</li>
<li>Soit vous créez l'élément de menu directement, et celui-ci vous renvoie un pointeur vers la QAction créée automatiquement.</li>
</ul><br>
Nous allons tester ces 2 possibilités.<br>
<br>
<h4>Créer une QAction, puis créer l'élément de menu</h4><br>
<br>
Nous allons tout d'abord créer une QAction, puis nous l'ajouterons au menu "Fichier" :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuFichier</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Fichier"</span><span class="p">);</span>

<span class="ln-xtra">    <span class="n">QAction</span> <span class="o">*</span><span class="n">actionQuitter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="s">"&amp;Quitter"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">menuFichier</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionQuitter</span><span class="p">);</span></span>

    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuEdition</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Edition"</span><span class="p">);</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuAffichage</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Affichage"</span><span class="p">);</span>


<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Dans l'exemple de code ci-dessus, nous créons d'abord une QAction correspondant à l'action "Quitter". Nous définissons en second paramètre de son constructeur un pointeur sur la fenêtre principale (this), qui servira de parent à l'action.<br>
Puis, nous ajoutons l'action au menu "Fichier".<br>
<br>
Résultat, l'élément de menu est créé :<br>
<br>
<div class="centre"><img src="./cpp_files/117669.png" alt="Menus"></div><br>
<br>
<br>
<h4>Créer l'élément de menu et récupérer la QAction</h4><br>
<br>
Il y a une autre façon de faire.<br>
Parfois, vous trouverez que créer une QAction avant de générer l'élément de menu est un peu lourd. Dans ce cas, vous pouvez passer par une des versions surchargées de la méthode addAction :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuFichier</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Fichier"</span><span class="p">);</span>

<span class="ln-xtra">    <span class="n">QAction</span> <span class="o">*</span><span class="n">actionQuitter</span> <span class="o">=</span> <span class="n">menuFichier</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="s">"&amp;Quitter"</span><span class="p">);</span></span>

    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuEdition</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Edition"</span><span class="p">);</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuAffichage</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Affichage"</span><span class="p">);</span>

    <span class="n">connect</span><span class="p">(</span><span class="n">actionQuitter</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le résultat est strictement le même :<br>
<br>
<div class="centre"><img src="./cpp_files/117669.png" alt="Menus"></div><br>
<br>
<br>
<h3>Les sous-menus</h3><br>
<br>
Les sous-menus sont gérés par la classe <a href="http://doc.trolltech.com/qmenu.html">QMenu</a>.<br>
<br>
Imaginons que nous voulions créer un sous-menu "Fichiers récents" au menu "Fichier". Ce sous-menu affichera une liste de fichiers récemment ouverts par le programme (des fichiers bidons pour cet exemple).<br>
<br>
Au lieu d'appeler addAction() de la QMenuBar, appelez cette fois addMenu() qui renvoie un pointeur vers un QMenu :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">QMenu</span> <span class="o">*</span><span class="n">fichiersRecents</span> <span class="o">=</span> <span class="n">menuFichier</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"Fichiers &amp;récents"</span><span class="p">);</span>
<span class="n">fichiersRecents</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="s">"Fichier bidon 1.txt"</span><span class="p">);</span>
<span class="n">fichiersRecents</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="s">"Fichier bidon 2.txt"</span><span class="p">);</span>
<span class="n">fichiersRecents</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="s">"Fichier bidon 3.txt"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous voyez que j'ajoute ensuite de nouvelles actions pour peupler le sous-menu "Fichiers récents". Résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/117847.png" alt="Sous-menus"></div><br>
<br>
Je n'ai pas récupéré de pointeur vers les QAction créées à chaque fois. J'aurais dû le faire si je voulais ensuite connecter les signaux des actions à des slots, mais je ne l'ai pas fait ici pour simplifier le code.<br>
<br>
<div class="rmq information">Vous pouvez créer des menus contextuels personnalisés de la même façon, avec des QMenu. Un menu contextuel est un menu qui s'affiche lorsqu'on fait un clic droit sur un widget. C'est un petit peu plus complexe. Je vous laisse lire la doc de QWidget à propos des menus contextuels pour savoir comment faire ça si vous en avez besoin.</div><br>
<br>
<h3>Manipulations plus avancées des QAction</h3><br>
<br>
Une QAction est au minimum constituée d'un texte descriptif. Mais ce serait dommage de la limiter à ça.<br>
Voyons un peu ce qu'on peut faire avec les QAction...<br>
<br>
<br>
<h4>Connecter les signaux et les slots</h4><br>
<br>
Le premier rôle d'une QAction est de générer des signaux, que l'on aura connectés à des slots.<br>
La QAction propose plusieurs signaux intéressants. Le plus utilisé d'entre eux est triggered() qui indique que l'action a été choisie par l'utilisateur.<br>
<br>
On peut connecter notre action "Quitter" au slot quit() de l'application :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">connect</span><span class="p">(</span><span class="n">actionQuitter</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Désormais, un clic sur "Fichier / Quitter" fermera l'application. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Vous avez aussi un évènement hovered() qui s'active lorsqu'on passe la souris sur l'action. A tester !<br>
<br>
<br>
<h4>Ajouter un raccourci</h4><br>
<br>
On peut définir un raccourci clavier pour l'action. On passe pour cela par la méthode addShortcut().<br>
<br>
Cette méthode peut être utilisée de plusieurs manières différentes. La technique la plus simple est de lui envoyer une <a href="http://doc.trolltech.com/qkeysequence.html">QKeySequence</a> représentant le raccourci clavier :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="p">(</span><span class="s">"Ctrl+Q"</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voilà, il suffit d'écrire dans le constructeur de la QKeySequence le raccourci approprié, Qt se chargera de comprendre le raccourci tout seul.<br>
<br>
<div class="centre"><img src="./cpp_files/117798.png" alt="Menu et raccourci"></div><br>
<br>
Vous pouvez faire le raccourci clavier Ctrl + Q n'importe où dans la fenêtre maintenant, cela activera l'action "Quitter" !<br>
<br>
Sachez que QKeySequence accepte d'autres syntaxes :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">CTRL</span> <span class="o">+</span> <span class="n">Qt</span><span class="o">::</span><span class="n">Key_Q</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... créera le même raccourci "Ctrl + Q", sauf que cette fois nous sommes passés par des symboles pour le définir.<br>
<br>
Vous pouvez aussi utiliser une séquence prédéfinie, qui s'adapte en fonction des habitudes de l'OS.<br>
Par exemple, la séquence prédéfinie QKeySequence::HelpContents est faite pour représenter un raccourci clavier qui amène à l'aide.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="p">(</span><span class="n">QKeySequence</span><span class="o">::</span><span class="n">HelpContents</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Sous Windows, ce sera la touche F1, sous Mac OS X, ce sera le raccourci "Ctrl + ?".<br>
<br>
Pour avoir la liste des séquences prédéfinies, c'est dans la doc. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h4>Ajouter une icône</h4><br>
<br>
Chaque action peut avoir une icône.<br>
Lorsque l'action est associée à un menu, l'icône est affichée à gauche  de l'élément de menu. Mais, souvenez-vous, une action peut aussi être associée à une barre d'outils comme on le verra plus tard. L'icône peut donc aussi être réutilisée dans la barre d'outils.<br>
<br>
Pour ajouter une icône, appelez setIcon() et envoyez-lui un QIcon :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"quitter.png"</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/117800.png" alt="Icône dans un menu"></div><br>
<br>
<br>
<h4>Pouvoir cocher une action</h4><br>
<br>
Lorsqu'une action peut avoir 2 états (activée, désactivée), vous pouvez la rendre "cochable" grâce à setCheckable().<br>
Imaginons par exemple le menu Edition / Gras :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">actionGras</span><span class="o">-&gt;</span><span class="n">setCheckable</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le menu a maintenant 2 états et peut être précédé d'une case à cocher :<br>
<br>
<div class="centre"><img src="./cpp_files/117801.png" alt="Menu cochable"></div><br>
<br>
On vérifiera dans le code si l'action est cochée avec isChecked().<br>
<br>
<div class="flot_gauche"><img src="./cpp_files/117804.png" alt="Bouton gras coché"></div>Lorsque l'action est utilisée sur une barre d'outils, le bouton reste enfoncé lorsque l'action est "cochée". C'est ce que vous avez l'habitude de voir dans un traitement de texte par exemple (cf image ci-contre <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ).<br>
<br>
<br>
Ah, puisqu'on parle de barre d'outils, il serait temps d'apprendre à en créer une !
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11337">La barre d'outils</h2>
		<div class="ss_part_texte">
		La barre d'outils est généralement constituée d'icônes et située sous les menus.<br>
Avec Qt, la barre d'outils utilise des actions pour construire chacun des éléments de la barre. Étant donné que vous avez appris à manipuler des actions juste avant, vous devriez donc être capables de créer une barre d'outils très rapidement. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Pour ajouter une barre d'outils, vous devez tout d'abord appeler la méthode addToolBar() de la QMainWindow. Il faudra donner un nom à la barre d'outils, même si celui-ci ne s'affiche pas.<br>
Vous récupérez un pointeur vers la QToolBar :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QToolBar</span> <span class="o">*</span><span class="n">toolBarFichier</span> <span class="o">=</span> <span class="n">addToolBar</span><span class="p">(</span><span class="s">"Fichier"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Maintenant que nous avons notre QToolBar, nous pouvons commencer !<br>
<br>
<br>
<h3>Ajouter une action</h3><br>
<br>
Le plus simple est d'ajouter une action à la QToolBar. On utilise comme pour les menus une méthode appelée addAction() qui prend comme paramètre une QAction.<br>
Le gros intérêt que vous devriez saisir maintenant, c'est que vous pouvez réutiliser ici vos QAction créées pour les menus !<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">// Création des menus</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuFichier</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Fichier"</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">QAction</span> <span class="o">*</span><span class="n">actionQuitter</span> <span class="o">=</span> <span class="n">menuFichier</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="s">"&amp;Quitter"</span><span class="p">);</span></span>
    <span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="p">(</span><span class="s">"Ctrl+Q"</span><span class="p">));</span>
    <span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"quitter.png"</span><span class="p">));</span>
    
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuEdition</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Edition"</span><span class="p">);</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuAffichage</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Affichage"</span><span class="p">);</span>

    <span class="c">// Création de la barre d'outils</span>
    <span class="n">QToolBar</span> <span class="o">*</span><span class="n">toolBarFichier</span> <span class="o">=</span> <span class="n">addToolBar</span><span class="p">(</span><span class="s">"Fichier"</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">toolBarFichier</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionQuitter</span><span class="p">);</span></span>

    <span class="n">connect</span><span class="p">(</span><span class="n">actionQuitter</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Dans ce code, on voit qu'on crée d'abord une QAction pour un menu (ligne 7), puis plus loin on réutilise cette action pour l'ajouter à la barre d'outils (ligne 16).<br>
<br>
<div class="centre"><img src="./cpp_files/117832.png" alt="Barre outils"></div><br>
<br>
Comme l'action est la même que celle utilisée pour le menu "Quitter", on retrouve :<br>
<br>
<ul>
<li><strong>Son icône</strong> : ici affichée dans la barre d'outils.</li>
<li><strong>Son texte</strong> : ici affiché lorsqu'on pointe sur l'icône.</li>
<li><strong>Son action</strong> : elle est toujours connectée au slot quit() de l'application, ce qui a pour effet de mettre fin au programme.</li>
</ul><br>
Et voilà comment Qt fait d'une pierre deux coups grâce aux QAction ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<br>
<h3>Ajouter un widget</h3><br>
<br>
Les barres d'outils contiennent le plus souvent des QAction, mais il arrivera que vous ayez besoin d'insérer des éléments plus complexes.<br>
La QToolBar gère justement tous types de widgets.<br>
<br>
Vous pouvez ajouter des widgets avec la méthode addWidget(), comme vous le faisiez avec les layouts :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">QFontComboBox</span> <span class="o">*</span><span class="n">choixPolice</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFontComboBox</span><span class="p">;</span>
<span class="n">toolBarFichier</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">choixPolice</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ici, on insère une liste déroulante (plus précisément une QFontComboBox, une liste déroulante spécialisée dans le choix d'une police).<br>
Le widget s'insère alors dans la barre d'outils :<br>
<br>
<div class="centre"><img src="./cpp_files/117834.png" alt="Barre outils widget"></div><br>
<br>
... et vous pouvez l'utiliser comme n'importe quel widget normal, gérer ses signaux, ses slots, etc.<br>
<br>
<div class="centre"><img src="./cpp_files/117835.png" alt="Barre outils widget"></div><br>
<br>
<div class="rmq information">La méthode addWidget() crée une QAction automatiquement. Elle renvoie un pointeur vers cette QAction créée. Ici, on n'a pas récupéré le pointeur, mais vous pouvez le faire si vous avez besoin d'effectuer des opérations ensuite sur la QAction.</div><br>
<br>
<h3>Ajouter un séparateur</h3><br>
<br>
Si votre barre d'outils commence à comporter trop d'éléments, ça peut être une bonne idée de les séparer. C'est pour cela que Qt propose des <span class="italique">separators </span>(séparateurs).<br>
Cela vous permettra par exemple de regrouper les boutons "Annuler" et "Rétablir", pour ne pas les confondre avec les boutons "Gras", "Italique", "Souligné".<br>
<br>
Il suffit simplement d'appeler la méthode addSeparator() au moment où vous voulez insérer un séparateur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">// Création des menus</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuFichier</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Fichier"</span><span class="p">);</span>
    <span class="n">QAction</span> <span class="o">*</span><span class="n">actionQuitter</span> <span class="o">=</span> <span class="n">menuFichier</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="s">"&amp;Quitter"</span><span class="p">);</span>
    <span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="p">(</span><span class="s">"Ctrl+Q"</span><span class="p">));</span>
    <span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"quitter.png"</span><span class="p">));</span>

    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuEdition</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Edition"</span><span class="p">);</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuAffichage</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Affichage"</span><span class="p">);</span>

    <span class="c">// Création de la barre d'outils</span>
    <span class="n">QToolBar</span> <span class="o">*</span><span class="n">toolBarFichier</span> <span class="o">=</span> <span class="n">addToolBar</span><span class="p">(</span><span class="s">"Fichier"</span><span class="p">);</span>
    <span class="n">toolBarFichier</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionQuitter</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">toolBarFichier</span><span class="o">-&gt;</span><span class="n">addSeparator</span><span class="p">();</span></span>
    <span class="n">QFontComboBox</span> <span class="o">*</span><span class="n">choixPolice</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFontComboBox</span><span class="p">;</span>
    <span class="n">toolBarFichier</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">choixPolice</span><span class="p">);</span>

    <span class="n">connect</span><span class="p">(</span><span class="n">actionQuitter</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/117842.png" alt="Barre outils break"><br>
<span class="italique">Notez le séparateur entre le bouton Quitter et la liste déroulante</span></div><br>
<br>
Vous pouvez aussi insérer un séparateur à une position précise grâce à insertSeparator().<br>
<br>
<h3>Plus d'options pour la barre d'outils</h3><br>
<br>
Par défaut, la barre d'outils est déplaçable. Vous pouvez la placer en haut, sur les côtés ou en bas, et vous pouvez même en faire une mini-fenêtre indépendante :<br>
<br>
<div class="centre"><img src="./cpp_files/117841.png" alt="Barre outils déplaçable"></div><br>
<br>
Si vous souhaitez éviter que la barre d'outils soit déplaçable, modifiez sa propriété movable.<br>
Si vous souhaitez juste éviter qu'on puisse créer une mini-fenêtre indépendante, modifiez sa propriété floatable.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11336">Les docks</h2>
		<div class="ss_part_texte">
		Les docks sont des mini-fenêtres que l'on peut généralement déplacer à notre guise dans la fenêtre principale.<br>
Vous avez l'habitude d'en voir dans des programmes complexes comme Photoshop ou votre IDE (Code::Blocks en utilise un pour afficher la liste des fichiers du projet par exemple).<br>
<br>
<br>
<h3>Créer un QDockWidget</h3><br>
<br>
Créez un <a href="http://doc.trolltech.com/qdockwidget.html">QDockWidget</a> et affectez-lui un titre pour commencer. Indiquez que la fenêtre principale (this) est son widget parent en second paramètre :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QDockWidget</span> <span class="o">*</span><span class="n">dock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QDockWidget</span><span class="p">(</span><span class="s">"Palette"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Puis, placez ce dock sur la fenêtre principale à l'aide de la méthode addDockWidget() :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">addDockWidget</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">LeftDockWidgetArea</span><span class="p">,</span> <span class="n">dock</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Comme vous pouvez le voir, le premier paramètre permet d'indiquer à quel endroit le dock doit être placé. On peut le mettre en haut, en bas, à gauche ou à droite. On peut même faire flotter le dock comme une mini-fenêtre.<br>
<br>
<strong><span class="rouge">Par défaut, l'utilisateur a le droit de déplacer le dock</span></strong>. Si vous ne souhaitez pas qu'il puisse le faire, faites appel à la méthode setFeatures() du QDockWidget. Vous pouvez tout personnaliser à partir de là.<br>
<br>
<div class="rmq information">De manière générale, évitez d'empêcher à l'utilisateur de réorganiser les docks. La puissance des docks c'est justement que l'on peut les réorganiser selon ses préférences. Ce serait dommage de perdre en fonctionnalités.</div><br>
<br>
<h3>Peupler le QDockWidget</h3><br>
<br>
Notre QDockWidget est créé mais il ne contient rien.<br>
Pour le peupler en widgets, il faut d'abord créer un widget conteneur et indiquer que ce widget gère le contenu du QDockWidget.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">QWidget</span> <span class="o">*</span><span class="n">contenuDock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QWidget</span><span class="p">;</span>
<span class="n">dock</span><span class="o">-&gt;</span><span class="n">setWidget</span><span class="p">(</span><span class="n">contenuDock</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Après, il n'y a plus qu'à placer des widgets et / ou des layouts dans contenuDock, comme si c'était une fenêtre.<br>
Je mets quelques widgets au pif, ne faites pas spécialement attention au détail de ce code :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="n">QPushButton</span> <span class="o">*</span><span class="n">crayon</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Crayon"</span><span class="p">);</span>
<span class="n">QPushButton</span> <span class="o">*</span><span class="n">pinceau</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Pinceau"</span><span class="p">);</span>
<span class="n">QPushButton</span> <span class="o">*</span><span class="n">feutre</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Feutre"</span><span class="p">);</span>
<span class="n">QLabel</span> <span class="o">*</span><span class="n">labelEpaisseur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLabel</span><span class="p">(</span><span class="s">"Epaisseur :"</span><span class="p">);</span>
<span class="n">QSpinBox</span> <span class="o">*</span><span class="n">epaisseur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QSpinBox</span><span class="p">;</span>

<span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">dockLayout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
<span class="n">dockLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">crayon</span><span class="p">);</span>
<span class="n">dockLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">pinceau</span><span class="p">);</span>
<span class="n">dockLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">feutre</span><span class="p">);</span>
<span class="n">dockLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">labelEpaisseur</span><span class="p">);</span>
<span class="n">dockLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">epaisseur</span><span class="p">);</span>

<span class="n">contenuDock</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">dockLayout</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h3>Code complet</h3><br>
<br>
Voici un code complet qui utilise des menus, une barre d'outils et un dock. Il est un peu long mais ne vous laissez pas impressionner, il n'y a rien de nouveau ni de compliqué.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">// Création des menus</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuFichier</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Fichier"</span><span class="p">);</span>

    <span class="n">QAction</span> <span class="o">*</span><span class="n">actionQuitter</span> <span class="o">=</span> <span class="n">menuFichier</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="s">"&amp;Quitter"</span><span class="p">);</span>
    <span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="p">(</span><span class="s">"Ctrl+Q"</span><span class="p">));</span>
    <span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"quitter.png"</span><span class="p">));</span>

    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuEdition</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Edition"</span><span class="p">);</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuAffichage</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="s">"&amp;Affichage"</span><span class="p">);</span>

    <span class="c">// Création de la barre d'outils</span>
    <span class="n">QToolBar</span> <span class="o">*</span><span class="n">toolBarFichier</span> <span class="o">=</span> <span class="n">addToolBar</span><span class="p">(</span><span class="s">"Fichier"</span><span class="p">);</span>
    <span class="n">toolBarFichier</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionQuitter</span><span class="p">);</span>
    <span class="n">toolBarFichier</span><span class="o">-&gt;</span><span class="n">addSeparator</span><span class="p">();</span>
    <span class="n">QFontComboBox</span> <span class="o">*</span><span class="n">choixPolice</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QFontComboBox</span><span class="p">;</span>
    <span class="n">toolBarFichier</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">choixPolice</span><span class="p">);</span>

    <span class="c">// Création des docks</span>
    <span class="n">QDockWidget</span> <span class="o">*</span><span class="n">dock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QDockWidget</span><span class="p">(</span><span class="s">"Palette"</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">addDockWidget</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">LeftDockWidgetArea</span><span class="p">,</span> <span class="n">dock</span><span class="p">);</span>

    <span class="n">QWidget</span> <span class="o">*</span><span class="n">contenuDock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QWidget</span><span class="p">;</span>
    <span class="n">dock</span><span class="o">-&gt;</span><span class="n">setWidget</span><span class="p">(</span><span class="n">contenuDock</span><span class="p">);</span>

    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">crayon</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Crayon"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">pinceau</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Pinceau"</span><span class="p">);</span>
    <span class="n">QPushButton</span> <span class="o">*</span><span class="n">feutre</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Feutre"</span><span class="p">);</span>
    <span class="n">QLabel</span> <span class="o">*</span><span class="n">labelEpaisseur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLabel</span><span class="p">(</span><span class="s">"Epaisseur :"</span><span class="p">);</span>
    <span class="n">QSpinBox</span> <span class="o">*</span><span class="n">epaisseur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QSpinBox</span><span class="p">;</span>

    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">dockLayout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
    <span class="n">dockLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">crayon</span><span class="p">);</span>
    <span class="n">dockLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">pinceau</span><span class="p">);</span>
    <span class="n">dockLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">feutre</span><span class="p">);</span>
    <span class="n">dockLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">labelEpaisseur</span><span class="p">);</span>
    <span class="n">dockLayout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">epaisseur</span><span class="p">);</span>

    <span class="n">contenuDock</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">dockLayout</span><span class="p">);</span>

    <span class="c">// Création de la zone centrale</span>
    <span class="n">QWidget</span> <span class="o">*</span><span class="n">zoneCentrale</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QWidget</span><span class="p">;</span>
    <span class="n">setCentralWidget</span><span class="p">(</span><span class="n">zoneCentrale</span><span class="p">);</span>

    <span class="n">connect</span><span class="p">(</span><span class="n">actionQuitter</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
J'ai volontairement mis des commentaires pour séparer les différentes sections de la génération de la fenêtre.<br>
<br>
Voilà le résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/117865.png" alt="Dock"></div><br>
<br>
Le dock est placé à gauche comme nous l'avons demandé, mais nous pouvons le changer de côté.<br>
<br>
D'autre part, nous pouvons faire sortir le dock et nous en servir comme d'une mini-fenêtre indépendante :<br>
<br>
<div class="centre"><img src="./cpp_files/117866.png" alt="Dock flottant"></div><br>
<br>
Bien sûr, cet exemple est à améliorer : il vaudrait mieux afficher des icônes sur les boutons plutôt que du texte, c'est plus intuitif et plus habituel. <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11335">La barre d'état</h2>
		<div class="ss_part_texte">
		La barre d'état est une petite barre affichée en bas de la fenêtre. Elle indique ce qu'est en train de faire l'application.<br>
<br>
Par exemple, un navigateur web comme Firefox affiche le message "Terminé" lorsque la page web a été chargée. Lorsque la page est en cours de chargement, une barre de progression apparaît à cet emplacement.<br>
<br>
La barre d'état est automatiquement créée et retournée par la méthode statusBar() de la QMainWindow.<br>
Celle-ci renvoie un pointeur vers une QStatusBar que vous devez conserver :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QStatusBar</span> <span class="o">*</span><span class="n">barreEtat</span> <span class="o">=</span> <span class="n">statusBar</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notre barre d'état est créée ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Maintenant, que peut-on faire dedans ?<br>
Il faut savoir qu'une barre d'état peut afficher 3 types de messages différents :<br>
<br>
<ul>
<li><strong>Un message temporaire</strong> : il est affiché brièvement par-dessus tous les messages normaux.</li>
<li><strong>Un message normal</strong> : il est affiché tout le temps, sauf quand un message temporaire est affiché.</li>
<li><strong>Un message permanent</strong> : il est affiché tout le temps, même quand un message temporaire est affiché.</li>
</ul><br>
<br>
<h3>Les messages temporaires</h3><br>
<br>
C'est le plus simple : appelez la méthode showMessage() et indiquez le message à afficher. Par exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">barreEtat</span><span class="o">-&gt;</span><span class="n">showMessage</span><span class="p">(</span><span class="s">"Prêt"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/117872.png" alt="Barre de statut"></div><br>
<br>
Vous pouvez indiquer en second paramètre la durée d'affichage du message en millisecondes, avant qu'il disparaisse. Exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">barreEtat</span><span class="o">-&gt;</span><span class="n">showMessage</span><span class="p">(</span><span class="s">"Le fichier a été sauvegardé"</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce message restera affiché 2 secondes.<br>
<br>
<br>
<h3>Les messages normaux et permanents</h3><br>
<br>
Pour les messages normaux et permanents, c'est un peu plus compliqué : il faut utiliser des widgets. Vous pouvez placer a priori n'importe quel widget dans cette zone, les plus courants étant les QLabel et les QProgressBar.<br>
<br>
Utilisez :<br>
<br>
<ul>
<li><strong>addWidget()</strong> : pour afficher un widget normal.</li>
<li><strong>addPermanentWidget()</strong> : pour afficher un widget permanent.</li>
</ul><br>
<br>
Exemple de widget normal affiché en barre d'état :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">QProgressBar</span> <span class="o">*</span><span class="n">progression</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QProgressBar</span><span class="p">;</span>
<span class="n">barreEtat</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">progression</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voilà, avec ça vous pouvez faire tout ce que vous voulez. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Les status tips des QAction</h3><br>
<br>
Les QAction disposent d'une propriété dont je ne vous ai pas parlé jusqu'ici : statusTip.<br>
Elle permet d'indiquer un message qui doit s'afficher dans la barre d'état lorsqu'on pointe sur une action. Cela permet de donner de plus amples indications sur le rôle d'un élément de menu par exemple.<br>
<br>
Mettons en place un statusTip sur l'action "Quitter" :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setStatusTip</span><span class="p">(</span><span class="s">"Quitte le programme"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Et voici ce que fait le statusTip, lorsqu'on pointe sur l'élément de menu :<br>
<br>
<div class="centre"><img src="./cpp_files/117990.png" alt="Status tip"></div><br>
<br>
Vous pouvez voir que la barre d'état affiche le statusTip lorsque la souris pointe sur l'action. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Pfiou ! Ce n'est pas la fenêtre <strong>principale </strong>pour rien : c'est fou tout ce qu'on peut mettre dedans. A tel point qu'on se demande des fois s'il reste de la place pour afficher le widget central. <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"><br>
<br>
La QMainWindow offre beaucoup de possibilités, mais ne vous sentez pas obligés de toutes les utiliser. Au contraire, ne faites appel qu'à ce qui vous sert, et ne surchargez pas inutilement la fenêtre principale. Sinon, vos utilisateurs mettront du temps avant d'arriver à la maîtriser, ce qui n'est jamais très bon.<br>
<br>
<br>
<h3>Exercice : créer un éditeur de texte</h3><br>
<br>
Je crois que l'exercice de ce chapitre est tout trouvé : je vous propose de faire un éditeur de texte (en mode MDI, <span class="italique">of course</span> <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).<br>
En effet, un éditeur de texte contient un peu tout ce qu'on vient d'apprendre :<br>
<br>
<ul>
<li>Des menus</li>
<li>Une barre d'outils</li>
<li>Une barre d'état</li>
<li>Un mode multi-documents (MDI)</li>
</ul><br>
Et vous pouvez même ajouter des docks si vous leur trouvez une utilité. <img src="./cpp_files/hihi.png" alt="^^" class="smilies"><br>
<br>
Bien que classique, c'est un très bon exercice. Il faudra bien vous organiser. Pour ce qui est de l'écriture des fichiers, utilisez <a href="http://doc.trolltech.com/qfile.html">QFile</a>.<br>
Bon courage !
	</div>
	
	<hr>
	<h1 id="chap_11350">Traduire son programme avec Qt Linguist</h1>
	<div id="chap_intro">
	Si vous avez de l'ambition pour vos programmes, vous aurez peut-être envie un jour de les traduire dans d'autres langues. En effet, ce serait dommage de limiter votre programme seulement aux francophones, il y a certainement de nombreuses autres personnes qui aimeraient pouvoir en profiter !<br>
<br>
La traduction d'applications n'est normalement pas une chose facile. D'ailleurs, il ne s'agit pas seulement de traduire des mots ou des phrases. Il ne suffit pas toujours de dire "Ouvrir" = "Open".<br>
<br>
En effet, on parle des milliers de langues et dialectes différents sur notre bonne vieille planète. Certaines ressemblent au français, certaines écrivent de droite à gauche (l'arabe par exemple), d'autres ont des accents très particuliers que nous n'avons l'habitude d'utiliser (le ñ espagnol par exemple). Et je vous parle même pas des caractères hébraïques et japonais. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
On ne parle donc pas seulement de traduction mais de <strong>localisation</strong>. Il faut que notre programme puisse s'adapter avec les habitudes de chaque langue. Il faut que les phrases soient écrites de droite à gauche si nécessaire.<br>
<br>
C'est là que Qt excelle et vous simplifie littéralement la tâche. Tout est prévu. Tous les outils pour traduire au mieux vos applications sont installés de base.<br>
Comment ça fonctionne ? Nous allons voir ça. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11349">Les étapes de la traduction</h2>
		<div class="ss_part_texte">
		La traduction de programmes Qt est un processus bien pensé... mais encore faut-il comprendre comment ça fonctionne. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Qt suppose que les développeurs (vous) ne sont pas des traducteurs. Il suppose donc que ce sont 2 personnes différentes.<br>
Tout a été fait pour que les traducteurs, même si ce ne sont pas des informaticiens, soient capables de traduire votre programme.<br>
<br>
<div class="rmq information">Dans la pratique, si c'est un petit projet personnel, vous serez peut-être <span class="italique">aussi </span>le traducteur de votre programme. Mais nous allons supposer ici que le traducteur est une autre personne.</div><br>
<br>
Je vous propose de regarder ce schéma de mon crû qui résume grosso modo les étapes de la traduction :<br>
<br>
<div class="centre"><img src="./cpp_files/118032.png" alt="Schema de la traduction"></div><br>
<br>
<ol class="liste_1">
<li>Tout d'abord, il y a le développeur. C'est vous. Vous écrivez normalement votre programme, en rédigeant les messages dans le code source dans votre langue maternelle (le français). Bref, rien ne change, à part un ou deux petits détails dont on reparlera dans la prochaine sous-partie.<br>
<br>
</li>
<li>Puis, vous générez un fichier contenant les chaînes à traduire. Un programme livré avec Qt le fait automatiquement pour vous. Ce fichier porte l'extension .ts, et est généralement de la forme : <span class="courrier">nomduprogramme_langue.ts</span>.<br>
Par exemple, pour le ZeroClassGenerator, ça donne quelque chose comme <span class="courrier">zeroclassgenerator_en.ts</span> pour la traduction anglaise, <span class="courrier">zeroclassgenerator_es.ts</span> pour la traduction espagnole, etc. Il faut connaître le symbole à 2 lettres de la langue de destination pour donner un nom correct au fichier .ts. Généralement c'est la même chose que les extensions des noms de domaine : fr (français), pl (polonais), ru (russe)...<br>
<br>
</li>
<li>Le traducteur récupère le ou les fichiers .ts à traduire (un par langue). Il les traduit via le programme <strong>Qt Linguist</strong> qu'on découvrira dans quelques minutes.<br>
<br>
</li>
<li>Une fois que le traducteur a fini, il retourne les fichiers .ts traduits au développeur, qui les "compile" en fichiers .qm binaires. La différence entre un .ts et un .qm, c'est un peu comme la différence entre un .cpp (la source) et un .exe (le programme binaire final).<br>
Le .qm contenant les traductions au format binaire, Qt pourra le charger et le lire très rapidement lors de l'exécution du programme, ce qui fait qu'on ne sentira pas de ralentissement si on charge une version traduite du programme.<br>
</li>
</ol><br>
<br>
Je vous propose de découvrir pas à pas chacune de ces étapes dans ce chapitre. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Nous allons commencer par vous, le développeur. Que faut-il faire de spécial lorsque vous écrivez le code source du programme ?
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11348">Préparer son code à une traduction</h2>
		<div class="ss_part_texte">
		La toute première étape de la traduction consiste à écrire son code de manière adaptée, afin que des traducteurs puissent ensuite récupérer tous les messages à traduire.<br>
<br>
<br>
<h3>Utilisez QString pour manipuler des chaînes de caractères</h3><br>
<br>
Comme vous le savez déjà, Qt utilise exclusivement sa classe <a href="http://doc.trolltech.com/qstring.html">QString</a> pour gérer les chaînes de caractères. Cette classe, très complète, gère nativement l'Unicode.<br>
<br>
<div class="rmq information">L'Unicode est une norme qui indique comment sont gérés les caractères à l'intérieur de l'ordinateur. Elle permet à un ordinateur d'afficher sans problème tous types de caractères, en particulier les caractères étrangers.<br>
<a href="http://fr.wikipedia.org/wiki/Unicode">En savoir plus sur Unicode.</a></div><br>
<br>
QString n'a donc aucun problème pour gérer des alphabets cyrilliques ou arabes.<br>
C'est pourquoi il est recommandé, si votre application est susceptible d'être traduite, d'utiliser toujours des QString pour manipuler des chaînes de caractères.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">QString</span> <span class="n">chaine</span> <span class="o">=</span> <span class="s">"Bonjour"</span><span class="p">;</span> <span class="c">// Bon : adapté pour la traduction</span>
<span class="kt">char</span> <span class="n">chaine</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Bonjour"</span><span class="p">;</span> <span class="c">// Mauvais : inadapté pour la traduction</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voilà, c'est juste un conseil que je vous donne là : de manière générale, utilisez autant que possible des QString. Evitez les tableaux de char.<br>
<br>
<h3>Faites passer les chaînes à traduire par la méthode tr()</h3><br>
<br>
<h4>Utilisation basique</h4><br>
<br>
La méthode tr() permet d'indiquer qu'une chaîne devra être traduite. Par exemple, avant vous faisiez :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">quitter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"&amp;Quitter"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Cela ne permettra pas de traduire le texte du bouton. En revanche, si vous faites d'abord appel à la méthode tr() :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">quitter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&amp;Quitter"</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... alors le texte pourra être traduit ensuite. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Vous rédigez donc les textes de votre programme dans votre langue maternelle (ici le français) en les entourant d'un tr().<br>
<br>
<div class="rmq information">La méthode tr() est définie dans QObject. C'est donc une méthode statique dont héritent toutes les classes de Qt, puisqu'elles dérivent de QObject. Dans la plupart des cas, écrire tr() devrait donc fonctionner. Si toutefois vous n'êtes pas dans une classe qui hérite de QObject, il faudra faire précéder tr() de QObject::, comme ceci :<br>
<span class="code2 cpp"><span class="n">quitter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="n">QObject</span><span class="o">::</span><span class="n">tr</span><span class="p">(</span><span class="s">"&amp;Quitter"</span><span class="p">));</span>
</span></div><br>
<br>
<h4>Facultatif : ajouter un message de contexte</h4><br>
<br>
Parfois, il arrivera que le texte à traduire ne soit pas suffisamment explicite à lui tout seul, ce qui rendra difficile sa traduction pour le traducteur qui ne le verra pas dans son contexte.<br>
<br>
Vous pouvez ajouter en second paramètre un message pour expliquer le contexte au traducteur.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">quitter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&amp;Quitter"</span><span class="p">,</span> <span class="s">"Utilisé pour le bouton de fermeture"</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="souligne">Ce message ne sera pas affiché dans votre programme</span> : il aidera juste le traducteur à comprendre ce qu'il doit traduire. En effet, dans certaines langues "Quitter" se traduit peut-être de plusieurs manières différentes. Avec le message de contexte, le traducteur saura comment bien traduire le mot.<br>
<br>
En général, le message de contexte n'est pas obligatoire.<br>
Parfois cependant, il devient vraiment indispensable. Par exemple quand on doit traduire un raccourci clavier (eh oui !) :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Ctrl+Q"</span><span class="p">,</span> <span class="s">"Raccourci clavier pour quitter"</span><span class="p">)));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le traducteur pourra ainsi traduire la chaîne en "Ctrl+S" si c'est le raccourci adapté dans la langue de destination.<br>
<br>
<br>
<h4>Facultatif : gestion des pluriels</h4><br>
<br>
Parfois, une chaîne doit être écrite différemment selon le nombre d'éléments.<br>
Imaginons un programme qui lit le nombre de fichiers dans un répertoire. Il affiche le message "<span class="italique">Il y a X fichier(s)</span>". Comment traduire ça correctement ?<br>
<br>
En fait, ça dépend vraiment des langues. Le pluriel est géré différemment en anglais et en français par exemple :<br>
<br>
<table class="tab_user">




<thead><tr><th>Nombre</th><th>Français</th><th>Anglais</th></tr></thead><tbody><tr>
<td><div class="centre">0</div></td>
<td>Il y a 0 fichier.</td>
<td>There are 0 files.</td>
</tr><tr>
<td><div class="centre">1</div></td>
<td>Il y a 1 fichier.</td>
<td>There is 1 file.</td>
</tr><tr>
<td><div class="centre">2</div></td>
<td>Il y a 2 fichiers.</td>
<td>There are 2 files.</td>
</tr></tbody></table><br>
<br>
Comme vous pouvez le voir, en français on dit "<span class="italique">Il y a 0 fichier.</span>", et en anglais "<span class="italique">There are 0 files.</span>". Les anglais mettent du pluriel quand le nombre d'éléments est à 0 !<br>
<br>
Et encore, je vous parle pas des russes, qui ont un pluriel pour quand il y a 2 éléments et un autre pluriel pour quand il y en a 3 !<br>
<span class="tpetit">(je simplifie parce qu'en fait c'est même un peu plus compliqué que ça encore)</span><br>
<br>
<div class="rmq question"> <img src="./cpp_files/waw.png" alt=":waw:" class="smilies"> <br>
J'vais jamais m'en sortir avec tous ces cas à gérer ! <img src="./cpp_files/pleure.png" alt=":&#39;(" class="smilies"></div><br>
<br>
Eh bien si, rassurez-vous. Qt est capable de gérer tous les pluriels pour chacune des langues.<br>
Ce sera bien entendu le rôle du traducteur ensuite de traduire ces pluriels correctement.<br>
<br>
Comment faire ? Utilisez le 3ème paramètre facultatif qui indique la cardinalité (le nombre d'éléments).<br>
Exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">tr</span><span class="p">(</span><span class="s">"Il y a %n fichier(s)"</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="n">nombreFichiers</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Si on ne veut pas indiquer de contexte comme moi dans ce cas, on est quand même obligé d'envoyer une chaîne vide pour utiliser le 3ème paramètre (c'est la règle des paramètres facultatifs en C++).</div><br>
<br>
Qt utilisera automatiquement la bonne version du texte traduit selon la langue de destination et le nombre d'éléments.<br>
Par ailleurs, le %n sera remplacé par le nombre indiqué en 3ème paramètre.<br>
<br>
<br>
Bon, avec tout ça, votre programme est codé de manière à pouvoir être traduit.<br>
Maintenant, comment se passe l'étape de la traduction ?
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11347">Créer les fichiers de traduction .ts</h2>
		<div class="ss_part_texte">
		Nous avons maintenant un programme qui fait appel à la méthode tr() pour désigner toutes les chaînes de caractères qui doivent être traduites.<br>
<br>
On va prendre l'exemple de notre TP ZeroClassGenerator. Je l'ai adapté pour qu'il utilise des tr().<br>
On souhaite que ZeroClassGenerator soit traduit dans les langues suivantes :<br>
<br>
<ul>
<li>Anglais</li>
<li>Espagnol</li>
</ul><br>
<br>
Nous devons générer 2 fichiers de traduction :<br>
<br>
<ul>
<li><span class="courrier">zeroclassgenerator_en.ts</span> pour l'anglais</li>
<li><span class="courrier">zeroclassgenerator_es.ts</span> pour l'espagnol</li>
</ul><br>
<br>
Il va falloir éditer le fichier .pro. Celui-ci se trouve dans le dossier de votre projet et a normalement été généré automatiquement lorsque vous avez fait <span class="code2 console">qmake&nbsp;-project</span>.<br>
Ouvrez ce fichier (dans mon cas ZeroClassGenerator.pro) avec un éditeur de texte comme Bloc-Notes, ou Notepad++, ou ce que vous voulez.<br>
<br>
Pour le moment il devrait contenir quelque chose comme ça :<br>
<br>
<span class="code">Code : Autre - <a href="#" class="select_code">Sélectionner</a></span><div class="code2"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><div class="syntax"><pre>######################################################################
#&nbsp;Automatically&nbsp;generated&nbsp;by&nbsp;qmake&nbsp;(2.01a)&nbsp;ven.&nbsp;23.&nbsp;mai&nbsp;16:31:10&nbsp;2008
######################################################################

TEMPLATE&nbsp;=&nbsp;app
TARGET&nbsp;=&nbsp;
DEPENDPATH&nbsp;+=&nbsp;.
INCLUDEPATH&nbsp;+=&nbsp;.

#&nbsp;Input
HEADERS&nbsp;+=&nbsp;FenCodeGenere.h&nbsp;FenPrincipale.h
SOURCES&nbsp;+=&nbsp;FenCodeGenere.cpp&nbsp;FenPrincipale.cpp&nbsp;main.cpp</pre></div></td></tr></tbody></table></div><br>
<br>
Rajoutez à la fin une directive TRANSLATIONS en indiquant les noms des fichiers de traduction à générer. Ici, nous rajoutons un fichier pour la traduction anglaise, et un autre pour la traduction espagnole :<br>
<br>
<span class="code">Code : Autre - <a href="#" class="select_code">Sélectionner</a></span><div class="code2"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><div class="syntax"><pre>######################################################################
#&nbsp;Automatically&nbsp;generated&nbsp;by&nbsp;qmake&nbsp;(2.01a)&nbsp;ven.&nbsp;23.&nbsp;mai&nbsp;16:31:10&nbsp;2008
######################################################################

TEMPLATE&nbsp;=&nbsp;app
TARGET&nbsp;=&nbsp;
DEPENDPATH&nbsp;+=&nbsp;.
INCLUDEPATH&nbsp;+=&nbsp;.

#&nbsp;Input
HEADERS&nbsp;+=&nbsp;FenCodeGenere.h&nbsp;FenPrincipale.h
SOURCES&nbsp;+=&nbsp;FenCodeGenere.cpp&nbsp;FenPrincipale.cpp&nbsp;main.cpp
<span class="ln-xtra">TRANSLATIONS&nbsp;=&nbsp;zeroclassgenerator_en.ts&nbsp;zeroclassgenerator_es.ts</span></pre></div></td></tr></tbody></table></div><br>
<br>
Bien. Maintenant, nous allons faire appel à un programme en console de Qt qui permet de générer automatiquement les fichiers .ts.<br>
<br>
Ouvrez une console (sous Windows, utilisez le raccourci Qt Command Prompt que vous utilisez normalement d'habitude pour compiler). Allez dans le dossier de votre projet.<br>
Tapez :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>lupdate&nbsp;NomDuProjet.pro</pre></div></td></tr></tbody></table></div><br>
<br>
lupdate est un programme qui va mettre à jour les fichiers de traduction .ts, ou les créer si ceux-ci n'existent pas.<br>
<br>
Essayons d'exécuter lupdate sur ZeroClassGenerator.pro :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>C:\Users\Mateo\Projets\ZeroClassGenerator&gt;lupdate&nbsp;ZeroClassGenerator.pro
Updating&nbsp;'zeroclassgenerator_en.ts'...
&nbsp;&nbsp;&nbsp;&nbsp;Found&nbsp;17&nbsp;source&nbsp;text(s)&nbsp;(17&nbsp;new&nbsp;and&nbsp;0&nbsp;already&nbsp;existing)
Updating&nbsp;'zeroclassgenerator_es.ts'...
&nbsp;&nbsp;&nbsp;&nbsp;Found&nbsp;17&nbsp;source&nbsp;text(s)&nbsp;(17&nbsp;new&nbsp;and&nbsp;0&nbsp;already&nbsp;existing)</pre></div></td></tr></tbody></table></div><br>
<br>
Le programme lupdate a trouvé dans mon code source 17 chaînes à traduire. Il a vérifié si les .ts existaient (ce qui n'était pas le cas) et les a donc créé.<br>
<br>
Ce programme est intelligent puisque, si vous l'exécutez une seconde fois, il ne mettra à jour que les chaînes qui ont changé. C'est très pratique, puisque cela permet d'avoir à faire traduire au traducteur seulement ce qui a changé par rapport à la version précédente de votre programme !<br>
<br>
Vous devriez maintenant avoir 2 fichiers supplémentaires dans le dossier de votre projet : zeroclassgenerator_en.ts et zeroclassgenerator_es.ts.<br>
<br>
Envoyez-les à votre traducteur (s'il sait parler anglais et espagnol <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ). Bien entendu, le fait qu'on ait 2 fichiers distincts nous permet d'envoyer le premier à un traducteur anglais, et le second à un traducteur espagnol.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11346">Traduire l'application sous Qt Linguist</h2>
		<div class="ss_part_texte">
		<div class="flot_gauche"><img src="./cpp_files/118039.png" alt="Qt Linguist"></div><br>
Qt a installé plusieurs programmes, vous vous souvenez ?<br>
L'un d'eux va nous être sacrément utile maintenant : c'est <strong>Qt Linguist</strong>.<br>
<br>
<br>
Votre traducteur a besoin de 2 choses :<br>
<ul>
<li>Du fichier .ts à traduire</li>
<li>Et de Qt Linguist pour pouvoir le traduire !</li>
</ul><br>
<br>
Votre traducteur lance donc Qt Linguist. Il devrait voir quelque chose comme ça :<br>
<br>
<div class="centre"><img src="./cpp_files/118042.png" alt="Qt Linguist"></div><br>
<br>
Ca a l'air un petit peu compliqué (et encore, vous avez pas vu Qt Designer <img src="./cpp_files/langue.png" alt=":p"> ).<br>
Vous reconnaissez d'ailleurs sûrement une QMainWindow, avec une barre de menus, une barre d'outils, des docks, et un widget central (bah oui, les programmes livrés avec Qt sont faits avec Qt <img src="./cpp_files/siffle.png" alt=":-°"> ).<br>
<br>
En fait, les docks prennent tellement de place qu'on a du mal à savoir où est le widget central. Pour vous aider, c'est l'espèce de bulle ronde au milieu à droite, avec "Source text" et "Translation". C'est justement là qu'on traduira les chaînes de caractères.<br>
<br>
<div class="rmq information">Comme vous le savez déjà, les docks peuvent être déplacés. N'hésitez pas à arranger la fenêtre à votre guise. Vous pouvez même faire sortir les docks de la fenêtre principale pour en faire des mini-fenêtres flottantes.</div><br>
<br>
Ouvrez un des fichiers .ts avec Qt Linguist, par exemple zeroclassgenerator_en.ts. La fenêtre se remplit :<br>
<br>
<div class="centre"><img src="./cpp_files/118043.png" alt="Qt Linguist chargé"></div><br>
<br>
Détaillons un peu chaque section de la fenêtre :<br>
<br>
<ul>
<li><strong>Context (à gauche) </strong>:  affiche la liste des fichiers source qui contiennent des chaînes à traduire. Vous reconnaissez vos fenêtres FenCodeGenere et FenPrincipale. Le nombre de chaînes traduites est indiqué à droite.</li>
<li><strong>Strings (en haut)</strong> : c'est la liste des chaînes à traduire pour le fichier sélectionné. Ces chaînes ont été extraites grâce à la présence de la méthode tr().</li>
<li><strong>Au milieu</strong> : vous avez la version française de la chaîne, et on vous demande d'écrire la version anglaise. Notez que Qt a automatiquement détecté que vous alliez traduire en anglais, grâce au nom du fichier qui contient "en".<br>
Si la chaîne à traduire peut être mise au pluriel, Qt Linguist vous demandera 2 traductions : une au singulier ("<span class="italique">There is %n file</span>") et une au pluriel ("<span class="italique">There are %n files</span>").</li>
<li><strong>Warnings (en bas)</strong> : affiche des avertissements bien utiles , comme "Vous avez oublié de mettre un &amp; pour faire un raccourci", ou "La chaîne traduite ne se termine pas par le même signe de ponctuation" (ici un deux-points). Cette zone peut afficher aussi la chaîne à traduire dans son contexte du code source.</li>
</ul><br>
C'est maintenant au traducteur de traduire tout ça ! <img src="./cpp_files/smile.png" alt=":)"><br>
<br>
Lorsqu'il est sûr de sa traduction, il doit marquer la chaîne comme étant validée (en cliquant sur le petit "?" ou en faisant Ctrl + Entrée). Un petit symbole coché vert doit apparaître, et le dock context doit afficher que toutes les chaînes ont bien été traduites (16/16 par exemple).<br>
<br>
Voici les 3 états que peut avoir chaque message :<br>
<br>
<div class="centre"><img src="./cpp_files/118162.png" alt="Etapes de la traduction"></div><br>
<br>
On procède donc en 2 temps : d'abord on traduit, puis ensuite on se relit et on valide. Lorsque toutes les chaînes sont validées (en vert), le traducteur vous rend le fichier .ts.<br>
<br>
Il ne nous reste plus qu'une étape : compiler ce .ts en un .qm, et adapter notre programme pour qu'il charge automatiquement le programme dans la bonne langue.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11345">Lancer l'application traduite</h2>
		<div class="ss_part_texte">
		Dernière ligne droite !<br>
Nous avons le .ts entièrement traduit par notre traducteur adoré, il ne nous reste plus qu'à le compiler dans le format final binaire .qm, et à le charger dans l'application.<br>
<br>
<br>
<h3>Compiler le .ts en .qm</h3><br>
<br>
Pour effectuer cette compilation, nous devons utiliser un autre programme de Qt : <span class="italique">lrelease</span>.<br>
<br>
Ouvrez donc une console Qt, rendez-vous dans le dossier de votre projet, et tapez :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>lrelease&nbsp;nomDuFichier.ts</pre></div></td></tr></tbody></table></div><br>
<br>
... pour compiler le fichier .ts indiqué.<br>
Vous pouvez aussi faire :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>lrelease&nbsp;nomDuProjet.pro</pre></div></td></tr></tbody></table></div><br>
<br>
... pour compiler tous les fichiers .ts du projet.<br>
<br>
Comme je viens de terminer la traduction anglaise, je vais compiler le fichier .ts anglais :<br>
<br>
<span class="code">Code : Console - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 console"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre></pre></td><td class="code"><div class="syntax"><pre>C:\Users\Mateo\Projets\ZeroClassGenerator&gt;lrelease&nbsp;zeroclassgenerator_en.ts
Updating&nbsp;'zeroclassgenerator_en.qm'...
&nbsp;&nbsp;&nbsp;&nbsp;Generated&nbsp;17&nbsp;translation(s)&nbsp;(17&nbsp;finished&nbsp;and&nbsp;0&nbsp;unfinished)</pre></div></td></tr></tbody></table></div><br>
<br>
Vous pouvez voir que lrelease ne compile que les chaînes marquées comme terminées (celles qui ont le symbole vert dans Qt Linguist). Si certaines ne sont pas marquées comme terminées, elles ne seront pas compilées dans le .qm.<br>
<br>
<div class="rmq information">Les chaînes non traduites ou non validées n'apparaîtront donc pas dans le programme. Dans ce cas, c'est la chaîne par défaut écrite dans le code (ici en français) qui sera affichée à la place.<br>
D'autre part, notez que vous pouvez aussi faire la même chose directement dans Qt Linguist, en allant dans le menu File / Release.</div><br>
<br>
Nous avons maintenant un fichier <span class="courrier">zeroclassgenerator_en.qm</span> dans le dossier de notre projet. Cool.<br>
Si on le chargeait dans notre programme maintenant ? <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Charger un fichier de langue .qm dans l'application</h3><br>
<br>
Le chargement d'un fichier de langue s'effectue au début de la fonction main().<br>
Pour le moment, votre fonction main() devrait ressembler à quelque chose comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">FenPrincipale</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Juste après la création de l'objet de type QApplication, nous allons rajouter les lignes suivantes :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

<span class="ln-xtra">    <span class="n">QTranslator</span> <span class="n">translator</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">translator</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="s">"zeroclassgenerator_en"</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">app</span><span class="p">.</span><span class="n">installTranslator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">translator</span><span class="p">);</span></span>

    <span class="n">FenPrincipale</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq attention">Vérifiez bien que le fichier .qm se trouve dans le même dossier que l'exécutable, sinon la traduction ne sera pas chargée et vous aurez toujours l'application en français !</div><br>
<br>
Si tout va bien, bravo, vous avez traduit votre application ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<div class="centre"><img src="./cpp_files/118164.png" alt="ZeroClassGenerator en anglais"></div><br>
<br>
<div class="rmq question">Euh, c'est bien mais c'est pas pratique. Là, mon application se chargera toujours en anglais. Il n'y a pas moyen qu'elle s'adapte à la langue de l'utilisateur ? <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> </div><br>
<br>
Si, bien sûr, c'est faisable. C'est même ce qu'on fera dans 99% des cas.<br>
Dans ce cas, on peut procéder comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="ln-xtra"> </span>
<span class="ln-xtra">    <span class="n">QString</span> <span class="n">locale</span> <span class="o">=</span> <span class="n">QLocale</span><span class="o">::</span><span class="n">system</span><span class="p">().</span><span class="n">name</span><span class="p">().</span><span class="n">section</span><span class="p">(</span><span class="sc">'_'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></span>
<span class="ln-xtra"> </span>
<span class="ln-xtra">    <span class="n">QTranslator</span> <span class="n">translator</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">translator</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="s">"zeroclassgenerator_"</span><span class="p">)</span> <span class="o">+</span> <span class="n">locale</span><span class="p">);</span></span>
    <span class="n">app</span><span class="p">.</span><span class="n">installTranslator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">translator</span><span class="p">);</span>

    <span class="n">FenPrincipale</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<strong>Explication</strong> : on veut récupérer le code à 2 lettres de la langue du PC de l'utilisateur. On utilise une méthode statique de <a href="http://doc.trolltech.com/qlocale.html">QLocale</a> pour récupérer des informations sur le système d'exploitation sur lequel le programme a été lancé.<br>
<br>
La méthode <span class="code2 cpp"><span class="n">QLocale</span><span class="o">::</span><span class="n">system</span><span class="p">().</span><span class="n">name</span><span class="p">()</span>
</span> renvoie un code ressemblant à ceci : "<span class="courrier">fr_FR</span>", où "fr" est la langue (français) et "FR" le pays (France).<br>
Si vous êtes québecois, vous aurez par exemple "<span class="courrier">fr_CA</span>" (français au Canada).<br>
<br>
<div class="centre"><img src="./cpp_files/118348.png" alt="Locale"></div><br>
<br>
On veut juste récupérer les 2 premières lettres. On utilise la méthode section() pour couper le chaîne en deux autour de l'underscore "_". Les 2 autres paramètres permettent d'indiquer qu'on veut le premier mot à gauche de l'underscore, à savoir le "fr".<br>
<br>
Au final, notre variable locale contiendra juste ce qu'on veut : la langue de l'utilisateur (par exemple "fr").<br>
On combine cette variable avec le début du nom du fichier de traduction, comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QString</span><span class="p">(</span><span class="s">"zeroclassgenerator_"</span><span class="p">)</span> <span class="o">+</span> <span class="n">locale</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si locale vaut "fr", le fichier de traduction chargé sera "zeroclassgenerator_fr".<br>
Si locale vaut "en", le fichier de traduction chargé sera "zeroclassgenerator_en".<br>
<br>
C'est compris ? <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
Grâce à ça, notre programme ira chercher le fichier de traduction correspondant à la langue de l'utilisateur. Au pire des cas, si le fichier de traduction n'existe pas car vous n'avez pas fait de traduction dans cette langue, c'est la langue française qui sera utilisée.<br>
<br>
<br>
Vous voilà maintenant aptes à traduire dans n'importe quelle langue ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Pour information, voilà ce que donne le ZeroClassGenerator traduit en arabe (merci à <span class="italique">zoro_2009</span> pour la traduction !) :<br>
<br>
<div class="centre"><img src="./cpp_files/118537.png" alt="ZeroClassGenerator en arabe"></div><br>
<br>
Voilà donc la preuve que Qt peut vraiment gérer tous les caractères de la planète grâce à son support de l'Unicode. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Comme vous avez pu le constater, la traduction d'applications Qt est un processus bien rôdé : tout est prévu ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Vous avez maintenant tous les outils en main pour diffuser votre programme partout dans le monde, même au Japon ! Encore faut-il trouver un traducteur japonais...<br>
<br>
<br>
<span class="tpetit">... et pour ça, désolé les amis, mais je ne pourrai vraiment pas vous aider. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"></span>
	</div>
	
	<hr>
	<h1 id="chap_11360">Modéliser ses fenêtres avec Qt Designer</h1>
	<div id="chap_intro">
	A force d'écrire le code de vos fenêtres, vous devez peut-être commencer à trouver ça long et répétitif. C'est amusant au début, mais au bout d'un moment on en a un peu marre d'écrire des constructeurs de 3 kilomètres de long juste pour placer les widgets sur la fenêtre.<br>
<br>
C'est là que Qt Designer vient vous sauver la vie. Il s'agit d'un programme livré avec Qt (vous l'avez donc déjà installé) qui permet de <strong>dessiner vos fenêtres visuellement</strong>. Mais plus encore, Qt Designer vous permet aussi de modifier les propriétés des widgets, d'utiliser des layouts, et d'effectuer la connexion entre signaux et slots.<br>
<br>
<div class="rmq erreur">Qt Designer n'est pas un programme magique qui va réfléchir à votre place. Il vous permet juste de gagner du temps et d'éviter les tâches répétitives d'écriture du code de génération de la fenêtre.<br>
N'utilisez PAS Qt Designer et <span class="souligne">ne lisez PAS ce chapitre si vous ne savez pas coder vos fenêtres à la main</span>. En clair, si vous avez voulu sauter les chapitres précédents et juste lire celui-ci parce que vous le trouvez attirant, <span class="souligne">vous allez vous planter</span>. C'est dit. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"></div><br>
<br>
Nous commencerons par apprendre à manipuler Qt Designer lui-même. Vous verrez que c'est un outil complexe mais qu'on s'y fait vite car il est assez intuitif.<br>
Ensuite, nous apprendrons à utiliser les fenêtres générées avec Qt Designer dans notre code source. Comme vous le verrez, il y a plusieurs façons de faire en fonction de vos besoins.<br>
<br>
C'est parti ! <img src="./cpp_files/smile.png" alt=":)" class="smilies">
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11359">Présentation de Qt Designer</h2>
		<div class="ss_part_texte">
		<div class="flot_gauche"><img src="./cpp_files/118488.png" alt="Qt Designer Icône"></div><br>
Nous allons commencer par démarrer directement Qt Designer.<br>
Normalement, un raccourci a déjà été créé sur votre système (cf icône ci-contre).<br>
<br>
<br>
<div class="rmq erreur">Attention : si vous utilisez un thème personnalisé sur votre ordinateur (par exemple un thème Windows XP téléchargé sur internet), il se pourrait que Qt Designer rencontre des bugs d'affichage. Essayez de désactiver le thème personnalisé et de revenir au thème par défaut avant d'exécuter Qt Designer.</div><br>
<br>
<br>
<h3>Choix du type de fenêtre à créer</h3><br>
<br>
Lorsque vous lancez Qt Designer, il vous propose de créer un nouveau projet. Vous avez le choix entre plusieurs types de fenêtres :<br>
<br>
<div class="centre"><img src="./cpp_files/118486.png" alt="Introduction de Qt Designer"></div><br>
<br>
Les 3 premiers choix correspondent à des QDialog.<br>
Vous pouvez aussi créer une QMainWindow si vous avez besoin de gérer des menus et des barres d'outils.<br>
Enfin, le dernier choix correspond à une simple fenêtre de type QWidget.<br>
<br>
Pour nos exemples, nous allons choisir de créer une fenêtre simple de type QWidget. Sélectionnez donc le choix Widget.<br>
<br>
<div class="rmq information">Il y a d'autres choix que je ne détaillerai pas ici, dans les sous-catégories "Widgets" et "Custom Widgets". Par exemple, on peut créer une fenêtre-QGroupBox.<br>
Vous utiliserez très rarement ces choix.</div><br>
<br>
<br>
<h3>Analyse de la fenêtre de Qt Designer</h3><br>
<br>
Lorsque vous avez créé un nouveau projet, la fenêtre de Qt Designer commence à s'animer et... comme vous pouvez le voir, c'est assez complet :<br>
<br>
<div class="centre"><img src="./cpp_files/118489.png" alt="Fenêtre de Qt Designer"></div><br>
<br>
<div class="rmq question">Wow ! Mais comment je vais faire pour m'y retrouver avec tous ces boutons ? <img src="./cpp_files/huh.png" alt=":o" class="smilies"></div><br>
<br>
En y allant méthodiquement. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Détaillons chacune des zones importantes dans l'ordre :<br>
<br>
<ol class="liste_1">
<li>Sur la <strong>barre d'outils</strong> de Qt Designer, au moins 4 boutons méritent votre attention. Ce sont les 4 boutons situés sous la marque "<strong><span class="rouge">(1)</span></strong>" rouge que j'ai placée sur la capture d'écran.<br>
<br>
<div class="centre"><img src="./cpp_files/118500.png" alt="Barre outils layouts"></div><br>
<br>
Ils permettent de passer d'un mode d'édition à un autre. Qt Designer propose 4 modes d'édition :<br>
<br>
<ul>
<li><strong>Edit Widgets</strong> : le mode par défaut, que vous utiliserez le plus souvent. Il permet d'insérer des widgets sur la fenêtre et de modifier leurs propriétés.</li>
<li><strong>Edit Signals/Slots</strong> : permet de créer des connexions entre les signaux et les slots de vos widgets.</li>
<li><strong>Edit Buddies</strong> : permet d'associer des QLabel avec leurs champs respectifs. Lorsque vous faites un layout de type QFormLayout, ces associations sont automatiquement créées.</li>
<li><strong>Edit Tab Order</strong> : permet de modifier l'ordre de tabulation entre les champs de la fenêtre, pour ceux qui naviguent au clavier et passent d'un champ à l'autre en appuyant sur la touche "Tab".</li>
</ul><br>
Nous ne verrons dans ce chapitre que les 2 premiers modes (Edit Widgets et Edit Signals/Slots). Les autres modes sont peu importants et je vous laisse les découvrir par vous-mêmes.<br>
<br>
</li>
<li>Au <strong>centre</strong> de Qt Designer, vous avez la fenêtre que vous êtes en train de dessiner. Pour le moment celle-ci est vide.<br>
Si vous créez une QMainWindow, vous aurez en plus une barre de menus et une barre d'outils. Leur édition se fait à la souris, c'est très intuitif.<br>
Si vous créez une QDialog, vous aurez probablement des boutons "OK" et "Annuler" déjà disposés.<br>
<br>
</li>
<li><strong>Widget Box</strong> : ce dock vous donne la possibilité de sélectionner un widget à placer sur la fenêtre. Vous pouvez constater qu'il y a un assez large choix ! Heureusement, ceux-ci sont organisés par groupes pour y voir plus clair.<br>
Pour placer un de ces widgets sur la fenêtre, il suffit de faire un glisser-déplacer. Simple et intuitif.<br>
<br>
<div class="rmq information">Les widgets en bas de la liste sont soit d'anciens widgets, soit des widgets modifiés non standards. Vous ne devriez pas avoir besoin d'y toucher.</div><br>
<br>
</li>
<li><strong>Property Editor</strong> : lorsqu'un widget est sélectionné sur la fenêtre principale, vous pouvez éditer ses propriétés. Vous noterez que les widgets possèdent en général beaucoup de propriétés, et que celles-ci sont organisées en fonction de la classe dans laquelle elles ont été définies. On peut ainsi modifier toutes les propriétés dont un widget hérite, en plus des propriétés qui lui sont propres.<br>
<br>
<div class="rmq information">Comme toutes les classes héritent de QObject, vous aurez toujours la propriété objectName. C'est le nom de l'objet qui sera créé. N'hésitez pas à le personnaliser, afin d'y voir plus clair tout à l'heure dans votre code source (sinon vous aurez par exemple des boutons appelés pushButton, pushButton_2, pushButton_3, ce qui n'est pas très clair).</div><br>
Si aucun widget n'est sélectionné, ce sont les propriétés de la fenêtre que vous éditerez. Vous pourrez donc par exemple modifier son titre avec la propriété windowTitle, son icône avec windowIcon, etc.<br>
<br>
</li>
<li><strong>Object Inspector</strong> : affiche la liste des widgets placés sur la fenêtre, en fonction de leur relation de parenté, sous forme d'arbre. Ca peut être pratique si vous avez une fenêtre complexe et que vous commencez à vous perdre dedans. Vous pouvez ainsi y voir par exemple que votre fenêtre contient un QGroupBox qui contient 3 cases à cocher.<br>
<br>
</li>
<li><strong>Signal / slot editor</strong> : si vous avez associé des signaux et des slots, les connexions du widget sélectionné apparaissent ici. Nous verrons comment réaliser des connexions dans Qt Designer tout à l'heure.<br>
<br>
</li>
<li><strong>Resource Browser</strong> : un petit utilitaire qui vous permet de naviguer à travers les fichiers de ressources de votre application. Ces fichiers de ressources rappellent un peu ceux de Windows (on en a brièvement parlé dans l'annexe du cours de C, à propos de l'ajout d'icône à un programme sous Windows).<br>
Ici, les fichiers de ressouces portent l'extension .qrc et ont l'avantage d'être compatibles avec tous les OS.<br>
<br>
<div class="rmq information">Les fichiers de ressources servent à empaqueter des fichiers (images, sons, texte...) au sein même de votre exécutable. Cela permet d'éviter d'avoir à placer ces fichiers dans le même dossier que votre programme, et cela évite donc le risque de les perdre (puisqu'ils se trouveront <span class="italique">toujours </span>dans votre exécutable).</div><br>
<br>
C'est un peu hors-sujet, donc je n'en parlerai pas plus ici. Consultez la doc à propos des ressources si vous voulez en savoir plus.<br>
<br>
</li>
<li><strong>Action Editor</strong> : permet de créer des QAction. C'est donc utile lorsque vous créez une QMainWindow avec des menus et une barre d'outils.</li></ol><br>
Voilà qui devrait suffire pour une présentation générale de Qt Designer. Maintenant, pratiquons un peu. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11358">Placer des widgets sur la fenêtre</h2>
		<div class="ss_part_texte">
		Placer des widgets sur la fenêtre est en fait très simple : vous prenez le widget que vous voulez dans la liste à gauche, et vous le faites glisser où vous voulez sur la fenêtre.<br>
<br>
Ce qui est très important à savoir, c'est qu'on peut placer ses widgets de 2 manières différentes :<br>
<br>
<ul>
<li><strong>De manière absolue</strong> : vos widgets seront disposés au pixel près sur la fenêtre. C'est la méthode par défaut, la plus précise, mais la moins flexible aussi. Je vous avais parlé de ses défauts dans le chapitre sur les layouts.</li>
<li><strong>Avec des layouts</strong> (recommandé pour les fenêtres complexes) : vous pouvez utiliser tous les layouts que vous connaissez. Verticaux, horizontaux, en grille, en formulaire... Grâce à cette technique, les widgets s'adapteront automatiquement à la taille de votre fenêtre.</li>
</ul><br>
<br>
Commençons par les placer de manière absolue, puis nous verrons comment utiliser les layouts dans Qt Designer.<br>
<br>
<h3>Placer les widgets de manière absolue</h3><br>
<br>
Je vous propose pour vous entraîner de faire une petite fenêtre simple composée de 3 widgets :<br>
<br>
<ul>
<li>QSlider</li>
<li>QLabel</li>
<li>QProgressBar</li>
</ul><br>
Votre fenêtre devrait à peu près ressembler à ceci maintenant :<br>
<br>
<div class="centre"><img src="./cpp_files/118569.png" alt="Formulaire Designer"></div><br>
<br>
Vous pouvez déplacer ces widgets comme bon vous semble sur la fenêtre.<br>
Vous pouvez les agrandir ou les rétrécir.<br>
<br>
Quelques raccourcis à connaître :<br>
<br>
<ul>
<li>En maintenant la touche <strong>Shift </strong>appuyée, vous pouvez sélectionner plusieurs widgets en même temps.</li>
<li>Faites <strong>Suppr </strong>pour supprimer les widgets sélectionnés.</li>
<li>Si vous maintenez la touche <strong>Ctrl </strong>enfoncée lorsque vous déplacez un widget, celui-ci sera copié.</li>
<li>Vous pouvez <strong>double-cliquer</strong> sur un widget pour modifier son nom (il vaut mieux donner un nom personnalisé plutôt que laisser le nom par défaut).<br>
Sur certains widgets complexes, comme la QComboBox (liste déroulante), le double clic a pour effet de vous permettre d'éditer la liste des éléments contenus dans la liste déroulante.</li>
<li>Pensez aussi à faire un <strong>clic droit</strong> sur les widgets pour modifier certaines propriétés, comme la bulle d'aide (toolTip).</li>
</ul><br>
<br>
Vous pouvez prévisualiser la fenêtre en faisant Ctrl + R, ou encore en allant dans le menu "Form / Preview".<br>
<br>
<div class="rmq information">Le menu "Form / Preview in..." vous permet de prévisualiser la fenêtre dans un autre style (Windows, Windows XP, Windows Vista, Plastique, CDE...)</div><br>
<br>
Voici notre fenêtre en mode "Preview" :<br>
<br>
<div class="centre"><img src="./cpp_files/118573.png" alt="Prévisualisation de la fenêtre"></div><br>
<br>
<br>
Ce mode nous permet de tester la fenêtre telle qu'elle apparaîtra à la fin, de manipuler les widgets, etc.<br>
Sortez du mode Preview et revenez à l'édition, nous avons encore des choses à voir.<br>
<br>
<h3>Utiliser les layouts</h3><br>
<br>
Pour le moment, nous n'utilisons aucun layout. Si vous essayez de redimensionner la fenêtre, vous verrez que les widgets ne s'adaptent pas à la nouvelle taille et qu'ils peuvent même disparaître si on réduit trop la taille de la fenêtre !<br>
<br>
Il y a 2 façons d'utiliser des layouts :<br>
<br>
<ul>
<li>Utiliser la barre d'outils en haut.</li>
<li>Glisser-déplacer des layouts depuis le dock de sélection de widgets ("Widget Box").</li>
</ul><br>
<br>
Pour une fenêtre simple comme celle-là, nous n'aurons besoin que d'un layout principal.<br>
Pour définir ce layout principal, le mieux est de passer par la barre d'outils :<br>
<br>
<div class="centre"><img src="./cpp_files/118499.png" alt="Barre outils layouts"></div><br>
<br>
Cliquez sur une <span class="souligne">zone vide</span> de la fenêtre (en clair, il faut que ce soit la fenêtre qui soit sélectionnée et non un de ses widgets). Vous devriez alors voir les boutons de la barre d'outils des layouts s'activer, comme sur l'image ci-dessus.<br>
<br>
Cliquez sur le bouton correspondant au layout vertical (le second) pour organiser automatiquement la fenêtre selon un layout vertical. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Vous devriez alors voir vos widgets s'organiser comme ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/118687.png" alt="Layout vertical"></div><br>
<br>
C'est le layout vertical qui les place comme ça afin qu'ils occupent toute la taille de la fenêtre. Bien sûr, vous pouvez réduire la taille de la fenêtre si vous le désirez.<br>
Vous pouvez aussi demander à ce que la fenêtre soit réduite à la taille minimale acceptable, en cliquant sur le bouton tout à droite de la barre d'outils, intitulé "Adjust Size".<br>
<br>
<div class="rmq information">Maintenant que vous avez défini le layout principal de la fenêtre, sachez que vous pouvez insérer un sous-layout en plaçant par exemple un des layouts proposés dans la Widget Box.</div><br>
<br>
<br>
<h3>Insérer des spacers</h3><br>
<br>
Vous trouvez que la fenêtre est un peu moche si on l'agrandit trop ?<br>
Moi aussi. Les widgets sont trop espacés, ça ne me convient pas.<br>
<br>
Pour changer la position des widgets <span class="italique">tout en conservant le layout</span>, on peut insérer un spacer. Il s'agit d'un widget invisible qui sert à créer de l'espace sur la fenêtre.<br>
<br>
Le mieux est encore d'essayer pour comprendre ce que ça fait. Dans la Widget Box, vous devriez avoir une section "Spacers" :<br>
<br>
<br>
<div class="centre"><img src="./cpp_files/118685.png" alt="Spacers"></div><br>
<br>
Prenez un "Vertical Spacer", et insérez-le tout en bas de la fenêtre. Vous devriez alors voir ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/118686.png" alt="Fenêtre avec spacer"></div><br>
<br>
Le spacer va forcer les autres widgets à se coller tout en haut. Ils sont toujours organisés selon un layout, mais au moins maintenant nos widgets sont plus rapprochés les uns des autres.<br>
Essayez de déplacer le spacer sur la fenêtre pour voir. Placez-le entre le libellé et la barre de progression. Vous devriez voir que la barre de progression se colle maintenant tout en bas.<br>
<br>
Le comportement du spacer est assez logique, mais il faut l'essayer pour bien comprendre. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Editer les propriétés des widgets</h3><br>
<br>
Il nous reste une chose très importante à voir : l'édition des propriétés des widgets.<br>
Sélectionnez par exemple le libellé (QLabel). Regardez le dock intitulé "Property Editor". Il affiche maintenant les propriétés du QLabel :<br>
<br>
<div class="centre"><img src="./cpp_files/118705.png" alt="Editeur de propriétés"></div><br>
<br>
Ces propriétés sont organisées en fonction de la classe dans laquelle elles ont été définies, et c'est une bonne chose. Je m'explique.<br>
Vous savez peut-être qu'un QLabel hérite de QFrame, qui hérite de QWidget, qui hérite lui-même de QObject ?<br>
<br>
Chacune de ces classes définit des propriétés. QLabel hérite donc des propriétés de QFrame, QWidget et QObject, mais a aussi des propriétés qui lui sont propres.<br>
<br>
Sur ma capture d'écran ci-dessus, on peut voir une propriété de QObject : objectName. C'est le nom de l'objet qui sera créé dans le code. Je vous conseille de le personnaliser pour que vous puissiez vous y retrouver dans le code source ensuite.<br>
<br>
<div class="rmq information">La plupart du temps, on peut éditer le nom d'un widget en double-cliquant dessus sur la fenêtre.</div><br>
<br>
Si vous descendez un peu plus bas dans la liste, vous devriez vous rendre compte qu'un grand nombre de propriétés sont proposées par QWidget (notamment la police, le style de curseur de la souris, etc.).Descendez encore plus bas. Vous devriez arriver sur les propriétés héritées de QFrame, puis celles propres à QLabel :<br>
<br>
<div class="centre"><img src="./cpp_files/118706.png" alt="Editeur de propriétés"></div><br>
<br>
Comme vous pouvez le voir, ces propriétés ont été mises en valeur : elles sont en vert.<br>
Je trouve que c'est très bien d'avoir organisé les propriétés comme ça. Ainsi, on voit bien où elles sont définies.<br>
<br>
Vous devriez modifier la propriété <span class="italique">text</span>, pour changer le texte affiché dans le QLabel. Mettez par exemple "0". Amusez-vous à changer la police (propriété <span class="italique">font </span>issue de QWidget) ou encore à mettre une bordure (propriété <span class="italique">frameShape </span>issue de QFrame).<br>
<br>
Vous remarquerez que lorsque vous éditez une propriété, son nom s'affiche en gras pour être mis en valeur. Cela vous permet par la suite de repérer du premier coup d'oeil les propriétés que vous avez modifiées.<br>
<br>
<div class="rmq information">Certaines propriétés, comme <span class="italique">alignement </span>de QLabel, possèdent des sous-propriétés. Cliquez sur la petite flèche à gauche pour afficher et modifier ces sous-propriétés. Essayez de faire en sorte que le texte de notre libellé soit centré horizontalement par exemple.</div><br>
<br>
Modifiez aussi les propriétés de la QProgressBar pour qu'elle affiche 0% pour défaut (propriété <span class="italique">value</span>).<br>
<br>
Vous pouvez aussi modifier les propriétés de la fenêtre. Cliquez sur une zone vide de la fenêtre afin qu'aucun widget ne soit sélectionné. Le dock "Property Editor" vous affichera alors les propriétés de la fenêtre (ici, notre fenêtre est un QWidget, donc vous aurez juste les propriétés de QWidget).<br>
<br>
<div class="rmq information">Astuce : si vous ne comprenez pas à quoi sert une propriété, cliquez dessus puis appuyez sur la touche F1. Qt Designer lancera automatiquement Qt Assistant pour afficher l'aide sur la propriété sélectionnée.</div><br>
<br>
Essayez d'avoir une fenêtre qui ressemble au final grosso modo à la mienne :<br>
<br>
<div class="centre"><img src="./cpp_files/118708.png" alt="Fenêtre avec propriétés éditées"></div><br>
<br>
Le libellé et la barre de progression doivent afficher 0 par défaut.<br>
<br>
<br>
Bravo, vous savez maintenant insérer des widgets, les organiser selon un layout et personnaliser leurs propriétés dans Qt Designer ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Nous n'avons utilisé pour le moment que le mode "Edit Widgets". Il nous reste à étudier le mode "Edit Signals/Slots"...
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11357">Configurer les signaux et les slots</h2>
		<div class="ss_part_texte">
		Passez en mode "Edit Signals/Slots" en cliquant sur le second bouton de la barre d'outils :<br>
<br>
<div class="centre"><img src="./cpp_files/118500.png" alt="Barre outils layouts"></div><br>
<br>
<div class="rmq information">Vous pouvez aussi appuyer sur la touche F4. Vous pourrez faire F3 pour revenir au mode d'édition des widgets.</div><br>
<br>
Dans ce mode, on ne peut pas ajouter, modifier, supprimer, ni déplacer de widgets. Par contre, si vous pointez sur les widgets de votre fenêtre, vous devriez voir un cadre rouge autour d'eux.<br>
<br>
Vous pouvez, de manière très intuitive, associer les widgets entre eux pour créer des connexions simples entre leurs signaux et slots. Je vous propose par exemple d'associer le QSlider avec notre QProgressBar.<br>
<br>
Pour cela, cliquez sur le QSlider et maintenez le bouton gauche de la souris enfoncé. Pointez sur la QProgressBar et relâchez le bouton. La connexion que vous allez faire devrait ressembler à ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/118709.png" alt="Connexion dans Qt Designer"></div><br>
<br>
Une fenêtre apparaît alors pour que vous puissiez choisir le signal et le slot à connecter :<br>
<br>
<div class="centre"><img src="./cpp_files/118710.png" alt="Choix des signaux et slots"></div><br>
<br>
A gauche : les signaux disponibles dans le QSlider.<br>
A droite : les slots <span class="italique">compatibles</span> disponibles dans la QProgressBar.<br>
<br>
Sélectionnez un signal à gauche, par exemple sliderMoved(int). Ce signal est envoyé dès que l'on déplace un peu le slider.<br>
Vous verrez que la liste des slots compatibles apparaît à droite.<br>
<br>
<div class="rmq information">En fonction du signal choisi, Qt Designer ne vous affiche que les slots de destination compatibles. Par exemple, sliderMoved(int) s'accorde bien avec setValue(int). On peut aussi le connecter à reset(), dans ce cas le nombre envoyé en paramètre sera perdu.<br>
Par contre, on ne peut pas connecter le signal sliderMoved(int) au slot setRange(int, int) car le signal n'envoie pas assez de paramètres. D'ailleurs, vous ne devriez pas voir ce slot disponible dans la liste des slots si vous avez choisi le signal sliderMoved(int), ce qui vous empêche de créer une connexion incompatible.</div><br>
<br>
Nous allons connecter sliderMoved(int) du QSlider avec setValue(int) de la QProgressBar.<br>
Faites OK pour valider une fois le signal et le slot choisis. C'est bon, la connexion est créée. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<div class="centre"><img src="./cpp_files/118711.png" alt="Connexion effectuée"></div><br>
<br>
Faites de même pour associer sliderMoved(int) du QSlider à setNum(int) du QLabel.<br>
<br>
<br>
Notez que vous pouvez aussi connecter un widget à la fenêtre. Dans ce cas, visez une zone vide de la fenêtre. La flèche devrait se transformer en symbole de masse (bien connu par ceux qui font de l'électricité ou de l'électronique) :<br>
<br>
<div class="centre"><img src="./cpp_files/118712.png" alt="Connexion à la masse"></div><br>
<br>
Cela vous permet d'associer un signal du widget à un slot de la fenêtre, ce qui peut vous être utile si vous voulez créer un bouton "Fermer la fenêtre" par exemple.<br>
<br>
<div class="rmq attention"><strong>Attention </strong>: si dans la fenêtre du choix du signal et du slot vous ne voyez aucun slot s'afficher pour la fenêtre, c'est normal. Qt les masque par défaut car ils sont nombreux. Si on les affichait pour chaque connexion entre 2 widgets, on en aurait beaucoup trop (puisque tous les widgets héritent de QWidget).<br>
Pour afficher quand même les signaux et slots issus de QWidget, cochez la case "<span class="italique">Show signals and slots inherited from QWidget</span>".</div><br>
<br>
Passez maintenant en mode preview (Ctrl + R) pour tester vos connexions.<br>
Essayez de déplacer le slider. Si vous avez fait les choses correctement, vous devriez voir le libellé et la barre de progression changer de valeur en même temps ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<div class="centre"><img src="./cpp_files/118713.png" alt="Prévisualisation de la fenêtre"></div><br>
<br>
Pour des connexions simples entre les signaux et les slots des widgets, Qt Designer est donc très intuitif et convient parfaitement.<br>
<br>
<div class="rmq question">Eh, mais si je veux créer un slot personnalisé pour faire des manipulations un peu plus complexes, comment je fais ?</div><br>
<br>
Qt Designer ne peut pas vous aider pour ça. Si vous voulez créer un signal ou un slot personnalisé, il faudra le faire tout à l'heure dans le code source.<br>
Comme vous pourrez le voir néanmoins, c'est très simple à faire.<br>
<br>
En y réfléchissant bien, c'est même d'ailleurs la seule chose que vous aurez à coder ! En effet, tout le reste est automatiquement géré par Qt Designer. Vous n'avez plus qu'à vous concentrer sur la partie "réflexion" de votre code source.<br>
Qt Designer vous permet donc de gagner du temps en vous épargnant les tâches répétitives et basiques qu'on fait à chaque fois que l'on crée une fenêtre.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11356">Utiliser la fenêtre dans votre application</h2>
		<div class="ss_part_texte">
		Il reste une dernière étape, et pas des moindres : apprendre à utiliser la fenêtre ainsi créée dans votre application.<br>
<br>
<br>
<h3>Notre nouvel exemple</h3><br>
<br>
Je vous propose de créer une nouvelle fenêtre (parce que l'exemple de tout à l'heure était bien joli, mais pas très intéressant à part pour tester les signaux et slots <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ). On va créer une mini-calculatrice :<br>
<br>
<div class="centre"><img src="./cpp_files/118714.png" alt="Mini calculatrice"></div><br>
<br>
Essayez de reproduire à peu près la même fenêtre que moi.<br>
Un layout principal horizontal suffira à organiser les widgets.<br>
<br>
La fenêtre est constituée des widgets suivants, de gauche à droite :<br>
<br>
<table class="tab_user">






<thead><tr><th>Widget</th><th>Nom de l'objet</th></tr></thead><tbody><tr>
<td>QSpinBox</td>
<td>nombre1</td>
</tr><tr>
<td>QComboBox</td>
<td>operation</td>
</tr><tr>
<td>QSpinBox</td>
<td>nombre2</td>
</tr><tr>
<td>QPushButton</td>
<td>boutonEgal</td>
</tr><tr>
<td>QLabel</td>
<td>resultat</td>
</tr></tbody></table><br>
<br>
Pensez à bien renommer les widgets afin que vous puissiez vous y retrouver dans votre code source ensuite. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Pensez aussi à donner un nom à la fenêtre. Je l'ai appelée "<strong>FenCalculatrice</strong>".<br>
<br>
Pour la liste déroulante du choix de l'opération, je l'ai déjà pré-remplie avec 4 valeurs : +, -, * et /.<br>
Double-cliquez sur la liste déroulante pour ajouter / supprimer des valeurs.<br>
<br>
<br>
Enregistrez cette fenêtre dans le dossier de votre projet. Je lui ai donné le nom calculatrice.ui.<br>
Tous les fichiers de fenêtres créés avec Qt Designer portent l'extension .ui (comme User Interface, "Interface Utilisateur" en français).<br>
<br>
<br>
<h3>Le principe de la génération du code source</h3><br>
<br>
Essayons maintenant de récupérer le code de la fenêtre dans notre application et d'ouvrir cette fenêtre.<br>
<br>
<div class="rmq question">Le code ? Quel code ? Je ne vois pas de code moi ?<br>
Qt Designer est censé générer un code source ?</div><br>
<br>
Non, Qt Designer ne fait que produire un fichier .ui. C'est le petit programme <span class="italique">uic </span>qui se charge de transformer le .ui en code source C++.<br>
<br>
Voilà ce que ça donne schématiquement :<br>
<br>
<div class="centre"><img src="./cpp_files/118735.png" alt="Schéma compilation des UI"></div><br>
<br>
Vous dessinez la fenêtre avec Qt Designer qui produit un fichier .ui.<br>
Ce fichier est transformé automatiquement en code source par le petit programme en ligne de commande <span class="italique">uic</span>. Celui-ci génèrera un fichier <span class="italique">ui_nomDeVotreFenetre.h</span>. Qt met tout le code dans le fichier .h, <span class="souligne">ne vous étonnez donc pas s'il n'y a pas de .cpp correspondant</span>.<br>
<br>
Vous continuez à programmer vos autres fichiers source comme avant (.cpp et .h).<br>
A la compilation, le fichier <span class="italique">ui_nomDeVotreFenetre.h</span> sera compilé avec vos autres fichiers source !<br>
<br>
<div class="rmq information"><strong>Pour information</strong> : ce n'est pas obligatoire, mais si vous voulez voir le code source qui sera généré pour votre fenêtre, vous pouvez à tout moment aller dans le menu "Form / Preview Code..." de Qt Designer.<br>
Regardez ce code mais ne l'enregistrez pas. C'est vraiment juste pour avoir une idée de ce à quoi ressemblera le code généré.</div><br>
<br>
Nous allons procéder en 2 étapes :<br>
<br>
<ol class="liste_1">
<li>Nous allons mettre à jour le fichier .pro de notre projet, afin que Qt sache que nous avons un fichier .ui et qu'il faudra générer le code source correspondant. <span class="souligne">Vous n'appellerez pas <span class="italique">uic</span> directement, c'est Qt qui le fera pour vous avant la compilation</span>.</li>
<li>Puis, nous adapterons le code source dans notre application afin d'ouvrir la fenêtre générée avec Qt Designer.</li></ol><br>
<br>
<h3>Préparer notre projet à générer le code</h3><br>
<br>
La première étape consiste à mettre à jour le fichier .pro de votre application pour lui faire comprendre que votre programme utilise désormais un .ui créé avec Qt Designer.<br>
<br>
<br>
<br>
Le fichier .pro a normalement été automatiquement généré par <span class="code2 console">qmake&nbsp;-project</span>.<br>
<br>
Vous avez 2 possibilités :<br>
<ul>
<li>Soit vous retapez <span class="code2 console">qmake&nbsp;-project</span> dans la console. Dans ce cas, Qt découvrira automatiquement la présence d'un fichier .ui dans le dossier du projet, et modifiera le fichier .pro en conséquence.</li>
<li>Soit vous éditez à la main le fichier .pro avec un éditeur de texte, et vous rajoutez la ligne surlignée dans le code ci-dessous :<br>
<br>
<span class="code">Code : Autre - <a href="#" class="select_code">Sélectionner</a></span><div class="code2"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><div class="syntax"><pre>######################################################################
#&nbsp;Automatically&nbsp;generated&nbsp;by&nbsp;qmake&nbsp;(2.01a)&nbsp;lun.&nbsp;2.&nbsp;juin&nbsp;12:00:20&nbsp;2008
######################################################################

TEMPLATE&nbsp;=&nbsp;app
TARGET&nbsp;=&nbsp;
DEPENDPATH&nbsp;+=&nbsp;.
INCLUDEPATH&nbsp;+=&nbsp;.

#&nbsp;Input
<span class="ln-xtra">FORMS&nbsp;+=&nbsp;calculatrice.ui</span>
SOURCES&nbsp;+=&nbsp;main.cpp</pre></div></td></tr></tbody></table></div><br>
<br>
Comme vous pouvez le voir, j'ai ajouté la ligne FORMS. Elle donne la liste des fichiers .ui utilisés par votre application.</li>
</ul><br>
<br>
Voilà, c'est bon. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Maintenant, faites un <span class="code2 console">qmake</span>. Cela aura pour effet de préparer votre code à la compilation en générant un makefile, comme je vous l'avais expliqué au tout début de la partie sur Qt.<br>
<br>
<div class="rmq information">Le fichier <span class="courrier">ui_calculatrice.h</span> sera généré par <span class="italique">uic</span> au moment de la compilation, lorsque vous taperez <span class="code2 console">make</span> (ne le faites pas maintenant, nous le ferons plus tard).<br>
Vous n'avez rien d'autre à faire, vous n'avez pas besoin d'appeler <span class="italique">uic</span> vous-mêmes. Le programme <span class="italique">uic</span> sera automatiquement appelé juste avant la compilation.</div><br>
<br>
<br>
<h3>Utiliser la fenêtre dans notre application</h3><br>
<br>
Il nous reste une importante étape : modifier le code source de notre application pour ouvrir la fenêtre créée sous Qt Designer.<br>
Et là, nous avons le choix. Nous pouvons utiliser la fenêtre de 3 manières différentes, de la plus simple à la plus compliquée (la plus compliquée étant la meilleure bien sûr <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ) :<br>
<br>
<ul>
<li>Utilisation directe</li>
<li>Utilisation avec un héritage simple</li>
<li>Utilisation avec un héritage multiple</li>
</ul><br>
Je vais vous décrire chacune de ces 3 méthodes. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Vous verrez que la dernière, bien que plus complexe, est la plus pratique et la plus souple.<br>
<br>
<br>
<h4>Utilisation directe</h4><br>
<br>
<span class="marron"><strong>Avantages</strong> : technique très simple à mettre en oeuvre, à peine quelques lignes à écrire.<br>
<strong>Défauts</strong> : pas de possibilité de personnaliser la fenêtre, ni d'écrire des slots personnalisés. La fenêtre est "figée".</span><br>
<br>
<br>
La technique la plus simple, mais la moins puissante, consiste à utiliser directement la fenêtre générée.<br>
On va supposer que votre programme n'est constitué que d'un main(). Ajoutez les lignes surlignées :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span>
<span class="ln-xtra"><span class="cp">#include "ui_calculatrice.h"</span></span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

<span class="ln-xtra">    <span class="n">QWidget</span> <span class="o">*</span><span class="n">fenetre</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QWidget</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">Ui</span><span class="o">::</span><span class="n">FenCalculatrice</span> <span class="n">ui</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">ui</span><span class="p">.</span><span class="n">setupUi</span><span class="p">(</span><span class="n">fenetre</span><span class="p">);</span></span>

    <span class="n">fenetre</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Dans un premier temps, on inclut le fichier <span class="courrier">ui_calculatrice.h</span> qui sera généré par <span class="italique">uic</span> juste avant la compilation.<br>
<br>
Ensuite, on fait comme si on créait une nouvelle fenêtre en créant un nouvel objet de type QWidget (ligne 9).<br>
<br>
Au lieu d'afficher cette fenêtre directement, on la précharge avec le contenu que l'on a dessiné dans Qt Designer. Pour cela, on crée un objet de type Ui::FenCalculatrice (où "FenCalculatrice" est le nom que vous avez donné à votre fenêtre dans Qt Designer). On appelle setupUi(fenetre) pour dessiner le contenu de la fenêtre avec l'interface réalisée sous Qt Designer.<br>
<br>
On peut ensuite ouvrir la fenêtre avec <span class="code2 cpp"><span class="n">fenetre</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">();</span>
</span> comme d'habitude. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
Compilez maintenant avec <span class="code2 console">make</span> en ligne de commande. Le programme <span class="italique">uic </span>sera appelé en arrière-plan pour que le fichier <span class="italique">ui_calculatrice.h</span> soit généré. Puis, l'ensemble des fichiers .cpp et .h seront compilés comme d'habitude.<br>
Admirez ensuite le programme ainsi généré :<br>
<br>
<div class="centre"><img src="./cpp_files/118736.png" alt="Mini calculatrice"></div><br>
<br>
Ca marche ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Vous noterez toutefois qu'il y a un défaut : notre fenêtre s'affiche, c'est bien beau, mais elle ne réagit pas au clic sur le bouton "=". En effet, la méthode que nous venons de voir est très simple, mais elle a un énorme défaut : nous ne pouvons pas créer nos propres slots pour personnaliser un peu le code de la fenêtre.<br>
<br>
Les techniques suivantes que nous allons voir nous permettent de le faire, et sont donc bien plus souples.<br>
<br>
<br>
<h4>Utilisation avec un héritage simple</h4><br>
<br>
<span class="marron"><strong>Avantages</strong> : on peut personnaliser la fenêtre et écrire nos propres slots.<br>
<strong>Défauts</strong> : il faut utiliser le préfixe "ui" devant les noms de tous les widgets pour pouvoir les utiliser.</span><br>
<br>
Nous allons hériter de la fenêtre créée avec Qt Designer. Pour faire cela, nous allons créer une nouvelle classe dans notre projet intitulée "FenCalculatrice" (du même nom que la fenêtre créée sous Qt Designer, oui oui). Créez un .cpp et un .h.<br>
<br>
Au final, votre projet devrait comporter les fichiers suivants :<br>
<br>
<ul>
<li>main.cpp</li>
<li>FenCalculatrice.h</li>
<li>FenCalculatrice.cpp</li>
</ul><br>
<br>
Refaites un <span class="code2 console">qmake&nbsp;-project</span> pour mettre à jour le fichier .pro de votre projet, afin de vous assurer que les nouveaux fichiers FenCalculatrice.h et FenCalculatrice.cpp seront bien compilés.<br>
<br>
Définissez le fichier <strong>FenCalculatrice.h</strong> comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_FENCALCULATRICE</span>
<span class="cp">#define HEADER_FENCALCULATRICE</span>

<span class="cp">#include &lt;QtGui&gt;</span>
<span class="cp">#include "ui_calculatrice.h"</span>

<span class="k">class</span> <span class="nc">FenCalculatrice</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">FenCalculatrice</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">private</span> <span class="nl">slots:</span>
        <span class="cm">/* Insérez les prototypes de vos slots personnalisés ici */</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">Ui</span><span class="o">::</span><span class="n">FenCalculatrice</span> <span class="n">ui</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On inclut "ui_calculatrice.h" pour pouvoir utiliser la fenêtre créée avec Qt Designer.<br>
On crée une classe FenCalculatrice héritant de QWidget. Ehhh oui, il faut hériter du même type que la fenêtre créée sous Qt Designer (qui était un QWidget si vous vous souvenez bien).<br>
<br>
On crée un constructeur classique.<br>
On déclare un objet "ui" de type Ui::FenCalculatrice. Ca c'est la particularité. L'objet ui contiendra tous les widgets de la fenêtre, vous allez voir.<br>
<br>
<br>
Maintenant, on va implémenter le constructeur dans FenCalculatrice.cpp. Là, vous allez voir, c'est ultra-simple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenCalculatrice.h"</span>

<span class="n">FenCalculatrice</span><span class="o">::</span><span class="n">FenCalculatrice</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ui</span><span class="p">.</span><span class="n">setupUi</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// A faire en premier</span>

    <span class="cm">/*</span>
<span class="cm">    Personnalisez vos widgets ici si nécessaire</span>
<span class="cm">    Réalisez des connexions supplémentaires entre signaux et slots</span>
<span class="cm">    */</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Tout ce que vous avez à faire, c'est un <span class="code2 cpp"><span class="n">ui</span><span class="p">.</span><span class="n">setupUi</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
</span> pour créer le contenu de la fenêtre.<br>
Il faut faire cela en premier dans le constructeur. Ensuite, libre à vous de personnaliser les widgets et de créer des connexions supplémentaires entre des signaux et des slots.<br>
<br>
<strong>Particularité</strong> : tous les widgets sont accessibles en faisant <span class="code2 cpp"><span class="n">ui</span><span class="p">.</span><span class="n">nomDuWidget</span>
</span>.<br>
Par exemple, on peut changer le texte du bouton comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenCalculatrice.h"</span>

<span class="n">FenCalculatrice</span><span class="o">::</span><span class="n">FenCalculatrice</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ui</span><span class="p">.</span><span class="n">setupUi</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

<span class="ln-xtra">    <span class="n">ui</span><span class="p">.</span><span class="n">boutonEgal</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="s">"Egal"</span><span class="p">);</span></span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Le nom du bouton "boutonEgal", nous l'avons défini dans Qt Designer tout à l'heure (propriété objectName de QObject). Retournez voir le petit tableau un peu plus haut pour vous souvenir de la liste des noms des widgets de la fenêtre.</div><br>
<br>
Bon en général vous n'aurez pas besoin de personnaliser vos widgets, vu que vous avez tout fait sous Qt Designer. Mais si vous avez besoin d'adapter leur contenu à l'exécution (pour afficher le nom de l'utilisateur par exemple), il faudra passer par là.<br>
<br>
Maintenant ce qui est intéressant surtout, c'est d'effectuer une connexion :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenCalculatrice.h"</span>

<span class="n">FenCalculatrice</span><span class="o">::</span><span class="n">FenCalculatrice</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ui</span><span class="p">.</span><span class="n">setupUi</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

<span class="ln-xtra">    <span class="n">connect</span><span class="p">(</span><span class="n">ui</span><span class="p">.</span><span class="n">boutonEgal</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">calculerOperation</span><span class="p">()));</span></span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq attention">N'oubliez pas à chaque fois de mettre le préfixe "ui" devant chaque nom de widget !</div><br>
<br>
Ce code nous permet de faire en sorte que le slot calculerOperation() de la fenêtre soit appelé à chaque fois que l'on clique sur le bouton.<br>
<br>
Il ne vous reste plus qu'à adapter votre main pour appeler la fenêtre comme une fenêtre classique :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QtGui&gt;</span>
<span class="cp">#include "FenCalculatrice.h"</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">FenCalculatrice</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
La méthode que nous venons de voir est très pratique et on peut faire tout ce qu'on veut avec, mais il faut écrire le préfixe "ui" devant le nom du widget à chaque fois.<br>
Si vous voulez évitez d'avoir à écrire "ui", il va falloir faire un héritage multiple...<br>
<br>
<br>
<h4>Utilisation avec un héritage multiple</h4><br>
<br>
<span class="marron"><strong>Avantages</strong> : on peut personnaliser la fenêtre, écrire nos propres slots, et on n'a pas besoin de mettre le préfixe "ui" devant chaque nom de widget.<br>
<strong>Défauts</strong> : il faut faire un héritage multiple, une technique un peu plus complexe que l'héritage classique.</span><br>
<br>
<br>
L'héritage multiple est une technique complexe du C++ que je ne vous ai pas enseignée jusqu'alors dans le cours. Il faut dire qu'on l'utilise rarement et, bien que cette technique soit puissante, elle est considérée comme trop complexes par certains nouveaux langages (Java, Ruby...) qui ont décidé de ne pas gérer l'héritage multiple.<br>
<br>
Bon, le principe c'est quoi ? A priori c'est tout bête : c'est <strong>une classe qui hérite de 2 classes</strong> (ou plus !).<br>
Dans notre cas, il faut que l'on hérite à la fois de QWidget (le type de la fenêtre) et de Ui::FenCalculatrice (la fenêtre créée sous Qt Designer) !<br>
<br>
<div class="centre"><img src="./cpp_files/118805.png" alt="Héritage multiple"></div><br>
<br>
En pratique, dans la déclaration de la classe (fichier <strong>FenCalculatrice.h</strong>), ce qui change c'est la ligne 7 :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_FENCALCULATRICE</span>
<span class="cp">#define HEADER_FENCALCULATRICE</span>

<span class="cp">#include &lt;QtGui&gt;</span>
<span class="cp">#include "ui_calculatrice.h"</span>

<span class="ln-xtra"><span class="k">class</span> <span class="nc">FenCalculatrice</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span><span class="p">,</span> <span class="k">private</span> <span class="n">Ui</span><span class="o">::</span><span class="n">FenCalculatrice</span></span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">FenCalculatrice</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">private</span> <span class="nl">slots:</span>
        <span class="cm">/* Insérez les prototypes de vos slots personnalisés ici */</span>
<span class="p">};</span>


<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La seule ligne qui change a été surlignée, c'est celle de déclaration de la classe. On hérite de QWidget et de Ui::FenCalculatrice à la fois.<br>
Vous noterez qu'on n'a plus besoin de définir un objet "ui" de type Ui::FenCalculatrice cette fois.<br>
<br>
Dans le fichier .cpp, c'est pareil sauf que maintenant vous pouvez enlever tous les préfixes "ui" :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenCalculatrice.h"</span>

<span class="n">FenCalculatrice</span><span class="o">::</span><span class="n">FenCalculatrice</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setupUi</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

    <span class="n">connect</span><span class="p">(</span><span class="n">boutonEgal</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">calculerOperation</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
<h3>Personnaliser le code et utiliser les Auto-Connect</h3><br>
<br>
Les fenêtres créées avec Qt Designer bénéficient du système "<strong>Auto-Connect</strong>" de Qt. C'est un système qui crée les connexions tout seul.<br>
<br>
Par quelle magie ?<br>
Il vous suffit en fait de créer des slots en leur donnant un nom qui respecte une convention.<br>
<br>
Prenons le widget <span class="rouge">boutonEgal</span> et son signal <span class="bleu">clicked()</span>. Si vous créez un slot appelé <span class="courrier">on_<span class="rouge">boutonEgal</span>_<span class="bleu">clicked()</span></span> dans votre fenêtre, ce slot sera automatiquement appelé lors d'un clic sur le bouton.<br>
<br>
La convention à respecter est représentée sur le schéma ci-dessous :<br>
<br>
<div class="centre"><img src="./cpp_files/118815.png" alt="Auto-Connect"></div> <br>
<br>
<br>
Essayons d'utiliser l'Auto-Connect dans notre programme. Je me base ici sur un héritage multiple.<br>
<br>
Voici le .h :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_FENCALCULATRICE</span>
<span class="cp">#define HEADER_FENCALCULATRICE</span>

<span class="cp">#include &lt;QtGui&gt;</span>
<span class="cp">#include "ui_calculatrice.h"</span>

<span class="k">class</span> <span class="nc">FenCalculatrice</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span><span class="p">,</span> <span class="k">private</span> <span class="n">Ui</span><span class="o">::</span><span class="n">FenCalculatrice</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">FenCalculatrice</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">private</span> <span class="nl">slots:</span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">on_boutonEgal_clicked</span><span class="p">();</span></span>
<span class="p">};</span>


<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
... et le .cpp :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenCalculatrice.h"</span>

<span class="n">FenCalculatrice</span><span class="o">::</span><span class="n">FenCalculatrice</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span> <span class="n">QWidget</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setupUi</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="ln-xtra"><span class="kt">void</span> <span class="n">FenCalculatrice</span><span class="o">::</span><span class="n">on_boutonEgal_clicked</span><span class="p">()</span></span>
<span class="ln-xtra"><span class="p">{</span></span>
<span class="ln-xtra">    <span class="kt">int</span> <span class="n">somme</span> <span class="o">=</span> <span class="n">nombre1</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">()</span> <span class="o">+</span> <span class="n">nombre2</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span></span>
<span class="ln-xtra">    <span class="n">resultat</span><span class="o">-&gt;</span><span class="n">setNum</span><span class="p">(</span><span class="n">somme</span><span class="p">);</span></span>
<span class="ln-xtra"><span class="p">}</span></span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Vous noterez qu'on n'a plus besoin de faire de connexion dans le constructeur. Ben oui, c'est le principe de l'Auto-Connect. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Comme vous le voyez, il suffit de créer un slot avec un nom particulier, et tout roule comme sur des roulettes !<br>
<br>
Vous pouvez tester le programme, ça marche !<br>
<br>
<div class="centre"><img src="./cpp_files/118818.png" alt="Mini calculatrice opérationnelle"></div><br>
<br>
Bon, j'avoue, je n'ai géré ici que l'addition. Mais je vais pas tout vous faire non plus hein. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
<strong>Exercice </strong> (me dites pas que vous l'avez pas vu venir <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ) : complétez le code de la calculatrice pour effectuer la bonne opération en fonction de l'élément sélectionné dans la liste déroulante.<br>
<br>
<div class="rmq information">L'Auto-Connect est activé par défaut dans les fenêtres créées avec Qt Designer, mais vous pouvez aussi vous en servir dans vos autres fenêtres "faites main".<br>
Il suffira d'ajouter la ligne suivante dans le constructeur de la fenêtre pour bénéficier de toute la puissance de l'Auto-Connect : <span class="code2 cpp"><span class="n">QMetaObject</span><span class="o">::</span><span class="n">connectSlotsByName</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></div>
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Ceux qui croyaient que Qt Designer était un "<span class="italique">programme magique qui allait réaliser des fenêtres tout seul sans avoir besoin de coder</span>" en ont été pour leurs frais ! <img src="./cpp_files/pirate.png" alt=":pirate:" class="smilies"> <br>
<br>
Pourtant, comme avec Qt Linguist, le processus de création de fenêtres de Qt Designer a été très bien pensé. Tout est logique et s'enchaîne de bout en bout, mais encore faut-il comprendre cette logique. J'espère vous y avoir aidé à travers ce chapitre.<br>
<br>
J'ai profité de ce chapitre pour survoler la notion d'<strong>héritage multiple</strong>. Il y aurait à redire sur cette notion, mais c'est un peu complexe et on peut se contenter de retenir ce qui a été dit dans ce chapitre si on a juste besoin d'utiliser des fenêtres créées avec Qt Designer.<br>
Si vous voulez en savoir plus (et je vous y encourage), il vous faudra chercher d'autres cours sur le web traitant de l'héritage multiple en C++.<br>
<br>
<br>
Entraînez-vous à utiliser quelques fenêtres créées avec Qt Designer, et en particulier à créer des slots personnalisés.<br>
Tant qu'à faire, je vous conseille de vous servir de l'Auto-Connect. Une fois qu'on y a goûté on ne peut plus s'en passer. <img src="./cpp_files/langue.png" alt=":p" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11372">TP : zNavigo, le navigateur web des Zéros !</h1>
	<div id="chap_intro">
	Depuis le temps que vous pratiquez Qt, vous avez acquis sans vraiment le savoir les capacités de base pour réaliser des programmes complexes. Le but d'un TP comme celui-ci, c'est de vous montrer justement que vous êtes capables de mener à bien des projets qui auraient pu vous sembler complètement fous il y a quelques temps.<br>
<br>
Vous ne rêvez pas : le but de ce TP sera de... <strong>réaliser un navigateur web</strong> !<br>
<br>
<div class="centre"><a href="http://uploads.siteduzero.com/files/121001_122000/121749.png"><img src="./cpp_files/121749.png" alt="zNavigo"></a></div><br>
<br>
<div class="rmq question">Quoi ? Je suis capable de faire ça moi ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"></div><br>
<br>
Oui, et nous allons voir comment dans ce chapitre !<br>
<br>
Nous allons commencer dans un premier temps par découvrir la notion de <span class="italique">moteur web</span>, pour bien comprendre comment fonctionnent les autres navigateurs. Puis, nous mettrons en place le plan du développement de notre programme afin de nous assurer que nous partons dans la bonne direction et que nous n'oublions rien.<br>
<br>
Firefox n'a qu'à bien se tenir. <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> 
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11371">Les navigateurs et les moteurs web</h2>
		<div class="ss_part_texte">
		Comme toujours, il faut d'abord prendre le temps de <span class="italique">réfléchir à son programme</span> avant de foncer le coder tête baissée. C'est ce qu'on appelle la phase de <strong>conception</strong>.<br>
<br>
Je sais, je me répète à chaque fois, mais c'est vraiment parce que c'est très important. Si je vous dis "<span class="italique">faites-moi un navigateur web</span>" et que vous créez de suite un nouveau projet en vous demandant ce que vous allez bien pouvoir mettre dans le <span class="italique">main</span>, ben... c'est le ramassage assuré. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
Pour moi, la conception est l'étape la plus difficile du projet. Plus difficile même que le code. En effet, si vous concevez bien votre programme, si vous réfléchissez bien à la façon dont il doit fonctionner, vous aurez simplifié à l'avance votre projet et vous n'aurez pas à écrire des lignes de code difficiles inutilement.<br>
<br>
Dans un premier temps, je vais vous expliquer comment fonctionne un navigateur web. Un peu de culture générale à ce sujet vous permettra de mieux comprendre ce que vous avez à faire (et ce que vous n'avez pas à faire).<br>
Je vous donnerai ensuite quelques conseils pour organiser votre code : quelles classes créer, par quoi commencer, etc.<br>
<br>
<br>
<h3>Les principaux navigateurs</h3><br>
<br>
Commençons par le commencement : vous savez ce qu'est un navigateur web ?<br>
Bon, je ne me moque pas de vous, mais il vaut mieux être sûr de ne perdre personne. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Un navigateur web est un programme qui permet de consulter des sites web.<br>
Parmi les plus connus d'entre eux, citons Internet Explorer, Mozilla Firefox ou encore Safari. Mais il y en a aussi beaucoup d'autres, certes moins utilisés, comme Opera, Konqueror, Epiphany, Maxthon, Lynx...<br>
<br>
Je vous rassure, il n'est pas nécessaire de tous les connaître pour pouvoir prétendre en créer un.<br>
Par contre, ce qu'il faut que vous sachiez, c'est que chacun de ces navigateurs est constitué de ce qu'on appelle un <strong>moteur web</strong>. Qu'est-ce que c'est que cette bête-là ?<br>
<br>
<br>
<h3>Le moteur web</h3><br>
<br>
Tous les sites web sont écrits en langage HTML (ou XHTML). Voici un exemple de code HTML permettant de créer une page très simple :<br>
<br>
<span class="code">Code : HTML - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 html"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9</pre></td><td class="code"><div class="syntax"><pre><span class="cp">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</span>
<span class="nt">&lt;html</span> <span class="na">xmlns=</span><span class="s">"http://www.w3.org/1999/xhtml"</span> <span class="na">xml:lang=</span><span class="s">"fr"</span> <span class="nt">&gt;</span>
   <span class="nt">&lt;head&gt;</span>
       <span class="nt">&lt;title&gt;</span>Bienvenue sur mon site !<span class="nt">&lt;/title&gt;</span>
       <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"Content-Type"</span> <span class="na">content=</span><span class="s">"text/html; charset=iso-8859-1"</span> <span class="nt">/&gt;</span>
   <span class="nt">&lt;/head&gt;</span>
   <span class="nt">&lt;body&gt;</span>
   <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est bien joli tout ce code, mais ça ne ressemble pas au résultat visuel qu'on a l'habitude de voir lorsqu'on navigue sur le web.<br>
<br>
L'objectif est justement de transformer ce code en un résultat visuel : le site web. <span class="souligne">C'est le rôle du moteur web</span>.<br>
Voici son fonctionnement, résumé dans un schéma très simple :<br>
<br>
<div class="centre"><img src="./cpp_files/121727.png" alt="Moteur web"></div><br>
<br>
Ca n'a l'air de rien, mais c'est un travail difficile : réaliser un moteur web est très délicat. C'est généralement le fruit des efforts de nombreux programmeurs experts (et encore, ils avouent avoir du mal <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ). Certains moteurs sont meilleurs que d'autres, mais aucun n'est parfait ni complet. Comme le web est en perpétuelle évolution, il est peu probable qu'un moteur parfait sorte un jour.<br>
<br>
<br>
Quand on programme un navigateur, on utilise généralement le moteur web sous forme de bibliothèque.<br>
Le moteur web n'est donc pas un programme, mais il est utilisé par des programmes.<br>
<br>
...<br>
 <img src="./cpp_files/unsure.gif" alt=":euh:" class="smilies"> <br>
...<br>
<br>
Ce sera plus clair avec un schéma. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Regardons comment est constitué Firefox par exemple :<br>
<br>
<div class="centre"><img src="./cpp_files/121649.png" alt="Schéma du navigateur web"></div><br>
<br>
On voit que le navigateur (en vert) "contient" le moteur web (en jaune au centre).<br>
<br>
<div class="rmq information">La partie en vert est habituellement appelée le "chrome", pour désigner l'interface.</div><br>
<br>
<div class="rmq question">Mais c'est nul ! Alors le navigateur web c'est juste les 2-3 boutons en haut et c'est tout ?</div><br>
<br>
Oh non ! Loin de là.<br>
Le navigateur ne se contente pas de gérer les boutons "Précédente", "Suivante", "Actualiser", etc. C'est aussi lui qui gère les marque-pages (favoris), le système d'onglets, les options d'affichage, la barre de recherche, etc.<br>
<br>
Tout cela représente déjà un énorme travail ! En fait, les développeurs de Firefox ne sont pas les mêmes que ceux qui développent son moteur web. Il y a des équipes séparées, tellement chacun de ces éléments représente du travail.<br>
<br>
<br>
<h3>Les principaux navigateurs et leurs moteurs</h3><br>
<br>
Un grand nombre de navigateurs ne s'occupent pas du moteur web. Ils en utilisent un "tout prêt".<br>
De nombreux navigateurs sont basés sur le même moteur web. Voici un petit schéma de mon crû qui vous permet de vous donner une idée un peu de "qui utilise quoi" :<br>
<br>
<div class="centre"><img src="./cpp_files/121654.png" alt="Navigateurs et moteurs web"></div><br>
<br>
Les noms des moteurs web ne sont pas connus du grand public. D'ailleurs, il est probable que vous n'ayez entendu parler d'aucun d'eux jusqu'à aujourd'hui. Ce qui est connu, c'est le navigateur, alors que c'est le moteur web qui se tape tout le sale boulot. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Je n'ai pas mis tous les navigateurs et moteurs web existants, mais cela permet déjà d'avoir une bonne idée de ce qui se passe.<br>
Comme vous le voyez, rares sont les navigateurs à avoir leur propre moteur web. On peut noter l'exception d'Opera (et encore, le moteur a été revendu à Adobe qui ne voulait pas en coder un pour son logiciel Dreamweaver).<br>
<br>
Tout ça pour dire quoi ? Eh bien déjà que <strong>créer un moteur web n'est ni de votre niveau, ni du mien</strong>. Comme de nombreux navigateurs, nous en utiliserons un déjà existant.<br>
<br>
Lequel ? Eh bien il se trouve que Qt (oui, parce qu'on parle de Qt ici, j'espère que vous n'avez pas oublié <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ), Qt donc vous propose depuis peu d'utiliser le moteur WebKit dans vos programmes. C'est donc ce moteur-là que nous allons utiliser pour créer notre navigateur.<br>
<br>
<br>
<h3>Configurer son projet pour utiliser WebKit</h3><br>
<br>
WebKit est un des nombreux modules de Qt. Il ne fait pas partie du module "GUI", dédié à la création de fenêtres, il s'agit d'un module à part.<br>
<br>
Pour pouvoir l'utiliser, il faudra modifier le fichier .pro du projet pour que Qt sache qu'il a besoin de charger WebKit.<br>
Voici un exemple de fichier .pro qui indique que le projet utilise WebKit :<br>
<br>
<span class="code">Code : Autre - <a href="#" class="select_code">Sélectionner</a></span><div class="code2"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><div class="syntax"><pre>######################################################################
#&nbsp;Automatically&nbsp;generated&nbsp;by&nbsp;qmake&nbsp;(2.01a)&nbsp;mer.&nbsp;18.&nbsp;juin&nbsp;11:49:49&nbsp;2008
######################################################################

TEMPLATE&nbsp;=&nbsp;app
<span class="ln-xtra">QT&nbsp;+=&nbsp;webkit</span>
TARGET&nbsp;=&nbsp;
DEPENDPATH&nbsp;+=&nbsp;.
INCLUDEPATH&nbsp;+=&nbsp;.

#&nbsp;Input
HEADERS&nbsp;+=&nbsp;FenPrincipale.h
SOURCES&nbsp;+=&nbsp;FenPrincipale.cpp&nbsp;main.cpp</pre></div></td></tr></tbody></table></div><br>
<br>
Le plus simple est de faire un <span class="code2 console">qmake&nbsp;-project</span> d'abord pour générer le fichier .pro, puis de rajouter la ligne que j'ai surlignée : <span class="code2">QT&nbsp;+=&nbsp;webkit</span><br>
<br>
D'autre part, vous devrez rajouter l'include suivant dans les fichiers de votre code source faisant appel à WebKit :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QtWebKit&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Enfin, il faudra joindre 2 nouvelles DLL à votre programme pour qu'il fonctionne : QtWebKit4.dll et QtNetwork4.dll.<br>
<br>
Ouf, tout est prêt. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11370">Organisation du projet</h2>
		<div class="ss_part_texte">
		<h3>Objectif</h3><br>
<br>
Avant d'aller plus loin, il me semble indispensable de vous montrer à quoi doit ressembler le navigateur une fois terminé.<br>
Votre objectif est de réaliser un navigateur web semblable à celui-ci :<br>
<br>
<div class="centre"><img src="./cpp_files/121737(1).png" alt="zNavigo"></div><br>
<br>
Parmi les fonctionnalités de ce super navigateur, affectueusement nommé "zNavigo", on compte :<br>
<br>
<ul>
<li>Accès aux pages précédentes et suivantes</li>
<li>Arrêter le chargement de la page</li>
<li>Actualiser la page</li>
<li>Retour à la page d'accueil</li>
<li>Saisie d'une adresse</li>
<li>Navigation par onglets</li>
<li>Affichage du pourcentage de chargement dans la barre d'état</li>
</ul><br>
<br>
Le menu "Fichier" propose d'ouvrir et de fermer un onglet, ainsi que de quitter le programme.<br>
Le menu "Navigation" reprend le contenu de la barre d'outils (ce qui est très facile à faire grâce aux QAction je vous le rappelle).<br>
Le menu "?" (aide) propose d'afficher les fenêtres "A propos..." et "A propos de Qt..." qui donnent des informations respectivement sur notre programme et sur Qt.<br>
<br>
Ca n'a l'air de rien comme ça, mais ça représente déjà un sacré boulot !<br>
Si vous avez du mal dans un premier temps, vous pouvez vous épargner la gestion des onglets... mais moi j'ai trouvé que c'était un peu trop simple sans les onglets, alors j'ai choisi de vous faire jouer avec, histoire de corser le tout. <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> <br>
<br>
<br>
<h3>Les fichiers du projet</h3><br>
<br>
J'ai l'habitude de faire une classe par fenêtre. Comme notre projet ne sera constitué (au moins dans un premier temps) que d'une seule fenêtre, nous aurons donc les fichiers suivants :<br>
<br>
<ul>
<li>main.cpp</li>
<li>FenPrincipale.h</li>
<li>FenPrincipale.cpp</li>
</ul><br>
Si vous voulez utiliser les mêmes icônes que moi, les voici :<br>
<br>
<div class="centre"><img src="./cpp_files/121766.png" alt="Précédente"><img src="./cpp_files/121768.png" alt="Suivante"><img src="./cpp_files/121767.png" alt="Stop"><img src="./cpp_files/121764.png" alt="Actualiser"><img src="./cpp_files/121763.png" alt="Accueil"><img src="./cpp_files/121765.png" alt="Go"><img src="./cpp_files/121769.png" alt="zNavigo"></div><br>
<br>
Notez que la dernière est l'icône du programme (affichée en haut à gauche).<br>
<br>
<div class="rmq information">Toutes ces icônes sont sous licence LGPL et proviennent du site <a href="http://www.everaldo.com/">http://www.everaldo.com</a></div><br>
<br>
<h3>Utiliser QWebView pour afficher une page web</h3><br>
<br>
Le <a href="http://doc.trolltech.com/qwebview.html">QWebView</a> est le principal nouveau widget que vous aurez besoin d'utiliser dans ce chapitre. Il permet d'afficher une page web. C'est lui le <strong>moteur web</strong>.<br>
<br>
Vous ne savez pas vous en servir, mais vous savez maintenant <a href="http://doc.trolltech.com/qwebview.html">lire la doc</a>. Vous allez voir, ce n'est pas bien difficile !<br>
<br>
Regardez en particulier les signaux et slots proposés par le QWebView. Il y a tout ce qu'il faut savoir pour, par exemple, connaître le pourcentage de chargement de la page pour le répercuter sur la barre de progression de la barre d'état (signal <span class="code2 cpp"><span class="n">loadProgress</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</span>). <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Comme l'indique la doc, pour créer le widget et charger une page, c'est très simple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">QWebView</span> <span class="o">*</span><span class="n">pageWeb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QWebView</span><span class="p">;</span>
<span class="n">pageWeb</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">(</span><span class="n">QUrl</span><span class="p">(</span><span class="s">"http://www.siteduzero.com/"</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Voilà c'est tout ce que je vous expliquerai sur QWebView, pour le reste lisez la doc. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<br>
<h3>La navigation par onglets</h3><br>
<br>
Le problème de QWebView, c'est qu'il ne permet d'afficher qu'une seule page web à la fois. Il ne gère pas la navigation par onglets. Il va falloir implémenter le système d'onglets nous-mêmes.<br>
<br>
Vous n'avez jamais entendu parler de QTabWidget ? Si si, souvenez-vous, nous l'avons découvert dans un des chapitres précédents. Ce widget-conteneur est capable d'accueillir n'importe quels widgets... comme un QWebView !<br>
En combinant un QTabWidget et des QWebView (un par onglet), vous pourrez reconstituer un véritable navigateur par onglets !<br>
<br>
<br>
Une petite astuce toutefois, qui pourra vous être bien utile : savoir retrouver un widget contenu dans un widget parent.<br>
Comme vous le savez, le QTabWidget utilise des sous-widgets pour gérer chacune des pages. Ces sous-widgets sont généralement des QWidget génériques (invisibles), qui servent à contenir d'autres widgets.<br>
<br>
Dans notre cas : <span class="bleu"><strong>QTabWidget</strong></span> <span class="italique">contient</span> des <span class="rouge"><strong>QWidget</strong></span> (pages d'onglet) qui eux-mêmes <span class="italique">contiennent</span> chacun un <span class="violet"><strong>QWebView</strong></span> (la page web).<br>
<br>
<div class="centre"><img src="./cpp_files/122283.png" alt="Enfants dans le zNavigo"></div><br>
<br>
La méthode findChild (définie dans QObject) permet de retrouver le widget enfant contenu dans le widget parent.<br>
<br>
Par exemple, si je connais le QWidget "pageOnglet", je peux retrouver le QWebView qu'il contient comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QWebView</span> <span class="o">*</span><span class="n">pageWeb</span> <span class="o">=</span> <span class="n">pageOnglet</span><span class="o">-&gt;</span><span class="n">findChild</span><span class="o">&lt;</span><span class="n">QWebView</span> <span class="o">*&gt;</span><span class="p">();</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Mieux encore, je vous donne la méthode toute faite qui permet de retrouver le QWebView actuellement visualisé par l'utilisateur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="n">QWebView</span> <span class="o">*</span><span class="n">FenPrincipale</span><span class="o">::</span><span class="n">pageActuelle</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">onglets</span><span class="o">-&gt;</span><span class="n">currentWidget</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">findChild</span><span class="o">&lt;</span><span class="n">QWebView</span> <span class="o">*&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/122279.png" alt="Schéma findChild"></div><br>
<br>
"onglets" correspond au QTabWidget.<br>
Sa méthode currentWidget() permet d'obtenir un pointeur vers le QWidget qui sert de page pour la page actuellement affichée.<br>
On demande ensuite à retrouver le QWebView que le QWidget contient à l'aide de la méthode findChild(). Cette méthode utilise les templates C++ (avec &lt;QWebView *&gt;). Je ne vais pas rentrer dans les détails ici car ce serait un peu trop long, mais en gros cela permet de faire en sorte que la méthode retourne bien un QWebView * (sinon elle n'aurait pas su quoi renvoyer).<br>
<br>
<br>
J'admets, c'est un petit peu compliqué, mais au moins ça pourra vous aider. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Let's go !</h3><br>
<br>
Voilà, vous savez déjà tout ce qu'il faut pour vous en sortir.<br>
<br>
Notez que ce TP fait la part belle à la QMainWindow, n'hésitez donc pas à relire ce chapitre dans un premier temps pour bien vous remémorer son fonctionnement.<br>
Pour ma part, j'ai choisi de coder la fenêtre "à la main" (pas de Qt Designer donc) car celle-ci est un peu complexe.<br>
<br>
Comme il y a beaucoup d'initialisations à faire dans le constructeur, je vous conseille de les placer dans des méthodes que vous appellerez depuis le constructeur pour améliorer la lisibilité :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9</pre></td><td class="code"><div class="syntax"><pre><span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">creerActions</span><span class="p">();</span>
    <span class="n">creerMenus</span><span class="p">();</span>
    <span class="n">creerBarresOutils</span><span class="p">();</span>

    <span class="c">/* Autres initialisations */</span>

<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Bon courage ! <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11369">Génération de la fenêtre principale</h2>
		<div class="ss_part_texte">
		Commençons par les choses simples (et un peu répétitives).<br>
<br>
<br>
<h3>main.cpp</h3><br>
<br>
Tout d'abord le main.cpp, qui ne devrait pas vous perturber :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QTranslator&gt;</span>
<span class="cp">#include &lt;QLocale&gt;</span>
<span class="cp">#include &lt;QLibraryInfo&gt;</span>
<span class="cp">#include "FenPrincipale.h"</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="c">// Traduction des chaînes prédéfinies par Qt dans notre langue</span>
    <span class="n">QString</span> <span class="n">locale</span> <span class="o">=</span> <span class="n">QLocale</span><span class="o">::</span><span class="n">system</span><span class="p">().</span><span class="n">name</span><span class="p">();</span>
    <span class="n">QTranslator</span> <span class="n">translator</span><span class="p">;</span>
    <span class="n">translator</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="s">"qt_"</span><span class="p">)</span> <span class="o">+</span> <span class="n">locale</span><span class="p">,</span> <span class="n">QLibraryInfo</span><span class="o">::</span><span class="n">location</span><span class="p">(</span><span class="n">QLibraryInfo</span><span class="o">::</span><span class="n">TranslationsPath</span><span class="p">));</span>
    <span class="n">app</span><span class="p">.</span><span class="n">installTranslator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">translator</span><span class="p">);</span>

    <span class="c">// Ouverture de la fenêtre principale du navigateur</span>
    <span class="n">FenPrincipale</span> <span class="n">principale</span><span class="p">;</span>
    <span class="n">principale</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je me contente d'ouvrir la fenêtre principale. Les quelques lignes de code au début sont celles que je vous avais données il y a quelques chapitres, pour faire en sorte que les chaînes de caractères de base (Yes / No) soient traduites en français dans l'application.<br>
<br>
<br>
Maintenant, créons la classe FenPrincipale, notre plus gros morceau.<br>
<br>
<br>
<h3>FenPrincipale.h (première version)</h3><br>
<br>
Dans un premier temps, je ne crée que le squelette de la classe et ses premières méthodes, j'en rajouterai d'autres au fur et à mesure si besoin est.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_FENPRINCIPALE</span>
<span class="cp">#define HEADER_FENPRINCIPALE</span>

<span class="cp">#include &lt;QtGui&gt;</span>
<span class="cp">#include &lt;QtWebKit&gt;</span>

<span class="k">class</span> <span class="nc">FenPrincipale</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QMainWindow</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">FenPrincipale</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">creerActions</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">creerMenus</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">creerBarresOutils</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">creerBarreEtat</span><span class="p">();</span>

    <span class="k">private</span> <span class="nl">slots:</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">QTabWidget</span> <span class="o">*</span><span class="n">onglets</span><span class="p">;</span>

        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionNouvelOnglet</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionFermerOnglet</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionQuitter</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionAPropos</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionAProposQt</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionPrecedente</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionSuivante</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionStop</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionActualiser</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionAccueil</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionGo</span><span class="p">;</span>

        <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">champAdresse</span><span class="p">;</span>
        <span class="n">QProgressBar</span> <span class="o">*</span><span class="n">progression</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La classe hérite de QMainWindow comme prévu. J'ai inclus QtGui et QtWebKit pour pouvoir utiliser le module GUI et le module WebKit (moteur web).<br>
<br>
Mon idée c'est, comme je vous l'avais dit, de couper le constructeur en plusieurs sous-méthodes qui s'occupent chacune de créer une section différente de la QMainWindow : actions, menus, barre d'outils, barre d'état...<br>
<br>
J'ai prévu une section pour les slots personnalisés mais je n'ai encore rien mis, je verrai au fur et à mesure.<br>
<br>
Enfin, j'ai préparé les principaux attributs de la classe. En fin de compte, à part de nombreuses QAction, il n'y en a pas beaucoup. Je n'ai même pas eu besoin de mettre des objets de type QWebView : ceux-ci seront créés à la volée au cours du programme et on pourra les retrouver grâce à la méthode pageActuelle() que je vous ai donnée un peu plus tôt.<br>
<br>
Voyons voir l'implémentation du constructeur et de ses sous-méthodes qui génèrent le contenu de la fenêtre.<br>
<br>
<br>
<h3>Construction de la fenêtre</h3><br>
<br>
Direction FenPrincipale.cpp, on commence par le constructeur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">// Génération des widgets de la fenêtre principale</span>
    <span class="n">creerActions</span><span class="p">();</span>
    <span class="n">creerMenus</span><span class="p">();</span>
    <span class="n">creerBarresOutils</span><span class="p">();</span>
    <span class="n">creerBarreEtat</span><span class="p">();</span>

    <span class="c">// Génération des onglets et chargement de la page d'accueil</span>
    <span class="n">onglets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTabWidget</span><span class="p">;</span>
    <span class="n">onglets</span><span class="o">-&gt;</span><span class="n">addTab</span><span class="p">(</span><span class="n">creerOngletPageWeb</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"http://www.siteduzero.com"</span><span class="p">)),</span> <span class="n">tr</span><span class="p">(</span><span class="s">"(Nouvelle page)"</span><span class="p">));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">onglets</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">currentChanged</span><span class="p">(</span><span class="kt">int</span><span class="p">)),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">changementOnglet</span><span class="p">(</span><span class="kt">int</span><span class="p">)));</span>
    <span class="n">setCentralWidget</span><span class="p">(</span><span class="n">onglets</span><span class="p">);</span>

    <span class="c">// Définition de quelques propriétés de la fenêtre</span>
    <span class="n">setMinimumSize</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">350</span><span class="p">);</span>
    <span class="n">setWindowIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"images/znavigo.png"</span><span class="p">));</span>
    <span class="n">setWindowTitle</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"zNavigo"</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Nous allons voir juste après le code des méthodes creerActions(), creerMenus(), etc. Ce code est un peu long et répétitif, pas très intéressant mais il fallait le faire.<br>
<br>
Par contre, ce qui est intéressant ensuite dans le constructeur, c'est que l'on crée le QTabWidget et on lui ajoute un premier onglet. Pour la création d'un onglet, on va faire appel à une méthode "maison" creerOngletPageWeb() qui va se charger de créer le QWidget-page de l'onglet, ainsi que de créer un QWebView et de lui faire charger la page web envoyée en paramètre ("http://www.siteduzero.com" sera donc la page d'accueil par défaut <img src="./cpp_files/langue.png" alt=":p" class="smilies"> ).<br>
<br>
Vous noterez que l'on utilise la fonction de tr() partout, au cas où on voudrait traduire le programme par la suite. C'est une bonne habitude à prendre, même si on n'a pas forcément l'intention de traduire le programme au début (on peut toujours changer d'avis après).<br>
<br>
On connecte enfin et surtout le signal currentChanged() du QTabWidget à un slot personnalisé changementOnglet() que l'on va devoir écrire. Ce slot sera appelé à chaque fois que l'utilisateur change d'onglet, pour, par exemple, mettre à jour l'URL dans la barre d'adresse ainsi que le titre de la page affiché en haut de la fenêtre.<br>
<br>
<br>
Bon, il faut maintenant écrire les méthodes de génération des actions, des menus, etc. C'était un peu long et fastidieux mais je suis arrivé jusqu'au bout. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Ne vous laissez pas impressionner par la taille du code, je n'ai pas tout écrit d'un coup, j'y suis allé petit à petit.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">creerActions</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">actionNouvelOnglet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&amp;Nouvel onglet"</span><span class="p">),</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">actionNouvelOnglet</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Ctrl+T"</span><span class="p">));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">actionNouvelOnglet</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">nouvelOnglet</span><span class="p">()));</span>
    <span class="n">actionFermerOnglet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&amp;Fermer l'onglet"</span><span class="p">),</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">actionFermerOnglet</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Ctrl+W"</span><span class="p">));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">actionFermerOnglet</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">fermerOnglet</span><span class="p">()));</span>
    <span class="n">actionQuitter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&amp;Quitter"</span><span class="p">),</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">actionQuitter</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Ctrl+Q"</span><span class="p">));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">actionQuitter</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>

    <span class="n">actionPrecedente</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"images/precedente.png"</span><span class="p">),</span> <span class="n">tr</span><span class="p">(</span><span class="s">"&amp;Precedente"</span><span class="p">),</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">actionPrecedente</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="o">::</span><span class="n">Back</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">actionPrecedente</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">precedente</span><span class="p">()));</span>
    <span class="n">actionSuivante</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"images/suivante.png"</span><span class="p">),</span> <span class="n">tr</span><span class="p">(</span><span class="s">"&amp;Suivante"</span><span class="p">),</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">actionSuivante</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="o">::</span><span class="n">Forward</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">actionSuivante</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">suivante</span><span class="p">()));</span>
    <span class="n">actionStop</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"images/stop.png"</span><span class="p">),</span> <span class="n">tr</span><span class="p">(</span><span class="s">"S&amp;top"</span><span class="p">),</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">actionStop</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">stop</span><span class="p">()));</span>
    <span class="n">actionActualiser</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"images/actualiser.png"</span><span class="p">),</span> <span class="n">tr</span><span class="p">(</span><span class="s">"&amp;Actualiser"</span><span class="p">),</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">actionActualiser</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="o">::</span><span class="n">Refresh</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">actionActualiser</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">actualiser</span><span class="p">()));</span>
    <span class="n">actionAccueil</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"images/accueil.png"</span><span class="p">),</span> <span class="n">tr</span><span class="p">(</span><span class="s">"A&amp;ccueil"</span><span class="p">),</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">actionAccueil</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">accueil</span><span class="p">()));</span>
    <span class="n">actionGo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s">"images/go.png"</span><span class="p">),</span> <span class="n">tr</span><span class="p">(</span><span class="s">"A&amp;ller à"</span><span class="p">),</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">actionGo</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">chargerPage</span><span class="p">()));</span>

    <span class="n">actionAPropos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&amp;A propos..."</span><span class="p">),</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">actionAPropos</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">aPropos</span><span class="p">()));</span>
    <span class="n">actionAPropos</span><span class="o">-&gt;</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="o">::</span><span class="n">HelpContents</span><span class="p">);</span>
    <span class="n">actionAProposQt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QAction</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"A propos de &amp;Qt..."</span><span class="p">),</span> <span class="k">this</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">actionAProposQt</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">triggered</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">aboutQt</span><span class="p">()));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">creerMenus</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuFichier</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&amp;Fichier"</span><span class="p">));</span>

    <span class="n">menuFichier</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionNouvelOnglet</span><span class="p">);</span>
    <span class="n">menuFichier</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionFermerOnglet</span><span class="p">);</span>
    <span class="n">menuFichier</span><span class="o">-&gt;</span><span class="n">addSeparator</span><span class="p">();</span>
    <span class="n">menuFichier</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionQuitter</span><span class="p">);</span>

    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuNavigation</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&amp;Navigation"</span><span class="p">));</span>

    <span class="n">menuNavigation</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionPrecedente</span><span class="p">);</span>
    <span class="n">menuNavigation</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionSuivante</span><span class="p">);</span>
    <span class="n">menuNavigation</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionStop</span><span class="p">);</span>
    <span class="n">menuNavigation</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionActualiser</span><span class="p">);</span>
    <span class="n">menuNavigation</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionAccueil</span><span class="p">);</span>


    <span class="n">QMenu</span> <span class="o">*</span><span class="n">menuAide</span> <span class="o">=</span> <span class="n">menuBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addMenu</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&amp;?"</span><span class="p">));</span>

    <span class="n">menuAide</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionAPropos</span><span class="p">);</span>
    <span class="n">menuAide</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionAProposQt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">creerBarresOutils</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">champAdresse</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLineEdit</span><span class="p">;</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">champAdresse</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">returnPressed</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">chargerPage</span><span class="p">()));</span>

    <span class="n">QToolBar</span> <span class="o">*</span><span class="n">toolBarNavigation</span> <span class="o">=</span> <span class="n">addToolBar</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Navigation"</span><span class="p">));</span>

    <span class="n">toolBarNavigation</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionPrecedente</span><span class="p">);</span>
    <span class="n">toolBarNavigation</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionSuivante</span><span class="p">);</span>
    <span class="n">toolBarNavigation</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionStop</span><span class="p">);</span>
    <span class="n">toolBarNavigation</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionActualiser</span><span class="p">);</span>
    <span class="n">toolBarNavigation</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionAccueil</span><span class="p">);</span>
    <span class="n">toolBarNavigation</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">champAdresse</span><span class="p">);</span>
    <span class="n">toolBarNavigation</span><span class="o">-&gt;</span><span class="n">addAction</span><span class="p">(</span><span class="n">actionGo</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">creerBarreEtat</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">progression</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QProgressBar</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="n">progression</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
    <span class="n">progression</span><span class="o">-&gt;</span><span class="n">setMaximumHeight</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
    <span class="n">statusBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">progression</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce code ne fait rien d'extraordinairement nouveau, je ne vois pas trop ce que je pourrais commenter. Il y a beaucoup de connexions à des slots personnalisés que l'on devra écrire.<br>
<br>
<br>
C'était la partie "longue" du code, mais certainement pas la plus complexe.<br>
<br>
Voyons maintenant quelques méthodes qui s'occupent de gérer les onglets...<br>
<br>
<br>
<h3>Méthodes de gestion des onglets</h3><br>
<br>
En fait, il n'y a que 2 méthodes dans cette catégorie :<br>
<br>
<ul>
<li><strong>creerOngletPageWeb()</strong> : je vous en ai parlé dans le constructeur, elle se charge de créer un QWidget-page ainsi qu'un QWebView à l'intérieur, et de retourner ce QWidget-page à l'appelant pour qu'il puisse créer le nouvel onglet.</li>
<li><strong>pageActuelle()</strong> : une méthode bien pratique que je vous ai donnée un peu plus tôt, qui permet à tout moment d'obtenir un pointeur vers le QWebView de l'onglet actuellement sélectionné.</li>
</ul><br>
<br>
Voici ces méthodes :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></td><td class="code"><div class="syntax"><pre><span class="n">QWidget</span> <span class="o">*</span><span class="n">FenPrincipale</span><span class="o">::</span><span class="n">creerOngletPageWeb</span><span class="p">(</span><span class="n">QString</span> <span class="n">url</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QWidget</span> <span class="o">*</span><span class="n">pageOnglet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QWidget</span><span class="p">;</span>
    <span class="n">QWebView</span> <span class="o">*</span><span class="n">pageWeb</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QWebView</span><span class="p">;</span>

    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">setContentsMargins</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">pageWeb</span><span class="p">);</span>
    <span class="n">pageOnglet</span><span class="o">-&gt;</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">url</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">pageWeb</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">(</span><span class="n">QUrl</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"html/page_blanche.html"</span><span class="p">)));</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">url</span><span class="p">.</span><span class="n">left</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="o">!=</span> <span class="s">"http://"</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">url</span> <span class="o">=</span> <span class="s">"http://"</span> <span class="o">+</span> <span class="n">url</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">pageWeb</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">(</span><span class="n">QUrl</span><span class="p">(</span><span class="n">url</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c">// Gestion des signaux envoyés par la page web</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">pageWeb</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">titleChanged</span><span class="p">(</span><span class="n">QString</span><span class="p">)),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">changementTitre</span><span class="p">(</span><span class="n">QString</span><span class="p">)));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">pageWeb</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">urlChanged</span><span class="p">(</span><span class="n">QUrl</span><span class="p">)),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">changementUrl</span><span class="p">(</span><span class="n">QUrl</span><span class="p">)));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">pageWeb</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">loadStarted</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">chargementDebut</span><span class="p">()));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">pageWeb</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">loadProgress</span><span class="p">(</span><span class="kt">int</span><span class="p">)),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">chargementEnCours</span><span class="p">(</span><span class="kt">int</span><span class="p">)));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">pageWeb</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">loadFinished</span><span class="p">(</span><span class="kt">bool</span><span class="p">)),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">chargementTermine</span><span class="p">(</span><span class="kt">bool</span><span class="p">)));</span>

    <span class="k">return</span> <span class="n">pageOnglet</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">QWebView</span> <span class="o">*</span><span class="n">FenPrincipale</span><span class="o">::</span><span class="n">pageActuelle</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">onglets</span><span class="o">-&gt;</span><span class="n">currentWidget</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">findChild</span><span class="o">&lt;</span><span class="n">QWebView</span> <span class="o">*&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Je ne commente pas pageActuelle(), je l'ai déjà fait auparavant.<br>
<br>
Pour ce qui est de creerOngletPageWeb(), elle crée comme prévu un QWidget et elle place un nouveau QWebView à l'intérieur. La page web charge l'URL indiquée en paramètre, et rajoute le "<span class="courrier">http://</span>" en préfixe si celui-ci a été oublié.<br>
Si aucune URL n'a été spécifiée, on charge une page blanche. J'ai pour l'occasion créé un fichier HTML vide, placé dans un sous-dossier "html" du programme.<br>
<br>
On connecte plusieurs signaux intéressants envoyés par le QWebView, qui, à mon avis, parlent d'eux-mêmes : "Le titre a changé", "L'URL a changé", "Début du chargement", "Chargement en cours", "Chargement terminé".<br>
<br>
Bref, rien de sorcier, mais ça fait encore tout plein de slots personnalisés à écrire tout ça ! <img src="./cpp_files/siffle.png" alt=":-°" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11368">Les slots personnalisés</h2>
		<div class="ss_part_texte">
		Bon, il y a de quoi faire. Reprenons notre FenPrincipale.h, que voici maintenant en version complète avec toutes les méthodes et tous les slots.<br>
<br>
<br>
<h3>FenPrincipale.h (version complète)</h3><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_FENPRINCIPALE</span>
<span class="cp">#define HEADER_FENPRINCIPALE</span>

<span class="cp">#include &lt;QtGui&gt;</span>
<span class="cp">#include &lt;QtWebKit&gt;</span>

<span class="k">class</span> <span class="nc">FenPrincipale</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QMainWindow</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">FenPrincipale</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">creerActions</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">creerMenus</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">creerBarresOutils</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">creerBarreEtat</span><span class="p">();</span>
<span class="ln-xtra">        <span class="n">QWidget</span> <span class="o">*</span><span class="n">creerOngletPageWeb</span><span class="p">(</span><span class="n">QString</span> <span class="n">url</span> <span class="o">=</span> <span class="s">""</span><span class="p">);</span></span>
<span class="ln-xtra">        <span class="n">QWebView</span> <span class="o">*</span><span class="n">pageActuelle</span><span class="p">();</span></span>

    <span class="k">private</span> <span class="nl">slots:</span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">precedente</span><span class="p">();</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">suivante</span><span class="p">();</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">accueil</span><span class="p">();</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">stop</span><span class="p">();</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">actualiser</span><span class="p">();</span></span>
<span class="ln-xtra"> </span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">aPropos</span><span class="p">();</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">nouvelOnglet</span><span class="p">();</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">fermerOnglet</span><span class="p">();</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">chargerPage</span><span class="p">();</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">changementOnglet</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">);</span></span>
<span class="ln-xtra"> </span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">changementTitre</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">titreComplet</span><span class="p">);</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">changementUrl</span><span class="p">(</span><span class="k">const</span> <span class="n">QUrl</span> <span class="o">&amp;</span> <span class="n">url</span><span class="p">);</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">chargementDebut</span><span class="p">();</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">chargementEnCours</span><span class="p">(</span><span class="kt">int</span> <span class="n">pourcentage</span><span class="p">);</span></span>
<span class="ln-xtra">        <span class="kt">void</span> <span class="n">chargementTermine</span><span class="p">(</span><span class="kt">bool</span> <span class="n">ok</span><span class="p">);</span></span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">QTabWidget</span> <span class="o">*</span><span class="n">onglets</span><span class="p">;</span>

        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionNouvelOnglet</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionFermerOnglet</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionQuitter</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionAPropos</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionAProposQt</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionPrecedente</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionSuivante</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionStop</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionActualiser</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionAccueil</span><span class="p">;</span>
        <span class="n">QAction</span> <span class="o">*</span><span class="n">actionGo</span><span class="p">;</span>

        <span class="n">QLineEdit</span> <span class="o">*</span><span class="n">champAdresse</span><span class="p">;</span>
        <span class="n">QProgressBar</span> <span class="o">*</span><span class="n">progression</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="italique">Les lignes ajoutées par rapport à la fois précédente ont été surlignées.</span><br>
<br>
Maintenant implémentons tout ça. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<br>
<h3>Implémentation des slots</h3><br>
<br>
<h4>Slots appelés par les actions de la barre d'outils</h4><br>
<br>
Commençons par les actions de la barre d'outils :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">precedente</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pageActuelle</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">suivante</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pageActuelle</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">forward</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">accueil</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pageActuelle</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">(</span><span class="n">QUrl</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"http://www.siteduzero.com"</span><span class="p">)));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">stop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pageActuelle</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">actualiser</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">pageActuelle</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">reload</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On utilise la (très) pratique fonction pageActuelle() pour obtenir un pointeur vers le QWebView que l'utilisateur est en train de regarder (histoire d'affecter la page web de l'onglet en cours, et pas les autres).<br>
<br>
Toutes ces méthodes, comme back() et forward(), sont des slots. On les appelle ici comme si c'étaient de simples méthodes.<br>
<br>
<div class="rmq question">Pourquoi ne pas avoir connecté directement les signaux envoyés par les QAction aux slots du QWebView ?</div><br>
<br>
On aurait pu s'il n'y avait pas eu d'onglets. Le problème justement ici, c'est qu'on gère plusieurs onglets différents.<br>
<br>
Par exemple, on ne pouvait pas connecter lors de sa création la QAction "actualiser" au QWebView... parce que le QWebView à actualiser dépend de l'onglet actuellement sélectionné !<br>
Voilà donc pourquoi on passe par un petit slot maison qui va d'abord chercher à savoir quel est le QWebView que l'on est en train de visualiser pour être sûr qu'on recharge la bonne page. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h4>Slots appelés par d'autres actions des menus</h4><br>
<br>
Voici les slots appelés par les actions des menus suivants :<br>
<br>
<ul>
<li>Nouvel onglet</li>
<li>Fermer l'onglet</li>
<li>A propos...</li>
</ul><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">aPropos</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QMessageBox</span><span class="o">::</span><span class="n">information</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">tr</span><span class="p">(</span><span class="s">"A propos..."</span><span class="p">),</span> <span class="n">tr</span><span class="p">(</span><span class="s">"zNavigo est un projet réalisé pour illustrer les tutoriels C++ du &lt;a href=</span><span class="se">\"</span><span class="s">http://www.siteduzero.com</span><span class="se">\"</span><span class="s">&gt;Site du Zéro&lt;/a&gt;.&lt;br /&gt;Les images de ce programme ont été créées par &lt;a href=</span><span class="se">\"</span><span class="s">http://www.everaldo.com</span><span class="se">\"</span><span class="s">&gt;Everaldo Coelho&lt;/a&gt;"</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">nouvelOnglet</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">indexNouvelOnglet</span> <span class="o">=</span> <span class="n">onglets</span><span class="o">-&gt;</span><span class="n">addTab</span><span class="p">(</span><span class="n">creerOngletPageWeb</span><span class="p">(),</span> <span class="n">tr</span><span class="p">(</span><span class="s">"(Nouvelle page)"</span><span class="p">));</span>
    <span class="n">onglets</span><span class="o">-&gt;</span><span class="n">setCurrentIndex</span><span class="p">(</span><span class="n">indexNouvelOnglet</span><span class="p">);</span>

    <span class="n">champAdresse</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
    <span class="n">champAdresse</span><span class="o">-&gt;</span><span class="n">setFocus</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">OtherFocusReason</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">fermerOnglet</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">// On ne doit pas fermer le dernier onglet, sinon le QTabWidget ne marche plus</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">onglets</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">onglets</span><span class="o">-&gt;</span><span class="n">removeTab</span><span class="p">(</span><span class="n">onglets</span><span class="o">-&gt;</span><span class="n">currentIndex</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">QMessageBox</span><span class="o">::</span><span class="n">critical</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">tr</span><span class="p">(</span><span class="s">"Erreur"</span><span class="p">),</span> <span class="n">tr</span><span class="p">(</span><span class="s">"Il faut au moins un onglet !"</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le slot aPropos() se contente d'afficher une boîte de dialogue.<br>
<br>
nouvelOnglet() rajoute un nouvel onglet à l'aide de la méthode addTab() du QTabWidget, comme on l'avait fait dans le constructeur. Pour que le nouvel onglet s'affiche immédiatement, on force son affichage avec setCurrentIndex() qui se sert de l'index (numéro) de l'onglet que l'on vient de créer.<br>
On vide la barre d'adresse et on lui donne le focus, c'est-à-dire que le curseur est directement placé dedans pour que l'utilisateur puisse écrire une URL.<br>
<br>
<div class="rmq information">L'action "Nouvel onglet" a comme raccourci "Ctrl+T", ce qui permet d'ouvrir un onglet à tout moment à l'aide du raccourci clavier correspondant.<br>
Vous pouvez aussi ajouter un bouton dans la barre d'outils pour ouvrir un nouvel onglet ou, encore mieux, rajouter un mini-bouton dans un des coins du QTabWidget. Regardez du côté de la méthode <a href="http://doc.trolltech.com/qtabwidget.html#setCornerWidget">setCornerWidget()</a>.</div><br>
<br>
fermerOnglet() supprime l'onglet actuellement sélectionné. Il vérifie au préalable que l'on n'est pas en train d'essayer de supprimer le dernier onglet, auquel cas le QTabWidget n'aurait plus lieu d'exister. Un système à onglets sans onglets, ça fait désordre. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<br>
<h4>Slots de chargement d'une page et de changement d'onglet</h4><br>
<br>
Ces slots sont appelés respectivement lorsqu'on demande à charger une page (appui sur la touche Entrée après avoir écrit une URL, ou clic sur le bouton tout à droite de la barre d'outils) et lorsqu'on change d'onglet.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">chargerPage</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QString</span> <span class="n">url</span> <span class="o">=</span> <span class="n">champAdresse</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">();</span>

    <span class="c">// On rajoute le "http://" s'il n'est pas déjà dans l'adresse</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">url</span><span class="p">.</span><span class="n">left</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="o">!=</span> <span class="s">"http://"</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s">"http://"</span> <span class="o">+</span> <span class="n">url</span><span class="p">;</span>
        <span class="n">champAdresse</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">pageActuelle</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">(</span><span class="n">QUrl</span><span class="p">(</span><span class="n">url</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">changementOnglet</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">changementTitre</span><span class="p">(</span><span class="n">pageActuelle</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">title</span><span class="p">());</span>
    <span class="n">changementUrl</span><span class="p">(</span><span class="n">pageActuelle</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">url</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On vérifie au préalable que l'utilisateur a mis le préfixe <span class="courrier">http://</span>, et si ce n'est pas le cas on le rajoute (sinon l'adresse n'est pas valide).<br>
<br>
Lorsque l'utilisateur change d'onglet, on met à jour 2 choses sur la fenêtre : le titre de la page, affiché tout en haut de la fenêtre et sur un onglet, et l'URL inscrite dans la barre d'adresse.<br>
changementTitre() et changementUrl() sont des slots personnalisés, que l'on se permet d'appeler comme n'importe quelle méthode. Ces slots sont aussi automatiquement appelés lorsque le QWebView envoie les signaux correspondants.<br>
<br>
Voyons voir comment implémenter ces slots...<br>
<br>
<br>
<h4>Slots appelés lorsqu'un signal est envoyé par le QWebView</h4><br>
<br>
Lorsque le QWebView s'active, il va envoyer des signaux. Ceux-ci sont connectés à des slots personnalisés de notre fenêtre. Les voici :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">changementTitre</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span> <span class="n">titreComplet</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QString</span> <span class="n">titreCourt</span> <span class="o">=</span> <span class="n">titreComplet</span><span class="p">;</span>

    <span class="c">// On tronque le titre pour éviter des onglets trop larges</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">titreComplet</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">40</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">titreCourt</span> <span class="o">=</span> <span class="n">titreComplet</span><span class="p">.</span><span class="n">left</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span> <span class="o">+</span> <span class="s">"..."</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">setWindowTitle</span><span class="p">(</span><span class="n">titreCourt</span> <span class="o">+</span> <span class="s">" - "</span> <span class="o">+</span> <span class="n">tr</span><span class="p">(</span><span class="s">"zNavigo"</span><span class="p">));</span>
    <span class="n">onglets</span><span class="o">-&gt;</span><span class="n">setTabText</span><span class="p">(</span><span class="n">onglets</span><span class="o">-&gt;</span><span class="n">currentIndex</span><span class="p">(),</span> <span class="n">titreCourt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">changementUrl</span><span class="p">(</span><span class="k">const</span> <span class="n">QUrl</span> <span class="o">&amp;</span> <span class="n">url</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">url</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="o">!=</span> <span class="n">tr</span><span class="p">(</span><span class="s">"html/page_blanche.html"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">champAdresse</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="n">url</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">chargementDebut</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">progression</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">chargementEnCours</span><span class="p">(</span><span class="kt">int</span> <span class="n">pourcentage</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">progression</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span><span class="n">pourcentage</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">chargementTermine</span><span class="p">(</span><span class="kt">bool</span> <span class="n">ok</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">progression</span><span class="o">-&gt;</span><span class="n">setVisible</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
    <span class="n">statusBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">showMessage</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Prêt"</span><span class="p">),</span> <span class="mi">2000</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ces slots ne sont pas très complexes. Ils mettent à jour la fenêtre (par exemple la barre de progression en bas) lorsqu'il y a lieu.<br>
<br>
Certains sont très utiles, comme changementUrl(). En effet, lorsque l'utilisateur clique sur un lien sur la page, l'URL change et il faut par conséquent mettre à jour le champ d'adresse.<br>
<br>
Vous noterez que je tronque le titre de la page à 40 caractères si celui-ci est trop long. Cela permet d'éviter d'avoir des onglets qui font 4km de large. <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11367">Conclusion et améliorations possibles</h2>
		<div class="ss_part_texte">
		Ouf ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Pas fâché d'en avoir terminé, mais le plus beau dans tout ça, c'est qu'on a un navigateur parfaitement fonctionnel !<br>
<br>
Je remets ici le screenshot par plaisir. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<div class="centre"><img src="./cpp_files/121737(1).png" alt="zNavigo"></div><br>
<br>
<div class="rmq attention">A l'heure actuelle, un bug dans QtWebKit dans la gestion des cookies ne permet pas de se connecter au Site du Zéro. C'est un peu dommage, mais comme le module est assez récent il devrait s'améliorer et être corrigé à l'avenir. Ne soyez donc pas surpris si vous ne pouvez pas vous connecter au site avec.</div><br>
<br>
<h3>Télécharger le code source et l'exécutable</h3><br>
<br>
Je vous propose de télécharger le code source ainsi que l'exécutable Windows du projet :<br>
<br>
<div class="centre"><a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/cpp/znavigo.zip"><span class="gros">Télécharger le code source et l'exécutable Windows (39 Ko)</span></a></div><br>
<br>
Pensez à ajouter les DLL nécessaires dans le même dossier que l'exécutable si vous voulez que celui-ci fonctionne. Cette fois, comme je vous l'avais dit, il faut 2 nouvelles DLL : QtWebKit4.dll et QtNetwork4.dll.<br>
<br>
<br>
<h3>Améliorations possibles</h3><br>
<br>
Améliorer le navigateur, c'est possible ?<br>
Certainement ! Il fonctionne, mais il est encore loin d'être parfait, et j'ai des tonnes d'idées pour l'améliorer. Bon ces idées sont repompées des navigateurs qui existent déjà, mais rien ne vous empêche d'en inventer de nouvelles super-révolutionnaires bien sûr. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
<ul>
<li><strong>Afficher l'historique dans un menu</strong> : il existe une classe <a href="http://doc.trolltech.com/qwebhistory.html">QWebHistory</a> qui permet de récupérer l'historique de toutes les pages visitées via un QWebView. Pour obtenir un objet de type QWebHistory du QWebView de l'onglet en cours, utilisez <span class="code2 cpp"><span class="n">pageActuelle</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">history</span><span class="p">()</span>
</span>.<br>
Renseignez-vous ensuite sur la doc de QWebHistory pour essayer de trouver comment récupérer la liste des pages visitées. Vous pourriez, par exemple, rajouter un menu "Historique" qui afficherait l'historique des pages vues sur l'onglet en cours.<br>
<br>
</li>
<li><strong>Gestion des adresses HTTPS</strong> : certains sites sont sécurisés (comme Paypal et Adsense par exemple). Ils utilisent des adresses https:// au lieu de http://. A cause de la vérification que l'on a faite, notre navigateur n'accepte que les adresses http://. Modifiez-le pour qu'il puisse gérer aussi bien les http:// que les https://.<br>
<br>
</li>
<li><strong>Zone de recherche Google</strong> : vous pourriez rajouter une zone de recherche google en haut à droite, qui appelle automatiquement Google avec les mots-clés sélectionnés.<br>
Je vous laisse vous renseigner sur le fonctionnement de Google. Vous pouvez imiter un autre navigateur comme Firefox par exemple, pour voir l'URL qu'il charge lorsqu'on fait une recherche Google.<br>
<br>
</li>
<li><strong>Recherche dans la page</strong> : rajoutez la possibilité de faire une recherche dans le texte de la page web affichée. Indice : QWebView dispose d'une méthode findText() !<br>
<br>
</li>
<li><strong>Disparition des onglets s'il ne reste plus qu'une seule page</strong> : voilà une amélioration délicate. Un QTabWidget sans onglets ne peut exister. Mais s'il ne reste qu'une seule page affichée, ça ne sert à rien d'utiliser un système à onglets.<br>
Essayer de gérer le cas où il ne reste plus qu'une seule page affichée, afin que le QTabWidget disparaisse (au moins jusqu'à ce qu'on demande à ouvrir un nouvel onglet).<br>
<br>
</li>
<li><strong>Fenêtre d'options</strong> : vous pourriez créer une nouvelle fenêtre d'options qui permet de définir la taille de police par défaut, l'URL de la page d'accueil, etc.<br>
Pour modifier la taille de la police par défaut, regardez du côté de <a href="http://doc.trolltech.com/qwebsettings.html">QWebSettings</a>.<br>
<br>
Pour enregistrer les options, vous pouvez passer par la classe QFile pour écrire dans un fichier. Mais j'ai mieux : utilisez la classe <a href="http://doc.trolltech.com/qsettings.html">QSettings</a> qui est spécialement faite pour enregistrer des options. En général, les options sont enregistrées dans un fichier (.ini, .conf...), mais on peut aussi enregistrer les options dans la base de registres sous Windows.<br>
Prenez bien le temps de lire la description de cette classe, c'est un peu long mais c'est vraiment très intéressant.<br>
<br>
</li>
<li><strong>Gestion des marque-pages (favoris)</strong> : voilà une fonctionnalité très répandue sur la plupart des navigateurs. L'utilisateur aime bien pouvoir enregistrer les adresses de ses sites web préférés.<br>
Là encore, pour l'enregistrement, je vous recommande chaudement de passer par un <a href="http://doc.trolltech.com/qsettings.html">QSettings</a>.<br>
<br>
Vous pourrez ensuite afficher la liste des sites favoris dans un menu, ou encore dans une nouvelle barre d'outils comme le fait Firefox.<br>
<br>
</li>
<li><strong>Impression d'une page web</strong> : pourquoi ne pas faire s'amuser avec l'imprimante ?<br>
Les QWebFrame contiennent une méthode <a href="http://doc.trolltech.com/qwebframe.html#print">print()</a> qui prend en paramètre une imprimante (QPrinter).<br>
<br>
Le QWebView est constitué d'une QWebPage qui est elle-même constituée d'un ou plusieurs QWebFrame (généralement un seul). Je vous laisse découvrir comment obtenir un pointeur vers le QWebFrame.<br>
Je vous laisse aussi découvrir comment manipuler les <a href="http://doc.trolltech.com/qprinter.html">QPrinter</a>, qui permettent de faire appel à l'imprimante. Et je vous invite aussi à jeter un oeil à la classe <a href="http://doc.trolltech.com/qprintdialog.html">QPrintDialog</a> qui permet d'afficher une boîte de dialogue générique d'impression.<br>
<br>
Ah, que de choses à découvrir !<br>
<br>
</li>
<li><strong>Sauvegarde de l'état de la fenêtre à la clôture</strong> : c'est peut-être une des fonctionnalités les plus appréciées des navigateurs actuels. Lorsque l'utilisateur veut quitter le programme, enregistrez (toujours avec QSettings) la liste des onglets ouverts avec leurs URL. Vous pourrez ainsi les réouvrir automatiquement lors du prochain chargement du programme.</li>
</ul><br>

		</div>
		<hr>
		
	<div id="chap_conclusion">
	Voilà, avec tout ce que je vous ai donné à faire, je crois que j'ai le temps d'aller à la nage à Hawaï siroter une Piña Colada dans un bar en bord de mer.<br>
<br>
<br>
Et peut-être même que j'ai le temps de revenir d'ailleurs. <img src="./cpp_files/heureux.png" alt=":D" class="smilies">
	</div>
	
	<hr>
	<h1 id="chap_11384">L'architecture MVC avec les widgets complexes</h1>
	<div id="chap_intro">
	Nous attaquons maintenant un des chapitres les plus intéressants de ce cours sur Qt, mais aussi un des plus difficiles.<br>
<br>
Dans ce chapitre, nous apprendrons à manipuler 3 widgets complexes :<br>
<ul>
<li><strong>QListView</strong> : une liste d'éléments à un seul niveau.</li>
<li><strong>QTreeView</strong> : une liste d'éléments à plusieurs niveaux, organisée en arbre.</li>
<li><strong>QTableView</strong> : un tableau.</li>
</ul><br>
On ne peut pas utiliser ces widgets sans un minimum de théorie. Et c'est justement cette partie théorique qui me fait dire que ce chapitre sera l'un des plus intéressants : nous allons découvrir l'architecture MVC, une façon de programmer (on parle de <span class="italique">design pattern</span>) très puissante qui va nous donner énormément de flexibilité.
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11383">Présentation de l'architecture MVC</h2>
		<div class="ss_part_texte">
		Avant de commencer à manipuler les 3 widgets complexes dont je vous ai parlé en introduction, il est indispensable que je vous présente l'architecture MVC.<br>
<br>
<div class="rmq question">Qu'est-ce que l'architecture MVC ? A quoi ça sert ? Quel rapport avec la création de GUI ?</div><br>
<br>
<strong>MVC est l'abréviation de Model-View-Controller</strong>, ce qui signifie en français : "Modèle-Vue-Contrôleur".<br>
<br>
...<br>
<br>
... ça ne vous avance pas trop, j'ai l'impression. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Il s'agit d'un <span class="italique">design pattern</span>, une technique de programmation. C'est une "façon de programmer et d'organiser son code" bien pensée. Vous n'êtes pas obligés de programmer de cette manière-là, mais si vous le faites votre code sera plus lisible, plus clair et plus souple.<br>
<br>
L'architecture MVC vous propose de séparer les éléments de votre programme en 3 parties :<br>
<br>
<ul>
<li><strong>Le modèle</strong> : c'est la partie qui contient les données. Le modèle peut par exemple contenir la liste des élèves d'une classe, avec leurs noms, prénoms, âges...</li>
<li><strong>La vue</strong> : c'est la partie qui s'occupe de l'affichage. Elle affiche ce que contient le modèle.<br>
Par exemple, la vue pourrait être un tableau. Ce tableau affichera la liste des élèves si c'est ce que contient le modèle.</li>
<li><strong>Le contrôleur</strong> : c'est la partie "réflexion" du programme. Lorsque l'utilisateur sélectionne 3 élèves dans le tableau et appuie sur la touche "Supprimer", le contrôleur est appelé et se charge de supprimer les 3 élèves du modèle.</li>
</ul><br>
<br>
C'est dur à imaginer au début. Mais rassurez-vous, vous allez comprendre au fur et à mesure de ce chapitre l'intérêt de séparer le code en 3 parties et le rôle de chacune de ces parties. Ce n'est pas grave si vous ne voyez pas de suite comment ces parties interagissent entre elles.<br>
<br>
Commençons par un schéma, visuel et simple à retenir, qui présente le rôle de chacune de ces parties :<br>
<br>
<div class="centre"><img src="./cpp_files/120010.png" alt="MVC"></div><br>
<br>
Comme on peut le voir sur ce schéma :<br>
<br>
<ul>
<li><strong>Le modèle</strong> est la partie qui contient les données (comment, on verra ça après). Les données sont généralement récupérées en lisant un fichier ou une base de données.</li>
<li><strong>La vue</strong> est juste la partie qui affiche le modèle, ce sera donc un widget dans notre cas.<br>
Si un élément est ajouté au modèle (par exemple un nouvel élève apparaît) la vue se met à jour automatiquement pour afficher le nouveau modèle.</li>
<li><strong>Le contrôleur</strong> est la partie la plus algorithmique, c'est-à-dire le cerveau de votre programme. S'il y a des calculs à faire, c'est là qu'ils sont faits.</li>
</ul><br>
<br>

		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11382">L'architecture simplifiée modèle/vue de Qt</h2>
		<div class="ss_part_texte">
		En fait (vous allez me tuer je le sens <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ), Qt n'utilise pas vraiment MVC mais une version simplifiée de ce système : l'architecture modèle/vue.<br>
<br>
<div class="rmq question">Et le contrôleur on en fait quoi ? Poubelle ? Notre programme ne réfléchit pas ?</div><br>
<br>
Si si, je vous rassure. En fait, le contrôleur est intégré à la vue avec Qt.<br>
Grâce à ça, les données sont toujours séparées de leur affichage, mais on diminue un peu la complexité du modèle MVC en évitant au programmeur d'avoir à gérer les 3 parties.<br>
<br>
On s'éloigne donc un petit peu de la théorie pure sur MVC ici, pour s'intéresser à la façon dont Qt utilise ce principe en pratique.<br>
Vous venez donc d'apprendre que Qt adaptait ce principe à sa manière, pour garder les bonnes idées principales sans pour autant vous obliger à "trop" découper votre code ce qui aurait pu être un peu trop complexe et répétitif à la longue.<br>
<br>
Nous n'allons donc plus parler ici que de modèle et de vue. Comment sont gérés chacun de ces éléments avec Qt ?<br>
Cette question... avec des classes, comme d'habitude ! <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<br>
<h3>Les classes gérant le modèle</h3><br>
<br>
Il y a plusieurs types de modèles différents. En effet : on ne stocke pas de la même manière une liste d'élèves qu'une liste de villes !<br>
<br>
Vous avez 2 possibilités :<br>
<br>
<ul>
<li>Soit vous créez <strong>votre propre classe de modèle</strong>. Il faut créer une classe héritant de <a href="http://doc.trolltech.com/qabstractitemmodel.html">QAbstractItemModel</a>. C'est la solution la plus flexible mais aussi la plus complexe, nous ne la verrons pas ici.</li>
<li>Soit vous utilisez une des <strong>classes génériques toutes prêtes</strong> offertes par Qt :<br>
<ul>
<li><strong>QStringListModel</strong> : une liste de chaînes de caractères, de type QString. Très simple, très basique. Ca peut suffire pour les cas les plus simples.</li>
<li><strong>QStandardItemModel</strong> : une liste d'éléments organisés sous forme d'arbre (chaque élément peut contenir des sous-éléments). Ce type de modèle est plus complexe que le précédent, car il gère plusieurs niveaux d'éléments. Avec QStringListModel, c'est un des modèles les plus utilisés.</li>
<li><strong>QDirModel</strong> : la liste des fichiers et dossiers stockés sur votre ordinateur. Ce modèle va analyser en arrière-plan votre disque dur, et restitue la liste de vos fichiers sous la forme d'un modèle prêt à l'emploi.</li>
<li><strong>QSqlQueryModel, QSqlTableModel et QSqlRelationalTableModel</strong> : données issues d'une base de données. On peut s'en servir pour accéder à une base de données (ceux qui ont déjà utilisé MySQL, Oracle ou un autre système du genre seront probablement intéressés).<br>
Je ne vais pas rentrer dans les détails de la connexion à une base de données dans ce chapitre, ce serait un peu hors-sujet.</li>
</ul></li>
</ul><br>
<br>
Toutes ces classes proposent donc des modèles prêts à l'emploi, qui héritent de QAbstractItemModel.<br>
Si aucune de ces classes ne vous convient, vous devrez créer votre propre classe en héritant de QAbstractItemModel.<br>
<br>
<br>
<div class="centre"><img src="./cpp_files/120012.png" alt="Héritage des modèles"></div><br>
<br>
<span class="italique">Notez que je n'ai pas représenté toutes les classes de modèles ici.</span><br>
<br>
<br>
<h3>Les classes gérant la vue</h3><br>
<br>
Pour afficher les données issues du modèle, il nous faut une vue. Avec Qt, la vue est un widget, puisqu'il s'agit d'un affichage dans une fenêtre.<br>
<br>
Tous les widgets de Qt ne sont pas bâtis autour de l'architecture modèle/vue, loin de là (et ça n'aurait pas d'intérêt pour les plus simples d'entre eux que nous avons vu jusqu'à présent).<br>
<br>
On compte 3 widgets adaptés pour la vue avec Qt :<br>
<br>
<ul>
<li><a href="http://doc.trolltech.com/qlistview.html">QListView</a> : une liste d'éléments.<br>
<br>
<div class="centre"><img src="./cpp_files/120024.png" alt="Liste"></div><br>
<br>
</li>
<li><a href="http://doc.trolltech.com/qtreeview.html">QTreeView</a> : un arbre d'éléments, où chaque élément peut avoir des éléments enfants.<br>
<br>
<div class="centre"><img src="./cpp_files/120023.png" alt="Arbre"></div><br>
<br>
</li>
<li><a href="http://doc.trolltech.com/qtableview.html">QTableView</a> : un tableau.<br>
<br>
<div class="centre"><img src="./cpp_files/120022.png" alt="Tableau"></div></li>
</ul><br>
Voilà donc les fameux "widgets" complexes que je vais vous présenter dans ce chapitre. Mais pour pouvoir les utiliser et les peupler de données, il faut d'abord créer un modèle !<br>
<br>
<br>
<h3>Appliquer un modèle à la vue</h3><br>
<br>
Lorsqu'on utilise l'architecture modèle/vue avec Qt, cela se passe toujours en 3 temps. Il faut :<br>
<br>
<ol class="liste_1">
<li>Créer le modèle</li>
<li>Créer la vue</li>
<li>Associer la vue et le modèle</li></ol><br>
La dernière étape est essentielle. Cela revient en quelque sorte à "connecter" notre modèle à notre vue. Si on ne donne pas de modèle à la vue, elle ne saura pas quoi afficher, donc elle n'affichera rien. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
La connexion se fait toujours avec la méthode <span class="code2 cpp"><span class="n">setModel</span><span class="p">()</span>
</span> de la vue :<br>
<br>
<div class="centre"><img src="./cpp_files/120033.png" alt="Modèle vue Qt"></div><br>
<br>
<div class="rmq information">Le contrôleur n'a pas été représenté sur ce schéma car, comme je vous l'ai dit, Qt utilise une architecture modèle/vue simplifiée et se charge de gérer la partie contrôleur pour vous.</div><br>
<br>
Voilà donc comment on connecte un modèle à une vue en pratique. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
L'avantage de ce système, c'est qu'il est flexible. On peut avoir 2 modèles et appliquer soit l'un soit l'autre à la vue en fonction des besoins. Un gros intérêt est que dès que l'on modifie le modèle, la vue affiche instantanément les nouveaux éléments !<br>
<br>
<h3>Plusieurs modèles ou plusieurs vues</h3><br>
<br>
On peut pousser le principe un peu plus loin. Essayons d'imaginer que l'on a plusieurs modèles ou plusieurs vues.<br>
<br>
<br>
<h4>Plusieurs modèles et une vue</h4><br>
<br>
Imaginons que l'on ait 2 modèles : un qui contient une liste d'élèves, un autre qui contient une liste de capitales avec leur pays. Notre vue peut afficher soit l'un, soit l'autre :<br>
<br>
<div class="centre"><img src="./cpp_files/120117.png" alt="Plusieurs modèles et une vue"></div><br>
<br>
Il faut bien sûr faire un choix : une vue ne peut afficher qu'un seul modèle à la fois !<br>
L'avantage, c'est qu'au besoin on peut changer le modèle affiché par la vue en cours d'exécution, en appelant juste la méthode <span class="code2 cpp"><span class="n">setModel</span><span class="p">()</span>
</span> !<br>
<br>
<br>
<h4>Un modèle pour plusieurs vues</h4><br>
<br>
Imaginons le cas inverse. On a un modèle, mais plusieurs vues. Cette fois, rien ne nous empêche d'appliquer ce modèle à 2 vues en même temps !<br>
<br>
<div class="centre"><img src="./cpp_files/120118.png" alt="Un modèle pour plusieurs vues"></div><br>
<br>
On peut ainsi visualiser le même modèle de 2 façons différentes (ici sous forme de tableau ou de liste dans mon schéma).<br>
Comme le même modèle est associé à 2 vues différentes, si le modèle change alors les 2 vues changent en même temps ! Par exemple, si je modifie l'âge d'un des élèves dans une cellule du tableau, l'autre vue (la liste) est automatiquement mise à jour sans avoir besoin d'écrire la moindre ligne de code !
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11381">Utilisation d'un modèle simple</h2>
		<div class="ss_part_texte">
		Pour découvrir en douceur l'architecture modèle/vue de Qt, je vais vous proposer d'utiliser un modèle tout fait : <a href="http://doc.trolltech.com/qdirmodel.html">QDirModel</a>.<br>
<br>
Sa particularité, c'est qu'il est très simple à utiliser. Il analyse votre disque dur et génère le modèle correspondant. Pour créer ce modèle, c'est tout bête :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QDirModel</span> <span class="o">*</span><span class="n">modele</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QDirModel</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On possède désormais un modèle qui représente notre disque. On va l'appliquer à une vue.<br>
<br>
<div class="rmq question">Mais quelle vue utiliser ? Une liste, un arbre, un tableau ? Les modèles sont-ils compatibles avec toutes les vues ?</div><br>
<br>
Oui, toutes les vues peuvent afficher n'importe quel modèle. C'est toujours compatible.<br>
<br>
Par contre, même si ça marche avec toutes les vues, vous allez vous rendre compte que certaines sont plus adaptées que d'autres en fonction du modèle que vous utilisez.<br>
Par exemple, pour un QDirModel, la vue la plus adaptée est sans aucun doute l'arbre (QTreeView). Nous essaierons toutefois toutes les vues avec ce modèle pour comparer le fonctionnement.<br>
<br>
<br>
<h3>Le modèle appliqué à un QTreeView</h3><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>

<span class="ln-xtra">    <span class="n">QDirModel</span> <span class="o">*</span><span class="n">modele</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QDirModel</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">QTreeView</span> <span class="o">*</span><span class="n">vue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTreeView</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">vue</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">modele</span><span class="p">);</span></span>

    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">vue</span><span class="p">);</span>

    <span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On crée le modèle, puis la vue, et on dit à la vue "<span class="italique">Utilise ce modèle pour savoir quoi afficher</span>" (ligne 9).<br>
<br>
Le résultat est le suivant :<br>
<br>
<div class="centre"><img src="./cpp_files/120030.png" alt="Vue du disque en arbre"></div><br>
<br>
Une vue en forme d'arbre affiche le modèle de notre disque. Chaque élément peut avoir des sous-éléments dans un QTreeView, essayez de naviguer dedans :<br>
<br>
<div class="centre"><img src="./cpp_files/120031.png" alt="Vue du disque en arbre"></div><br>
<br>
Voilà un bel exemple d'arbre en action ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<br>
<br>
<h3>Le modèle appliqué à un QListView</h3><br>
<br>
Maintenant, essayons de faire la même chose, mais avec une liste (QListView). On garde le même modèle, mais on l'applique à une vue différente :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>

    <span class="n">QDirModel</span> <span class="o">*</span><span class="n">modele</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QDirModel</span><span class="p">;</span>
<span class="ln-xtra">    <span class="n">QListView</span> <span class="o">*</span><span class="n">vue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QListView</span><span class="p">;</span></span>
    <span class="n">vue</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">modele</span><span class="p">);</span>

    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">vue</span><span class="p">);</span>

    <span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/120032.png" alt="Vue du disque en liste"></div><br>
<br>
Ce type de vue ne peut afficher qu'un seul niveau d'éléments à la fois. Cela explique pourquoi je vois uniquement la liste de mes disques... et pourquoi je ne peux pas afficher leur contenu !<br>
<br>
La vue affiche bêtement ce qu'elle est capable d'afficher, c'est-à-dire le premier niveau d'éléments.<br>
Voilà la preuve qu'un même modèle marche sur plusieurs vues différentes, mais que certaines vues sont plus adaptées que d'autres !<br>
<br>
Vous pouvez modifier la racine utilisée par la vue en vous inspirant du code suivant, que je ne détaillerai pas pour le moment :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">vue</span><span class="o">-&gt;</span><span class="n">setRootIndex</span><span class="p">(</span><span class="n">modele</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">(</span><span class="s">"C:"</span><span class="p">));</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/120124.png" alt="Vue en liste"></div><br>
<br>
<br>
<h3>Le modèle appliqué à un QTableView</h3><br>
<br>
Un tableau ne peut pas afficher plusieurs niveaux d'éléments (seul l'arbre QTreeView peut le faire). Par contre, il peut afficher plusieurs colonnes :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>

    <span class="n">QDirModel</span> <span class="o">*</span><span class="n">modele</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QDirModel</span><span class="p">;</span>
    <span class="n">QTableView</span> <span class="o">*</span><span class="n">vue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTableView</span><span class="p">;</span>
    <span class="n">vue</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">modele</span><span class="p">);</span>

    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">vue</span><span class="p">);</span>

    <span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="centre"><img src="./cpp_files/120125.png" alt="Vue du disque en tableau"></div><br>
<br>
Comme précédemment, on peut appeler setRootIndex() pour modifier la racine des éléments affichés par la vue.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11380">Utilisation de modèles personnalisables</h2>
		<div class="ss_part_texte">
		Le modèle QDirModel que nous venons de voir était très simple à utiliser. Rien à paramétrer, rien à configurer, il analyse automatiquement votre disque dur pour construire son contenu.<br>
<br>
C'était une bonne introduction pour découvrir les vues avec un modèle simple. Cependant, dans la plupart des cas, vous voudrez utiliser vos propres données, votre propre modèle. C'est ce que nous allons voir ici, à travers 2 nouveaux modèles :<br>
<br>
<ul>
<li><a href="http://doc.trolltech.com/qstringlistmodel.html">QStringListModel</a> : une liste simple d'éléments de type texte, à un seul niveau.</li>
<li><a href="http://doc.trolltech.com/qstandarditemmodel.html">QStandardItemModel</a> : une liste plus complexe à plusieurs niveaux et plusieurs colonnes, qui peut convenir dans la plupart des cas.</li>
</ul><br>
<br>
Pour les cas simples, nous utiliserons donc QStringListModel, mais nous découvrirons aussi QStandardItemModel qui nous donne plus de flexibilité.<br>
<br>
<br>
<h3>QStringListModel : une liste de chaînes de caractères QString</h3><br>
<br>
Ce modèle, très simple, vous permet de gérer une liste de chaînes de caractères. Par exemple, si l'utilisateur doit choisir son pays parmi une liste :<br>
<br>
<span class="courrier">France<br>
Espagne<br>
Italie<br>
Portugal<br>
Suisse</span><br>
<br>
Pour construire ce modèle, il faut procéder en 2 temps :<br>
<br>
<ul>
<li>Construire un objet de type QStringList, qui contiendra la liste des chaînes.</li>
<li>Créer un objet de type QStringListModel et envoyer à son constructeur le QStringList que vous venez de créer pour l'initialiser.</li>
</ul><br>
<br>
QStringList surcharge l'opérateur "&lt;&lt;" pour vous permettre d'ajouter des éléments à l'intérieur simplement.<br>
Un exemple de code sera sûrement plus parlant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>

<span class="ln-xtra">    <span class="n">QStringList</span> <span class="n">listePays</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">listePays</span> <span class="o">&lt;&lt;</span> <span class="s">"France"</span> <span class="o">&lt;&lt;</span> <span class="s">"Espagne"</span> <span class="o">&lt;&lt;</span> <span class="s">"Italie"</span> <span class="o">&lt;&lt;</span> <span class="s">"Portugal"</span> <span class="o">&lt;&lt;</span> <span class="s">"Suisse"</span><span class="p">;</span></span>
<span class="ln-xtra">    <span class="n">QStringListModel</span> <span class="o">*</span><span class="n">modele</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QStringListModel</span><span class="p">(</span><span class="n">listePays</span><span class="p">);</span></span>

    <span class="n">QListView</span> <span class="o">*</span><span class="n">vue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QListView</span><span class="p">;</span>
    <span class="n">vue</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">modele</span><span class="p">);</span>

    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">vue</span><span class="p">);</span>

    <span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notre vue affiche maintenant la liste des pays qui se trouvent dans le modèle :<br>
<br>
<div class="centre"><img src="./cpp_files/120184.png" alt="Modèle StringList"></div><br>
<br>
La surcharge de l'opérateur "&lt;&lt;" est très pratique comme vous pouvez le voir. Sachez toutefois qu'il est aussi possible d'utiliser la méthode append() :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">listePays</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"Belgique"</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si, au cours de l'exécution du programme, un pays est ajouté, supprimé ou modifié, la vue (la liste) affichera automatiquement les modifications. Nous testerons cela en pratique un peu plus loin dans le chapitre.<br>
<br>
<br>
<h3>QStandardItemModel : une liste à plusieurs niveaux et plusieurs colonnes</h3><br>
<br>
Ce type de modèle est beaucoup plus complet (et donc complexe <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ) que le précédent. Il permet de créer tous les types de modèles possibles et imaginables.<br>
<br>
Pour bien visualiser les différents types de modèles que l'on peut concevoir avec un QStandardItemModel, voici un super schéma offert par la doc de Qt :<br>
<br>
<div class="centre"><img src="./cpp_files/120191.png" alt="Différents modèles possibles"></div><br>
<br>
<ul>
<li><strong>List Model</strong> : c'est un modèle avec une seule colonne et pas de sous-éléments. C'est le modèle utilisé par QStringList, mais QStandardItemModel peut aussi le faire (qui peut le plus peut le moins !).<br>
Ce type de modèle est en général adapté à un QListView.</li>
<li><strong>Table Model</strong> : les éléments sont organisés avec plusieurs lignes et colonnes.<br>
Ce type de modèle est en général adapté à un QTableView.</li>
<li><strong>Tree Model</strong> : les éléments ont des sous-éléments, ils sont organisés en plusieurs niveaux. Ce n'est pas représenté sur le schéma ci-dessus, mais rien n'interdit de mettre <a href="http://uploads.siteduzero.com/files/120001_121000/120205.png">plusieurs colonnes dans un modèle en arbre</a> aussi !<br>
Ce type de modèle est en général adapté à un QTreeView.</li>
</ul><br>
<br>
<br>
<h4>Gérer plusieurs lignes et colonnes</h4><br>
<br>
Pour construire un QStandardItemModel, on doit indiquer en paramètres le nombre de lignes et de colonnes qu'il doit gérer. Des lignes et des colonnes supplémentaires peuvent toujours être ajoutées par la suite au besoin.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>

<span class="ln-xtra">    <span class="n">QStandardItemModel</span> <span class="o">*</span><span class="n">modele</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QStandardItemModel</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span></span>

    <span class="n">QTableView</span> <span class="o">*</span><span class="n">vue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTableView</span><span class="p">;</span>
    <span class="n">vue</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">modele</span><span class="p">);</span>

    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">vue</span><span class="p">);</span>

    <span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<div class="rmq information">Si on ne demande qu'une seule colonne, cela reviendra à créer un modèle de type "List Model".</div><br>
<br>
Ici, un modèle à 5 lignes et 3 colonnes sera créé. Les éléments sont vides au départ, mais on a déjà un tableau :<br>
<br>
<div class="centre"><img src="./cpp_files/120193.png" alt="Table view avec QStandardItemModel"></div><br>
<br>
<div class="rmq information">On peut aussi appeler le constructeur par défaut (sans paramètres) si on ne connaît pas du tout la taille du tableau à l'avance.<br>
Il faudra appeler appendRow() et appendColumn() pour ajouter respectivement une nouvelle ligne ou une nouvelle colonne.</div><br>
<br>
Chaque élément est représenté par un objet de type QStandardItem.<br>
Pour définir un élément, on utilise la méthode setItem() du modèle. Donnez-lui respectivement le numéro de ligne, de colonne, et un QStandardItem à afficher. Attention : la numérotation commence à 0.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>

    <span class="n">QStandardItemModel</span> <span class="o">*</span><span class="n">modele</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QStandardItemModel</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="ln-xtra">    <span class="n">modele</span><span class="o">-&gt;</span><span class="n">setItem</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">new</span> <span class="n">QStandardItem</span><span class="p">(</span><span class="s">"Zéro !"</span><span class="p">));</span></span>

    <span class="n">QTableView</span> <span class="o">*</span><span class="n">vue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTableView</span><span class="p">;</span>
    <span class="n">vue</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">modele</span><span class="p">);</span>

    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">vue</span><span class="p">);</span>

    <span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ici, je crée un nouvel élément contenant le texte "Zéro !" à la 4ème ligne, 2nde colonne :<br>
<br>
<div class="centre"><img src="./cpp_files/120201.png" alt="Table view avec QStandardItemModel"></div><br>
<br>
Voilà comment on peut peupler le modèle d'éléments. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h4>Ajouter des éléments enfants</h4><br>
<br>
Essayons maintenant d'ajouter des éléments enfants.<br>
Pour pouvoir voir les éléments enfants, on va devoir changer de vue et passer par un QTreeView.<br>
<br>
Il faut procéder dans l'ordre :<br>
<br>
<ol class="liste_1">
<li>Créer un élément (par exemple "item"), de type QStandardItem. <span class="italique">Ligne 9</span></li>
<li>Ajouter cet élément <strong>au modèle</strong> avec appendRow(). <span class="italique">Ligne 10</span></li>
<li>Ajouter un sous-élément <strong>à "item"</strong> avec appendRow(). <span class="italique">Ligne 11</span></li></ol><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>

    <span class="n">QStandardItemModel</span> <span class="o">*</span><span class="n">modele</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QStandardItemModel</span><span class="p">;</span>

<span class="ln-xtra">    <span class="n">QStandardItem</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QStandardItem</span><span class="p">(</span><span class="s">"John Deuf"</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">modele</span><span class="o">-&gt;</span><span class="n">appendRow</span><span class="p">(</span><span class="n">item</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">item</span><span class="o">-&gt;</span><span class="n">appendRow</span><span class="p">(</span><span class="k">new</span> <span class="n">QStandardItem</span><span class="p">(</span><span class="s">"17 ans"</span><span class="p">));</span></span>

    <span class="n">QTreeView</span> <span class="o">*</span><span class="n">vue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTreeView</span><span class="p">;</span>
    <span class="n">vue</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">modele</span><span class="p">);</span>

    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">vue</span><span class="p">);</span>

    <span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat, on a créé un élément "John Deuf" qui contient un élément enfant "17 ans" :<br>
<br>
<div class="centre"><img src="./cpp_files/120206.png" alt="Arbre"></div><br>
<br>
Entraînez-vous à créer plusieurs éléments et des sous-éléments enfants, ce n'est pas compliqué si on est bien organisé mais il faut pratiquer. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="rmq information">Pour supprimer l'en-tête (marqué "1" et inutile), vous pouvez appeler : <span class="code2 cpp"><span class="n">vue</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hide</span><span class="p">();</span>
</span></div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11379">Gestion des sélections</h2>
		<div class="ss_part_texte">
		Nous avons découvert comment associer un modèle à une vue, et comment manipuler plusieurs modèles : QDirModel, QStringListModel et QStandardItemModel.<br>
<br>
Il nous reste à voir comment on peut récupérer le ou les éléments sélectionnés dans la vue, pour savoir quel est le choix de l'utilisateur.<br>
<br>
Nous entrons dans une partie vraiment complexe où de nombreuses classes se mêlent les unes aux autres. L'architecture modèle/vue de Qt est extrêmement flexible (on peut faire ce qu'on veut avec), mais en contrepartie il est beaucoup plus délicat de s'en servir car il y a plusieurs étapes à suivre dans un ordre précis.<br>
<br>
Par conséquent, et afin d'éviter de faire un chapitre beaucoup trop long et surtout trop complexe, j'ai volontairement décidé de limiter mes exemples ici aux <strong>sélections d'un QListView</strong>. Je vous laisserai le soin d'adapter ces exemples aux autres vues, en sachant que c'est relativement similaire à chaque fois (les principes sont les mêmes).<br>
<br>
Nous allons rajouter un bouton "Afficher la sélection" à notre fenêtre. Elle va ressembler à ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/120354.png" alt="Gestion de la sélection"></div><br>
<br>
Lorsqu'on cliquera sur le bouton, il ouvrira une boîte de dialogue (QMessageBox) qui affichera le nom de l'élément sélectionné.<br>
<br>
Nous allons apprendre à gérer 2 cas :<br>
<ul>
<li>Lorsqu'on ne peut sélectionner qu'<strong>un seul élément</strong> à la fois.</li>
<li>Lorsqu'on peut sélectionner <strong>plusieurs éléments</strong> à la fois.</li>
</ul><br>
<br>
<h3>Une sélection unique</h3><br>
<br>
Nous allons devoir créer une connexion entre un signal et un slot pour que le clic sur le bouton fonctionne.<br>
<br>
Modifions donc pour commencer le .h de la fenêtre :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_FENPRINCIPALE</span>
<span class="cp">#define HEADER_FENPRINCIPALE</span>

<span class="cp">#include &lt;QtGui&gt;</span>

<span class="k">class</span> <span class="nc">FenPrincipale</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">FenPrincipale</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">QListView</span> <span class="o">*</span><span class="n">vue</span><span class="p">;</span>
        <span class="n">QStringListModel</span> <span class="o">*</span><span class="n">modele</span><span class="p">;</span>
        <span class="n">QPushButton</span> <span class="o">*</span><span class="n">bouton</span><span class="p">;</span>

    <span class="k">private</span> <span class="nl">slots:</span>
        <span class="kt">void</span> <span class="n">clicSelection</span><span class="p">();</span>
<span class="p">};</span>


<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
J'ai rajouté la macro Q_OBJECT, mis quelques éléments de la fenêtre en attributs (pour pouvoir y accéder dans le slot), et ajouté le slot clicSelection() qui sera appelé après un clic sur le bouton.<br>
<br>
Maintenant retour au .cpp, où je fais la connexion et où j'écris le contenu du slot :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenPrincipale.h"</span>

<span class="n">FenPrincipale</span><span class="o">::</span><span class="n">FenPrincipale</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>

    <span class="n">QStringList</span> <span class="n">listePays</span><span class="p">;</span>
    <span class="n">listePays</span> <span class="o">&lt;&lt;</span> <span class="s">"France"</span> <span class="o">&lt;&lt;</span> <span class="s">"Espagne"</span> <span class="o">&lt;&lt;</span> <span class="s">"Italie"</span> <span class="o">&lt;&lt;</span> <span class="s">"Portugal"</span> <span class="o">&lt;&lt;</span> <span class="s">"Suisse"</span><span class="p">;</span>
    <span class="n">modele</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QStringListModel</span><span class="p">(</span><span class="n">listePays</span><span class="p">);</span>

    <span class="n">vue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QListView</span> <span class="p">;</span>
    <span class="n">vue</span><span class="o">-&gt;</span><span class="n">setModel</span><span class="p">(</span><span class="n">modele</span><span class="p">);</span>

    <span class="n">bouton</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s">"Afficher la sélection"</span><span class="p">);</span>

    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">vue</span><span class="p">);</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">bouton</span><span class="p">);</span>

    <span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>

<span class="ln-xtra">    <span class="n">connect</span><span class="p">(</span><span class="n">bouton</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">clicSelection</span><span class="p">()));</span></span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">clicSelection</span><span class="p">()</span>
<span class="p">{</span>
<span class="ln-xtra">    <span class="n">QItemSelectionModel</span> <span class="o">*</span><span class="n">selection</span> <span class="o">=</span> <span class="n">vue</span><span class="o">-&gt;</span><span class="n">selectionModel</span><span class="p">();</span></span>
<span class="ln-xtra">    <span class="n">QModelIndex</span> <span class="n">indexElementSelectionne</span> <span class="o">=</span> <span class="n">selection</span><span class="o">-&gt;</span><span class="n">currentIndex</span><span class="p">();</span></span>
<span class="ln-xtra">    <span class="n">QVariant</span> <span class="n">elementSelectionne</span> <span class="o">=</span> <span class="n">modele</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(</span><span class="n">indexElementSelectionne</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">DisplayRole</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">QMessageBox</span><span class="o">::</span><span class="n">information</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Elément sélectionné"</span><span class="p">,</span> <span class="n">elementSelectionne</span><span class="p">.</span><span class="n">toString</span><span class="p">());</span></span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Analysons le contenu du slot, qui contient les nouveautés (lignes 26 à 29). Voici ce que nous faisons ligne par ligne :<br>
<br>
<ol class="liste_1">
<li>On récupère un objet QItemSelectionModel qui contient des informations sur ce qui est sélectionné sur la vue. C'est la vue qui nous donne un pointeur vers cet objet grâce à vue-&gt;selectionModel().</li>
<li>On appelle la méthode currentIndex() de l'objet qui contient des informations sur la sélection. Cela renvoie un index, c'est-à-dire en gros le numéro de l'élément sélectionné sur la vue.</li>
<li>Maintenant qu'on connaît le numéro de l'élément sélectionné, on veut retrouver son texte. On appelle la méthode data() du modèle, et on lui donne l'index qu'on a récupéré (c'est-à-dire le numéro de l'élément sélectionné). On récupère le résultat dans un QVariant, qui est une classe qui peut aussi bien stocker des int que des chaînes de caractères.</li>
<li>On n'a plus qu'à afficher l'élément sélectionné récupéré. Pour extraire la chaîne du QVariant, on appelle toString().</li></ol><br>
<br>
Ouf ! Ce n'est pas simple je le reconnais, il y a plusieurs étapes.<br>
<br>
D'abord on récupère l'objet qui contient des informations sur les éléments sélectionnés sur la vue.<br>
Ensuite on demande à cet objet quel est l'indice (numéro) de l'élément actuellement sélectionné.<br>
On peut alors récupérer le texte contenu dans le modèle à cet indice.<br>
On affiche ce texte avec la méthode toString() de l'objet de type QVariant.<br>
<br>
Désormais, un clic sur le bouton vous indique quel élément est sélectionné :<br>
<br>
<div class="centre"><img src="./cpp_files/120355.png" alt="Elément sélectionné"></div><br>
<br>
<h3>Une sélection multiple</h3><br>
<br>
Par défaut, on ne peut sélectionner qu'un seul élément à la fois sur une liste. Pour changer ce comportement et autoriser la sélection multiple, rajoutez ceci dans le constructeur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">vue</span><span class="o">-&gt;</span><span class="n">setSelectionMode</span><span class="p">(</span><span class="n">QAbstractItemView</span><span class="o">::</span><span class="n">ExtendedSelection</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
D'autres modes de sélection sont disponibles, mais je vous laisse aller voir la doc de QAbstractItemView pour en savoir plus. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
Avec ce mode, on peut sélectionner n'importe quels éléments. On peut utiliser la touche Shift du clavier pour faire une sélection continue, ou Ctrl pour une sélection discontinue (avec des trous).<br>
<br>
Voici un exemple de sélection continue, désormais possible :<br>
<br>
<div class="centre"><img src="./cpp_files/120360.png" alt="Sélection multiple"></div><br>
<br>
Pour récupérer la liste des éléments sélectionnés, c'est un peu plus compliqué ici parce qu'il y en a plusieurs. On ne peut plus utiliser la méthode currentIndex(), il va falloir utiliser selectedIndexes().<br>
<br>
Je vous donne le nouveau code du slot, et on l'analyse ensuite ensemble. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">FenPrincipale</span><span class="o">::</span><span class="n">clicSelection</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QItemSelectionModel</span> <span class="o">*</span><span class="n">selection</span> <span class="o">=</span> <span class="n">vue</span><span class="o">-&gt;</span><span class="n">selectionModel</span><span class="p">();</span>
    <span class="n">QModelIndexList</span> <span class="n">listeSelections</span> <span class="o">=</span> <span class="n">selection</span><span class="o">-&gt;</span><span class="n">selectedIndexes</span><span class="p">();</span>
    <span class="n">QString</span> <span class="n">elementsSelectionnes</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">listeSelections</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">QVariant</span> <span class="n">elementSelectionne</span> <span class="o">=</span> <span class="n">modele</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(</span><span class="n">listeSelections</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Qt</span><span class="o">::</span><span class="n">DisplayRole</span><span class="p">);</span>
        <span class="n">elementsSelectionnes</span> <span class="o">+=</span> <span class="n">elementSelectionne</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="o">+</span> <span class="s">"&lt;br /&gt;"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">QMessageBox</span><span class="o">::</span><span class="n">information</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"Eléments sélectionnés"</span><span class="p">,</span> <span class="n">elementsSelectionnes</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est un peu plus gros bien sûr. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<ol class="liste_1">
<li>La première ligne ne change pas : on récupère l'objet qui contient des informations sur les éléments sélectionnés.</li>
<li>Ensuite, au lieu d'appeler currentIndex(), on demande selectedIndexes() parce qu'il peut y en avoir plusieurs.</li>
<li>On crée un QString vide dans lequel on stockera la liste des pays pour l'afficher ensuite dans la boîte de dialogue.</li>
<li>Vient ensuite une boucle. En effet, l'objet listeSelections récupéré est un tableau (en fait c'est un objet de type QList, mais on peut faire comme si c'était un tableau). On parcourt donc ce tableau ligne par ligne, et on récupère à chaque fois le texte correspondant.</li>
<li>On stocke ce texte à la suite du QString, qui se remplit au fur et à mesure.</li>
<li>Une fois la boucle terminée, on affiche le QString qui contient la liste des pays sélectionnés. Et voilà le travail !</li></ol><br>
<br>
<div class="centre"><img src="./cpp_files/120362.png" alt="Sélection multiple et affichage"></div><br>
<br>
Ici, je me contente d'afficher la liste des éléments sélectionnés dans une boîte de dialogue, mais en pratique vous ferez sûrement quelque chose de beaucoup plus intelligent avec ça. <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	En ce qui me concerne je vous ai donné la base pour démarrer, mais je serais bien incapable de vous montrer toutes les utilisations possibles de l'architecture modèle/vue de Qt. Nous ne pouvons pas tout voir, ce serait bien trop vaste.<br>
<br>
A vous de voir, maintenant que vous commencez à connaître le principe, de quels outils vous avez besoin. Entraînez-vous avec les autres vues (arbre, tableau) et essayez d'en faire une utilisation plus poussée. Vous pouvez refaire un TP précédent et y intégrer un widget basé sur l'architecture modèle/vue pour vous entraîner.<br>
Ce sera probablement difficile, mais bon, il faut bien des chapitres difficiles dans le cours sinon on va croire que c'est un site pour les débutants ici. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
N'oubliez pas de lire la doc surtout, elle contient toutes les informations dont vous avez besoin !<br>
<br>
<div class="rmq information">Au fait, il existe des classes "simplifiées" des vues que l'on vient de voir. Ces classes s'appellent QListWidget, QTreeWidget, et QTableWidget. Elles ne nécessitent pas la création d'un modèle à part, mais sont du coup moins flexibles.<br>
Utilisez-les lorsque vous avez une application très simple et que vous ne voulez pas manipuler l'architecture modèle/vue.</div>
	</div>
	
	<hr>
	<h1 id="chap_11396">Communiquer en réseau avec son programme</h1>
	<div id="chap_intro">
	Ah... Le réseau...<br>
C'est un peu le fantasme de la plupart des nouveaux programmeurs : arriver à faire en sorte que son programme puisse communiquer à travers le réseau, que ce soit en local (entre 2 PC chez vous) ou sur internet.<br>
<br>
Pourtant, c'est un sujet complexe parce que... il ne suffit pas seulement de savoir programmer en C++, il faut aussi beaucoup de connaissances théoriques sur le fonctionnement du réseau. Les couches d'abstraction, TCP/IP, UDP, Sockets... peut-être avez-vous entendu ces mots-là mais sauriez-vous vraiment les définir ?<br>
<br>
<div class="rmq information">En fait, pour que les choses soient claires, il faut savoir que je n'avais pas prévu de rédiger ce chapitre à la base. Tout d'abord parce que ce n'est plus vraiment du GUI (création de fenêtre), donc c'est un peu hors-sujet vis à vis des chapitres précédents. D'autre part, comme je vous l'ai dit, c'est un sujet complexe et il faudrait un tutoriel entier sur plusieurs chapitres pour bien vous expliquer la théorie sur les réseaux... chose que je ne peux pas faire sauf si vous me payez la greffe d'un troisième bras. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"></div><br>
<br>
Cependant, vous êtes nombreux à m'avoir demandé de faire un chapitre traitant du réseau. Face à la demande, j'ai finalement accepté de faire une <span class="italique">exception</span>.<br>
Exceptionnellement donc, nous n'allons pas vraiment parler que de GUI, nous allons aussi parler de réseau.<br>
<br>
Seulement voilà, comme je vous l'ai dit, pour bien faire il faudrait un tutoriel complet que je n'ai ni le temps ni les moyens de rédiger. Du coup, j'ai finalement trouvé un compromis : on va faire une sorte de <strong>chapitre-TP</strong>. Il y aura de la théorie et de la pratique à la fois.<br>
Nous ne verrons pas tout, nous nous concentrerons sur l'architecture réseau la plus classique (client / serveur). Cela vous donnera les bases pour comprendre un peu comment ça marche, et puis après il ne tiendra plus qu'à vous d'adapter ces exemples à vos programmes.<br>
<br>
<div class="rmq question">C'est un chapitre-TP ? Mais alors, quel est le sujet du TP ?</div><br>
<br>
Le sujet du "chapitre-TP" sera la réalisation d'un <strong>logiciel de Chat en réseau</strong>. Vous pourrez aussi bien communiquer en réseau local (entre vos PC à la maison) qu'entre plusieurs PC via internet.<br>
<br>
<br>
On y va ? <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
On va devoir commencer par un petit cours théorique, <span class="souligne">absolument indispensable</span> pour comprendre la suite de ce chapitre !
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11395">Comment communique-t-on en réseau ?</h2>
		<div class="ss_part_texte">
		Voilà une bien bonne question !<br>
A laquelle... je pourrais vous répondre par une encyclopédie en 12 volumes, et encore je n'aurais pas tout expliqué. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Nous allons donc voir les notions théoriques de base sur le réseau de façon <span class="italique">light </span>et ludique. A partir de là, nous pourrons voir comment on utilise ces connaissances en pratique avec Qt pour réaliser un Chat en réseau.<br>
<br>
<br>
Pour nos exemples, nous allons imaginer 2 utilisateurs. Appelons-les... par exemple Patrice et Ludovic.<br>
Patrice et Ludovic ont chacun un ordinateur et ils voudraient communiquer entre eux.<br>
<br>
<div class="centre"><img src="./cpp_files/122352.png" alt="Communication en réseau"></div><br>
<br>
Comment faire ? Comment communiquer, sachant qu'il y a des centaines, des milliers d'autres ordinateurs sur le réseau ?<br>
Et comment peuvent-ils se faire comprendre entre eux, faut-il qu'ils parlent le même langage ?<br>
<br>
Pour que vous puissiez avoir 2 programmes qui communiquent entre eux via le réseau, il vous faut 3 choses :<br>
<br>
<ol class="liste_1">
<li>Connaître l'<strong>adresse IP</strong> identifiant l'autre ordinateur.</li>
<li>Utiliser un <strong>port</strong> libre et ouvert.</li>
<li>Utiliser le même <strong>protocole</strong> de transmission des données.</li></ol><br>
Si tous ces éléments sont réunis, c'est bon. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Voyons voir comment faire pour avoir tout ça...<br>
<br>
<br>
<h3>1/ L'adresse IP : identification des machines sur le réseau</h3><br>
<br>
La première chose qui devrait vous préoccuper, c'est de savoir comment les ordinateurs font pour se reconnaître entre eux sur un réseau.<br>
Comment fait Patrice pour envoyer un message à Ludovic et seulement à lui ?<br>
<br>
<br>
<h4>Qu'est-ce qu'une IP ?</h4><br>
<br>
Il faut savoir que chaque ordinateur est identifié sur le réseau par ce qu'on appelle une adresse IP. C'est une série de nombres, par exemple :<br>
<br>
<div class="centre"><span class="tgros">85.215.27.118</span></div><br>
<br>
Cette adresse représente un ordinateur. Lorsque vous connaissez l'adresse IP de la personne avec qui vous voulez communiquer, vous savez déjà au moins vers qui vous vous dirigez. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Mais voilà, le problème, parce que sinon ça serait trop simple, c'est qu'un ordinateur peut avoir non pas une mais <span class="italique">plusieurs </span>IP.<br>
En général aujourd'hui, on peut considérer qu'un ordinateur a en moyenne 3 IP :<br>
<br>
<ul>
<li><strong>Une IP interne</strong> : c'est le localhost, aussi appelé loopback. C'est une IP qui sert pour communiquer à soi-même. Pas très utile vu qu'on n'emprunte pas le réseau du coup, mais ça nous sera très pratique pour les tests vous verrez.<br>
<span class="italique">Exemple : 127.0.0.1</span></li>
<li><strong>Une IP du réseau local</strong> : si vous avez plusieurs ordinateurs en réseau chez vous, ils peuvent communiquer entre eux sans passer par internet grâce à ces IP. Elles sont propres au réseau de votre maison.<br>
<span class="italique">Exemple : 192.168.0.3</span></li>
<li><strong>Une IP internet</strong> : c'est l'IP utilisée pour communiquer avec tous les autres ordinateurs de la planète qui sont connectés à internet. <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<span class="italique">Exemple : 86.79.12.105</span></li>
</ul><br>
Patrice et Ludovic ont donc plusieurs IP, selon le niveau auquel on se place :<br>
<br>
<div class="centre"><img src="./cpp_files/122355.png" alt="Adresses IP"></div><br>
<br>
Si je vous raconte ça, c'est parce que nous aurons besoin d'utiliser l'une ou l'autre de ces IP en fonction de la distance qui sépare Patrice de Ludovic.<br>
<br>
Si Patrice et Ludovic sont dans une même maison, reliés par un réseau local, nous utiliserons une IP du réseau local (en rouge sur mon schéma).<br>
Si Patrice et Ludovic sont reliés par internet, nous utiliserons leur adresse internet (en vert).<br>
<br>
Pour ce qui est de l'adresse localhost, elle peut nous servir pour "simuler" le fonctionnement du réseau. Si Patrice envoie un message à 127.0.0.1, celui-ci va immédiatement lui revenir. Cela peut nous être donc utile si on ne veut pas déranger notre ami Ludovic toutes les 5 minutes pour tester la dernière version de notre programme. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
<br>
<h4>Retrouver son adresse IP</h4><br>
<br>
<div class="rmq question">Comment je connais mon IP ? Ou plutôt mes IP ?<br>
Et comment je sais laquelle correspond au réseau local, et laquelle correspond à celle d'internet ?</div><br>
<br>
La méthode dépend de l'IP que vous recherchez.<br>
<br>
<ul>
<li><strong>Pour l'IP interne</strong> : pas besoin d'aller chercher plus loin, à coup sûr c'est 127.0.0.1 (ou son équivalent texte "localhost").<br>
<br>
</li>
<li><strong>Pour l'IP locale</strong> : pour la retrouver tout dépend de votre système d'exploitation.<br>
<br>
<ul>
<li><strong>Sous Windows</strong>, ouvrez une invite de commande (par exemple celui que vous utilisez avec Qt pour compiler) et tapez <span class="code2 console">ipconfig</span><br>
Il est possible que vous ayez plusieurs réponses, en fonction des moyens de connexion disponibles (câble ethernet, wifi...). En tout cas, l'une des IP que l'on vous donne est la bonne (à la ligne "Adresse IPv4").<br>
<br>
</li>
<li><strong>Sous Linux ou Mac OS</strong>, c'est le même principe dans une console mais pas la même commande : <span class="code2 console">ifconfig</span><br>
L'adresse est en général de la forme "192.168.XXX.XXX", mais cela peut être parfois différent.<br>
</li>
</ul><br>
</li>
<li><strong>Pour l'IP internet</strong> : le plus simple est probablement d'aller sur un site web qui est capable de vous la donner, comme par exemple <a href="http://www.whatismyip.com/">www.whatismyip.com</a> !</li>
</ul><br>
<br>
Maintenant que vous connaissez l'adresse IP de votre interlocuteur, alors vous allez pouvoir communiquer avec lui... ou presque. Le problème, c'est qu'il y a plusieurs portes d'entrée sur chaque ordinateur. C'est ce qu'on appelle <strong>les ports</strong>.<br>
<br>
<br>
<h3>2/ Les ports : différents moyens d'accès à un même ordinateur</h3><br>
<br>
Un ordinateur connecté à un réseau reçoit beaucoup de messages en même temps.<br>
Par exemple, si vous allez sur un site web en même temps que vous récupérez vos mails, des données différentes vont vous arriver simultanément.<br>
<br>
Pour ne pas confondre ces données et organiser tout ce bazar, on a inventé le concept de port.<br>
Un port est un nombre compris entre 1 et 65 536. Voici quelques ports célèbres :<br>
<br>
<ul>
<li><strong>21</strong> : utilisé par les logiciels FTP pour envoyer et recevoir des fichiers.</li>
<li><strong>80</strong> : utilisé pour naviguer sur le web par votre navigateur (par exemple Firefox, ou plutôt zNavigo <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).</li>
<li><strong>110</strong> : utilisé pour la réception de mails.</li>
</ul><br>
Imaginez que ces ports sont autant de portes d'entrée à votre ordinateur :<br>
<br>
<div class="centre"><img src="./cpp_files/122367.png" alt="Ports"></div><br>
<br>
Si on veut faire un programme qui communique avec Ludovic, il va falloir choisir un port qui ne soit pas déjà utilisé par un autre programme.<br>
<br>
La plupart des ports dont les numéros sont inférieurs à 1 024 sont déjà réservés par votre machine. Nous ferons donc en sorte de préférence dans notre programme d'utiliser un numéro de port compris entre 1 024 et 65 536.<br>
<br>
<div class="rmq attention">Pour éviter que n'importe quel programme puisse communiquer sur le réseau et accéder à une machine sans autorisation, on a inventé les <strong>firewalls </strong>(pare-feu). Leur rôle est de bloquer tous les ports d'une machine, et d'en autoriser seulement certains qui sont considérés comme "sûrs" (comme les ports 21, 80, 110...).<br>
Il faudra bien vérifier la configuration de votre firewall si vous en avez un (il y en a un activé sous Windows par défaut depuis Windows XP SP2), car celui-ci pourrait tout simplement bloquer les communications de notre programme !</div><br>
<br>
<br>
<h3>3/ Le protocole : transmettre des données avec le même "langage"</h3><br>
<br>
Bon, nous savons désormais 2 choses :<br>
<ul>
<li>Chaque ordinateur est identifié par une <strong>adresse IP</strong>.</li>
<li>On peut accéder à une IP via des milliers de <strong>ports </strong>différents.</li>
</ul><br>
L'IP, vous savez la retrouver. Le port, il faudra en choisir un qui soit libre (nous verrons comment en pratique plus tard).<br>
Vous êtes donc maintenant en mesure d'établir une connexion avec un ordinateur distant, car vous avez les 2 éléments nécessaires : une IP et un port.<br>
<br>
Il reste maintenant à envoyer des données à l'ordinateur distant pour que les 2 programmes puissent "parler" entre eux. Et ça mine de rien, ce n'est pas simple. En effet, il faut que les 2 programmes parlent la même langue, le même <strong>protocole</strong>. Il faut qu'ils communiquent de la même façon.<br>
<br>
<div class="rmq information"><strong>Définition</strong> : un protocole est un ensemble de règles qui permettent à 2 ordinateurs de communiquer. Il faut impérativement que les 2 ordinateurs parlent le même protocole pour que l'échange de données puisse fonctionner.</div><br>
<br>
<span class="italique">Exemple de la vie courante</span> : vous dites "Bonjour" lorsque vous commencez à parler à quelqu'un, et "Au revoir" lorsque vous partez. Eh bien pour les ordinateurs c'est pareil !<br>
<br>
<br>
<h4>Les différents niveaux des protocoles de communication</h4><br>
<br>
Il existe des centaines de protocoles de communication différents. Ceux-ci peuvent être très simples comme très complexes, selon si vous discutez à un "haut niveau" ou à un "bas niveau". On peut donc les ranger dans 2 catégories :<br>
<br>
<ul>
<li><strong>Protocoles de haut niveau</strong> : par exemple le protocole FTP, qui utilise le port 21 pour envoyer et recevoir des fichiers, est un système d'échange de données de haut niveau. Son mode de fonctionnement est déjà écrit et documenté. Il est donc assez facile à utiliser, mais on ne peut pas lui rajouter des possibilités.</li>
<li><strong>Protocoles de bas niveau</strong> : par exemple le protocole TCP. Il est utilisé par les programmes pour lesquels aucun protocole de haut niveau ne convient. Vous devrez manipuler les données qui transitent sur le réseau octet par octet. C'est plus difficile, mais vous pouvez faire tout ce que vous voulez.</li>
</ul><br>
<br>
<div class="centre"><img src="./cpp_files/122376.png" alt="Protocoles"></div><br>
<br>
<div class="rmq information">Pour ceux qui veulent aller plus loin, renseignez-vous sur le <a href="http://fr.wikipedia.org/wiki/Mod%C3%A8le_OSI">modèle OSI</a>. C'est un modèle d'organisation des données sur le réseau qui vous explique les différents niveaux de communication (on parle de "couches").<br>
Ici j'ai beaucoup (énormément) simplifié le schéma, mais sinon on ne s'en sortait pas en un seul chapitre. <img src="./cpp_files/langue.png" alt=":p" class="smilies"></div><br>
<br>
Les protocoles de haut niveau utilisent des ports bien connus et déjà définis.<br>
Les protocoles de bas niveau peuvent emprunter n'importe quel port, sont beaucoup plus flexibles, mais le problème c'est qu'il faut définir tout leur fonctionnement.<br>
<br>
<div class="rmq information">En fait, tous les protocoles de haut niveau utilisent des protocoles de bas niveau pour leur fonctionnement interne.<br>
Les protocoles de bas niveau sont "la base", on les utilise pour construire des protocoles de plus haut niveau.</div><br>
<br>
Nous n'allons pas créer un logiciel de mails, ni un client FTP. Nous allons inventer notre propre technique de discussion pour notre programme, notre propre protocole basé sur un protocole de bas niveau... <span class="souligne">Nous allons donc travailler à bas niveau</span>.<br>
<br>
Mauvaise nouvelle : ça va être plus difficile. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Bonne nouvelle : ça va être intéressant techniquement.<br>
<br>
<br>
<h4>Les protocoles de bas niveau TCP et UDP</h4><br>
<br>
Il faut savoir que les données s'envoient sur le réseau par petits bouts. On parle de <strong>paquets</strong>, qui peuvent être chacun découpés en sous-paquets :<br>
<br>
<div class="centre"><img src="./cpp_files/122388.png" alt="Paquets sur le réseau"></div><br>
<br>
Par exemple, imaginons que Patrice envoie à Ludovic le message : "<span class="italique">Salut Ludovic, comment ça va ?</span>". Le message ne sera peut-être pas envoyé d'un seul coup, il sera probablement découpé en plus petits paquets. Par exemple, on peut imaginer qu'il y aura 4 sous-paquets (j'invente, car le découpage sera peut-être différent) :<br>
<br>
<ol class="liste_1">
<li><strong>Sous-paquet 1</strong> : "<span class="italique">Salut Ludov</span>"</li>
<li><strong>Sous-paquet 2</strong> : "<span class="italique">ic, co</span>"</li>
<li><strong>Sous-paquet 3</strong> : "<span class="italique">mment ça v</span>"</li>
<li><strong>Sous-paquet 4</strong> : "<span class="italique">a ?</span>"</li></ol><br>
<br>
<div class="rmq information"><span class="italique">Ce n'est pas vous qui gérez le découpage en sous-paquets</span>, c'est le protocole de bas niveau qui s'en occupe. Il est donc impossible de connaître à l'avance la taille des paquets ou même leur nombre.<br>
Il est cependant important de savoir que ça fonctionne comme ça pour la suite.</div><br>
<br>
On peut envoyer ces paquets de plusieurs façons différentes, tout dépend du protocole de bas niveau que l'on utilise :<br>
<br>
<ul>
<li><strong>Protocole TCP</strong> : le plus classique. Il nécessite d'établir une connexion au préalable entre les ordinateurs. Il y a un système de contrôle qui permet de demander à renvoyer un paquet au cas où l'un d'entre eux se serait perdu sur le réseau (ça arrive <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ). Par conséquent, avec TCP on est sûr que tous les paquets arrivent à destination, et dans le bon ordre.<br>
En contrepartie de ces contrôles sécurisants, l'envoi des données est plus lent qu'avec UDP.</li>
<li><strong>Protocole UDP</strong> : il ne nécessite pas d'établir de connexion au préalable et il est très rapide. En revanche, il n'y a aucun contrôle ce qui fait qu'un paquet de données peut très bien se perdre sans qu'on en soit informé, ou les paquets peuvent arriver dans le désordre !</li>
</ul><br>
Il va falloir choisir l'un de ces 2 protocoles.<br>
Pour moi, le choix est tout fait : <span class="souligne">ce sera TCP</span>. En effet, nous allons réaliser un Chat et nous ne pouvons pas nous permettre que des messages (ou des bouts de messages) n'arrivent pas à destination, sinon la conversation pourrait devenir difficile à suivre et on risquerait de recevoir des messages comme : "<span class="italique">Salut Ludovmment ça va ?</span>" <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"><br>
<br>
<div class="rmq question">Mais alors, du coup tout le monde utilise TCP pour être sûr que le paquet arrive à destination non ? Qui peut bien être assez fou pour utiliser UDP ?</div><br>
<br>
Certaines applications complexes qui utilisent beaucoup le réseau peuvent être amenées à utiliser UDP. Je pense par exemple aux jeux vidéo.<br>
<br>
Prenez un jeu de stratégie comme Starcraft, ou un FPS comme Quake par exemple : il peut y avoir des dizaines d'unités qui se déplacent sur la carte en même temps. Il faut en continu envoyer la nouvelle position des unités qui se déplacent à tous les ordinateurs de la partie. On a donc besoin d'un protocole rapide comme UDP, et si un paquet se perd ce n'est pas grave : vu que la position des joueurs est rafraîchie plusieurs fois par seconde, ça ne se verra pas.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11394">L'architecture du projet de Chat avec Qt</h2>
		<div class="ss_part_texte">
		Nous venons de voir quelques petites notions théoriques sur le réseau, mais il va encore falloir préciser quelle est l'architecture réseau de notre programme de Chat.<br>
<br>
<div class="rmq question">Une architecture réseau ? Qu'est-ce que c'est que ça ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"></div><br>
<br>
Jusqu'ici, nous avons supposé un cas très simple : il n'y avait que 2 ordinateurs (celui de Patrice et celui de Ludovic). Le problème, c'est que notre programme de Chat doit permettre à plus de 2 personnes de discuter en même temps. Imaginons qu'une troisième personne appelée Vincent arrive sur le Chat. Vous le placez où sur le schéma ? Au milieu entre les 2 autres compères ? <img src="./cpp_files/rire.gif" alt=":lol:" class="smilies"><br>
<br>
<br>
<h3>Les architectures réseau</h3><br>
<br>
Pour faire simple, on a 2 architectures possibles pour résoudre le problème :<br>
<br>
<ul>
<li><strong>Une architecture client / serveur</strong> : c'est l'architecture réseau la plus classique et la plus simple à mettre en oeuvre. Les machines des utilisateurs (Patrice, Ludovic, Vincent...) sont appelées des "<span class="italique">clients</span>". En plus de ces machines, on utilise un autre ordinateur (appelé "<span class="italique">serveur</span>") qui va se charger de répartir les communications entre les clients.<br>
<br>
<div class="centre"><img src="./cpp_files/122572.png" alt="Architecture client serveur"></div><br>
</li>
<li><strong>Une architecture Peer-To-Peer (P2P)</strong> : ce mode plus complexe est dit décentralisé, car il n'y a pas de serveur. Chaque client peut communiquer directement avec un autre client. C'est plus direct, ça évite d'encombrer un serveur, mais c'est plus délicat à mettre en place.<br>
<br>
<div class="centre"><img src="./cpp_files/122573.png" alt="Architecture Peer to Peer"></div></li>
</ul><br>
<br>
Nous, nous allons utiliser une <strong>architecture client / serveur</strong>, la plus simple.<br>
<br>
Il va en fait falloir faire non pas un mais deux projets :<br>
<ul>
<li><strong>Un projet "serveur"</strong> : pour créer le programme qui va répartir les messages entre les clients.</li>
<li><strong>Un projet "client"</strong> : pour chaque client qui participera au Chat.</li>
</ul><br>
<br>
<div class="rmq information">Vous n'êtes pas obligés d'utiliser une machine spécialement pour faire serveur. L'une des machines des clients peut aussi faire office de serveur. Il suffira de faire tourner un programme "serveur" en même temps qu'un programme "client", c'est tout à fait possible.<br>
<br>
En pratique donc, une seule personne lancera le programme "serveur" et le programme "client" à la fois, et toutes les autres lanceront uniquement le programme "client".</div><br>
<br>
<br>
<h3>Principe de fonctionnement du Chat</h3><br>
<br>
Le principe du Chat est simple : une personne écrit un message, et tout le monde reçoit ce message sur son écran.<br>
<br>
Les choses se passent en 2 temps :<br>
<br>
<ul>
<li>Un client envoie un message au serveur.<br>
<br>
<div class="centre"><img src="./cpp_files/123289.png" alt="Envoi du message"></div><br>
</li>
<li>Le serveur renvoie ce message à tous les clients pour qu'il s'affiche sur leur fenêtre.<br>
<br>
<div class="centre"><img src="./cpp_files/123290.png" alt="Réception du message"></div></li>
</ul><br>
<br>
<div class="rmq question">Pourquoi le serveur renverrait-il le message à Vincent, vu que c'est lui qui l'a envoyé ?</div><br>
<br>
On peut gérer les choses de plusieurs manières. On pourrait s'arranger pour que le serveur n'envoie pas le message à Vincent pour éviter un trafic réseau inutile, mais cela compliquerait un petit peu le programme.<br>
Il est plus simple de faire en sorte que le serveur renvoie le message à tout le monde sans distinction. Vincent verra donc son message s'afficher sur son écran de discussion uniquement quand le serveur l'aura reçu et le lui aura renvoyé. Cela permet de vérifier en outre que la communication sur le réseau fonctionne correctement.<br>
<br>
<br>
<h3>Structure des paquets</h3><br>
<br>
Les messages qui circuleront sur le réseau seront placés dans des <strong>paquets</strong>. C'est à nous de définir la structure des paquets que l'on veut envoyer.<br>
<br>
Par exemple, quand Vincent va envoyer un message, un paquet va être créé avant d'être envoyé sur le réseau. Voici la structure de paquet que je propose pour notre programme de Chat :<br>
<br>
<div class="centre"><img src="./cpp_files/123273.png" alt="Structure du paquet"></div><br>
<br>
Le paquet est constitué de 2 parties :<br>
<br>
<ul>
<li><strong>tailleMessage </strong>: un nombre entier qui sert à indiquer la taille du message qui suit. Cela permet au serveur de connaître la taille totale du message envoyé, pour qu'il puisse savoir quand il a reçu le message en entier.<br>
<div class="rmq information">Ce nombre ne sera pas de type <span class="italique">int</span> comme on aurait pu s'y attendre mais de type <span class="italique">quint16</span>. En effet, le type <span class="italique">int </span>peut avoir une taille différente selon les machines sur le réseau (un int peut prendre 16 bits de mémoire sur une machine, et 8 bits sur une autre).<br>
Pour résoudre le problème, on utilise un type spécial de Qt, le <span class="italique">quint16</span>, qui correspond à un nombre entier prenant 16 bits de mémoire quelle que soit la machine (quand je vous avais dit que c'était bas niveau <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ).<br>
<span class="italique">quint16</span> signifie : "Qt Unsigned Int 16", soit "Entier non signé codé sur 16 bits".</div></li>
<li><strong>message </strong>: c'est le message envoyé par le client. Ce message sera de type QString (ça c'est simple, vous connaissez !).</li>
</ul><br>
<br>
<div class="rmq question">Pourquoi envoie-t-on la taille du message en premier ? On ne pourrait pas envoyer le message tout court ?</div><br>
<br>
Il faut savoir que le protocole TCP va découper le paquet en sous-paquets avant de l'envoyer sur le réseau. Il n'enverra peut-être pas tout d'un coup. Par exemple, notre paquet pourrait être découpé comme ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/123106.png" alt="Séparation en sous-paquets"></div><br>
<br>
On n'a aucun contrôle sur la taille de ces sous-paquets, et il n'y a aucun moyen de savoir à l'avance comment ça va être découpé.<br>
Le problème, c'est que le serveur va recevoir ces paquets petit à petit, et non pas tout d'un coup. Il ne <span class="italique">peut pas savoir</span> quand la totalité du message a été reçue.<br>
<br>
<div class="rmq information">Le protocole TCP ne permet pas de contrôler la taille des sous-paquets ni leur nombre, par contre il s'arrange pour que les paquets arrivent à destination dans le bon ordre (ce qui est pratique, parce que sinon ça aurait été encore plus compliqué à remettre en ordre <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ).<br>
Pour information, le protocole UDP, qui est plus rapide, ne fait aucun contrôle sur l'ordre des paquets envoyés !</div><br>
<br>
Bon, il faut qu'on arrive à savoir <span class="italique">quand </span>on a reçu le message en entier, et donc quand ce n'est plus la peine d'attendre de nouveaux sous-paquets.<br>
Pour résoudre ce problème, on envoie la taille du message dans un premier temps. Lorsque la taille du message a été reçue, on va attendre que le message soit au complet. On se base sur tailleMessage pour savoir combien d'octets il nous reste à recevoir.<br>
<br>
Lorsqu'on a récupéré tous les octets restants du paquet, on sait que le paquet est au complet, et cela veut dire qu'on a donc reçu le message entier.<br>
<br>
<br>
Bon, c'est pas simple, mais je vous avais prévenu hein ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11393">Réalisation du serveur</h2>
		<div class="ss_part_texte">
		Comme je vous l'ai dit, nous allons devoir réaliser 2 projets :<br>
<br>
<ul>
<li>Un projet "client"</li>
<li>Un projet "serveur"</li>
</ul><br>
Nous commençons par le serveur.<br>
<br>
<h3>Création du projet</h3><br>
<br>
Créez un nouveau projet constitué de 3 fichiers :<br>
<br>
<ul>
<li>main.cpp</li>
<li>FenServeur.cpp</li>
<li>FenServeur.h</li>
</ul><br>
<br>
Faites un <span class="code2 console">qmake&nbsp;-project</span> pour générer le .pro.<br>
Editez ensuite ce fichier .pro pour demander à Qt de rajouter la gestion du réseau :<br>
<br>
<span class="code">Code : Autre - <a href="#" class="select_code">Sélectionner</a></span><div class="code2"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><div class="syntax"><pre>######################################################################
#&nbsp;Automatically&nbsp;generated&nbsp;by&nbsp;qmake&nbsp;(2.01a)&nbsp;mer.&nbsp;25.&nbsp;juin&nbsp;14:54:55&nbsp;2008
######################################################################

TEMPLATE&nbsp;=&nbsp;app
<span class="ln-xtra">QT&nbsp;+=&nbsp;network</span>
TARGET&nbsp;=&nbsp;
DEPENDPATH&nbsp;+=&nbsp;.
INCLUDEPATH&nbsp;+=&nbsp;.

#&nbsp;Input
HEADERS&nbsp;+=&nbsp;FenServeur.h
SOURCES&nbsp;+=&nbsp;FenServeur.cpp&nbsp;main.cpp</pre></div></td></tr></tbody></table></div><br>
<br>
Avec <span class="code2">QT&nbsp;+=&nbsp;network</span>, Qt sait que le projet va utiliser le réseau et peut préparer un makefile approprié.<br>
<br>
<br>
<h3>La fenêtre du serveur</h3><br>
<br>
Le serveur est une application qui tourne en tâche de fond. Normalement, rien ne nous oblige à créer une fenêtre pour ce projet, mais on va quand même en faire une pour que l'utilisateur puisse arrêter le serveur en fermant la fenêtre.<br>
<br>
Notre fenêtre sera toute simple, elle affichera le texte "<span class="italique">Le serveur a été lancé sur le port XXXX</span>" et un bouton "<span class="italique">Quitter</span>".<br>
<br>
<div class="centre"><img src="./cpp_files/123111.png" alt="Fenêtre du serveur"></div><br>
<br>
Construire la fenêtre sera donc très simple, la vraie difficulté sera de faire toute la gestion du réseau derrière.<br>
<br>
<h3>main.cpp</h3><br>
<br>
Les main sont toujours très simples et classiques avec Qt :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include "FenServeur.h"</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">FenServeur</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h3>FenServeur.h</h3><br>
<br>
Voici maintenant le header de la fenêtre du serveur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_FENSERVEUR</span>
<span class="cp">#define HEADER_FENSERVEUR</span>

<span class="cp">#include &lt;QtGui&gt;</span>
<span class="cp">#include &lt;QtNetwork&gt;</span>


<span class="k">class</span> <span class="nc">FenServeur</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">FenServeur</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">envoyerATous</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>

    <span class="k">private</span> <span class="nl">slots:</span>
        <span class="kt">void</span> <span class="n">nouvelleConnexion</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">donneesRecues</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">deconnexionClient</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">QLabel</span> <span class="o">*</span><span class="n">etatServeur</span><span class="p">;</span>
        <span class="n">QPushButton</span> <span class="o">*</span><span class="n">boutonQuitter</span><span class="p">;</span>

        <span class="n">QTcpServer</span> <span class="o">*</span><span class="n">serveur</span><span class="p">;</span>
        <span class="n">QList</span><span class="o">&lt;</span><span class="n">QTcpSocket</span> <span class="o">*&gt;</span> <span class="n">clients</span><span class="p">;</span>
        <span class="n">quint16</span> <span class="n">tailleMessage</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notre fenêtre hérite de QWidget, ce qui nous permet de créer une fenêtre simple. Elle est constituée comme vous le voyez d'un QLabel et d'un QPushButton comme prévu.<br>
<br>
En plus de ça, j'ai rajouté d'autres attributs spécifiques à la gestion du réseau :<br>
<br>
<ul>
<li><span class="code2 cpp"><span class="n">QTcpServer</span> <span class="o">*</span><span class="n">serveur</span>
</span> : c'est l'objet qui représente le serveur sur le réseau.</li>
<li><span class="code2 cpp"><span class="n">QList</span><span class="o">&lt;</span><span class="n">QTcpSocket</span> <span class="o">*&gt;</span> <span class="n">clients</span>
</span> : c'est un tableau qui contient la liste des clients connectés. On aurait pu utiliser un tableau classique, mais on va passer par une QList, un tableau de taille dynamique. En effet, on ne connaît pas à l'avance le nombre de clients qui se connecteront. Chaque QTcpSocket de ce tableau représentera une connexion à un client.<br>
<div class="rmq information">Je ne vais pas m'étendre dans ce chapitre sur les <a href="http://doc.trolltech.com/qlist.html">QList</a>. Considérez juste que c'est une classe qui permet de gérer un tableau de taille variable, ce qui est très pratique quand on ne sait pas comme ici le nombre de clients qui vont se connecter.<br>
Pour plus d'infos pour apprendre à vous en servir, lisez la doc. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div></li>
<li><span class="code2 cpp"><span class="n">quint16</span> <span class="n">tailleMessage</span>
</span> : ce quint16 sera utilisé dans le code pour se "souvenir" de la taille du message que le serveur est en train de recevoir. Nous en avons déjà parlé et nous en reparlerons plus loin.</li>
</ul><br>
<br>
Voilà, à part ces attributs, on note que la classe est constituée de plusieurs méthodes (dont des slots) :<br>
<br>
<ul>
<li><strong>Le constructeur</strong> : il initialise les widgets sur la fenêtre et initialise aussi le serveur (QTcpServer) pour qu'il démarre.</li>
<li><strong>envoyerATous()</strong> : une méthode à nous qui se charge d'envoyer à tous les clients connectés le message passé en paramètre.</li>
<li><strong>Slot nouvelleConnexion()</strong> : appelé lorsqu'un nouveau client se connecte.</li>
<li><strong>Slot donneesRecues()</strong> : appelé lorsque le serveur reçoit des données. Attention, c'est là que c'est délicat, car ce slot est appelé à chaque sous-paquet reçu. Il faudra "attendre" d'avoir reçu le nombre d'octets indiqués dans tailleMessage avant de pouvoir considérer qu'on a reçu le message entier.</li>
<li><strong>Slot deconnexionClient()</strong> : appelé lorsqu'un client se déconnecte.</li>
</ul><br>
<br>
Implémentons ces méthodes en coeur, dans la joie et la bonne humeur ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<h3>FenServeur.cpp</h3><br>
<br>
<h4>Le constructeur</h4><br>
<br>
Le constructeur se charge de placer les widgets sur la fenêtre et de faire démarrer le serveur via le QTcpServer :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">FenServeur</span><span class="o">::</span><span class="n">FenServeur</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Création et disposition des widgets de la fenêtre</span>
    <span class="n">etatServeur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLabel</span><span class="p">;</span>
    <span class="n">boutonQuitter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Quitter"</span><span class="p">));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">boutonQuitter</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>

    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">etatServeur</span><span class="p">);</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">boutonQuitter</span><span class="p">);</span>
    <span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>

    <span class="n">setWindowTitle</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"ZeroChat - Serveur"</span><span class="p">));</span>

    <span class="c1">// Gestion du serveur</span>
    <span class="n">serveur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTcpServer</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serveur</span><span class="o">-&gt;</span><span class="n">listen</span><span class="p">(</span><span class="n">QHostAddress</span><span class="o">::</span><span class="n">Any</span><span class="p">,</span> <span class="mi">50885</span><span class="p">))</span> <span class="c1">// Démarrage du serveur sur toutes les IP disponibles et sur le port 50585</span>
    <span class="p">{</span>
        <span class="c1">// Si le serveur n'a pas été démarré correctement</span>
        <span class="n">etatServeur</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Le serveur n'a pas pu être démarré. Raison :&lt;br /&gt;"</span><span class="p">)</span> <span class="o">+</span> <span class="n">serveur</span><span class="o">-&gt;</span><span class="n">errorString</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// Si le serveur a été démarré correctement</span>
        <span class="n">etatServeur</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Le serveur a été démarré sur le port &lt;strong&gt;"</span><span class="p">)</span> <span class="o">+</span> <span class="n">QString</span><span class="o">::</span><span class="n">number</span><span class="p">(</span><span class="n">serveur</span><span class="o">-&gt;</span><span class="n">serverPort</span><span class="p">())</span> <span class="o">+</span> <span class="n">tr</span><span class="p">(</span><span class="s">"&lt;/strong&gt;.&lt;br /&gt;Des clients peuvent maintenant se connecter."</span><span class="p">));</span>
        <span class="n">connect</span><span class="p">(</span><span class="n">serveur</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">newConnection</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">nouvelleConnexion</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="n">tailleMessage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
J'ai fait en sorte de bien commenter mes codes sources pour vous aider du mieux possible à comprendre ce qui se passe.<br>
Vous voyez bien une première étape où on dispose les widgets sur la fenêtre (classique, rien de nouveau) et une seconde étape où on démarre le serveur.<br>
<br>
Quelques précisions sur la seconde étape, la plus intéressante pour ce chapitre. On crée un nouvel objet de type QTcpServer dans un premier temps (ligne 16). On lui passe en paramètre this, un pointeur vers la fenêtre, pour faire en sorte que la fenêtre soit le parent du QTcpServer. Cela permet de faire en sorte que le serveur soit automatiquement détruit lorsqu'on quitte la fenêtre.<br>
<br>
Ensuite, on essaie de démarrer le serveur grâce à <span class="code2 cpp"><span class="n">serveur</span><span class="o">-&gt;</span><span class="n">listen</span><span class="p">(</span><span class="n">QHostAddress</span><span class="o">::</span><span class="n">Any</span><span class="p">,</span> <span class="mi">50885</span><span class="p">)</span>
</span>. Il y a 2 paramètres :<br>
<br>
<ul>
<li><strong>L'IP</strong> : c'est l'IP sur laquelle le serveur "écoute" si de nouveaux clients arrivent. Comme je vous l'avais dit, un ordinateur peut avoir plusieurs IP : une IP interne (127.0.0.1), une IP pour le réseau local, une IP sur internet, etc. La mention QHostAddress::Any autorise toutes les connexions : internes (clients connectés sur la même machine), locales (clients connectés sur le même réseau local) et externes (clients connectés via internet).</li>
<li><strong>Le port</strong> : c'est le numéro du port sur lequel on souhaite lancer le serveur. J'ai choisi un numéro au hasard, compris entre 1 024 et 65 536. J'aurais aussi pu omettre ce paramètre, dans ce cas le serveur aurait choisi un port libre au hasard. N'hésitez pas à changer la valeur si le port n'est pas libre chez vous.</li>
</ul><br>
<br>
La méthode listen() renvoie un booléen : vrai si le serveur a bien pu se lancer, faux s'il y a eu un problème. On affiche un message en conséquence sur la fenêtre du serveur.<br>
Si le démarrage du serveur a fonctionné, on connecte le signal newConnection() vers notre slot personnalisé nouvelleConnexion() pour traiter l'arrivée d'un nouveau client sur le serveur.<br>
<br>
Si tout va bien, la fenêtre suivante devrait donc s'ouvrir :<br>
<br>
<div class="centre"><img src="./cpp_files/123111.png" alt="Fenêtre du serveur"></div><br>
<br>
S'il y a une erreur, vous aurez un message d'erreur adapté. Par exemple, essayez de lancer une seconde fois le serveur alors qu'un autre serveur tourne déjà :<br>
<br>
<div class="centre"><img src="./cpp_files/123120.png" alt="Serveur cassé"></div><br>
Ici, comme le port 50885 est déjà utilisé par un 1er serveur, notre 2nd serveur n'a pas le droit de démarrer sur ce port. D'où l'erreur. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h4>Slot nouvelleConnexion()</h4><br>
<br>
Ce slot est appelé dès qu'un nouveau client se connecte au serveur :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">FenServeur</span><span class="o">::</span><span class="n">nouvelleConnexion</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">envoyerATous</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;Un nouveau client vient de se connecter&lt;/em&gt;"</span><span class="p">));</span>

    <span class="n">QTcpSocket</span> <span class="o">*</span><span class="n">nouveauClient</span> <span class="o">=</span> <span class="n">serveur</span><span class="o">-&gt;</span><span class="n">nextPendingConnection</span><span class="p">();</span>
    <span class="n">clients</span> <span class="o">&lt;&lt;</span> <span class="n">nouveauClient</span><span class="p">;</span>

    <span class="n">connect</span><span class="p">(</span><span class="n">nouveauClient</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">readyRead</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">donneesRecues</span><span class="p">()));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">nouveauClient</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">disconnected</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">deconnexionClient</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On envoie à tous les clients déjà connectés un message comme quoi un nouveau client vient de se connecter. On verra le contenu de la méthode envoyerATous() un peu plus loin.<br>
<br>
Chaque client est représenté par un QTcpSocket. Pour récupérer la socket correspondant au nouveau client qui vient de se connecter, on appelle la méthode nextPendingConnection() du QTcpServer. Cette méthode retourne la QTcpSocket du nouveau client.<br>
<br>
Comme je vous l'ai dit, on conserve la liste des clients connectés dans un tableau, appelé <span class="italique">clients</span>.<br>
Ce tableau est géré par la classe QList qui est très simple d'utilisation. On ajoute le nouveau client à la fin du tableau très facilement, comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">clients</span> <span class="o">&lt;&lt;</span> <span class="n">nouveauClient</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<span class="italique">(vive la surcharge de l'opérateur &lt;&lt; <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> )</span><br>
<br>
On connecte ensuite les signaux que peut envoyer le client à des slots. On va gérer 2 signaux :<br>
<br>
<ul>
<li><strong>readyRead(</strong>) : signale que le client a envoyé des données. Ce signal est émis pour chaque sous-paquet reçu. Lorsqu'un client enverra un message, ce signal pourra donc être émis plusieurs fois jusqu'à ce que tous les sous-paquets soient arrivés.<br>
C'est notre slot personnalisé donneesRecues() (qui sera coton à écrire <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> ) qui traitera les sous-paquets.</li>
<li><strong>disconnected()</strong> : signale que le client s'est déconnecté. Notre slot se chargera d'informer les autres clients de son départ et de supprimer la QTcpSocket correspondante dans la liste des clients connectés.</li>
</ul><br>
<br>
<br>
<h4>Slot donneesRecues()</h4><br>
<br>
Voilà sans aucun doute LE point le plus délicat de ce chapitre. C'est un slot qui va être appelé à chaque fois qu'on reçoit un sous-paquet d'un des clients.<br>
<br>
On a au moins 2 problèmes pas évidents à résoudre :<br>
<br>
<ul>
<li>Comme on va recevoir plusieurs sous-paquets, il va falloir "attendre" d'avoir tout reçu avant de pouvoir dire qu'on a reçu le message en entier.</li>
<li>C'est le même slot qui est appelé quel que soit le client qui a envoyé un message. Du coup, comment savoir quel est le client à l'origine du message pour récupérer les données ?</li>
</ul><br>
Il faut utiliser l'objet QTcpSocket du client pour récupérer les sous-paquets qui ont transité par le réseau. Le problème, c'est qu'on a connecté les signaux de tous les clients à un même slot :<br>
<br>
<div class="centre"><img src="./cpp_files/124069.png" alt="Plusieurs signaux connectés à un slot"></div><br>
<br>
Comment le slot sait-il dans quelle QTcpSocket lire les données ?<br>
<br>
Vous ne pouviez pas trop le deviner, et à vrai dire je ne savais pas moi-même comment faire avant d'écrire ce chapitre <img src="./cpp_files/heureux.png" alt=":D" class="smilies"> .<br>
<br>
Il se trouve que j'ai découvert qu'on pouvait appeler la méthode <a href="http://doc.trolltech.com/qobject.html#sender">sender() de QObject</a> dans le slot pour retrouver un pointeur vers l'objet à l'origine du message. Très pratique ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Nouveau problème : cette méthode renvoie systématiquement un QObject (classe générique de Qt) car elle ne sait pas à l'avance de quel type sera l'objet. Notre objet QTcpSocket sera donc représenté par un QObject.<br>
Pour le transformer à nouveau en QTcpSocket, il faudra forcer sa conversion à l'aide de la méthode qobject_cast().<br>
<br>
En résumé, pour obtenir un pointeur vers la bonne QTcpSocket à l'origine du signal, il faudra écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QTcpSocket</span> <span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="n">qobject_cast</span><span class="o">&lt;</span><span class="n">QTcpSocket</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">sender</span><span class="p">());</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ce qui, schématiquement, revient à faire ceci :<br>
<br>
<div class="centre"><img src="./cpp_files/124119.png" alt="Sélection du signal et retransformation en QTcpSocket"></div><br>
<br>
<ol class="liste_1">
<li>On utilise sender() pour déterminer l'objet à l'origine du signal.</li>
<li>Comme sender() renvoie systématiquement un QObject, il faut le transformer à nouveau en QTcpSocket. Pour cela, on passe l'objet en paramètre à la méthode qobject_cast(), on indiquant entre les chevrons le type de retour que l'on souhaite obtenir : &lt;QTcpSocket *&gt;.</li></ol><br>
<div class="rmq information">La méthode qobject_cast() est similaire au dynamic_cast() de la bibliothèque standard du C++. Son rôle est de forcer la transformation d'un objet d'un type vers un autre.</div><br>
<br>
Il se peut que le qobject_cast() n'ait pas fonctionné (par exemple parce que l'objet n'était pas de type QTcpSocket contrairement à ce qu'on attendait). Dans ce cas, il renvoie 0. Il faut que l'on teste si le qobject_cast() a fonctionné avant d'aller plus loin.<br>
On va faire un return qui va arrêter la méthode s'il y a eu un problème :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QTcpSocket</span> <span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="n">qobject_cast</span><span class="o">&lt;</span><span class="n">QTcpSocket</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">sender</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="n">socket</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Si par hasard on n'a pas trouvé le client à l'origine du signal, on arrête la méthode</span>
    <span class="k">return</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On peut ensuite travailler à récupérer les données. On commence par créer un flux de données pour lire ce que contient la socket :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="syntax"><pre><span class="n">QDataStream</span> <span class="n">in</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notre objet "in" va nous permettre de lire le contenu du sous-paquet que vient de recevoir la socket du client.<br>
<br>
C'est maintenant que l'on va utiliser l'entier tailleMessage défini en tant qu'attribut de la classe. Si lors de l'appel au slot ce tailleMessage vaut 0, cela signifie qu'on est en train de recevoir le début d'un nouveau message.<br>
On demande à la socket combien d'octets ont été reçus dans le sous-paquet grâce à la méthode bytesAvailable(). Si on a reçu moins d'octets que la taille d'un quint16, on arrête la méthode de suite. On attendra le prochain appel de la méthode pour vérifier à nouveau si on a reçu assez d'octets pour récupérer la taille du message.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="syntax"><pre><span class="k">if</span> <span class="p">(</span><span class="n">tailleMessage</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Si on ne connaît pas encore la taille du message, on essaie de la récupérer</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">bytesAvailable</span><span class="p">()</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">quint16</span><span class="p">))</span> <span class="c1">// On n'a pas reçu la taille du message en entier</span>
         <span class="k">return</span><span class="p">;</span>

    <span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">tailleMessage</span><span class="p">;</span> <span class="c1">// Si on a reçu la taille du message en entier, on la récupère</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
La ligne 6 est exécutée uniquement si on a reçu assez d'octets. En effet, le return a arrêté la méthode avant si ce n'était pas le cas.<br>
On récupère donc la taille du message et on la stocke. On la "retient" pour la suite des opérations.<br>
<br>
Pour bien comprendre ce code, il faut se rappeler que le paquet est découpé en sous-paquets :<br>
<br>
<div class="centre"><img src="./cpp_files/123106.png" alt="Séparation en sous-paquets"></div><br>
<br>
Notre slot est appelé à chaque fois qu'un sous-paquet a été reçu.<br>
<br>
On vérifie si on a reçu assez d'octets pour récupérer la taille du message (première section en gris foncé). La taille de la première section "tailleMessage" peut être facilement retrouvée grâce à l'opérateur sizeof() que vous avez probablement déjà utilisé.<br>
Si on n'a pas reçu assez d'octets, on arrête la méthode (return). On attendra que le slot soit à nouveau appelé et on vérifiera alors cette fois si on a reçu assez d'octets.<br>
<br>
<br>
<br>
<br>
Maintenant la suite des opérations. On a reçu la taille du message. On va maintenant essayer de récupérer le message lui-même :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="c1">// Si on connaît la taille du message, on vérifie si on a reçu le message en entier</span>
<span class="k">if</span> <span class="p">(</span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">bytesAvailable</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tailleMessage</span><span class="p">)</span> <span class="c1">// Si on n'a pas encore tout reçu, on arrête la méthode</span>
    <span class="k">return</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le principe est le même. On regarde le nombre d'octets reçus, et si on en a moins que la taille annoncée du message, on arrête (return).<br>
<br>
Si tout va bien, on peut passer à la suite de la méthode. Si ces lignes s'exécutent, c'est qu'on a reçu le message en entier, donc qu'on peut le récupérer dans une QString :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="syntax"><pre><span class="c1">// Si ces lignes s'exécutent, c'est qu'on a reçu tout le message : on peut le récupérer !</span>
<span class="n">QString</span> <span class="n">message</span><span class="p">;</span>
<span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">message</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notre QString "message" contient maintenant le message envoyé par le client !<br>
<br>
Ouf ! Le serveur a reçu le message du client !<br>
Mais ce n'est pas fini : il faut maintenant renvoyer le message à tous les clients comme je vous l'avais expliqué. Pour reprendre notre exemple, Vincent vient d'envoyer un message au serveur, celui-ci l'a récupéré et s'apprête à le renvoyer à tout le monde.<br>
<br>
L'envoi du message à tout le monde se fait via la méthode envoyerATous dont je vous ai déjà parlé et qu'il va falloir écrire.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="c1">// 2 : on renvoie le message à tous les clients</span>
<span class="n">envoyerATous</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On a presque fini. Il manque juste une petite chose : remettre tailleMessage à 0 pour que l'on puisse recevoir de futurs messages d'autres clients :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="syntax"><pre><span class="c1">// 3 : remise de la taille du message à 0 pour permettre la réception des futurs messages</span>
<span class="n">tailleMessage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Si on n'avait pas fait ça, le serveur aurait cru lors du prochain sous-paquet reçu que le nouveau message est de la même longueur que le précédent, ce qui n'est certainement pas le cas. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
Bon, résumons le slot en entier :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">FenServeur</span><span class="o">::</span><span class="n">donneesRecues</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 1 : on reçoit un paquet (ou un sous-paquet) d'un des clients</span>

    <span class="c1">// On détermine quel client envoie le message (recherche du QTcpSocket du client)</span>
    <span class="n">QTcpSocket</span> <span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="n">qobject_cast</span><span class="o">&lt;</span><span class="n">QTcpSocket</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">sender</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">socket</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Si par hasard on n'a pas trouvé le client à l'origine du signal, on arrête la méthode</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Si tout va bien, on continue : on récupère le message</span>
    <span class="n">QDataStream</span> <span class="n">in</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tailleMessage</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Si on ne connaît pas encore la taille du message, on essaie de la récupérer</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">bytesAvailable</span><span class="p">()</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">quint16</span><span class="p">))</span> <span class="c1">// On n'a pas reçu la taille du message en entier</span>
             <span class="k">return</span><span class="p">;</span>

        <span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">tailleMessage</span><span class="p">;</span> <span class="c1">// Si on a reçu la taille du message en entier, on la récupère</span>
    <span class="p">}</span>

    <span class="c1">// Si on connaît la taille du message, on vérifie si on a reçu le message en entier</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">bytesAvailable</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tailleMessage</span><span class="p">)</span> <span class="c1">// Si on n'a pas encore tout reçu, on arrête la méthode</span>
        <span class="k">return</span><span class="p">;</span>


    <span class="c1">// Si ces lignes s'exécutent, c'est qu'on a reçu tout le message : on peut le récupérer !</span>
    <span class="n">QString</span> <span class="n">message</span><span class="p">;</span>
    <span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">message</span><span class="p">;</span>


    <span class="c1">// 2 : on renvoie le message à tous les clients</span>
    <span class="n">envoyerATous</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>

    <span class="c1">// 3 : remise de la taille du message à 0 pour permettre la réception des futurs messages</span>
    <span class="n">tailleMessage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
J'espère avoir été clair, car ce slot n'est pas simple et pas très facile à lire je dois bien avouer. La clé, le truc à comprendre, c'est que chaque return arrête la méthode. Le slot sera à nouveau appelé au prochain sous-paquet reçu, donc ces instructions s'exécuteront probablement plusieurs fois pour un message.<br>
<br>
Si la méthode arrive à s'exécuter jusqu'au bout, c'est qu'on a reçu le message en entier. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<br>
<h4>Slot deconnexionClient()</h4><br>
<br>
Ce slot est appelé lorsqu'un client se déconnecte.<br>
<br>
On va envoyer un message à tous les clients encore connectés pour qu'ils sachent qu'un client vient de partir. Puis, on supprime la QTcpSocket correspondant au client dans notre tableau QList. Ainsi, le serveur "oublie" ce client, il ne considère plus qu'il fait partie des connectés.<br>
<br>
Voici le slot en entier :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">FenServeur</span><span class="o">::</span><span class="n">deconnexionClient</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">envoyerATous</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;Un client vient de se déconnecter&lt;/em&gt;"</span><span class="p">));</span>

    <span class="c1">// On détermine quel client se déconnecte</span>
    <span class="n">QTcpSocket</span> <span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="n">qobject_cast</span><span class="o">&lt;</span><span class="n">QTcpSocket</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">sender</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">socket</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Si par hasard on n'a pas trouvé le client à l'origine du signal, on arrête la méthode</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">clients</span><span class="p">.</span><span class="n">removeOne</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>

    <span class="n">socket</span><span class="o">-&gt;</span><span class="n">deleteLater</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Comme plusieurs signaux sont connectés à ce slot, on ne sait pas quel est le client à l'origine de la déconnexion. Pour le retrouver, on utilise la même technique que pour le slot donneesRecues(), je ne la réexplique donc pas.<br>
<br>
La méthode removeOne() de QList permet de supprimer le pointeur vers l'objet dans le tableau. Notre liste des clients est maintenant à jour.<br>
<br>
Il ne reste plus qu'à finir de supprimer l'objet lui-même (nous venons seulement de supprimer le pointeur de la QList là).<br>
Pour supprimer l'objet, il faudrait faire un <span class="code2 cpp"><span class="k">delete</span> <span class="n">client</span><span class="p">;</span>
</span>. Petit problème : si on supprime l'objet à l'origine du signal, on risque de faire bugger Qt. Heureusement tout a été prévu : on a juste à appeler deleteLater() (qui signifie "supprimer plus tard") et Qt se chargera de faire le delete lui-même un peu plus tard, lorsque notre slot aura fini de s'exécuter.<br>
<br>
<br>
<h4>Méthode envoyerATous()</h4><br>
<br>
Ah, cette fois ce n'est pas un slot. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
C'est juste une méthode que j'ai décidé d'écrire dans la classe pour bien séparer le code, et aussi parce qu'on en a besoin plusieurs fois (vous avez remarqué que j'ai appelé cette méthode plusieurs fois dans les codes précédents non ?).<br>
<br>
Dans le slot donneesRecues, nous recevions un message. Là, nous voulons au contraire en envoyer un, et ce à tous les clients connectés (tous les clients présents dans la QList).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="syntax"><pre><span class="kt">void</span> <span class="n">FenServeur</span><span class="o">::</span><span class="n">envoyerATous</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Préparation du paquet</span>
    <span class="n">QByteArray</span> <span class="n">paquet</span><span class="p">;</span>
    <span class="n">QDataStream</span> <span class="n">out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">paquet</span><span class="p">,</span> <span class="n">QIODevice</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">);</span>

    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">quint16</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// On écrit 0 au début du paquet pour réserver la place pour écrire la taille</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">;</span> <span class="c1">// On ajoute le message à la suite</span>
    <span class="n">out</span><span class="p">.</span><span class="n">device</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// On se replace au début du paquet</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">quint16</span><span class="p">)</span> <span class="p">(</span><span class="n">paquet</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">quint16</span><span class="p">));</span> <span class="c1">// On écrase le 0 qu'on avait réservé par la longueur du message</span>


    <span class="c1">// Envoi du paquet préparé à tous les clients connectés au serveur</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">clients</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">clients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">paquet</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Quelques explications bien sûr. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
On crée un QByteArray "paquet" qui va contenir le paquet à envoyer sur le réseau. La classe QByteArray représente une suite d'octets quelconque.<br>
<br>
On utilise un QDataStream comme tout à l'heure pour écrire dans le QByteArray facilement. Cela va nous permettre d'utiliser l'opérateur "&lt;&lt;".<br>
<br>
Ce qui est particulier, c'est qu'<span class="italique">on écrit d'abord le message</span> (QString) et ensuite on calcule sa taille qu'on écrit au début du message.<br>
<br>
Voilà ce qu'on fait sur le paquet dans l'ordre :<br>
<br>
<ol class="liste_1">
<li>On écrit le nombre 0 de type quint16 pour "réserver" de la place.</li>
<li>On écrit à la suite le message, de type QString. Le message a été reçu en paramètre de la méthode envoyerATous().</li>
<li>On se replace au début du paquet (comme si on remettait le curseur au début d'un texte dans un traitement de texte).</li>
<li>On écrase le 0 qu'on avait écrit pour réserver de la place par la bonne taille du message. Cette taille est calculée via une simple soustraction : la taille du message est égale à la taille du paquet moins la taille réservée pour le quint16.<br>
<br>
<div class="centre"><img src="./cpp_files/124829.png" alt="Calcul de la taille du paquet"></div></li></ol><br>
Notre paquet est prêt. Nous allons l'envoyer à tous les clients grâce à la méthode write() du socket.<br>
Pour cela, on fait une boucle sur la QList, et on envoie le message à chaque client.<br>
<br>
Et voilà, le message est parti ! <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h4>FenServeur.cpp en entier</h4><br>
<br>
Voici le contenu du fichier FenServeur.cpp que je viens de décortiquer en entier :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114</pre></div></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenServeur.h"</span>

<span class="n">FenServeur</span><span class="o">::</span><span class="n">FenServeur</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Création et disposition des widgets de la fenêtre</span>
    <span class="n">etatServeur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLabel</span><span class="p">;</span>
    <span class="n">boutonQuitter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QPushButton</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Quitter"</span><span class="p">));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">boutonQuitter</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">clicked</span><span class="p">()),</span> <span class="n">qApp</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">quit</span><span class="p">()));</span>

    <span class="n">QVBoxLayout</span> <span class="o">*</span><span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">;</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">etatServeur</span><span class="p">);</span>
    <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">boutonQuitter</span><span class="p">);</span>
    <span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">);</span>

    <span class="n">setWindowTitle</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"ZeroChat - Serveur"</span><span class="p">));</span>

    <span class="c1">// Gestion du serveur</span>
    <span class="n">serveur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTcpServer</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">serveur</span><span class="o">-&gt;</span><span class="n">listen</span><span class="p">(</span><span class="n">QHostAddress</span><span class="o">::</span><span class="n">Any</span><span class="p">,</span> <span class="mi">50885</span><span class="p">))</span> <span class="c1">// Démarrage du serveur sur toutes les IP disponibles et sur le port 50585</span>
    <span class="p">{</span>
        <span class="c1">// Si le serveur n'a pas été démarré correctement</span>
        <span class="n">etatServeur</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Le serveur n'a pas pu être démarré. Raison :&lt;br /&gt;"</span><span class="p">)</span> <span class="o">+</span> <span class="n">serveur</span><span class="o">-&gt;</span><span class="n">errorString</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// Si le serveur a été démarré correctement</span>
        <span class="n">etatServeur</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"Le serveur a été démarré sur le port &lt;strong&gt;"</span><span class="p">)</span> <span class="o">+</span> <span class="n">QString</span><span class="o">::</span><span class="n">number</span><span class="p">(</span><span class="n">serveur</span><span class="o">-&gt;</span><span class="n">serverPort</span><span class="p">())</span> <span class="o">+</span> <span class="n">tr</span><span class="p">(</span><span class="s">"&lt;/strong&gt;.&lt;br /&gt;Des clients peuvent maintenant se connecter."</span><span class="p">));</span>
        <span class="n">connect</span><span class="p">(</span><span class="n">serveur</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">newConnection</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">nouvelleConnexion</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="n">tailleMessage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenServeur</span><span class="o">::</span><span class="n">nouvelleConnexion</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">envoyerATous</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;Un nouveau client vient de se connecter&lt;/em&gt;"</span><span class="p">));</span>

    <span class="n">QTcpSocket</span> <span class="o">*</span><span class="n">nouveauClient</span> <span class="o">=</span> <span class="n">serveur</span><span class="o">-&gt;</span><span class="n">nextPendingConnection</span><span class="p">();</span>
    <span class="n">clients</span> <span class="o">&lt;&lt;</span> <span class="n">nouveauClient</span><span class="p">;</span>

    <span class="n">connect</span><span class="p">(</span><span class="n">nouveauClient</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">readyRead</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">donneesRecues</span><span class="p">()));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">nouveauClient</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">disconnected</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">deconnexionClient</span><span class="p">()));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenServeur</span><span class="o">::</span><span class="n">donneesRecues</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 1 : on reçoit un paquet (ou un sous-paquet) d'un des clients</span>

    <span class="c1">// On détermine quel client envoie le message (recherche du QTcpSocket du client)</span>
    <span class="n">QTcpSocket</span> <span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="n">qobject_cast</span><span class="o">&lt;</span><span class="n">QTcpSocket</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">sender</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">socket</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Si par hasard on n'a pas trouvé le client à l'origine du signal, on arrête la méthode</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Si tout va bien, on continue : on récupère le message</span>
    <span class="n">QDataStream</span> <span class="n">in</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tailleMessage</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Si on ne connaît pas encore la taille du message, on essaie de la récupérer</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">bytesAvailable</span><span class="p">()</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">quint16</span><span class="p">))</span> <span class="c1">// On n'a pas reçu la taille du message en entier</span>
             <span class="k">return</span><span class="p">;</span>

        <span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">tailleMessage</span><span class="p">;</span> <span class="c1">// Si on a reçu la taille du message en entier, on la récupère</span>
    <span class="p">}</span>

    <span class="c1">// Si on connaît la taille du message, on vérifie si on a reçu le message en entier</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">bytesAvailable</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tailleMessage</span><span class="p">)</span> <span class="c1">// Si on n'a pas encore tout reçu, on arrête la méthode</span>
        <span class="k">return</span><span class="p">;</span>


    <span class="c1">// Si ces lignes s'exécutent, c'est qu'on a reçu tout le message : on peut le récupérer !</span>
    <span class="n">QString</span> <span class="n">message</span><span class="p">;</span>
    <span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">message</span><span class="p">;</span>


    <span class="c1">// 2 : on renvoie le message à tous les clients</span>
    <span class="n">envoyerATous</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>

    <span class="c1">// 3 : remise de la taille du message à 0 pour permettre la réception des futurs messages</span>
    <span class="n">tailleMessage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenServeur</span><span class="o">::</span><span class="n">deconnexionClient</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">envoyerATous</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;Un client vient de se déconnecter&lt;/em&gt;"</span><span class="p">));</span>

    <span class="c1">// On détermine quel client se déconnecte</span>
    <span class="n">QTcpSocket</span> <span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="n">qobject_cast</span><span class="o">&lt;</span><span class="n">QTcpSocket</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">sender</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">socket</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Si par hasard on n'a pas trouvé le client à l'origine du signal, on arrête la méthode</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">clients</span><span class="p">.</span><span class="n">removeOne</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>

    <span class="n">socket</span><span class="o">-&gt;</span><span class="n">deleteLater</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">FenServeur</span><span class="o">::</span><span class="n">envoyerATous</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Préparation du paquet</span>
    <span class="n">QByteArray</span> <span class="n">paquet</span><span class="p">;</span>
    <span class="n">QDataStream</span> <span class="n">out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">paquet</span><span class="p">,</span> <span class="n">QIODevice</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">);</span>

    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">quint16</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// On écrit 0 au début du paquet pour réserver la place pour écrire la taille</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">;</span> <span class="c1">// On ajoute le message à la suite</span>
    <span class="n">out</span><span class="p">.</span><span class="n">device</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// On se replace au début du paquet</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">quint16</span><span class="p">)</span> <span class="p">(</span><span class="n">paquet</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">quint16</span><span class="p">));</span> <span class="c1">// On écrase le 0 qu'on avait réservé par la longueur du message</span>


    <span class="c1">// Envoi du paquet préparé à tous les clients connectés au serveur</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">clients</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">clients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">paquet</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h3>Lancement du serveur</h3><br>
<br>
Bonne nouvelle, devinez quoi : notre projet "serveur" est terminé !<br>
Nous avons fait le plus dur, l'implémentation du serveur dans FenServeur.cpp. Compilez, et lancez le serveur ainsi créé.<br>
<br>
Vous risquez d'avoir une alerte de votre pare-feu (firewall). Par exemple sous Windows :<br>
<br>
<div class="centre"><img src="./cpp_files/122746.png" alt="Firewall"></div><br>
<br>
En effet, notre programme va communiquer sur le réseau. Le pare-feu nous demande si nous voulons autoriser notre programme à le faire : répondez oui en cliquant sur "Débloquer".<br>
<br>
<div class="rmq attention">Dans cet exemple, j'ai considéré que le pare-feu de votre système d'exploitation était votre seul pare-feu. Si vous comptez utiliser le Chat sur internet et que vous êtes derrière un routeur, vérifiez la configuration du routeur et ouvrez le port 50885 pour les données TCP.<br>
Si le Chat n'a pas l'air de fonctionner, c'est très probablement à cause d'un pare-feu quelque part qui bloque le port.</div><br>
<br>
Notre serveur est maintenant lancé :<br>
<br>
<div class="centre"><img src="./cpp_files/123111.png" alt="Fenêtre du serveur"></div><br>
<br>
Bravo ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Laissez ce programme tourner en fond sur votre ordinateur (vous pouvez réduire la fenêtre). Il va servir à faire la communication entre les différents clients.<br>
<br>
Bon, mauvaise nouvelle chers auditeurs : nous avons beaucoup sué, mais nous avons fait seulement 50% du travail !<br>
Il faut maintenant s'attaquer au projet "client" pour réaliser le programme qui sera utilisé par tous les clients pour chatter. Heureusement, nous avons déjà fait le plus dur en analysant le slot donneesRecues, on devrait donc aller un peu plus vite. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11392">Réalisation du client</h2>
		<div class="ss_part_texte">
		Si la fenêtre du serveur était toute simple, il en va autrement pour la fenêtre du client.<br>
En effet, autant créer une fenêtre pour le serveur était facultatif, autant pour le client il faut bien qu'il ait une fenêtre pour écrire ses messages. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Voici la fenêtre de client que l'on veut coder :<br>
<br>
<div class="centre"><img src="./cpp_files/124121(1).png" alt="Chat côté client"></div><br>
<br>
Nous aurons 3 fichiers à nouveau :<br>
<br>
<ul>
<li>main.cpp</li>
<li>FenClient.h</li>
<li>FenClient.cpp</li>
</ul><br>
<br>
<h3>Dessin de la fenêtre avec Qt Designer</h3><br>
<br>
Bon, la réalisation de cette fenêtre ne nous intéresse pas vraiment. C'est une fenêtre tout ce qu'il y a de plus classique.<br>
Pour gagner du temps, je vous propose de créer l'interface de la fenêtre du client via Qt Designer. Ce programme a justement été conçu pour gagner du temps pour ceux qui savent déjà coder la fenêtre à la main, ce qui est notre cas.<br>
<br>
<div class="rmq information">J'aurais pu utiliser Qt Designer pour le TP zNavigo aussi, mais la fenêtre était beaucoup plus complexe et le nombre d'onglets variable. J'avais donc décidé de l'écrire à la main.<br>
Pour une fenêtre assez simple comme celle-là, l'utilisation de Qt Designer permet au contraire de gagner du temps, pour peu qu'on sache déjà coder la fenêtre à la main.</div><br>
<br>
J'ouvre donc Qt Designer et je dessine la fenêtre suivante :<br>
<br>
<div class="centre"><img src="./cpp_files/124122.png" alt="Fenêtre du client sous Qt Designer"></div><br>
<br>
Je prends soin à bien donner un nom correct à chacun des widgets via la propriété objectName (sauf pour les QLabel, car on n'aura pas à les réutiliser ceux-là donc on s'en moque un peu <img src="./cpp_files/hihi.png" alt="^^" class="smilies"> ).<br>
Je veille aussi à utiliser des layouts partout sur ma fenêtre pour la rendre redimensionnable sans problème. Je sélectionne plusieurs widgets à la fois et je clique sur un des boutons de la barre d'outils en haut pour les assembler selon un layout (notez que je n'utilise jamais les layouts de la widget box à gauche).<br>
<br>
Pour vous faire gagner du temps si vous ne voulez pas redessiner la fenêtre sous Qt Designer, voici le fichier FenClient.ui que j'ai généré :<br>
<br>
<div class="centre"><span class="gros"><a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/cpp/FenClient.ui">Télécharger FenClient.ui</a></span><br>
<span class="italique">(faites clic droit / enregistrer sous)</span></div><br>
<br>
<h3>Client.pro</h3><br>
<br>
J'ai mis à jour le fichier .pro pour indiquer qu'il y avait un UI dans le projet et qu'on utilisait le module network de Qt.<br>
Vérifiez donc que votre .pro ressemble au mien :<br>
<br>
<span class="code">Code : Autre - <a href="#" class="select_code">Sélectionner</a></span><div class="code2"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><div class="syntax"><pre>######################################################################
#&nbsp;Automatically&nbsp;generated&nbsp;by&nbsp;qmake&nbsp;(2.01a)&nbsp;mer.&nbsp;25.&nbsp;juin&nbsp;17:13:47&nbsp;2008
######################################################################

TEMPLATE&nbsp;=&nbsp;app
<span class="ln-xtra">QT&nbsp;+=&nbsp;network</span>
TARGET&nbsp;=&nbsp;
DEPENDPATH&nbsp;+=&nbsp;.
INCLUDEPATH&nbsp;+=&nbsp;.

#&nbsp;Input
HEADERS&nbsp;+=&nbsp;FenClient.h
<span class="ln-xtra">FORMS&nbsp;+=&nbsp;FenClient.ui</span>
SOURCES&nbsp;+=&nbsp;FenClient.cpp&nbsp;main.cpp</pre></div></td></tr></tbody></table></div><br>
<br>
<br>
<h3>main.cpp</h3><br>
<br>
Revenons au code. Le main est toujours très simple et sans originalité : il ouvre la fenêtre.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include "FenClient.h"</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">FenClient</span> <span class="n">fenetre</span><span class="p">;</span>
    <span class="n">fenetre</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h3>FenClient.h</h3><br>
<br>
Notre fenêtre utilise un fichier généré avec Qt Designer. Direction le chapitre sur Qt Designer si vous avez oublié comment se servir d'une fenêtre générée dans son code.<br>
<br>
Nous allons ici utiliser un héritage multiple afin de simplifier au maximum le code par la suite :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#ifndef HEADER_FENCLIENT</span>
<span class="cp">#define HEADER_FENCLIENT</span>

<span class="cp">#include &lt;QtGui&gt;</span>
<span class="cp">#include &lt;QtNetwork&gt;</span>
<span class="cp">#include "ui_FenClient.h"</span>


<span class="k">class</span> <span class="nc">FenClient</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span><span class="p">,</span> <span class="k">private</span> <span class="n">Ui</span><span class="o">::</span><span class="n">FenClient</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="n">FenClient</span><span class="p">();</span>

    <span class="k">private</span> <span class="nl">slots:</span>
        <span class="kt">void</span> <span class="n">on_boutonConnexion_clicked</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">on_boutonEnvoyer_clicked</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">on_message_returnPressed</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">donneesRecues</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">connecte</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">deconnecte</span><span class="p">();</span>
        <span class="kt">void</span> <span class="n">erreurSocket</span><span class="p">(</span><span class="n">QAbstractSocket</span><span class="o">::</span><span class="n">SocketError</span> <span class="n">erreur</span><span class="p">);</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">QTcpSocket</span> <span class="o">*</span><span class="n">socket</span><span class="p">;</span> <span class="c">// Représente le serveur</span>
        <span class="n">quint16</span> <span class="n">tailleMessage</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Notez qu'on inclut ui_FenClient.h pour réutiliser la fenêtre générée. <br>
<br>
Notre fenêtre comporte pas mal de slots qu'il va falloir implémenter, heureusement ils seront assez simples. On utilise les autoconnect pour les 3 premiers d'entre eux pour gérer les évènements de la fenêtre :<br>
<br>
<ul>
<li><strong>on_boutonConnexion_clicked()</strong> : appelé lorsqu'on clique sur le bouton "Connexion" et qu'on souhaite donc se connecter au serveur.</li>
<li><strong>on_boutonEnvoyer_clicked()</strong> : appelé lorsqu'on clique sur "Envoyer" pour envoyer un message dans le Chat.</li>
<li><strong>on_message_returnPressed()</strong> : appelé lorsqu'on appuie sur la touche "Entrée" lorsqu'on rédige un message. Comme cela revient au même que on_boutonEnvoyer_clicked(), on appellera cette méthode directement pour éviter d'avoir à écrire 2 fois le même code.</li>
<li><strong>donneesRecues()</strong> : appelé lorsqu'on reçoit un sous-paquet du serveur. Ce slot sera très similaire à celui du serveur qui possède le même nom.</li>
<li><strong>connecte()</strong> : appelé lorsqu'on vient de réussir à se connecter au serveur.</li>
<li><strong>deconnecte()</strong> : appelé lorsqu'on vient de se déconnecter du serveur.</li>
<li><strong>erreurSocket(QAbstractSocket::SocketError erreur)</strong> : appelé lorsqu'il y a eu une erreur sur le réseau (connexion au serveur impossible par exemple).</li>
</ul><br>
<br>
En plus de ça, on a 2 attributs à manipuler :<br>
<br>
<ul>
<li><strong>QTcpSocket *socket</strong> : une socket qui représentera la connexion au serveur. On utilisera cette socket pour envoyer des paquets au serveur, par exemple lorsque l'utilisateur veut envoyer un message.</li>
<li><strong>quint16 tailleMessage</strong> : permet à l'objet de se "souvenir" de la taille du message qu'il est en train de recevoir dans son slot donneesRecues(). Il a la même utilité que sur le serveur.</li>
</ul><br>
<h3>FenClient.cpp</h3><br>
<br>
Maintenant implémentons tout ce beau monde !<br>
Courage, après ça c'est fini vous allez pouvoir savourer votre Chat ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<br>
<h4>Le constructeur</h4><br>
<br>
Notre constructeur se doit d'appeler setupUi() dès le début pour mettre en place les widgets sur la fenêtre. C'est justement là qu'on gagne du temps grâce à Qt Designer : on n'a pas à coder le placement des widgets sur la fenêtre. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td class="code"><div class="syntax"><pre><span class="n">FenClient</span><span class="o">::</span><span class="n">FenClient</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">setupUi</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

    <span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTcpSocket</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">readyRead</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">donneesRecues</span><span class="p">()));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">connected</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">connecte</span><span class="p">()));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">disconnected</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">deconnecte</span><span class="p">()));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">QAbstractSocket</span><span class="o">::</span><span class="n">SocketError</span><span class="p">)),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">erreurSocket</span><span class="p">(</span><span class="n">QAbstractSocket</span><span class="o">::</span><span class="n">SocketError</span><span class="p">)));</span>

    <span class="n">tailleMessage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
En plus de setupUi(), on fait quelques initialisations supplémentaires indispensables :<br>
<br>
<ul>
<li>On crée l'objet de type QTcpSocket qui va représenter la connexion au serveur.</li>
<li>On connecte les signaux qu'il est susceptible d'envoyer à nos slots personnalisés.</li>
<li>On met tailleMessage à 0 pour permettre la réception de nouveaux messages.</li>
</ul><br>
Notez qu'on ne se connecte pas au serveur dans le constructeur. On prépare juste la socket, mais on ne fera la connexion que lorsque le client aura cliqué sur le bouton "Connexion" (il faut bien lui laisser le temps de rentrer l'adresse IP du serveur !).<br>
<br>
<br>
<h4>Slot on_boutonConnexion_clicked()</h4><br>
<br>
Ce slot se fait appeler dès que l'on a cliqué sur le bouton "Connexion" en haut de la fenêtre.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></td><td class="code"><div class="syntax"><pre><span class="c">// Tentative de connexion au serveur</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">on_boutonConnexion_clicked</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">// On annonce sur la fenêtre qu'on est en train de se connecter</span>
    <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;Tentative de connexion en cours...&lt;/em&gt;"</span><span class="p">));</span>
    <span class="n">boutonConnexion</span><span class="o">-&gt;</span><span class="n">setEnabled</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

    <span class="n">socket</span><span class="o">-&gt;</span><span class="n">abort</span><span class="p">();</span> <span class="c">// On désactive les connexions précédentes s'il y en a</span>
    <span class="n">socket</span><span class="o">-&gt;</span><span class="n">connectToHost</span><span class="p">(</span><span class="n">serveurIP</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">(),</span> <span class="n">serveurPort</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span> <span class="c">// On se connecte au serveur demandé</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<ol class="liste_1">
<li>Dans un premier temps, on affiche sur la zone de messages "listeMessages" au centre de la fenêtre que l'on est en train d'essayer de se connecter.</li>
<li>On désactive temporairement le bouton "Connexion" pour empêcher au client de retenter une connexion alors qu'une tentative de connexion est déjà en cours.</li>
<li>Si la socket est déjà connectée à un serveur, on coupe la connexion avec abort(). Si on n'était pas connecté, cela n'aura aucun effet, mais c'est par sécurité pour que l'on ne soit pas connecté à 2 serveurs à la fois.</li>
<li>On se connecte enfin au serveur avec la méthode connectToHost(). On utilise l'IP et le port demandés par l'utilisateur dans les champs de texte en haut de la fenêtre.</li></ol><br>
<h4>Slot on_boutonEnvoyer_clicked()</h4><br>
<br>
Ce slot est appelé lorsqu'on essaie d'envoyer un message (le bouton "Envoyer" en bas à droite a été cliqué).<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><div class="syntax"><pre><span class="c">// Envoi d'un message au serveur</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">on_boutonEnvoyer_clicked</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QByteArray</span> <span class="n">paquet</span><span class="p">;</span>
    <span class="n">QDataStream</span> <span class="n">out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">paquet</span><span class="p">,</span> <span class="n">QIODevice</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">);</span>

    <span class="c">// On prépare le paquet à envoyer</span>
    <span class="n">QString</span> <span class="n">messageAEnvoyer</span> <span class="o">=</span> <span class="n">tr</span><span class="p">(</span><span class="s">"&lt;strong&gt;"</span><span class="p">)</span> <span class="o">+</span> <span class="n">pseudo</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">()</span> <span class="o">+</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;/strong&gt; : "</span><span class="p">)</span> <span class="o">+</span> <span class="n">message</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">();</span>

    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">quint16</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">messageAEnvoyer</span><span class="p">;</span>
    <span class="n">out</span><span class="p">.</span><span class="n">device</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">quint16</span><span class="p">)</span> <span class="p">(</span><span class="n">paquet</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">quint16</span><span class="p">));</span>

    <span class="n">socket</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">paquet</span><span class="p">);</span> <span class="c">// On envoie le paquet</span>

    <span class="n">message</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span> <span class="c">// On vide la zone d'écriture du message</span>
    <span class="n">message</span><span class="o">-&gt;</span><span class="n">setFocus</span><span class="p">();</span> <span class="c">// Et on remet le curseur à l'intérieur</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
Ce code est similaire à celui de la méthode envoyerATous() du serveur. Il s'agit d'un envoi de données sur le réseau.<br>
<br>
<ol class="liste_1">
<li>On prépare un QByteArray dans lequel on va écrire le paquet qu'on veut envoyer.</li>
<li>On construit ensuite la QString contenant le message à envoyer. Vous noterez qu'on met le nom de l'auteur et son texte directement dans la même QString. Idéalement, il vaudrait mieux séparer les deux pour avoir un code plus logique et plus modulable, mais cela aurait compliqué le code de ce chapitre bien délicat, donc ça sera dans les améliorations à faire à la fin. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></li>
<li>On calcule la taille du message.</li>
<li>On envoie le paquet ainsi créé au serveur en utilisant la socket qui le représente et sa méthode write().</li>
<li>On efface automatiquement la zone d'écriture des messages en bas pour qu'on puisse en écrire un nouveau et on donne le focus à cette zone immédiatement pour que le curseur soit placé dans le bon widget.</li></ol><br>
<br>
<h4>Slot on_message_returnPressed()</h4><br>
<br>
Ce slot est appelé lorsqu'on a appuyé sur la touche "Entrée" après avoir rédigé un message.<br>
Cela a le même effet qu'un clic sur le bouton "Envoyer", nous appelons donc le slot que nous venons d'écrire :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="c">// Appuyer sur la touche Entrée a le même effet que cliquer sur le bouton "Envoyer"</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">on_message_returnPressed</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">on_boutonEnvoyer_clicked</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<h4>Slot donneesRecues()</h4><br>
<br>
Voilà à nouveau le slot de vos pires cauchemars. <img src="./cpp_files/diable.png" alt=":diable:" class="smilies"> <br>
Il est quasiment identique à celui du serveur (la réception de données fonctionne de la même manière) je ne le réexplique donc pas :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></td><td class="code"><div class="syntax"><pre><span class="c">// On a reçu un paquet (ou un sous-paquet)</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">donneesRecues</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">/* Même principe que lorsque le serveur reçoit un paquet :</span>
<span class="c">    On essaie de récupérer la taille du message</span>
<span class="c">    Une fois qu'on l'a, on attend d'avoir reçu le message entier (en se basant sur la taille annoncée tailleMessage)</span>
<span class="c">    */</span>
    <span class="n">QDataStream</span> <span class="n">in</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tailleMessage</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">bytesAvailable</span><span class="p">()</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">quint16</span><span class="p">))</span>
             <span class="k">return</span><span class="p">;</span>

        <span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">tailleMessage</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">bytesAvailable</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tailleMessage</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>


    <span class="c">// Si on arrive jusqu'à cette ligne, on peut récupérer le message entier</span>
    <span class="n">QString</span> <span class="n">messageRecu</span><span class="p">;</span>
    <span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">messageRecu</span><span class="p">;</span>

    <span class="c">// On affiche le message sur la zone de Chat</span>
    <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">messageRecu</span><span class="p">);</span>

    <span class="c">// On remet la taille du message à 0 pour pouvoir recevoir de futurs messages</span>
    <span class="n">tailleMessage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La seule différence ici en fait, c'est qu'on affiche le message reçu dans la zone de Chat à la fin : <span class="code2 cpp"><span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">messageRecu</span><span class="p">);</span>
</span><br>
<br>
<br>
<h4>Slot connecte()</h4><br>
<br>
Ce slot est appelé lorsqu'on a réussi à se connecter au serveur.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6</pre></td><td class="code"><div class="syntax"><pre><span class="c">// Ce slot est appelé lorsque la connexion au serveur a réussi</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">connecte</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;Connexion réussie !&lt;/em&gt;"</span><span class="p">));</span>
    <span class="n">boutonConnexion</span><span class="o">-&gt;</span><span class="n">setEnabled</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Tout bêtement, on se contente d'afficher "Connexion réussie" dans la zone de Chat pour que le client sache qu'il est bien connecté au serveur.<br>
On réactive aussi le bouton "Connexion" qu'on avait désactivé, pour permettre une nouvelle connexion à un autre serveur.<br>
<br>
<br>
<h4>Slot deconnecte()</h4><br>
<br>
Ce slot est appelé lorsqu'on est déconnecté du serveur.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="c">// Ce slot est appelé lorsqu'on est déconnecté du serveur</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">deconnecte</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;Déconnecté du serveur&lt;/em&gt;"</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
On affiche juste un message sur la zone de texte pour que le client soit au courant.<br>
<br>
<br>
<h4>Slot erreurSocket()</h4><br>
<br>
Ce slot est appelé lorsque la socket a rencontré une erreur.<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><div class="syntax"><pre><span class="c">// Ce slot est appelé lorsqu'il y a une erreur</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">erreurSocket</span><span class="p">(</span><span class="n">QAbstractSocket</span><span class="o">::</span><span class="n">SocketError</span> <span class="n">erreur</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">erreur</span><span class="p">)</span> <span class="c">// On affiche un message différent selon l'erreur qu'on nous indique</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">QAbstractSocket</span><span class="o">::</span><span class="nl">HostNotFoundError:</span>
            <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;ERREUR : le serveur n'a pas pu être trouvé. Vérifiez l'IP et le port.&lt;/em&gt;"</span><span class="p">));</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">QAbstractSocket</span><span class="o">::</span><span class="nl">ConnectionRefusedError:</span>
            <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;ERREUR : le serveur a refusé la connexion. Vérifiez si le programme </span><span class="se">\"</span><span class="s">serveur</span><span class="se">\"</span><span class="s"> a bien été lancé. Vérifiez aussi l'IP et le port.&lt;/em&gt;"</span><span class="p">));</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">QAbstractSocket</span><span class="o">::</span><span class="nl">RemoteHostClosedError:</span>
            <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;ERREUR : le serveur a coupé la connexion.&lt;/em&gt;"</span><span class="p">));</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;ERREUR : "</span><span class="p">)</span> <span class="o">+</span> <span class="n">socket</span><span class="o">-&gt;</span><span class="n">errorString</span><span class="p">()</span> <span class="o">+</span> <span class="n">tr</span><span class="p">(</span><span class="s">"&lt;/em&gt;"</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">boutonConnexion</span><span class="o">-&gt;</span><span class="n">setEnabled</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La raison de l'erreur est passée en paramètre. Elle est de type <a href="http://doc.trolltech.com/qabstractsocket.html#SocketError-enum">QAbstractSocket::SocketError</a> (c'est une énumération).<br>
<br>
On fait un switch pour afficher un message différent en fonction de l'erreur. Je n'ai pas traité toutes les erreurs possibles, lisez la doc pour connaître les autres raisons d'erreurs que l'on peut gérer.<br>
<br>
La plupart des erreurs que je gère ici sont liées à la connexion au serveur. J'affiche un message intelligible en français pour que l'on comprenne la raison de l'erreur.<br>
Le cas "default" est appelé pour les erreurs que je n'ai pas gérées. J'affiche le message d'erreur envoyé par la socket (qui sera peut-être en anglais mais bon c'est mieux que rien).<br>
<br>
<br>
<h4>FenClient.cpp en entier</h4><br>
<br>
C'est fini ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
Bon, ça n'a pas été trop long ni trop difficile après avoir fait le serveur, avouez. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Voici le code complet de FenClient.cpp :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include "FenClient.h"</span>

<span class="n">FenClient</span><span class="o">::</span><span class="n">FenClient</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">setupUi</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

    <span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTcpSocket</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">readyRead</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">donneesRecues</span><span class="p">()));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">connected</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">connecte</span><span class="p">()));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">disconnected</span><span class="p">()),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">deconnecte</span><span class="p">()));</span>
    <span class="n">connect</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">QAbstractSocket</span><span class="o">::</span><span class="n">SocketError</span><span class="p">)),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">erreurSocket</span><span class="p">(</span><span class="n">QAbstractSocket</span><span class="o">::</span><span class="n">SocketError</span><span class="p">)));</span>

    <span class="n">tailleMessage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">// Tentative de connexion au serveur</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">on_boutonConnexion_clicked</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">// On annonce sur la fenêtre qu'on est en train de se connecter</span>
    <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;Tentative de connexion en cours...&lt;/em&gt;"</span><span class="p">));</span>
    <span class="n">boutonConnexion</span><span class="o">-&gt;</span><span class="n">setEnabled</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>

    <span class="n">socket</span><span class="o">-&gt;</span><span class="n">abort</span><span class="p">();</span> <span class="c">// On désactive les connexions précédentes s'il y en a</span>
    <span class="n">socket</span><span class="o">-&gt;</span><span class="n">connectToHost</span><span class="p">(</span><span class="n">serveurIP</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">(),</span> <span class="n">serveurPort</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span> <span class="c">// On se connecte au serveur demandé</span>
<span class="p">}</span>

<span class="c">// Envoi d'un message au serveur</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">on_boutonEnvoyer_clicked</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QByteArray</span> <span class="n">paquet</span><span class="p">;</span>
    <span class="n">QDataStream</span> <span class="n">out</span><span class="p">(</span><span class="o">&amp;</span><span class="n">paquet</span><span class="p">,</span> <span class="n">QIODevice</span><span class="o">::</span><span class="n">WriteOnly</span><span class="p">);</span>

    <span class="c">// On prépare le paquet à envoyer</span>
    <span class="n">QString</span> <span class="n">messageAEnvoyer</span> <span class="o">=</span> <span class="n">tr</span><span class="p">(</span><span class="s">"&lt;strong&gt;"</span><span class="p">)</span> <span class="o">+</span> <span class="n">pseudo</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">()</span> <span class="o">+</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;/strong&gt; : "</span><span class="p">)</span> <span class="o">+</span> <span class="n">message</span><span class="o">-&gt;</span><span class="n">text</span><span class="p">();</span>

    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">quint16</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">messageAEnvoyer</span><span class="p">;</span>
    <span class="n">out</span><span class="p">.</span><span class="n">device</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">quint16</span><span class="p">)</span> <span class="p">(</span><span class="n">paquet</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">quint16</span><span class="p">));</span>

    <span class="n">socket</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">paquet</span><span class="p">);</span> <span class="c">// On envoie le paquet</span>

    <span class="n">message</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span> <span class="c">// On vide la zone d'écriture du message</span>
    <span class="n">message</span><span class="o">-&gt;</span><span class="n">setFocus</span><span class="p">();</span> <span class="c">// Et on remet le curseur à l'intérieur</span>
<span class="p">}</span>

<span class="c">// Appuyer sur la touche Entrée a le même effet que cliquer sur le bouton "Envoyer"</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">on_message_returnPressed</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">on_boutonEnvoyer_clicked</span><span class="p">();</span>
<span class="p">}</span>

<span class="c">// On a reçu un paquet (ou un sous-paquet)</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">donneesRecues</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c">/* Même principe que lorsque le serveur reçoit un paquet :</span>
<span class="c">    On essaie de récupérer la taille du message</span>
<span class="c">    Une fois qu'on l'a, on attend d'avoir reçu le message entier (en se basant sur la taille annoncée tailleMessage)</span>
<span class="c">    */</span>
    <span class="n">QDataStream</span> <span class="n">in</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tailleMessage</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">bytesAvailable</span><span class="p">()</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">quint16</span><span class="p">))</span>
             <span class="k">return</span><span class="p">;</span>

        <span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">tailleMessage</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">bytesAvailable</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tailleMessage</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>


    <span class="c">// Si on arrive jusqu'à cette ligne, on peut récupérer le message entier</span>
    <span class="n">QString</span> <span class="n">messageRecu</span><span class="p">;</span>
    <span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">messageRecu</span><span class="p">;</span>

    <span class="c">// On affiche le message sur la zone de Chat</span>
    <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">messageRecu</span><span class="p">);</span>

    <span class="c">// On remet la taille du message à 0 pour pouvoir recevoir de futurs messages</span>
    <span class="n">tailleMessage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">// Ce slot est appelé lorsque la connexion au serveur a réussi</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">connecte</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;Connexion réussie !&lt;/em&gt;"</span><span class="p">));</span>
    <span class="n">boutonConnexion</span><span class="o">-&gt;</span><span class="n">setEnabled</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="c">// Ce slot est appelé lorsqu'on est déconnecté du serveur</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">deconnecte</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;Déconnecté du serveur&lt;/em&gt;"</span><span class="p">));</span>
<span class="p">}</span>

<span class="c">// Ce slot est appelé lorsqu'il y a une erreur</span>
<span class="kt">void</span> <span class="n">FenClient</span><span class="o">::</span><span class="n">erreurSocket</span><span class="p">(</span><span class="n">QAbstractSocket</span><span class="o">::</span><span class="n">SocketError</span> <span class="n">erreur</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">erreur</span><span class="p">)</span> <span class="c">// On affiche un message différent selon l'erreur qu'on nous indique</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">QAbstractSocket</span><span class="o">::</span><span class="nl">HostNotFoundError:</span>
            <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;ERREUR : le serveur n'a pas pu être trouvé. Vérifiez l'IP et le port.&lt;/em&gt;"</span><span class="p">));</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">QAbstractSocket</span><span class="o">::</span><span class="nl">ConnectionRefusedError:</span>
            <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;ERREUR : le serveur a refusé la connexion. Vérifiez si le programme </span><span class="se">\"</span><span class="s">serveur</span><span class="se">\"</span><span class="s"> a bien été lancé. Vérifiez aussi l'IP et le port.&lt;/em&gt;"</span><span class="p">));</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">QAbstractSocket</span><span class="o">::</span><span class="nl">RemoteHostClosedError:</span>
            <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;ERREUR : le serveur a coupé la connexion.&lt;/em&gt;"</span><span class="p">));</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">listeMessages</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"&lt;em&gt;ERREUR : "</span><span class="p">)</span> <span class="o">+</span> <span class="n">socket</span><span class="o">-&gt;</span><span class="n">errorString</span><span class="p">()</span> <span class="o">+</span> <span class="n">tr</span><span class="p">(</span><span class="s">"&lt;/em&gt;"</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">boutonConnexion</span><span class="o">-&gt;</span><span class="n">setEnabled</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div>
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11391">Test du Chat et améliorations</h2>
		<div class="ss_part_texte">
		<span class="barre">Notre projet</span> Nos projets sont terminés !<br>
Nous avons fait le client et le serveur !<br>
<br>
Je vous propose de tester le bon fonctionnement du Chat dans un premier temps, et éventuellement de télécharger les projets tous prêts.<br>
Nous verrons ensuite comment vous pouvez améliorer tout cela. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h3>Tester le Chat</h3><br>
<br>
Avant toute chose, vous voudrez peut-être récupérer le projet tout prêt et zippé pour partir sur la même base que moi.<br>
<br>
<div class="centre"><span class="gros"><a href="http://www.siteduzero.com/uploads/fr/ftp/mateo21/cpp/chat.zip">Télécharger Chat.zip (60 Ko)</a></span></div><br>
<br>
Le zip contient un sous-dossier par projet : serveur et client.<br>
<br>
Vous pouvez exécuter directement les programmes serveur.exe et client.exe si vous êtes sous Windows (en n'oubliant pas de mettre les DLL de Qt dans le même répertoire). Si vous utilisez un autre OS, vous devrez recompiler le projet (faites un qmake et un make).<br>
<br>
<br>
Vous pouvez dans un premier temps tester le Chat en interne sur votre propre ordinateur. Je vous propose de lancer :<br>
<br>
<ul>
<li>Un serveur</li>
<li>Deux clients</li>
</ul><br>
Cela va nous permettre de simuler une conversation en interne sur notre ordinateur. Cela utilisera le réseau, mais à l'intérieur de votre propre machine. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
J'avoue que c'est un peu curieux, mais si ça fonctionne en interne, ça fonctionnera en réseau local et sur internet sans problème (pour peu que le port soit ouvert). C'est donc une bonne idée de faire ses tests en interne dans un premier temps.<br>
<br>
Voici ce que ça donne quand je me parle à moi-même :<br>
<br>
<div class="centre"><a href="http://uploads.siteduzero.com/files/124001_125000/124148.png"><img src="./cpp_files/124148.png" alt="Chat en interne"></a></div><br>
<br>
Comme vous pouvez le voir, tout fonctionne (sauf peut-être mon cerveau <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).<br>
<br>
Amusez-vous ensuite à tester le programme en réseau local ou sur internet avec des amis. Pensez à chaque fois à vérifier si le port est ouvert. Si vous avez un problème avec le programme, il y a 99% de chances que ça vienne du port.<br>
<br>
Voici une petite conversation en réseau local :<br>
<br>
<div class="centre"><img src="./cpp_files/124121(1).png" alt="Chat côté client"></div><br>
<br>
Je ne l'ai pas testé sur internet mais je sais pertinemment que ça fonctionne. Le principe du réseau est le même partout, que ce soit en interne, en local ou via internet. C'est juste l'IP qui change à chaque fois.<br>
<br>
<br>
<h3>Améliorations à réaliser</h3><br>
<br>
Bon, le moins qu'on puisse dire c'est que j'ai bien travaillé dans ce chapitre, maintenant à votre tour de bosser un peu. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
Voici quelques suggestions d'améliorations que vous pouvez réaliser sur le Chat, plus ou moins difficiles selon le cas :<br>
<br>
<ul>
<li>Vous pouvez <strong>griser la zone d'envoi des messages</strong> ainsi que le bouton "Envoyer" lorsque le client n'est pas connecté.</li>
<li>Sur la fenêtre du serveur, il devrait être assez facile d'<strong>afficher le nombre de clients qui sont connectés</strong>.</li>
<li>Plus délicat car ça demande un peu de réorganisation du code : au lieu d'avoir une QList de QTcpSocket, faites une QList d'objets de type Client.<br>
Il faudra <strong>créer une nouvelle classe Client</strong> qui va représenter un client. Elle aura des attributs comme : sa QTcpSocket, le pseudo (QString), pourquoi pas l'avatar (QPixmap), etc. A partir de là vous aurez alors beaucoup plus de souplesse dans votre Chat !</li>
<li>Vous pourriez alors facilement <strong>afficher le pseudo du membre qui vient se connecter</strong>. Pour le moment, on a juste "Un client vient de se connecter".</li>
<li>Plutôt graphique mais sympa : vous pourriez <strong>gérer la mise en forme des messages</strong> (gras, rouge...) ainsi que des <strong>smilies</strong>. Bon après il s'agit pas de recréer MSN (quoique, le principe est tout à fait le même <img src="./cpp_files/clin.png" alt=";)" class="smilies"> ) donc n'allez pas trop loin dans ce genre de fonctionnalités quand même.</li>
<li>Plus délicat, mais très intéressant : essayez d'<strong>afficher la liste des clients connectés</strong> sur la fenêtre des clients. Vous devriez rajouter un widget QListView pour afficher cette liste, ça vous ferait travailler MVC en plus. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Le plus délicat est de gérer la liste des connectés, car pour le moment le pseudo est directement intégré aux messages qui sont envoyés. Il faudrait essayer de gérer le contenu des paquets un peu différemment, à vous de voir.</li>
<li>Actuellement, le serveur est un peu minimal et ne gère pas tous les cas. Par exemple, si 2 clients envoient un message en même temps, il n'y a qu'une seule variable tailleMessage pour 2 messages en cours de réception. Je vous recommande de gérer plutôt <strong>1 tailleMessage par client</strong> (vous n'avez qu'à mettre tailleMessage dans la classe Client).</li>
</ul><br>
<br>
Je m'arrête là pour les suggestions, il y a déjà du travail !<br>
<br>
On pourrait aussi imaginer de permettre un Chat en privé entre certains clients, ou encore d'autoriser l'envoi de fichier sur le réseau (le tout étant de récupérer le fichier à envoyer sous forme de QByteArray).<br>
<br>
Enfin, n'oubliez pas que le réseau ne se limite pas au Chat. Si vous faites un jeu en réseau par exemple, il faudra non pas envoyer des messages texte, mais plutôt les actions des autres joueurs. Dans ce cas, le schéma des paquets envoyés deviendra un peu plus complexe, mais c'est nécessaire.<br>
<br>
A vous d'adapter un peu mon code, vous êtes grands maintenant, au boulot ! <img src="./cpp_files/clin.png" alt=";)" class="smilies">
		</div>
		<hr>
		
	<div id="chap_conclusion">
	Bon, je crois que c'était mon plus gros chapitre. Il était temps que je m'arrête. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
J'espère que vous avez apprécié cette partie sur Qt, nous avons vu beaucoup de choses (un peu trop même) et pourtant nous n'avons pas tout vu. <img src="./cpp_files/huh.png" alt=":o" class="smilies"><br>
<br>
Je vous laisse vous entraîner avec le réseau, les widgets, et pour tout le reste n'oubliez pas : il y a la doc ! Et les forums du Site du Zéro aussi, oui oui, c'est vrai.
	</div>
	
<div>
<br>

</div>

<hr>
<h2>Partie 4 : Annexes</h2>
<div>
Besoin d'aller encore plus loin ?<br>
Lisez donc les annexes !
</div>
	
	<hr>
	<h1 id="chap_11405">Ce que vous pouvez encore apprendre</h1>
	<div id="chap_intro">
	Qu'on se le dise : bien que le tutoriel C++ s'arrête là, vous ne savez pas tout sur tout. D'ailleurs, personne ne peut vraiment prétendre tout savoir sur le C++ et toutes ses bibliothèques.<br>
<br>
L'objectif n'est pas de <span class="italique">tout savoir</span>, mais d'<span class="souligne">être capable d'apprendre <span class="italique">ce dont vous avez besoin</span> lorsque c'est nécessaire</span>.<br>
<br>
Si je devais moi-même vous apprendre tout sur le C++, j'y passerais toute une vie (et encore, ça serait toujours incomplet). J'ai autre chose à faire, et j'en serais de toute façon incapable.<br>
Du coup, plutôt que de tout vous apprendre, j'ai choisi de vous enseigner de bonnes bases tout au long du cours. Cette annexe a pour but, maintenant que le cours est fini, de vous donner un certain nombre de pistes pour continuer votre apprentissage. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
J'ai découpé ce chapitre en 3 parties :<br>
<br>
<ul>
<li>Ce que vous pouvez encore apprendre sur le langage C++ lui-même.</li>
<li>Ce que vous pouvez encore apprendre sur la bibliothèque standard du C++, que nous avons seulement effleuré ici.</li>
<li>Ce que vous pouvez encore apprendre sur la bibliothèque Qt.</li>
</ul><br>
<div class="rmq information">Cette annexe est seulement là pour vous <strong>présenter</strong> de nouvelles notions, pas pour vous les expliquer. Ne soyez donc pas surpris si je suis beaucoup plus succint que d'habitude. Imaginez cette annexe comme un sommaire de ce qu'il vous reste à apprendre. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></div>
	</div>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11404">... sur le langage C++</h2>
		<div class="ss_part_texte">
		Le langage C++ est suffisamment riche pour qu'il vous reste encore de nombreuses notions à découvrir. Certaines d'entre elles sont particulièrement complexes, je ne vous le cache pas, et vous n'en aurez pas besoin tout le temps.<br>
<br>
<br>
Toutefois, au cas où vous en ayez besoin un jour, je vais vous présenter <span class="italique">rapidement</span> ces notions. A vous ensuite d'approfondir vos connaissances, par exemple en lisant des <a href="http://www.siteduzero.com/tutoriel-2-261-c.html">tutoriels écrits par d'autres Zéros sur le C++</a>, en lisant des livres dédiés au C++, ou tout simplement en faisant une recherche Google. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
Voici les notions que je vais vous présenter ici :<br>
<br>
<ul>
<li>L'héritage multiple</li>
<li>Le masquage de méthodes</li>
<li>Les exceptions</li>
<li>Les templates</li>
<li>Les namespaces</li>
<li>Les classes et fonctions amies</li>
<li>Les méthodes virtuelles pures et les classes abstraites</li>
</ul><br>
<br>
<h3>L'héritage multiple</h3><br>
<br>
L'héritage multiple consiste à hériter de plusieurs classes à la fois. Nous avons déjà fait cela dans la partie sur Qt, pour pouvoir utiliser une interface dessinée dans Qt Designer :<br>
<br>
<div class="centre"><img src="./cpp_files/125974.png" alt="Héritage multiple"></div><br>
<br>
Pour hériter de plusieurs classes, il suffit de mettre une virgule entre les noms de classe, comme on l'avait fait :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4</pre></td><td class="code"><div class="syntax"><pre><span class="k">class</span> <span class="nc">FenCalculatrice</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span><span class="p">,</span> <span class="k">private</span> <span class="n">Ui</span><span class="o">::</span><span class="n">FenCalculatrice</span>
<span class="p">{</span>

<span class="p">};</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
C'est une notion qui paraît simple mais qui, en réalité, est très complexe.<br>
<br>
En fait, la plupart des langages de programmation plus récents, comme Java et Ruby, ont carrément décidé de ne pas gérer l'héritage multiple. Pourquoi ? Parce que ça peut être utile dans certaines conditions assez rares, mais si on l'utilise mal (quand on débute) ça peut devenir un cauchemar à gérer.<br>
<br>
Bref, jetez un coup d'oeil à cette notion, mais juste un coup d'oeil de préférence, car vous ne devriez pas y avoir recours souvent. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Le masquage de méthodes</h3><br>
<br>
Lorsqu'une classe hérite d'une autre classe, il est possible d'avoir 2 méthodes du même nom (et du même prototype).<br>
<br>
Prenons un exemple :<br>
<br>
<div class="centre"><img src="./cpp_files/125988.png" alt="Masquage"></div><br>
<br>
Ici, la classe Guerrier qui hérite de Personnage possède une méthode qui s'appelle elle aussi coupDePoing. Si notre guerrier fait un coupDePoing, c'est la méthode définie dans Guerrier qui sera utilisée, celle de Personnage sera ignorée (masquée).<br>
<br>
Nanoc en parle plus en détail dans son <a href="http://www.siteduzero.com/tuto-3-32111-1-retour-sur-l-heritage.html#ss_part_2">tutoriel sur l'héritage</a>. N'hésitez pas à aller y jeter un oeil. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Les exceptions</h3><br>
<br>
Les exceptions sont un mécanisme du C++ qui permet de gérer les erreurs.<br>
<br>
En temps normal, pour vérifier qu'une fonction n'a pas eu d'erreur, celle-ci renvoie un booléen. Il nous suffit alors de tester la valeur de retour comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7
8</pre></td><td class="code"><div class="syntax"><pre><span class="k">if</span> <span class="p">(</span><span class="n">maFonction</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ca a marché !"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Erreur lors de l'appel de maFonction()"</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Ca marche, mais ce n'est pas très pratique dans un gros programme. En effet, parfois on a besoin de faire "remonter" l'erreur à la fonction appelante, parce qu'on ne peut pas traiter l'erreur de suite. Ici, on mélange le code "utile" du programme avec la gestion des erreurs.<br>
<br>
<br>
Un des gros intérêt des exceptions, c'est qu'elles vous permettent de regrouper vos erreurs. Cela fonctionne en 2 temps :<br>
<br>
<ul>
<li>On essaie (<strong>try</strong>) d'exécuter certaines fonctions.</li>
<li>Si une de ces fonctions a généré une erreur, on la récupère (<strong>catch</strong>) et on gère l'erreur dans un endroit bien défini du code.</li>
</ul><br>
<br>
Exemple :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></td><td class="code"><div class="syntax"><pre><span class="k">try</span> <span class="c">// On essaie d'exécuter les lignes de codes qui suivent</span>
<span class="p">{</span>
    <span class="n">maFonction</span><span class="p">();</span>
    <span class="n">autreFonction</span><span class="p">();</span>
    <span class="n">encoreUneAutreFonction</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">erreur</span><span class="p">)</span> <span class="c">// Si une erreur est survenue dans les lignes précédentes, on exécute ces lignes</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Erreur ! Raison : "</span> <span class="o">&lt;&lt;</span> <span class="n">erreur</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Il faut que les fonctions maFonction(), autreFonction() et encoreUneAutreFonction() envoient un message d'erreur à l'aide du mot-clé <strong>throw</strong> si jamais elles rencontrent une erreur. Dans ce cas, si une erreur est détectée, les instructions situées dans le bloc <strong>catch</strong> seront exécutées.<br>
<br>
Pour plus d'informations sur les exceptions, je vous recommande la lecture du <a href="http://www.siteduzero.com/tuto-3-26467-1-c-la-gestion-des-exceptions.html">tutoriel de Nanoc</a>.<br>
<br>
<div class="rmq information">Pour information, les exceptions ne sont pas bien utilisables avec la bibliothèque Qt, qui ne les prend pas correctement en charge. Vous ne pouvez donc pas vraiment utiliser d'exceptions dans un programme Qt.</div><br>
<br>
<br>
<h3>Les templates</h3><br>
<br>
Les templates sont une notion pratique et puissante du C++ que nous avons déjà rencontrée, sans vraiment expliquer le fonctionnement derrière.<br>
<br>
Imaginez que vous ayez besoin d'écrire une fonction (ou une classe) qui doit pouvoir accepter n'importe quel type de paramètre, et qui doit pouvoir retourner n'importe quel type. En fait, vous avez besoin d'écrire une fonction évolutive qui s'adapte à tous les types de données.<br>
<br>
Voici par exemple une fonction d'addition qui utilise le principe des templates :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5</pre></td><td class="code"><div class="syntax"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">addition</span><span class="p">(</span><span class="n">T</span> <span class="n">element1</span><span class="p">,</span> <span class="n">T</span> <span class="n">element2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">somme</span> <span class="o">=</span> <span class="n">element1</span> <span class="o">+</span> <span class="n">element2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">somme</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
La fonction annonce dès le début qu'elle utilise le principe des templates. Le <span class="code2 cpp"><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span> indique que le symbole T représente n'importe quel type de variable.<br>
<br>
Dans la fonction ensuite, on voit que celle-ci retourne un élément de type T et qu'elle en reçoit 2 de type T eux aussi. En fait, à la compilation, le "T" sera remplacé par le type nécessaire. Par exemple, <strong>T</strong> sera remplacé par <strong>int</strong> si vous appelez la fonction comme ceci :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">addition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c">// T sera remplacé par int car a, b et c sont des int</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les templates peuvent aussi être utilisés par des classes. Cela permet à la bibliothèque standard du C++ (et à Qt aussi d'ailleurs) de créer des classes qui gèrent des tableaux d'objets à taille variable.<br>
<br>
Dans le chapitre sur le réseau, nous avions par exemple utilisé un tableau QList qui utilisait le principe des templates :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="n">QList</span><span class="o">&lt;</span><span class="n">QTcpSocket</span> <span class="o">*&gt;</span> <span class="n">clients</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les QList sont des tableaux qui acceptent n'importe quel type de données et dont la taille peut varier. Entre les chevrons &lt; et &gt;, on indique à la classe ce qu'on va stocker à l'intérieur (ici des pointeurs sur QTcpSocket). <span class="souligne">Grâce aux templates, les QList peuvent donc stocker n'importe quel type de données</span> !<br>
<br>
Vous pouvez retrouver une <a href="http://www.siteduzero.com/tuto-3-32985-1-c-les-templates.html">explication plus détaillée des templates par foester</a> dans son tutoriel. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Les namespaces</h3><br>
<br>
Souvenez-vous. Dès le début du tutoriel C++, je vous ai fait utiliser les objets cout et cin qui permettent d'afficher un message dans la console et de récupérer le texte saisi au clavier.<br>
<br>
Voici le tout premier code source C++ que vous aviez découvert :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello world!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le préfixe "std::" correspond à ce qu'on appelle un namespace, c'est-à-dire <span class="italique">espace de nom</span> en français. Les namespaces sont utiles dans de très gros programmes où il y a beaucoup de noms de classes et de variables différents.<br>
<br>
Quand vous avez beaucoup de noms différents dans un programme, il y a un risque que 2 classes aient le même nom. Par exemple, vous pourriez utiliser 2 classes Couleur dans votre programme : une dans votre bibliothèque "Jeu3D" et une autre dans votre bibliothèque "Fenetre".<br>
Normalement, avoir 2 classes du même nom est interdit... sauf si ces classes sont chacune dans un namespace différent ! Imaginez que les namespaces sont comme des "boîtes" qui évitent de mélanger les noms de classes et de variables.<br>
<br>
<div class="centre"><img src="./cpp_files/126323.png" alt="Namespaces"></div><br>
<br>
Si la classe est dans un namespace, on doit placer le nom du namespace en préfixe devant :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="n">Jeu3D</span><span class="o">::</span><span class="n">Couleur</span> <span class="n">rouge</span><span class="p">;</span> <span class="c">// Utilisation de la classe Couleur située dans le namespace Jeu3D</span>
<span class="n">Fenetre</span><span class="o">::</span><span class="n">Couleur</span> <span class="n">vert</span><span class="p">;</span> <span class="c">// Utilisation d'une AUTRE classe appelée elle aussi Couleur, dans le namespace Fenetre</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
<br>
Le namespace "std" est utilisé par toute la bibliothèque standard du C++. Il faut donc mettre ce préfixe devant chaque nom issu de la bibliothèque standard (cout, cin, endl, string...).<br>
Il est aussi possible, comme je vous l'avais dit, d'utiliser la directive "using namespace" au début du fichier :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1</pre></td><td class="code"><div class="syntax"><pre><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Grâce à ça, dans tout le fichier le compilateur saura que vous faites références à des noms définis dans le namespace std. Cela vous évite d'avoir à répéter "std::" partout.<br>
<br>
<div class="rmq information">Certains programmeurs préfèrent éviter d'utiliser "using namespace" car, en lisant le code ensuite, on ne sait plus vraiment à quel namespace le nom se rapporte.</div><br>
<br>
Pour plus d'informations, lisez le <a href="http://www.siteduzero.com/tuto-3-24815-1-les-espaces-de-nom-namespace.html">tutoriel sur les namespaces de Vanger</a>.<br>
<br>
<br>
<h3>Les classes et fonctions amies</h3><br>
<br>
Vous vous souvenez de la notion de portée ? Je l'espère en tout cas !<br>
Non ? Si je vous dis "public", "private", "protected", ça vous revient ?<br>
<br>
Ah, j'aime mieux ça. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
Ces mots-clés servent à définir la portée d'un attribut ou d'une méthode dans une classe :<br>
<br>
<ul>
<li>Une méthode "<strong>public</strong>" pourra être appelée depuis n'importe quelle fonction de votre code.</li>
<li>Une méthode "<strong>private</strong>" ne pourra être appelée que par une autre méthode de votre classe..</li>
<li>Une méthode "<strong>protected</strong>" est identique à private, à la différence près que les classes filles y auront quand même accès elles aussi.</li>
</ul><br>
<br>
A cette liste, il faudrait rajouter la portée "<strong>friend</strong>". Je n'en ai pas parlé dans le cours car c'est une notion à double tranchant : elle peut être très pratique dans certains cas, mais si vous l'utilisez mal vous risquez de ne plus respecter le principe d'encapsulation (et donc coder comme des malpropres <img src="./cpp_files/pinch.png" alt="&gt;_&lt;" class="smilies">  ).<br>
<br>
Pour ceux qui veulent en savoir plus et qui me promettent de ne pas utiliser abusivement friend, je les autorise à lire le <a href="http://www.siteduzero.com/tuto-3-32379-1-l-amitie.html">tutoriel sur l'amitié de Nanoc</a> (friend = ami au cas où vous n'auriez pas percuté <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).<br>
<br>
<br>
<h3>Les méthodes virtuelles (pures) et les classes abstraites</h3><br>
<br>
Il y aurait beaucoup à dire sur les notions de méthodes virtuelles pures, méthodes virtuelles, classes virtuelles et classes abstraites. La pire erreur serait de mettre tout dans le même paquet. Ces notions sont chacune très différentes les unes des autres et ne signifient pas du tout la même chose à chaque fois (quel intérêt d'avoir mis des noms similaires ? Bah juste pour vous embrouiller <img src="./cpp_files/siffle.png" alt=":-°" class="smilies"> ).<br>
<br>
Ce que vous devez retenir c'est que ce sont des notions avancées de C++ dont on n'a besoin que dans des cas très précis, donc rares.<br>
<br>
Je vous conseille de vous attarder en premier sur la notion de méthodes virtuelles pures : ce sont des méthodes que l'on définit sans implémenter. Dans ce cas, la classe est dite "abstraite" et on ne peut pas l'instancier (on ne peut pas créer d'objets avec). L'implémentation de la méthode virtuelle pure doit alors être faite dans une classe fille.<br>
<br>
Cette notion est expliquée par cysboy dans son <a href="http://www.siteduzero.com/tuto-3-27760-1-les-classes-abstraites.html">tutoriel Java</a>. Oui c'est pour du Java je sais, mais le <span class="italique">principe </span>est le même et son tutoriel a l'avantage de montrer le principe à l'aide de nombreux schémas. <br>
Pour des explications spécifiques au C++, jetez un oeil au <a href="http://casteyde.christian.free.fr/cpp/cours/online/x3782.html">cours de Christian Casteyde</a> ou à la <a href="http://cpp.developpez.com/faq/cpp/?page=virtual#CLASS_fonction_vituelle">FAQ C++ de Developpez.com</a>.<br>
<br>
Je vous laisse faire des recherches supplémentaires à ce sujet si le coeur vous en dit, mais ne commencez pas par apprendre ça car ce sont des notions tout de même assez délicates.
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11403">... sur la bibliothèque standard</h2>
		<div class="ss_part_texte">
		Comme le C, le C++ propose une bibliothèque standard. L'avantage par rapport à une bibliothèque externe comme Qt, c'est justement que cette bibliothèque est installée par défaut sur tous les ordinateurs. Pas besoin de livrer des DLL supplémentaires.<br>
<br>
La bibliothèque standard du C++ est très riche (et parfois complexe). Je vous ai présenté quelques notions de base à ce sujet dans mon cours :<br>
<br>
<ul>
<li>Les entrées / sorties avec <strong>cin </strong>et <strong>cout</strong>.</li>
<li>Les chaînes de caractères à taille variable, avec la classe <strong>string</strong>.</li>
</ul><br>
<br>
Ca, c'est vraiment un tout petit bout de la bibliothèque standard C++ qui propose en fait de nombreux autres outils. Comme pour la classe string, ces outils sont plutôt faciles à utiliser et très pratiques, mais ils font appels à des mécanismes complexes en interne.<br>
<br>
<br>
<h3>Les différentes parties de la bibliothèque standard du C++</h3><br>
<br>
La bibliothèque standard du C++ peut être découpée comme ceci :<br>
<br>
<ul>
<li><strong>La bibliothèque de flux</strong> : c'est elle qui gère les flux d'entrée / sortie cin et cout, en utilisant en particulier les opérateurs &lt;&lt; et &gt;&gt;.</li>
<li><strong>La gestion des chaînes de caractères</strong> : avec la classe string.</li>
<li><strong>La bibliothèque standard du C</strong> : elle est aussi utilisable en C++. En effet, certaines fonctions basiques (comme les fonctions mathématiques) n'ont pas été réécrites en C++ car cela n'aurait eu aucun intérêt. Par conséquent, on utilise toujours les fonctions du C.</li>
<li><strong>La bibliothèque standard de templates, aussi appelée STL</strong> (Standard Template Library) : c'est une grosse grosse partie de la bibliothèque standard du C++ qui utilise massivement le principe des templates que je vous ai présenté un peu plus haut.</li>
</ul><br>
<br>
<h3>La STL</h3><br>
<br>
C'est clairement le plus gros morceau de la bibliothèque standard du C++. Il s'agit d'un ensemble de classes et d'algorithmes qui utilisent les templates pour créer des conteneurs capables de stocker n'importe quel type de données.<br>
<br>
<br>
<h4>Présentation de la STL</h4><br>
<br>
Quand on veut stocker plusieurs objets du même type en temps normal, on utilise généralement un tableau :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2</pre></td><td class="code"><div class="syntax"><pre><span class="kt">int</span> <span class="n">tableauEntiers</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">string</span> <span class="n">tableauChaines</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le problème, c'est que <span class="souligne">ce genre de tableau a une taille fixe</span>. Le premier ne peut stocker que 10 entiers, et le second que 5 chaînes (string) maximum.<br>
<br>
Parfois, on ne sait pas combien de données différentes notre tableau va contenir. Ca peut très bien être 3 comme 300... Imaginez par exemple un jeu en ligne : on ne sait pas combien de joueurs vont participer à l'avance quand on écrit le code. Rappelez-vous de notre programme de Chat : on ne sait pas combien de gens vont chatter.<br>
<br>
<div class="rmq question">Je sais ! On n'a qu'à créer un très grand tableau pour être sûr de pouvoir tout stocker !<br>
<span class="code2 cpp"><span class="kt">int</span> <span class="n">tableauEntiers</span><span class="p">[</span><span class="mi">999999</span><span class="p">];</span>
</span> et hop là ! Le problème est réglé ! <img src="./cpp_files/heureux.png" alt=":D" class="smilies"></div><br>
<br>
Ca va pas la tête ? <img src="./cpp_files/blink.gif" alt="o_O" class="smilies"> <br>
En faisant ça, vous consommez beaucoup trop de mémoire inutilement. Ce n'est pas du tout efficace.<br>
<br>
En fait, le top serait d'avoir un tableau dont la taille change en fonction des besoins. Il fait 3 cases s'il y a 3 éléments, il s'agrandit automatiquement à 4 cases si on ajoute un élément, se réduit à 2 cases si on en enlève un.<br>
<br>
Figurez-vous que c'est tout le principe de la STL. Elle propose des classes "conteneur" qui se comportent comme des tableaux dynamiques (= à taille variable). Le truc, c'est que la STL propose de très nombreuses classes conteneur. On aurait pu se dire qu'une aurait suffit, mais en fait non. <img src="./cpp_files/heureux.png" alt=":D" class="smilies"><br>
<br>
Tout dépend de vos besoins. La <a href="http://cpp.developpez.com/faq/cpp/?page=STL">FAQ STL de Developpez.com</a> propose <a href="http://cpp.developpez.com/faq/cpp/?page=STL#STL_choix_conteneur">un schéma</a> qui fait un peu peur au début mais qui résume en fait très bien la situation.<br>
Tout dépend comme vous le voyez si vous avez besoin de créer un tableau ordonné ou si au contraire l'ordre n'a pas d'importance. Tout dépend aussi de la fréquence à laquelle vous allez insérer des éléments dans les conteneurs, de la façon dont vous voulez les lire, etc.<br>
<br>
Dans tous les cas, les conteneurs sont capables de stocker n'importe quel type de données grâce aux templates.<br>
<br>
<br>
<h4>Liste des classes de la STL</h4><br>
<br>
Voici une liste des différents conteneurs proposés par la STL :<br>
<br>
<ul>
<li>stack</li>
<li>queue</li>
<li>priority_queue</li>
<li>list</li>
<li>vector</li>
<li>dequeue</li>
<li>map</li>
<li>set</li>
<li>multi_map</li>
<li>multi_set</li>
</ul><br>
<br>
Chacun d'entre eux a ses spécificités. Le <a href="http://cpp.developpez.com/faq/cpp/?page=STL#STL_choix_conteneur">schéma</a> dont je vous ai parlé vous permet de faire votre choix parmi la jungle des conteneurs disponibles.<br>
<br>
<br>
<h4>Un exemple simple : la classe vector</h4><br>
<br>
Commencez par exemple par la classe vector, c'est un bon début pour découvrir la STL.<br>
<br>
On peut se servir de vector comme d'un tableau à taille dynamique. Voici un exemple d'utilisation, pour un vector qui va stocker des int :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre>1
2
3
4
5
6
7</pre></td><td class="code"><div class="syntax"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tableauEntiers</span><span class="p">;</span> <span class="c">// Création d'un tableau d'entiers à taille variable</span>

<span class="n">tableauEntiers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span> <span class="c">// Insère 14</span>
<span class="n">tableauEntiers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span> <span class="c">// Insère 27</span>
<span class="n">tableauEntiers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">83</span><span class="p">);</span> <span class="c">// Insère 83</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tableauEntiers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c">// Affiche 27</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Le vector ne nécessite donc pas que l'on définisse une taille lors de sa création. On ajoute des éléments à la fin du tableau avec la méthode push_back(). On peut ensuite accéder à n'importe quel élément du vector comme si c'était un tableau (merci la surcharge de l'opérateur [] ! ).<br>
<br>
<div class="rmq information">Pour connaître la taille actuelle du tableau, appelez la méthode size(). Dans notre exemple précédent, cette méthode aurait renvoyé 3.</div><br>
<br>
Il y aurait beaucoup à dire encore sur les vector. Nanoc leur a justement dédié un <a href="http://www.siteduzero.com/tuto-3-29540-1-les-tableaux-dynamiques.html">tutoriel</a> que je vous invite à lire. <img src="./cpp_files/smile.png" alt=":)" class="smilies"><br>
<br>
<br>
<h4>Les algorithmes</h4><br>
<br>
La STL propose de nombreuses fonctions capables d'effectuer des opérations sur ces conteneurs :<br>
<br>
<ul>
<li>Copier le tableau</li>
<li>Trier les éléments dans le tableau</li>
<li>Trouver l'élément le plus petit ou le plus grand</li>
<li>Scinder ou fusionner un tableau</li>
<li>Rechercher dans un tableau</li>
<li>Supprimer les doublons</li>
</ul><br>
<br>
Bref, toutes les opérations de base sont déjà codées pour vous ! Il n'y a plus qu'à les utiliser.<br>
<br>
<br>
<h3>Où trouver de la documentation ?</h3><br>
<br>
Comme je ne peux pas vous expliquer tout ça à moins d'y passer un temps fou, il faudra lire la documentation ou rechercher d'autres tutoriels.<br>
<br>
Personnellement, bien qu'il n'y ait pas de "site officiel" comme pour Qt, j'ai tendance à utiliser ce site comme documentation de référence pour la bibliothèque standard du C++ :<br>
<br>
<div class="centre"><span class="gros"><a href="http://www.cppreference.com/">www.cppreference.com</a></span></div><br>
<br>
Vous y retrouverez en particulier la liste des classes de la STL et des algorithmes qui y sont proposés.<br>
<br>
Bonne lecture <img src="./cpp_files/smile.png" alt=":)" class="smilies">
		</div>
		<hr>
		
		<hr class="separateur_parties">
		<h2 id="ss_part_11402">... sur la bibliothèque Qt</h2>
		<div class="ss_part_texte">
		Dans le cours, nous avons eu largement le temps d'étudier la bibliothèque Qt et de découvrir à quel point il était simple de créer des GUI (fenêtres).<br>
<br>
Nous avons aussi découvert que cette bibliothèque était énorme, et qu'on devait plutôt parler de <span class="italique">framework</span> (ensemble de bibliothèques).<br>
Je vous rappelle que Qt est constitué de plusieurs modules :<br>
<br>
<ul>
<li>GUI</li>
<li>OpenGL</li>
<li>Dessin</li>
<li>Réseau</li>
<li>SVG</li>
<li>Scripts</li>
<li>XML</li>
<li>SQL</li>
<li>Core</li>
</ul><br>
En ce qui nous concerne, nous avons eu l'occasion de bien faire le tour du module GUI (c'était le but !) et nous nous sommes initiés aussi un peu au réseau.<br>
<br>
Malgré cela, nous n'avons pas tout tout vu sur le module GUI. D'autre part, nous avons seulement effleuré le module réseau, et nous n'avons pas du tout parlé des autres modules.<br>
Je vais, dans cette annexe, vous présenter brièvement quelques-uns de ces modules. Je ne vais pas vous les expliquer (ce serait beaucoup trop long !), juste vous en parler pour vous donner quelques pistes.<br>
<br>
Surtout, pensez à vous rendre sur <a href="http://doc.trolltech.com/">la doc</a> pour en savoir plus ! <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h3>Module GUI : des petites fonctionnalités cachées</h3><br>
<br>
Il y a quelques widgets et fonctionnalités plus rares dont je n'ai pas eu l'occasion de parler. Je vais vous en présenter quelques-uns rapidement ici. Ils ne sont pas toujours utiles mais ça peut être bien de savoir qu'ils existent.<br>
<br>
Cette liste des autres fonctionnalités à découvrir n'est pas complète, loin de là. Je ne connais pas tout. Je vous donne juste une idée des "petites choses" que vous pouvez découvrir si vous passez un peu de temps dans la doc. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<br>
<h4>QCalendarWidget : un calendrier tout prêt</h4><br>
<br>
Le widget <a href="http://doc.trolltech.com/qcalendarwidget.html">QCalendarWidget</a> permet d'afficher un calendrier :<br>
<br>
<div class="centre"><img src="./cpp_files/126300.png" alt="QCalendarWidget"></div><br>
<br>
Si vous devez réaliser un agenda ou si l'utilisateur doit sélectionner une date, nul doute que ce widget vous fera gagner un temps fou !<br>
<br>
<br>
<h4>QSplashScreen : pour faire patienter au démarrage</h4><br>
<br>
Parfois, certains programmes sont un peu longs à charger. Pour faire patienter l'utilisateur, on affiche un "splash screen", c'est-à-dire une petite image au centre de l'écran. C'est ce que fait Code::Blocks au démarrage par exemple.<br>
<br>
Qt permet de créer un "splash screen" avec la classe <a href="http://doc.trolltech.com/qsplashscreen.html">QSplashScreen</a>. On l'utilise en général dans le main, juste avant d'ouvrir la fenêtre principale :<br>
<br>
<span class="code">Code : C++ - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 cpp"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></td><td class="code"><div class="syntax"><pre><span class="cp">#include &lt;QApplication&gt;</span>
<span class="cp">#include &lt;QTranslator&gt;</span>
<span class="cp">#include &lt;QLocale&gt;</span>
<span class="cp">#include &lt;QLibraryInfo&gt;</span>
<span class="ln-xtra"><span class="cp">#include &lt;QSplashScreen&gt;</span></span>
<span class="ln-xtra"><span class="cp">#include &lt;QPixmap&gt;</span></span>
<span class="cp">#include "FenPrincipale.h"</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

<span class="ln-xtra">    <span class="n">QSplashScreen</span> <span class="n">splash</span><span class="p">(</span><span class="n">QPixmap</span><span class="p">(</span><span class="s">"znavigo.png"</span><span class="p">),</span> <span class="n">Qt</span><span class="o">::</span><span class="n">WindowStaysOnTopHint</span><span class="p">);</span></span>
<span class="ln-xtra">    <span class="n">splash</span><span class="p">.</span><span class="n">show</span><span class="p">();</span></span>

    <span class="c">// Traduction des chaînes prédéfinies par Qt dans notre langue</span>
    <span class="n">QString</span> <span class="n">locale</span> <span class="o">=</span> <span class="n">QLocale</span><span class="o">::</span><span class="n">system</span><span class="p">().</span><span class="n">name</span><span class="p">();</span>
    <span class="n">QTranslator</span> <span class="n">translator</span><span class="p">;</span>
    <span class="n">translator</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="s">"qt_"</span><span class="p">)</span> <span class="o">+</span> <span class="n">locale</span><span class="p">,</span> <span class="n">QLibraryInfo</span><span class="o">::</span><span class="n">location</span><span class="p">(</span><span class="n">QLibraryInfo</span><span class="o">::</span><span class="n">TranslationsPath</span><span class="p">));</span>
    <span class="n">app</span><span class="p">.</span><span class="n">installTranslator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">translator</span><span class="p">);</span>

    <span class="c">// Ouverture de la fenêtre principale du navigateur</span>
    <span class="n">FenPrincipale</span> <span class="n">principale</span><span class="p">;</span>
    <span class="n">principale</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Résultat :<br>
<br>
<div class="centre"><img src="./cpp_files/126309.png" alt="Splash screen"></div><br>
<br>
Le splash screen peut être arrêté en cliquant dessus.<br>
Après, libre à vous de l'arrêter automatiquement au bout d'un certain temps, il faut juste chercher dans la doc comment faire.<br>
<br>
<br>
<h4>Afficher une icône dans le system tray</h4><br>
<br>
Pour certaines applications résidentes en mémoire, il peut être utile de placer une icône dans le system tray, oui là à côté de l'horloge vous savez. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Qt permet justement de le faire avec QSystemTrayIcon :<br>
<br>
<br>
<div class="centre"><img src="./cpp_files/126310.png" alt="System tray"></div><br>
<br>
Le mieux pour apprendre à s'en servir est de jeter un oeil à l'<a href="http://doc.trolltech.com/desktop-systray.html">exemple fourni dans la doc de Qt</a>.<br>
<br>
<br>
<h3>Module réseau : utilisez des classes de haut niveau</h3><br>
<br>
Dans notre découverte du réseau, nous avons utilisé des QTcpSocket et un QTcpServer. C'est une gestion assez bas niveau des paquets et il nous a fallu apprendre un peu comment le réseau fonctionnait.<br>
On aurait pu parler des paquets UDP aussi, mais on les utilise vraiment dans des cas spécifiques.<br>
<br>
En revanche, ce qu'on n'a pas vu, c'est qu'il y a des classes de plus haut niveau qui vous évitent d'avoir à manipuler les paquets TCP directement. Je pense en particulier à :<br>
<br>
<ul>
<li><strong>QHttp </strong>: vous permet d'utiliser le protocole HTTP et donc de télécharger des pages web ou des fichiers via le web.</li>
<li><strong>QFtp </strong>: vous permet de télécharger et d'envoyer des fichiers par FTP. Vous pourriez créer votre propre client FTP comme Filezilla par exemple. <img src="./cpp_files/clin.png" alt=";)" class="smilies"></li>
</ul><br>
<br>
Ces classes sont beaucoup plus faciles à utiliser que celles que nous avons vues, donc n'hésitez pas à y jeter un oeil.<br>
Elles sont brièvement introduites dans la <a href="http://doc.trolltech.com/qtnetwork.html">page d'accueil du module</a> réseau sur la doc de Qt.<br>
<br>
<br>
<h3>Module SQL : accès aux bases de données</h3><br>
<br>
Si votre programme doit enregistrer de nombreuses données, il peut être utile de les stocker dans une base de données. C'est un système puissant pour enregistrer des informations, mais il faut connaître le langage SQL pour écrire et lire des informations dedans.<br>
<br>
Qt propose tout ce qu'il faut pour se connecter à une base de données dans votre programme, mais il n'inclue pas la base de données... ce sera à vous de l'installer. En clair, si vous utilisez MySQL comme base de données, il faudra d'abord aller installer MySQL sur le <a href="http://www.mysql.fr/">site officiel</a> avant de pouvoir établir une connexion avec dans votre programme.<br>
<br>
<div class="rmq information">MySQL est un système de gestion de base de données puissant mais évitez d'y avoir recours systématiquement dans vos programmes. Ce serait un peu utiliser un tank équipé de missiles nucléaires pour tuer une mouche.<br>
Parfois, stocker les meilleurs scores dans un jeu pour être facilement fait dans des fichiers (avec QFile par exemple) sous forme de texte simple ou au format XML (je vais en parler un peu plus loin). Inutile de sortir l'artillerie lourde MySQL pour ça.<br>
<br>
Si toutefois vous avez vraiment besoin d'une base de données mais que vous ne voulez pas utiliser MySQL qui est un peu gros, jetez un oeil du côté de <a href="http://fr.wikipedia.org/wiki/SQLite">SQLite</a> qui est tout léger (mais un peu moins complet).</div><br>
<br>
Une fois que vous avez installé votre système de gestion de base de données sur votre ordinateur, vous pouvez découvrir comment y faire appel depuis Qt. Le mieux est de lire l'<a href="http://doc.trolltech.com/qtsql.html">introduction au module QtSql</a> sur la doc. En tout cas c'est ce que je ferais à votre place.<br>
<br>
En quelques minutes de lecture de cette seule page, vous devriez déjà savoir vous connecter à la base de données et exécuter des requêtes SQL (mais attention, il faut connaître le langage SQL avant !).<br>
<br>
<br>
<h3>Module XML : pour ceux qui doivent gérer des données au format XML</h3><br>
<br>
Le XML est un langage générique qui est à la base de nombreux autres langages, comme XHTML (qui permet de créer des pages web).<br>
<br>
Le principe de XML peut être très vite compris si vous avez déjà fait du XHTML avant. En gros, c'est vous qui définissez vos propres balises :<br>
<br>
<span class="code">Code : XML - <a href="#" class="select_code">Sélectionner</a></span><div class="code2 xml"><table class="syntaxtable"><tbody><tr><td class="linenos"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></td><td class="code"><div class="syntax"><pre><span class="nt">&lt;bibliotheque&gt;</span>
	<span class="nt">&lt;livre&gt;</span>
		<span class="nt">&lt;auteur&gt;</span>J.R.R. Tolkien<span class="nt">&lt;/auteur&gt;</span>
		<span class="nt">&lt;titre&gt;</span>Le seigneur des anneaux<span class="nt">&lt;/titre&gt;</span>
	<span class="nt">&lt;/livre&gt;</span>
	<span class="nt">&lt;livre&gt;</span>
		<span class="nt">&lt;auteur&gt;</span>R. Barjavel<span class="nt">&lt;/auteur&gt;</span>
		<span class="nt">&lt;titre&gt;</span>La nuit des temps<span class="nt">&lt;/titre&gt;</span>
	<span class="nt">&lt;/livre&gt;</span>
<span class="nt">&lt;/bibliotheque&gt;</span>
</pre></div>
</td></tr></tbody></table></div><br>
<br>
Les données sont placées entre des balises que vous définissez. L'avantage du XML est qu'il est facile à lire (enfin, tant que le fichier n'est pas trop gros ou trop complexe).<br>
<br>
Vous pouvez vous servir de cette technique pour organiser vos données dans des fichiers sans avoir recours à une base de données. D'autre part, le XML est un format d'échange devenu courant de nos jours, et il est possible que quelqu'un vous "envoie" des données au format XML que vous devrez traiter dans votre programme.<br>
<br>
Pour lire le contenu d'un document XML comme celui ci-dessus (et pour écrire du XML aussi), il y a le module QtXml qui permet de faire cela facilement. Il vous faudra acquérir avant un peu de théorie sur le fonctionnement de XML (DOM, SAX, XQuery, DTD, XML Schema...). Il vaut mieux être rôdé sur la théorie de XML avant de s'y lancer sinon vous n'en profiterez pas. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
<div class="rmq information">Je vous conseille de lire cette petite <a href="http://www.siteduzero.com/tuto-3-2882-1-le-point-sur-xml.html">introduction à XML</a> sur le Site du Zéro avant de faire des recherches plus approfondies.<br>
<a href="http://fr.wikipedia.org/wiki/Extensible_Markup_Language">Wikipédia</a> est une bonne source de départ aussi.</div><br>
<br>
Une fois que vous connaissez un peu mieux le fonctionnement de XML, direction la <a href="http://doc.trolltech.com/qtxml.html">page d'accueil du module QtXml</a> pour découvrir les outils que Qt met à votre disposition pour lire et écrire du XML. Il y a de quoi faire, et encore une fois je vous le rappelle, mieux vaut être armé et connaître XML avant de se lancer là-dedans !<br>
<br>
<br>
<h3>Module Core : toutes les fonctionnalités de base de Qt</h3><br>
<br>
Le module QtCore contient des classes de base de Qt qui n'ont pas de rapport avec les GUI et qui peuvent donc être utilisées dans un programme purement console.<br>
<br>
Dans ce module, on trouve un certain nombre de classes que vous connaissez déjà :<br>
<br>
<ul>
<li><strong>QString </strong>: gestion des chaînes de caractères.</li>
<li><strong>QByteArray </strong>: une suite d'octets (on s'en est servi dans le programme de Chat pour construire des paquets).</li>
<li><strong>QFile </strong>: accès aux fichiers.</li>
<li><strong>QLocale </strong>: permet d'accéder aux habitudes de représentation des nombres et chaînes dans différentes langues.</li>
<li><strong>QList </strong>: une liste capable de stocker un tableau à taille dynamique (cette classe est une version "Qt" de ce qui se fait dans la STL dont je vous ai parlé plus haut).</li>
<li><strong>QUrl </strong>: représente une URL.</li>
</ul><br>
<br>
Voilà quelques exemples de classes du module QtCore que vous avez déjà utilisées. Comme vous le voyez, ces classes font partie du "coeur" de Qt et pas du module GUI car elles peuvent être réutilisées dans tous les autres modules.<br>
<br>
Jetez donc un oeil à la <a href="http://doc.trolltech.com/qtcore.html">liste des classes du module QtCore</a>. Il y a de quoi faire, et on retrouve notamment de nombreuses versions "Qt" de classes présentes dans la STL (il y a même un <a href="http://doc.trolltech.com/qvector.html">QVector</a> !).<br>
<br>
Bonne pêche !
		</div>
		<hr>
		
	<div id="chap_conclusion">
	J'espère que cette annexe aura rempli son rôle : vous aider à regarder dans de nouvelles directions. L'inconnu, ça fait un peu peur au début, mais on s'y fait très vite vous verrez. <img src="./cpp_files/clin.png" alt=";)" class="smilies"><br>
<br>
Comme vous avez pu le voir, tout ce que vous pouvez faire en C++ (et en programmation en général) est tellement riche qu'on n'aurait jamais assez d'une vie pour tout connaître. J'espère que vous me comprenez maintenant. <img src="./cpp_files/langue.png" alt=":p" class="smilies"><br>
<br>
Plutôt que de tout apprendre, essayez plutôt de découvrir une nouvelle notion à la fois. Si vous vous éparpillez trop, vous aurez du mal à bien assimiler ces connaissances.<br>
<br>
Bon courage, et bonne continuation ! <img src="./cpp_files/smile.png" alt=":)" class="smilies">
	</div>
	
<div>
<br>

</div>


<hr>

<div id="btuto_conclusion">
	Le cours de C++ s'arrête là !<br>
<br>
J'espère que vous aurez appris au moins autant de choses que vous ne l'espériez, et surtout que vous avez formé votre esprit à être capable de programmer en toutes circonstances par la suite.<br>
<br>
N'hésitez pas à lire la dernière annexe "Ce que vous pouvez encore apprendre", qui vous donne de nombreuses ouvertures pour continuer votre apprentissage si vous le désirez. <img src="./cpp_files/smile.png" alt=":)" class="smilies">
</div>


<div class="infobox cadre_auteur_date" id="tuto_details">
  <form action="http://www.siteduzero.com/tutoriel-54-11406.html" method="post">
    <div class="dnone"><input type="hidden" value="ed76eab401a049a91b67ae7f6cc351d083c1edd5" name="challenge"></div>

    <h3 class="special">Informations sur le tutoriel</h3>
   
    <div class="conteneur_infobox">
	<a href="#onglets_tutos">Retour en haut <img src="./cpp_files/fleche_haut.png" alt="Retour en haut" title="Retour en haut"></a>
	<br>
   	<br>			
<strong>Créé</strong> : Le 18/09/2007 à 17:13:58<br>
<strong>Modifié</strong> : Hier à 15:51:57<br>

<strong>Avancement</strong> : 100%<br>

<br>


<a href="http://www.siteduzero.com/tutoriel-50-11406-69571-apprenez-a-programmer-en-c.html#r69571">202 commentaires</a><br>

  <a href="http://www.siteduzero.com/tutoriel-3-11406-apprenez-a-programmer-en-c.html">Revenir au sommaire du tutoriel</a><br>


    </div>
  </form>
</div>

<div class="clearer"></div>

                </div>
            </div>

            <div id="footer">
                <ul>
                    <li>
                        Le Site du Zéro
                        <ul>
                            <li><a href="http://www.siteduzero.com/plan.html">Plan du site</a></li>
                            <li><a href="http://www.siteduzero.com/membres-304.html">L'équipe</a></li>
                            <li><a href="http://www.siteduzero.com/mentions.html">Mentions légales</a></li>
                            <li><a href="http://www.siteduzero.com/accessibilite.html" accesskey="0">Accessibilité</a></li>
                            <li><a href="http://www.siteduzero.com/livreor.html">Livre d'or</a></li>
                            <li><a href="http://suggestions.siteduzero.com/">Suggestions <sup style="color:green;">Nouveau !</sup></a></li>
                        </ul>
                    </li>
                    <li>
                        Simple IT
                        <ul>
                            <li><a href="http://www.siteduzero.com/simpleit.html">Qui sommes-nous ? </a></li>
                            
                                <li><a href="http://www.siteduzero.com/formations.html">Formation professionnelle</a></li>
                                <li><a href="http://www.siteduzero.com/recrutement.html">Recrutement</a></li>
                            
                            <li><a href="http://www.simple-it.fr/blog/">Notre blog</a></li>
                        </ul>
                    </li>
                    <li>
                        Contacts
                        <ul>
                            <li><a href="http://www.siteduzero.com/publicite-440.html">Espace annonceurs</a></li>
                            <li><a href="http://www.siteduzero.com/presse.html">Espace presse</a></li>
                            <li><strong><a href="http://www.siteduzero.com/contact.html" accesskey="7">Nous contacter</a></strong></li>
                            <li><a href="http://www.siteduzero.com/promouvoir.html">Promouvoir le site</a></li>
                            <li><a href="http://bugs.siteduzero.com/">Signaler un bug</a></li>
                        </ul>
                    </li>
                    
                        <li>
                            Partenaires 
                            <ul>
                                <li><a href="http://www.planethoster.net/?a_aid=SiteDuZero&a_bid=bf0ae269">Hébergement web</a></li>
                                <li><a href="http://www.zcorrecteurs.fr/">Correction tutoriels</a></li>
                            </ul>
                        </li>
                    
                    <li>
                        Suivez-nous
                        <ul class="dernier">
                            <li><a href="http://www.siteduzero.com/Templates/xml/news_fr.xml"><img src="./cpp_files/rss_mini.png" alt="Flux RSS"> Flux RSS News</a>, <a href="http://www.siteduzero.com/Templates/xml/tutoriels_fr.xml">Cours</a>, <a href="http://www.simple-it.fr/blog/index.php?feed/atom">Blog</a></li>
                            <li><a href="http://www.siteduzero.com/twitter.html"><img src="./cpp_files/twitter_mini.png" alt="Twitter"> Twitter</a></li>
                            <li><a href="http://www.facebook.com/siteduzero"><img src="./cpp_files/fb_mini.png" alt="Facebook"> Facebook</a></li>
                        </ul>
                    </li>
                </ul>

                
            </div>

            


            
            <script type="text/javascript" src="./cpp_files/scripts_lang.min.js"></script>
            <script type="text/javascript" src="./cpp_files/scripts.min.js"></script>
            <script type="text/javascript" src="./cpp_files/lib.min.js"></script>

            
                <script type="text/javascript">
    var addthis_config = {  ui_508_compliant: true,
                            ui_cobrand: "Site du Zéro",
                            ui_header_color: "#ffffff",
                            ui_header_background: "#7AB7FC",
                            username: "simpleit",
                            services_exclude: 'print,pdfonline,email,twitter,facebook,myspace,googlebuzz,blogger,buzz,live',
                            data_track_clickback: true  };
                        
    var addthis_share = {templates: { twitter:'{{title}} {{url}} #SdZ' } };

    $('div.slidable').hide();
    $('a.expend').show();
    $('a.expend').removeAttr('style');
    
    $('.expend').click(function(e)
    {
        e.preventDefault();
        $(this).hide('fast');
        $(this).next('div.slidable').slideToggle('fast');
    });
   
</script>
<script type="text/javascript" src="./cpp_files/addthis_widget.js"></script>
            

            <div class="droite printnone">
                <a href="http://www.xiti.com/xiti.asp?s=129196" title="WebAnalytics">
                    <script type="text/javascript">
                        <!--
                        Xt_param = 's=129196&p=%2Ftutoriel-3-11406-apprenez-a-programmer-en-c.html%3Fall%3D1';
                        try {Xt_r = top.document.referrer;}
                        catch(e) {Xt_r = document.referrer; }
                        Xt_h = new Date();
                        Xt_i = '<img width="80" height="15" border="0" ';
                        Xt_i += 'src="http://logv23.xiti.com/g.xiti?'+Xt_param;
                        Xt_i += '&hl='+Xt_h.getHours()+'x'+Xt_h.getMinutes()+'x'+Xt_h.getSeconds();
                        if(parseFloat(navigator.appVersion)>=4)
                        {
                        Xt_s=screen;Xt_i+='&r='+Xt_s.width+'x'+Xt_s.height+'x'+Xt_s.pixelDepth+'x'+Xt_s.colorDepth;
                        }
                        document.write(Xt_i+'&ref='+Xt_r.replace(/[<>"]/g, '').replace(/&/g, '$')+'">');
                        //-->
                    </script><img width="80" height="15" border="0" src="./cpp_files/g.xiti">
                    <object>
                        <noscript>
                            &lt;p&gt;&lt;img width="80" height="15" src="http://logv23.xiti.com/g.xiti?s=129196&amp;amp;p=&amp;amp;" alt="WebAnalytics" /&gt;&lt;/p&gt;
                        </noscript>
                    </object>
                </a>
                <script type="text/javascript">
                    var _gaq = _gaq || [];
                    _gaq.push(['_setAccount', 'UA-19807070-2']);
                    _gaq.push(['_trackPageview']);

                    (function() {
                    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                    })();
                </script>
            </div>

            <!-- /#2 662/#0.6291/#0.5039/# -->
	
    


<div style="display: none; position: absolute; overflow-x: hidden; overflow-y: hidden; z-index: 1000; outline-width: 0px; outline-style: initial; outline-color: initial; " class="ui-dialog ui-widget ui-widget-content ui-corner-all " tabindex="-1" role="dialog" aria-labelledby="ui-dialog-title-dialog_bientot"><div class="ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix" unselectable="on"><span class="ui-dialog-title" id="ui-dialog-title-dialog_bientot" unselectable="on">Bientôt sur le Site du Zéro.</span><a href="#" class="ui-dialog-titlebar-close ui-corner-all" role="button" unselectable="on"><span class="ui-icon ui-icon-closethick" unselectable="on">close</span></a></div><div id="dialog_bientot" style="" class="ui-dialog-content ui-widget-content">
                <p>Le Site du Zéro vous proposera bientôt de nouveaux cours partant de Zéro dans d'autres domaines que l'informatique ! </p>
                 <a style="color:#2677C9;text-decoration:none;" href="http://www.siteduzero.com/tutoriel-1-433-sciences.html">Découvrir les cours scientifiques</a>
            </div><div class="ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"><button type="button" class="ui-state-default ui-corner-all">Ok</button></div></div><div id="tooltip" style="display: none; "><h3></h3><div class="body"></div><div class="url"></div></div></body></html>
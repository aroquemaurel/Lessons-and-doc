Université Paul Sabatier – Toulouse III IUT A - Toulouse Rangueil

Programmation Orient´ e Objet e
Semestre 3

Toulouse, le 17 décembre 2011

Chapitre 1 Les classes et les objets
Clef moodle $noj11b$ 2 facteurs de qualité en génie logiciel Extensibilité Capacité pour un logiciel à intégrer de nouvelles fonctionnalités Réutilisabilité Capacité pour un logiciel à être réexploité, tout en partie, pour de nouvelles applications

1.1

L’objet

Déﬁnition Structure de données présente à l’exécution formée de champs et d’opérations applicable à ces champs. Un objet est une identité, un état et un comportement État Ensemble des valeurs des champs de l’objet Comportement L’ensemble de ces opérations

1.2

La classe

Déﬁnition Description d’une famille d’objets ayant même comportement. Deux composantes dans une classe : – La description des données appelés attributs – La description des opérations appelés méthodes

2

Programmation Orientée Objet

– 3–

1.2.1

Exemple

La classe article associée aux des objets laLacoste et laBadoit
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26

class Article { private String designation ; private float prixHT ;

public float prixDeVent () { return ( prixHT * 1.196) ; } public float coutLivraison () { return ( prixHT * 0.05) ; } public String getDesignation () { return ( designation ) ; } public float getPrixHT () { return ( prixHT ) ; } public void setPrixHT ( float p ) { prixHT = p ; } }

1.2.2

Remarques

1 Les méthodes de la classe Article (getPrixHT, setPrixHT, . . .) ne possèdent pas en paramètre un article 2 Principe de l’encapsulation une classe n’exporte (mot-clé public) que ses services (méthode applicable à un article). Tout ce qui n’est pas exporté est considéré privé (mot-clé private) 3 L’ensemble des services d’une classe (ses méthodes publiques) sont spéciﬁés par une interface.

1.3

Les objets instances de classe

Classe = modèle Objet = Représentant de ce modèle (appelé l’instance)

Université Paul Sabatier Toulouse III

obj3

Programmation Orientée Objet

– 4–

1.3.1

Relation d’instanciation

Relation entre la classe et l’objet. écriture d’une méthode spéciﬁque à la classe appelée constructeur (création d’une instance à partir du modèle) Convention le nom du constructeur est le nom de la classe et ne renvoit aucun résultat.
1 2 3 4 5 6 7 8 9 10

class Article { // constructeur initialise les champs d ’ un article public Article ( String d , float p ) { designation = d ; prixHt = p ; } // autres m é thodes }

1.3.2

Création d’objet

Pour créer un objet, on invoque le constructeur par l’opération new Exemple
1 2 3 4 5 6 7 8 9

// d é claration de l ’ instance laLacoste Article laLacoste // cr é ation de l ’ instance laLacoste laLacoste = new Article ( " Cehmise " , 50.0) ; // d é claration de l ’ instance laBadoit Article laBadoit // cr é ation de l ’ instance laBadoit laBadoit = new Article ( " EauGazeuse " , 0.70) ;

Remarques – Classe = Type – Classe = Entité statique et Objet = Entité statique (créé par l’opérateur new) – Une classe comprend en général les méthodes suivantes : – Un (ou plusieurs) constructeur – Des destructeurs (pour récupérer la mémoire des objets) – Des sélecteurs ou opération de consultation pour accéder aux champs de l’objet (souvent préﬁxés par get) – Des modiﬁcateurs pour modiﬁer l’état d’un objet (préﬁxés par set) – Des itérateurs permettant de balayer une collection d’attributs – L’interface de la classe Article s’enrichit du constructeur

Université Paul Sabatier Toulouse III

obj3

Chapitre 2 L’héritage de classes et la composition d’objets
Deux relations entre classes – La relation “être”(héritage) m – La relation “avoir” ou “posseder” (⇒ composition d’objets)

2.1

L’héritage la relation “être”

Déﬁnition Une classe partage ses propriétés (attributs + méthodes) avec une autre classe apelée super-classe. Relation entre la classe et sa super-classe. Exemple Les objets laLacoste et laBadoit partagent des propriétés communes (désignation, prixHT, getDesignation, . . .) mais avec des spéciﬁtés (couleur et taille pour laLacoste, prixDeVente pour laBadoit (TVA=5.5%), . . .)

2.1.1

Deux modes d’héritages

– Le mode par enrichissement : ajout d’attributs et/ou méthodes à la super-classe (appelée aussi classe ancêtre)
1 2 3 4 5 6 7 8 9 10 11 12

class Chemise extends Article { private int taille ; private Couleur coloris ; // constructeur de la classe Chemise public Chemise ( String d , float p , int t , Couleur c ) { super (d , p ) ; taille = t ; coloris = c ; } }

5

Programmation Orientée Objet

– 6–

– Le mode par substitution redéﬁnition dans une sous-classe d’une méthode héritée
1 2 3 4 5 6 7

8 9 10 11 12

class EauGazeuse extends Article { // Constructeur de la classe EauGazeuse public EauGazeuse ( String d , float p ) { super (d , p ) ; } // red é finition du calcul du prix de vente de la classe Article // TVA = 5.5% public float prixDeVente () { return ( getPrixHT () * 1.055) ; } }

A partir des deux classes Chemise et EauGazeuse, on peut créer les objets laLacoste et laBadoit.
1 2 3 4 5

Chemise laLacoste ; laLacoste = new Chemise ( " Chemise " , 50.0 , 1 , rouge ) ; EauGazeuse laBadoit ; laBadoit = new EauGazeuse ( " EauGazeuse " , 0.70) ;

Remarques – Dans une même classe on peut hériter par enrichissement et par substitution – Pour un eau gazeuse, une seule déﬁnition de la méthode prixDeVente, celle redéﬁnie dans la classe chemise (elle masque la méthode héritée) – Dans la classe Chemise l’accès au prixHT par le selecteur getPrixHT d’Article (rincipe d’encapsulation)

2.1.2

Sémantique de l’héritage

– Pas de sémantique formelle ! En général hériter = “être une sorte de” Attention : héritage = partage de code Point de vue extension Une classe est un ensemble d’objet Si E designe l’ensemble des objets d’une classe alors si B hérite de A (mot clé extends) E(B) ∈ E(A) Remarque L’ensemble des chemises est un inclus dans l’ensemble des articles Point de vue intention Une classe est un ensemble de proriétés (attributs + méthodes) si I désigne l’intention d’une classe alors si B hérité de A on a I(A) ∈ I(B) Remarque Une chemise possède les propriétés d’un article

Université Paul Sabatier Toulouse III

obj3

Programmation Orientée Objet

– 7–

Remarque Avec ces deux points de vue complémentaire : Si B hérite de A, alors B est considéré sous-type de A (d’après classe = type) Conséquence : Tout objet déclaré de type A pourra mémoriser dynamiquement un objet de type B (polymorphisme) :

2.1.3

Le graphe d’héritage

Représentation graphique de la relation d’héritage entre classe (cf diagramme de classe en UML par exemple) Exemple Classes Article et ses dérivés Article -dateDeLivraison +prixDeVente() hériteune sorte de") ("est de

Chemise +prixDeVente()

Eau gazeuse +prixDeVente()

2.1.4

Méthodes retardées et classes abstraites

Une méthode est dite retardée lorsque l’ensemble des sous-classes d’une classe donnée en proposent une déﬁnition. Exemple UML : Employé

Directeur Commercial -forfait -prime +salaire()

Comptable -forfait +salaire()

caissière -nbHeures

Remarques – Appliquer la méthode salaire à un employé n’a pas de sens. A l’exécution, l’employé devra référencer(dans le code) un comptable, une caissière ou un directeur commercial. – Une classe qui hérite d’une classe abstraite reste abstraite si elle ne déﬁnit pas la méthode retardée. – On ne peut pas créer d’objet à partir d’une classe abstraite Par contre une classe abstraite peut avoir un constructeur pour ses classes descendantes (super)

Université Paul Sabatier Toulouse III

obj3

Programmation Orientée Objet

– 8–

2.1.5

Héritage simple et héritage multiple

Héritage simple une classe ne peut hériter directement que d’une seule classe ancêtre Héritage multiple Sa classe peut hériter directement de plusieurs classe intérêt partager plusieurs point de vue complémentaire Article fragile Article electronique

Chaine Hiﬁ
1 2 3 4

class ChaineHifi extends ArticleFragile , ArticleElectronique { }

Remarques – En héritage simple le graphie d’héritage est un arbre. – Tous les langages à objets ne possèdent pas l’héritage multiple car : – Sémantique peut claire – Pue d’exemple pertinent exploitant l’héritage multiple – Des problèmes théorique et pratiques que subsistent

2.1.6

Conﬂits d’héritage

En héritage multiple, une même méthode peut être héritée par une sous classe plusieurs fois ! Problème pour la sous-classe quelle méthode retenir parmi l’ensemble des méthodes.

Université Paul Sabatier Toulouse III

obj3

Programmation Orientée Objet

– 9–

Exemple Coût de livraison pour un fromage Article +coutDeLivraison()

Article fragile +coutDeLivraison()

Article électronique

Fromage

Méthode de coutLivraison conﬂit d’héritage

Dans les langages pas de relation universelle. Deux approches : – Le choix est établi par le langage en considérant un parcours de graphe d’héritage – Le programmeur résout (dans son code) le conﬂit 1ère approche Diﬀérents parcours possibles du graphe : en largeur d’abord, en profondeur d’abord, stratagème mixe. . . exemple : Parcours 1 : Fromage, Article fragile, Article Périssable, Article ⇒ CoutLivraison de la classe Fragile Parcours 2 : Résolution du conﬂit par le programmeur par exemple : – En forçant la redéﬁnition – En obligeant à renommer la méthode dans la sous-classe

2.2

La composition d’objets. La relation Avoir

Deux manières d’utiliser un classe : – L’héritage (relation Être) – La composition relation (Avoir)

2.2.1

Déﬁnition

Un objet composite (ou agrégation d’objets) est un objet formé de l’assemblage de plusieurs objets. Avantage Construire des objets complexes à partir d’objets existant. Les constituants d’un objet composite ne sont accessible que via leurs interfaces (principe d’encapsulation)

Université Paul Sabatier Toulouse III

obj3

Programmation Orientée Objet

– 10 –

2.2.2

Exemple

La chaîne hiﬁ Lecteur CD Tuner Enceinte

Chaine Hiﬁ

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22

class ChaineHifi { private Tuner t ; private LecteurCD l ; private Tableau < Enceinte > e ; // Constructeur public ChaineHifi ( int nb ) { t = new Tuner () ; l = new LecteurCD () ; e = new Tableau < Enceinte > ( nb ) ; } } interface Tableau <T > { Tableau <T >( int n ) ; int longueur () ; T getIeme ( int i ) ; void setIeme ( int i , T x ) ; }

Remarques Avec un langage à objet, déﬁnition d’une bibliothèque de classes pour réutiliser ce qui existe déjà pour la classe Tableau La communication entre un objet composite et ses constituants est réutilisée via l’interface des constituants ⇒ relation client-fournisseur entre le composite (client) et ses constituants (fournisseur) Une classe A est cliente d’une classe B (et B est fournisseur de A) si – A contient un attribut b de type B – A possède une méthode avec un paramètre d’entrée ou de retour de type B – A utilise une variable locale de type B pour une de ses méthodes Université Paul Sabatier Toulouse III obj3

Programmation Orientée Objet

– 11 –

Le premier cas correspond à une dépendance structurelle les deux autres cas à une dépendance non structurelle

2.3
2.3.1

Mise en œuvre des mécanismes de réutilisation
Héritage d’interface

Mode d’héritage dans lequel toutes les sous-classes peuvent répondre aux services d’une classe ancêtre Point de vue Une classe est assimilé à un type donc une sous classe est assimilé à un sous type. En principe la classe ancêtre est souvent abstraite. Exemple : les classes Tableau, Liste, Ensemble d’interface collection Tableau Interface

Liste Collection

Ensemble

1 2 3 4 5 6 7 8 9

class ChaineHifi { private Collection < Enceinte > e ; public chainehifi ( int nb ) { // ... e = new Tableau < Enceinte > ( nb ) ; } }

2.3.2

Héritage versus composition

héritage statique (déﬁnit à la compilation). Composition dynamique (à l’exécution) Avec la composition possibilité de combiner dynamiquement des objets entre eux.

Université Paul Sabatier Toulouse III

obj3

Programmation Orientée Objet

– 12 –

Exemple Les produits laitiers avec uniquement l’héritage

Produit Laitier

Lait

Yaourt

Lait en bouteille

Lait en brique

yaourt en pot

yaourt à boire

Les produits laitiers avec deux hiérarchies d’héritage : le produit et son conditionnement. Produit Laitier Conditonnement

Lait

Yaourt

Bouteille

Brique

Pot

2.3.3

Héritage versus état d’un objet

Ne pas confondre héritage (classiﬁcation) et état d’un objet (valeurs des champs de l’objet)

Université Paul Sabatier Toulouse III

obj3

Chapitre 3 L’envoi de message et le polymorphisme
Envoie de message demandé par un objet de l’exécution d’un service de la classe. C’est l’unique de manière de dialoguer entre objets. Envoi de message = (Objet receveur, sélecteur de méthode, une liste de paramètre)

3.1
3.1.1

L’envoi de message
Cas général

L’envoi de message est réalisé par la primitive send ou la notation pointée Exemple Soit l’objet laLacoste, instance de la classe chemise. prix = laLacoste.prixDeVente() ; Avec un prixHT de 50e, prix = 59.8euros (car TVA = 19.6%) Soit a de type Article et prix = a.prixDeVente() Si a à l’exécution désigne une chemise (instance de la classe Chemise). prix = 59.8 euros (TVA = 19.6)
1 2 3 4 5 6 7 8 9 10 11 12

class HyperMarch é { private Tableau < Article > stock ; public void editerStock () { for ( int i = 0; i < stock . longueur ; i ++) { out . println ( stock . getIeme ( i ) . getDesignation () ) ; } } // autres m é thodes }

3.1.2

Désignation de l’objet receveur (objet self)

Dans les exemples de la section 3-1-1, on connait l’identité de l’objet receveur. L’objet laLacoste, l’objet a, l’objet out. . . lorsque l’objet receveur n’est pas connu, on le désigne par l’objet courant receveur du message :

13

Programmation Orientée Objet

– 14 –

l’objet self (en Java, self = this). Cas code d’un code d’une classe = code de l’instance (l’objet) courant Exemple Dans la classe Article, ajout d’une méthode prixAvecLivraison = prixDeVente + coutLIvraison Le même code doit s’appliquer à une chemise avec un taux de TVA = 19.6% et une eau gazeuse avec TVA = 5.5%
1 2 3 4 5 6 7 8 9

class Article { // ... // Calcule le prix de vente avec livraison d ’ un article public float prixAvecLivraison () { return ( this . prixDeVente () + this . coutLIvraison () ) ; } }

Remarque Cet objet courant this est implicite dans la première version de la classe Article (chapitre 1 section 2).

3.1.3

Accès à la superméthode (mot-clé super)

Héritage par substitution ⇒ la méthode héritée est masquée par la redéﬁnition. La méthode masquée est appelée superméthode.
1 2 3 4 5 6 7 8 9 10 11 12

class HyperMarch é { private Tableau < Article > stock ; public void editerStock () { for ( int i = 0; i < stock . longueur ; i ++) { out . println ( stock . getIeme ( i ) . getDesignation () ) ; } } // autres m é thodes }

pb Comment réutiliser le code de la superméthode ? On utilise la superméthode par un envoi de message en utilisant le mot clé super (qui n’est pas un objet) Exemple Dans la classe Chaine-hiﬁ, redéﬁnition de la méthode prixDeVente déﬁnie par : prixDeV entematerielHif i = prixDeV enteArticle + coutGarantieM aterielHif i

Université Paul Sabatier Toulouse III

obj3

Programmation Orientée Objet

– 15 –

Remarque Attention à l’usage de super ! Un envoi de message avec super ne doit s’appliquer pour l’accès d’une superméthode masquée par l’héritage. Dans les autres cas utiliser this.
1 2 3 4 5 6 7 8 9 10

class ChaineHifi extends Article { private float coutGarantie ; public float prixDeVente () { return ( super . prixDeVente () + this . coutGarantie () ) ; } // Autres m é thodes }

3.1.4

La délégation

Mécanisme de communication entre objets (par envoi de message) qui permet à un objet composite de déléguer à un de ses composant la requête à satisfaire. Exemple Un produit laitier conﬁe à un de ses composants conditionnement le soi d’emballer le produit. Pour mettre en place la relation non structurelle, on communique à l’emballage la référence this du produit laitier. ProduitLaitier 1 1 Conditionnement

dépendance non structurelle
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

class ProduitLaitier { private Conditionnement emballage ; public ProduitLaitier ( Conditionnement c ) { this . emballage = c ; } public void condtionner () { this . emballage condtionner ( this ) ; } // autre m é thodes }

Université Paul Sabatier Toulouse III

obj3

Programmation Orientée Objet

– 16 –

16 17 18 19 20 21 22 23 24

class Conditionnement { public void conditionner ( ProduitLaitier p ) { // ... } // autre m é thodes }

Remarque 1. Le code de méthodes conditionnement de ProduitLaitier et conditionnement est valide, quels que soient les produits laitiers et le conditionnement (ch chapitre 2 section 3.2) 2. Une classe A dépend d’une classe B (relation non structurelle). – Lorsque une méthode de A possède un paramètre de type ou un retour de type B – Lorsque une méthode de A possède un objet local de type B 3. On peut coder la classe Chemise du chapitre 2 par par un mécanisme de délégation. On indique alors qu’une chemise possède (relation avoir) la caractéristique d’un Article.

3.2

Le polymorphisme

Polymorphisme Plusieurs (poly) formes (morphes) possible d’une même entité. Deux types de molymorphisme lié : – Le polymorphisme d’inclusions – Le polymorphisme de redéﬁnition(ou polymorphisme) d’héritage

3.2.1

L’attachement polymorphe

Tout objet de classe d’appartenance (de type) A peut désigner à l’exécution un objet, sousclasse (sous type) de A. D’après le principe d’inclusion des extensions (chapitre 2, section 1) Exemple La classe Article avec Chemise et EauGazeuse.
1 2 3 4 5 6 7

Article a ; Chemise c ; c = new Chemise ( " Chemise " , 50.0 , 1 , rouge ) ; // Ecriture valide : a = c; a = new EauGazeuse ( " Eau Gazeuse " , 0.70) ;

Remarque 1. Les attachements polymorphes (cf exemple avec a et c) interviennent lors des relations paramètre eﬀectif. Paramètre formel- pour les paramètres de retour, pour les objets locaux et les objets courant this 2. L’attachement est autorisé dans le sens objetancetre = objetdescendant L’aﬀectation inverse n’a en général pas de sens ! Université Paul Sabatier Toulouse III obj3

Programmation Orientée Objet

– 17 –

3.2.2

Le polymorphisme d’inclusions

Ce polymorphisme résulte de l’héritage. À l’exécution, un objet d’une classe peut désigner un objet d’une sous classe. Traiter une famille d’ojet en ignorant pour chacun sa classe d’appartenance. (ici des chemises ch et des eaux gazeuses eg) Polymorphisme à condition de déﬁnir un héritage d’interface.

ch2 ch1 eg3

eg2

eg1

ch3

Exemple 1 Dans la classe HyperMarché, déﬁnition d’un attribut de type Tableau<Article>. Le table stock est un tableau polymorphe car il peut recevoir tout type d’article (des chemises, des eaux gazeuses,. . .) 2 Autre exemple :
1 2 3 4 5 6

ProduitLaitier p ; Conditionnement c ; c = new Bouteille () ; p = new Lait ( c ) ; p . conditionner () ;

3.2.3

Polymorphisme de redéﬁnition ou polymorphisme d’héritage

Polymorphisme qui s’appuie sur la redéﬁnition de méthode. À l’exécution, le système choisit la méthode la plus spécialisée (redéﬁnie) en fonction du type de l’objet. Appliquer une même méthode à des objets en ignorant pour chacun sa classe d’appartenance (ici la méthode m des chemises et des eaux gazeuses)

Université Paul Sabatier Toulouse III

obj3

Programmation Orientée Objet

– 18 –

m chemise

m chemise

m EauGazeuse

m EauGazeuse m chemise m EauGazeuse

3.2.4

Exemple

1 Calcul du prixDeVente d’un article, fonction la TVA (19.6%) en général et 5.5% pour les eaux gazeuses) Ce calcul s’eﬀectue en fonction du ième article du tableau stock de type Table<Article>.
1 2 3

public Float prixDeVente () { return this . prixHT * 1.196) ; } Listing 3.1 – Dans Article

1 2 3

public Float prixDeVente () { return this . prixHT * 1.055) ; } Listing 3.2 – Dans eau gazeuse

1

prix = this . stock . getI è me ( i ) . prixDeVente () ; Listing 3.3 – Dans supermarché 2 Calcul de la masse salariale de la classe HyperMarché avec un attribut personnel de type Liste<Employé>. Remarque : La méthode salaire de la classe employée est retardée !

1 2 3 4 5 6 7

public Float masseSalariale () { Float s =0.0 for ( int i = 0; i < this . personnel . longueur () ; i ++) s = s + this . personnel . getIeme . salaire () ; return ( s ) ; } Listing 3.4 – Dans supermarché

Université Paul Sabatier Toulouse III

obj3

Programmation Orientée Objet

– 19 –

3 Recharche séquentielle d’un élément dans un tableau
1 2 3 4

abstract class StructureSequentielle <T >{ // T est le type des é l é ments de la structure s é quentielle // se positionner sur le premier é l é ment de la structure s é quentielle abstract public void allerAuPremier () ; // se positionner sur l ’é l é ment suivant abstract public void allerAuSuivant () ; // la fin de la structure s é quentielle est - elle atteinte ? abstract public boolean epuise () ; // test si l ’é l é ment courant de la structure s é quentielle // coincide avec x abstract public boolean trouve () ;;

5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49

// recherche s é quentielle d ’ un é l é ment x // dans la structure s é quentielle public boolean existeElement ( T x ) { this . allerAuPremier () ; while (! this . epuise () && ! this . trouve ( x ) ) { this . allerAuSuivant () ; return (! this . epuise () ) ; } } }

class TableauSequentiel <T > extends structureSequentielle <T > { private Tableau <T > elements ; private int indice ; // constructeur public TableauSequentiel <T >( int n ) { this . elements = new Tableau <T >( n ) ; this . indice = 1; } // Aller au premier é l é ment du tableau public void allerAuPremier () { this . indice = 1; } // Aller au suivant du tableau s é quentiel public void allerAuSuivant () { this . indice = this . indice + 1; }

Université Paul Sabatier Toulouse III

obj3

Programmation Orientée Objet

– 20 –

50 51 52 53 54 55 56 57 58 59 60 61

// fin du tableau s é quentiel ? public boolean epuise () { return ( this . indice > this . elements . longueur () ; } // L ’é l é ment courant du tableau s é quentiel est - il é gal à x public boolean trouve ( T x ) { return ( this . elements . getI è me ( this . indice ) == x ) ; } } // M ê me é criture que tableS é quentielle <T > pour le TAD ListeSequentielle <T > , FichierSequentiel <T > , ...

Université Paul Sabatier Toulouse III

obj3

Annexe A épilogue : Et en java ?
Notion Typage Héritage Classes génériques Liaison dynamique Attributs privées Méthodes privées Instanciation Objetr receveur Accès à la superméthode pointeurs visible Racine du graphe d’héritage Algorithme de ramasse-miettes Autre caractéristiques Java statique simple Oui(depuis Java 1.5) Notation pointée Oui oui new this super non oui oui interface Commentaire Typage déﬁnie à la compilation ⇒ Pas de conﬂit d’héritage ! Possibilité de déﬁnir des familles de types (avec un paramètre formel de généricité) objet receveur.selecteur(parametre) Y compris en mode héritage (⇒ accesseurs get et set dans les sous classes) cf commentaire sur attributs privées En général, deux étapes pour créer un objet : le déclarer puis le créer (par new. Création explicite. A réserver pour l’accès à une méthode ancêtre marquée par l’héritage Par contre, tout est référence attention à = et == Classe objet (avec ses méthodes classe, equals et string) ⇒ Pas de destructeur à écrire Ensemble de méthodes retardées indiquant les services que doivent remplir les classes qui implémentent l’interface

21


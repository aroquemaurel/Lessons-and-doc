Une structure de donnée se traduit dans un langage par un type. On distingue, du plus simple au plus complexe: 
\begin{itemize}
	\item Les types élémentaires (cf cours algo)
	\item Les types composés (cf cours algo)
	\item Les Types Abstraits de données (étudiés dans ce cours)
\end{itemize}

\section{Notion de type abstrait}
	\subsection{Définitions}
		\paragraph{Type} Un type est un ensemble de valeurs et un ensemble d'opérations. 
		\paragraph{Type Abstrait} Un type abstrait est un type où l'utilisateur de la donnée ignore la représentation de la donnée mémoire et le codage des opérations.
	\subsection{Différents point de vue d'un TAD}
		\subsubsection{Concepteur}
			Il définit avec précision les opérations et les propriétés du type abstrait.\\
			Ce point de vue est appelé \textbf{spécifications} c'est la définition du type (QUOI?)
		\subsubsection{Programmeur}
			Il propose un codage des opérations du type\\
			Ce point de vue est appelé \textbf{implémentation} (COMMENT?)
		\subsubsection{Utilisateur}
			Il exploite les opérations du type pour son application.
	\subsection{Propriété des TADs}
		\paragraph{Encapsulation} 
			Les détails d'implémentations d'un type abstrait sont cachés (donc non accessible) au client.\\
			\subparagraph{Intérêt}			
				\begin{itemize}
					\item  Le programmeur peut modifier son implémentation sans impacter le client
					\item La localisation, le code du type abstrait est enregistré au même endroit de l'application.
					\item Notion de module, par exemple paquetage ou classe.
				\end{itemize}
	\subsection{En résumé}
		\input{16.tex}	
\section{Spécification d'un TAD}
	\paragraph{Définition} 
		Ensemble des opérations et des propriétés du type. \\
		Mode d'emploi de la structure de données
	\subsection{Opération}
		Énumération de l'ensemble des opérations selon la syntaxe pour une opération.
		$$ f: x_{1} \times x_{2} \times \dots \times x_{n} \rightarrow y_{1} \times y_{2} \times \dots \times y_{n}$$
		\paragraph{$f$} nom opération (symbole de fonction)
		\paragraph{$x_{1} \times x_{2} \times \dots \times x_{n}$} Domaines d'entrée de l'opération
		\paragraph{$y_{1} \times y_{2} \times \dots \times y_{n}$} Domaine de sortie de l'opération
		\paragraph{} Où les $x_{i}$ et $y_{i}$ sont des types dont l'un au moins est le type $T$ étudié
		\subsubsection{Exemple}
			Soit à définir le TAD Point d'affichage d'un point à l'écran.\\
			\subparagraph{Opération} 	
				\begin{itemize}
					\item Créer un point d'abscisse $x$, d'ordonnée $y$, de couleur $c$ et de taille $t$
					\item Connaître l'abscisse d'un point $p$
					\item Modifier la taille $t$ d'un point $p$
					\item Translater un point $p$ de $tx$ et $ty$
				\end{itemize}
			\subparagraph{Plus formellement}
				Soit Point le type point.
				\begin{eqnarray*}
					unPoint: Reel \times Reel \times Couleur \times Reel &\rightarrow& Point\\
					PointOrigine &\rightarrow& Point \\
					taille : Point &\rightarrow& Reel \\
					modifierTaille : Point \times Reel &\rightarrow& Point \\
					translater : Point \times Reel \times Reel &\rightarrow& Point\\
					\vdots \\ \vdots
				\end{eqnarray*}	
					Suite sur moodle clef = tads2
		\paragraph{Remarque}
			Une opération peut-être partielle\\
			Par exemple la taille $t$ du point doit être positive \\
			On définit une pré condition: pour $p$ de type Point $x$,$y$x et $t$ de type Réel et $c$ de type Couleur.\\
			$unPoint(x,y,c,t)$ est défini par $t > 0$
	\subsection{Propriétés}
		\paragraph{Opération} Syntaxe du Type Abstrait de Données
		\paragraph{Propriétés} Sémantique du Type Abstrait de Données
		\paragraph{Pour définir les propriétés} On combine les opérations entre elles et on indique le résultat de ces combinaisons.
		\subsubsection{On définit pour les opérations}
			\input{17.tex}	
			\subparagraph{Observateur} Opération qui fournit une caractéristique de la donnée (sans la modifier)
			\subparagraph{Opérateur} Opération qui fournit une valeur du type abstrait étudié
			\subparagraph{Générateur de base} Générateur qui permet de construire toutes les valeurs du type
			\subparagraph{Générateur secondaire} Générateur autre qu'un générateur de base
			\subparagraph{Pour écrire les propriétés}
				\begin{itemize}
					\item on fournit les valeurs des observateurs et des générateurs secondaires appliqués au générateurs de base
					\item On peut aussi procéder par équivalence avec le générateur de base
				\end{itemize}
			\subsubsection{Pour le TAD point}
				\begin{tabular}{c|c}
					Générateur de base & unPoint\\
					\hline
										  & pointOrigine;\\
					Générateur Secondaire & modifierTaille;\\
										  & translater;\\
					\hline
					Observateur & taille
				\end{tabular}
			
			\subsubsection{Propriété du TAD Point}
				Pour $x$, $y$, $tx$, $ty$, de type Réel.\\
				Pour $c$ de type Couleur\\
				\begin{eqnarray}
					pointOrigine&=&unPoint(0.0, 0.0, noir, 1.0)\\	
					taille(unPoint(x, y, c, t))&=&t\\
					modifierTaille(unPoint(x,y,c,tx),t2)&=&untPoint(x,y,c,t2)\\
					translater(unPoint(x,y,c,t),tx,ty&=&unPoint(x \times ty, y \times ty, c, t)
				\end{eqnarray}
		\subsection{}		
			\input{1.tex}
			\paragraph{Remarques}
				\subparagraph{}
				Propriété = Axiome définit par le constructeur \\ 
				Par exemple on aurait pu imaginer:\\
				$$modifierTaille(unPoint(x,y,c,t1),t2)$$
				$$unPoint(x,y,c,t1+t2)$$
				\subparagraph{}
					Pré conditions valides lors de l'écriture des propriétés.
				\subparagraph{}
					Les types élémentaires (entier, Réel, booléen ...) sont des types abstraits de données déjà définis dans le langage. \\
					Pour Booléen: Vrai $\rightarrow$ Booléen \\
									Faux $\rightarrow$ Booléen \\
									Non: Booléen $\rightarrow$ Booléen
									Et: Booléen $\times$ Booléen $\rightarrow$ Booléen \\ ...\\ \\
					Propriétés: Non(vrai) = Faux\\
								Non(faux) = vrai\\
								Et(vrai,vrai) = vrai\\
								Et(vrai,faux) = faux.\\
				\subparagraph{}
					Les types composés (Tableau, enregistrement) sont aussi des Types Abstrait de Données.	\\
					Pour tableau:\\
						unTableau : Entier $\times$ Entier $\rightarrow$ Tableau[T]\\
						ième : Tableau[T] $\times$ Entier $\rightarrow$ T\\
						changeIème : Tableau[T] $\times$ Entier $\times$ T$ \rightarrow$ Tableau[T]\\ \\
						$ième(tab, i) \equiv tab[i]$
						$changerIème(tab, i, el) equiv tab[i]<-e$\\
					Propriétés:\\
			\lstinputlisting[caption=Propriété]{1.algo}
				\subparagraph{}
					Il existe des TADs fondamentaux les tables, listes, piles, fils, arbres, graphe\\
					En général ces TADs sont génériques.\\
					Par exemple pour le TAD liste on introduit le TAD $liste[T]$
	\section{Du type Abstrait au type concret}
		\paragraph{Définition}
			Un type concret est la transition dans un langage d'un type abstrait.
		\paragraph{Schéma de traduction}
	%			\input{1.tex}	
		\subsection{Étapes de traductions}
			Soit Ta un TAD et Tc le type concret correspondant. \\
			\paragraph{Étape 1(Concepteur)}
				Définition de Tc un entête de sous programme pour chaque opérations de Ta.	
			\paragraph{Étape 2 (Programmeur)}
				Définir une représentation mémoire d'une valeur de Tc (Tableau, enregistrement, pointeur...)
			\paragraph{Étape 3 (Programmeur)}
				Codes les corps des sous programmes dans Tc (connaissant la représentation mémoire)
			\paragraph{}
				Les points 2 et 3 seront développés au chapitre suivant (implémentation d'un TAD)	
		\subsection{En tête des sous programmes}
			Dans Ta, opération = fonctions (au sens mathématique)\\
			Dans Tc, opération = procédure ou fonction \\
			Dans Tc, on distingue :
			\begin{itemize}
				\item Les opérations de construction
				\item Les opérations de modification 
				\item Les opérations d'évaluation
			\end{itemize}
			\subsubsection{Opération de construction}
				\paragraph{Rôle}
					Construire une valeur du type étudié, éventuellement à partir de valeur d'autres types.
					Opération appelée aussi \textbf{constructeur} 
				\paragraph{Caractéristique}
					Le type Ta étudié n'apparait que dans le domaine de sortie de l'opération.
				\paragraph{Règle}
					Une opération de construction dans Ta se code par une fonction dans Tc(en général)	
				\paragraph{Exemple 1}
					Dans Ta:
					unPoint Réel $\times$ Réel $\times$ Couleur $\times$ Réel $\rightarrow$ Point \\
					Dans Tc: 	
					\lstinputlisting[caption=Tc]{2.algo}
				\paragraph{Exemple 2}
					Dans Ta: pointOrigine $\rightarrow$ Point\\
					Dans Tc
					\lstinputlisting[caption=Tc]{2-1.algo}
					\subparagraph{}
						Le non respect d'une pré condition se traduit par une levée d'exception (cf unPoint)
					\subparagraph{}
						Un constructeur sans paramètre d'entrée est appelé constante du type abstrait
						pour un client 
					\lstinputlisting{2-2.algo}
				\subsection{Opération de consultation}
					\paragraph{Rôle}
						Fournit une caractéristique d'une valeur du type opération aussi appelé observateur
						.
					\paragraph{Caractéristique}
						Le type Ta étudié n'apparait que dans le domaine d'entrée de l'opération. \\
					 \paragraph{Règles}
						Une opération de consultation dans Ta se traduit toujours par une fonction dans TC
					\paragraph{Exemple}
						Dans Ta \\
						taille : Point $\rightarrow$ Réel	\\ \\
						Dans Tc\\
					\lstinputlisting{2-3.algo}
				\subsection{Opération de modification}
					\paragraph{Rôle}
						Modifier une caractéristique d'une valeur d'un type.
					\paragraph{Caractéristique}
						Le type Ta apparait à la fin dans le domaine d'entrée et le domaine de sortie de l'opérateur. 
					\paragraph{Règle}
						Une opération de modification dans Ta se code par une procédure dans Tc. 
						(avec le mode mise à jour pour la valeur à modifier!)
					\paragraph{Exemple}
						Dans Ta: modifierTaille: Point $\times$ Réel $\rightarrow$ Point \\
						Dans Tc
						\lstinputlisting{2-4.algo}
				\subsection{Les opérations d'évaluation}
					\paragraph{Rôle}
						Construit une nouvelle valeur du type abstrait à partir de la valeur existante du
						type. Opération avec ainsi similaire aux constructeur.
					\paragraph{Caractéristique}
						Le type Ta apparaît à la fin dans le domaine d'entrée et de sortie de l'opération.
						(comme une opération de modification).
					\paragraph{Règle}
						Une opération d'évaluation se traduit dans Ta par une fonction dans Tc.
					\paragraph{Exemple}
						Dans Ta: Point $\times$ Réel $\rightarrow$ Point\\
						Dans Tc
						\lstinputlisting{2-5.algo}
				\subsection{Spécification d'un type concret}
					\paragraph{Définition}
						Regroupement des en-têtes des sous programme de la spécification (cf 3.2), avec
						en commentaire les propriétés du type (cf 2). \\
						Cette spécification est aussi appelée spécification algorithmique du type abstrait
						. (cf moodle pour Point et Tableau[T])
\section{Utilisation d'un TAD}
		Un client d'un Type Abstrait de Données peut:
			\begin{itemize}	
				\item Définir des variables de type T
				\item Définir des paramètres de sous-programme de type T
				\item Définir de nouveaux type en utilisant le type T
				\item Appeler des sous-programme définis par le type T
			\end{itemize}
			\paragraph{Remarque}
				Le client n'a pas accès à la représentation mémoire et au codage des sous-programme définis
				dans T!
			\subsubsection{Exemple}
				Soit à calculer le point milieu d'un segment. \\
				En tant que client:	
				\lstinputlisting{2-6.algo}
%				\input{x.tex}
				\lstinputlisting{2-7.algo}
				où abscisse, ordonnée et unPoint sont des opérations du type Point (cf Moodle)					
\section{Processus d'élaboration d'un TAD}
	\subsection{Étape}
		 \begin{enumerate}
			\item Énumérer l'ensemble des opérations du type
			\item Pour chaque opération, préciser son profil (nom de l'opération, domaine d'entrée et 
				domaine de sortie)
			\item lister l'ensemble des propriétés du type
			\item Définir un entête de sous-programme pour chacune des opérations du type
			\item Choisir une représentation mémoire pour coder les opérations et les valeurs du type
			\item Coder avec la représentation mémoire choisie les corps des différents sous-programmes
		\end{enumerate} 	
		\paragraph{Remarque}
			\subparagraph{} Les étapes 1 à 3 sont relatives au type abstrait. (formalisme)	
			\subparagraph{} Les étapes 4 à 6 concernent les types concrets (programmation)
			\subparagraph{} L'étape 3 permet:
				\begin{itemize} 
					\item De donner la sémantique des opérations du type
					\item D'aider au codage des opérations du type concret
					\item De définir des jeux de tests pour ces opérations
				\end{itemize}


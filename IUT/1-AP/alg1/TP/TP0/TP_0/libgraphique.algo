-------------------------------------
-- Fichier libgraphique.algo
-- Auteur    : SAFORCADA Valentin
-- Date      : 10 octobre 2010
-------------------------------------

importer maths ;

-------------------------------------------------------------------------
-- Procédure initPoint : Initialise une structure Point passé en argument
-- Param    iX         : Abscisse entiere
-- Param    iY         : Ordonnée entiere
-- Param    pos        : structure Point qui va être initialisé
-------------------------------------------------------------------------
procédure initPoint(entrée iX <Entier>, entrée iY <Entier>, màj pos <Point>)
début
    pos.iX <- iX ;
    pos.iY <- iY ;
fin

-------------------------------------------------------------------------
-- Procédure initPoint : Initialise une structure Point passé en argument
-- Param    iX         : Abscisse entiere
-- Param    iY         : Ordonnée entiere
-- Param    pos        : structure Point qui va être initialisé
-------------------------------------------------------------------------
procédure initPoint(màj pos <Point>, entrée iX <Entier>, entrée iY <Entier>)
début
    pos.iX <- iX ;
    pos.iY <- iY ;
fin

-------------------------------------------------------------------------
-- Fonction getPoint : Renvoie une structure de type Point initialise aux
--                     coordonnés iX, iY
-- Param    iX       : Abscisse entiere
-- Param    iY       : Ordonnée entiere
-- Retourne <Point>
-------------------------------------------------------------------------
fonction getPoint(entrée iX <Entier>, entrée iY <Entier>) retourne <Point>
glossaire
    pos <Point> ;
début

    initPoint(iX, iY, pos) ;

    retourner pos ;
fin

-------------------------------------------------------------------------
-- Procédure initPolygone : Initialise tous les points du polygone à 0
-- Param    polygone      : <Polygone> à initialiser
-------------------------------------------------------------------------
procédure initPolygone(màj polygone <Polygone>)
glossaire
    i <Entier> ;
début
    i <- 1 ;

    tantque i <= MAXPOINT faire
        initPoint(0, 0, polygone[i] ) ;
        i <- i + 1 ;
    fin tantque ;

fin

-------------------------------------------------------------------------
-- Fonction pointIdentique : Renvoie VRAI si les points sont les mêmes
-- Param    pos1       : <Point> à comparer
-- Param    pos2       : <Point> à comparer
-- Retourne <Booléen>
-------------------------------------------------------------------------
fonction pointIdentique(entrée pos1 <Point>, entrée pos2 <Point>) retourne <Booléen>
début
    retourner (pos1.iX = pos2.iX et pos1.iY = pos2.iY) ;
fin

-------------------------------------------------------------------------
-- Procédure déplacerStyletDe : déplace le stylet de iNbr vers la
--                              direction actuelle
-- Param    iNbr              : nombre d'unité de déplacement
-------------------------------------------------------------------------
procédure déplacerStyletDe(entrée iNbr <Entier>)
glossaire
    i <Entier> ;
début
    i <- 0 ;

    tantque i /= iNbr faire
        déplacerStylet ;
        i <- i + 1 ;
    fin tantque ;

fin 

-------------------------------------------------------------------------
-- Précédure déplacerStyletAuPoint : Déplace le stylet au point pos
--                                   Le stylet est placé en direction
--                                   du nord à la fin.
-- Param pos                       : Position à atteindre
-- Param offSetX                   : Origine du répère
-- Param offSetY                   : Origine du répère
-- Param trace                     : si VRAI, trace le déplacement de
--                                   l'origine du répère vers pos
-------------------------------------------------------------------------
procédure déplacerStyletAuPoint(entrée pos <Point>, entrée offSetX <Entier>, entrée offSetY <Entier>, entrée trace <Booléen>) 
début
    
    leverStylet ;
    centrerStylet ;
    orienterNord ;

    si offSetX /= 0 ou offSetY /= 0 alors
        déplacerStyletAuPoint(getPoint(offSetX, offSetY), 0, 0, FAUX) ;
    fin si ;

    si trace alors
        baisserStylet ;
    fin si ;

    si pos.iX > 0 alors
        pivoterDroite ;
    sinon
        si pos.iX < 0 alors
            pivoterGauche ;
        fin si ;
    fin si ;

    déplacerStyletDe(abs(pos.iX)) ;
    orienterNord ;

    si pos.iY < 0 alors
        pivoterGauche ;
        pivoterGauche ;
    fin si ;

    déplacerStyletDe(abs(pos.iY)) ;
    orienterNord ;
fin

-------------------------------------------------------------------------
-- Précédure tracerSegment     : Trace le segment entre pos1 et pos2
--                               Algorithme de Bresenham généralisé
--                               en arithmétique entière
-- Param pos1                  : Position à atteindre
-- Param pos2                  : Position à atteindre
-------------------------------------------------------------------------
procédure tracerSegment(entrée pos1 <Point>, entrée pos2 <Point>) 
glossaire
    i            <Entier> ;
    iTemp        <Entier> ;    -- Permet d'échanger des valeurs
    iX           <Entier> ;
    iY           <Entier> ;
    iDeltaX      <Entier> ;
    iDeltaY      <Entier> ;
    s1           <Entier> ;
    s2           <Entier> ;
    e            <Entier> ;
    bInterchange <Booléen> ;
    offSet       <Point> ;
début
    iX <- pos1.iX ;
    iY <- pos1.iY ;
    iDeltaX <- abs(pos2.iX - pos1.iX) ;
    iDeltaY <- abs(pos2.iY - pos1.iY) ;
    s1 <- sign(pos2.iX - pos1.iX) ;
    s2 <- sign(pos2.iY - pos1.iY) ;

    si iDeltaY > iDeltaX alors
        iTemp <- iDeltaX ;
        iDeltaX <- iDeltaY ;
        iDeltaY <- iTemp ;
        bInterchange <- VRAI ;
    sinon
        bInterchange <- FAUX ;
    fin si ;

    e <- 2 * iDeltaY - iDeltaX ;

    i <- 1 ;
    offSet.iX <- iX ;
    offSet.iY <- iY ;

    tantque i <= iDeltaX faire
        déplacerStyletAuPoint(getPoint(iX - offSet.iX, iY - offSet.iY), offSet.iX, offSet.iY, VRAI) ;
        offSet.iX <- iX ;
        offSet.iY <- iY ;

        tantque e >= 0 faire
            si bInterchange alors
                iX <- iX + s1 ;
            sinon
                iY <- iY + s2 ;
            fin si ;
            e <- e - 2 * iDeltaX ;
        fin tantque ;
        si bInterchange alors
            iY <- iY + s2 ;
        sinon
            iX <- iX + s1 ;
        fin si ;
        e <- e + 2 * iDeltaY ;

        i <- i + 1 ;
    fin tantque ;
        
fin 

-------------------------------------------------------------------------
-- Précédure tracerPolygone     : Trace le polygone polygone
-- Param polygone               : polygone à tracer
-------------------------------------------------------------------------
procédure tracerPolygone (entrée polygone <Polygone>) 
glossaire 
    i <Entier> ;
    pointActuel  <Point> ;
    pointDepart  <Point> ;
    pointSuivant <Point> ;
début
    pointDepart  <- polygone[1] ;
    pointActuel  <- polygone[1] ;
    pointSuivant <- polygone[2] ;

    i <- 3 ;

    tantque non pointIdentique(pointDepart, pointSuivant) faire
        tracerSegment(pointActuel, pointSuivant) ;
        pointActuel  <- pointSuivant ;
        pointSuivant <- polygone[i] ;
        i <- i + 1 ;
    fin tantque ;

    tracerSegment(pointActuel, pointDepart) ;
fin

-------------------------------------------------------------------------
-- Précédure tracerCercle       : Trace le cercle de centre posDepart et
--                                de rayon iRayon
--                                Algorithme de Bresenham généralisé
--                                en arithmétique entière
-- Param posDepart              : origine du cercle
-- Param iRayon                 : rayon du cercle
-------------------------------------------------------------------------
procédure tracerCercle(entrée posDepart <Point>, entrée iRayon <Entier>) 
glossaire
    iX <Entier> ;
    iY <Entier> ;
    iDelta <Entier> ;
    iDeltaP <Entier> ;
    iLimite <Entier> ;
    iDeltaI <Entier> ;
    offSet <Point> ;
début
    iX <- 0 ;
    iY <- iRayon ;
    iDeltaI <- 2 * (1 - iRayon) ;
    iLimite <- 0 ;

    offSet.iX <- iX  ;
    offSet.iY <- iY  ;

    tantque iY /= iLimite faire
        déplacerStyletAuPoint(getPoint(iX - offSet.iX, iY - offSet.iY),         offSet.iX + posDepart.iX,   offSet.iY + posDepart.iY, VRAI) ;
        déplacerStyletAuPoint(getPoint(-(iX - offSet.iX), -(iY - offSet.iY)), - offSet.iX + posDepart.iX, - offSet.iY + posDepart.iY, VRAI) ;
        déplacerStyletAuPoint(getPoint(iX - offSet.iX, -(iY - offSet.iY)),      offSet.iX + posDepart.iX, - offSet.iY + posDepart.iY, VRAI) ;
        déplacerStyletAuPoint(getPoint(-(iX - offSet.iX), iY - offSet.iY),    - offSet.iX + posDepart.iX,   offSet.iY + posDepart.iY, VRAI) ;
        offSet.iX <- iX ;
        offSet.iY <- iY ;

        si iDeltaI < 0 alors
            iDelta <- 2 * iDeltaI + 2 * iY - 1 ;

            si iDelta <= 0 alors
                iX <- iX + 1 ;
                iDeltaI <- iDeltaI + 2 * iX + 1 ;
            sinon
                iX <- iX + 1 ;
                iY <- iY - 1 ;
                iDeltaI <- iDeltaI + 2 * iX - 2 * iY + 2 ;
            fin si ;

        sinon
            si iDeltaI > 0 alors
                iDeltaP <- 2 * iDeltaI + 2 * iY - 1 ;

                si iDeltaP <= 0 alors
                    iX <- iX + 1 ;
                    iY <- iY - 1 ;
                    iDeltaI <- iDeltaI + 2 * iX - 2 * iY + 2 ;
                sinon
                    iY <- iY - 1 ;
                    iDeltaI <- iDeltaI - 2 * iY + 1 ;
                fin si ;
            sinon -- iDeltaI = 0
                iX <- iX + 1 ;
                iY <- iY - 1 ;
                iDeltaI <- iDeltaI + 2 * iX - 2 * iY + 2 ;
            fin si ;
        fin si ;
    fin tantque ;
fin

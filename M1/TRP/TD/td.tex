\documentclass[12pt,a4paper,openany]{book}

\usepackage{lmodern}
\usepackage[svgnames]{xcolor} % Required to specify font color
\input{/home/aroquemaurel/cours/templates/templates/couleurs.tex}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[top=1.7cm, bottom=1.7cm, left=1.7cm, right=1.7cm]{geometry}
\usepackage{verbatim}
\usepackage[urlbordercolor={1 1 1}, linkbordercolor={1 1 1}, linkcolor=vert1, urlcolor=bleu, colorlinks=true]{hyperref}
\usepackage{tikz} %Vectoriel
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{multido}
\usepackage{amssymb}
\usepackage{graphicx} % Required for box manipulation
\usepackage{float}

\newcommand{\titre}{Techniques de base de résolution de problèmes}
\newcommand{\subtitle}{IA}
\newcommand{\auteur}{Antoine de \bsc{Roquemaurel}}
\newcommand{\formation}{M1 Informatique -- Développement Logiciel}
\newcommand{\semestre}{7}
\newcommand{\annee}{2014}
\newcommand{\prof}{Pierre \bsc{Regner}}
\newcommand{\logo}{/home/aroquemaurel/cours/templates/templates/ups.jpg}


\newcommand{\pole}{}
\newcommand{\sigle}{crcl}
\input{/home/aroquemaurel/cours/templates/templates/listings.tex} %prise en charge du langage algo
\input{/home/aroquemaurel/cours/templates/templates/classroomsTemplates/l2/cours.tex}
\input{/home/aroquemaurel/cours/templates/templates/remarquesExempleAttention.tex}
\input{/home/aroquemaurel/cours/templates/templates/polices.tex}
\input{/home/aroquemaurel/cours/templates/templates/affichageChapitre.tex}
\input{/home/aroquemaurel/cours/templates/templates/cover/couverture.tex}
\makeatother

\begin{document}
	\thispagestyle{empty} % Removes page numbers
	\titleBC 
	\setcounter{tocdepth}{2}
	\setcounter{secnumdepth}{3}
	\tableofcontents
	\chapter{Problèmes dans les espaces d'états}
	\section{La réécriture}
	\subsection{Algorithme en largeur d'abord}
	\begin{figure}[H]
		\centering
		\includegraphics[width=15cm]{Diagramme1.eps}
		\caption{Réécriture avec l'algorithme en largeur d'abord}
	\end{figure}
	\begin{description}
		\item[Chemin solution] \texttt{<r1, r5, r1, r5, r4>}
		\item[Nœuds développés] 14
		\item[Nœuds crées] 19
		\item[Algorithme optimal] Longueur dans plans solution 
		\item[Algorithme complet] S'il existe une solution, il l'a trouve, sous condition de couper les branches déjà explorées
	\end{description}

	\begin{remarque}
		Cet algorithme consomme beaucoup de mémoire est peut être très long à dérouler : il n'est donc pas très utilisé
	\end{remarque}

	\subsection{Algorithme en profondeur d'abord}
	\begin{figure}[H]
		\centering
		\includegraphics[width=15cm]{Diagramme2.eps}
		\caption{Réécriture avec l'algorithme en profondeur d'abord}
	\end{figure}
	\begin{description}
		\item[Chemin solution] \texttt{<r1, r5, r1, r5, r4>}
		\item[Nœuds développés] 8
		\item[Nœuds crées] 10
		\item[Algorithme optimal] Non optimal 
		\item[Algorithme complet] S'il existe une solution, il l'a trouve, sous condition de couper les branches déjà explorées
	\end{description}
	\begin{remarque}
		Cet algorithme consomme beaucoup moins de mémoire que la profondeur d'abord
\\~
	\end{remarque}

	\section{Le taquin $3\times 3$}
	\subsection{Algorithme << Glouton >>}
	\begin{remarque}
		L'algorithme Glouton peut aussi s'appeler Algorithme de Gradient
		\\~
	\end{remarque}
	\includegraphics[width=11.8cm]{Diagramme3.eps}	
	\begin{description}
		\item[Heuristique] Nombre de cases non en place
		\item[Opérateurs] H,D,B,G
		\item[Chemin solution] 9 étapes : \texttt{<H,H,D,B,G,H,D,B,G>}
		\item[Nœuds développés] 9
		\item[Nœuds crées] 20
	\end{description}
	\subsection{Un autre problème}
	\begin{figure}[H]
		\centering
		\includegraphics[width=11cm]{Diagramme5.eps}
		\caption{Pas de solution}
	\end{figure}
	\begin{remarque}
		Aucune solution, on est dans un autre espace d'état
	\end{remarque}
	\section{Le jeu de cartes}
	On peut considérer les opérateurs prendre à droite/ prendre à gauche, mais on peut aussi conceptualiser un opérateur prendre 2 cartes ou seul la
	première compte : à ce moment là, notre arbre de recherche sera pratiquement deux fois moins long.

	\subsection{Modélisation des opérateurs}
	\begin{tabular}{cc}
		\begin{minipage}{0.5\textwidth}
			Solution à profondeur 5: 
			\begin{itemize}
				\item Prendre droite impair
				\item Prendre droite pair
				\item Prendre gauche impair
				\item Prendre droite impair
			\end{itemize}
		\end{minipage}
		&
		\begin{minipage}{0.5\textwidth}
			Solution à profondeur 3: 
			\begin{itemize}
				\item Prendre droite gauche
				\item Prendre droite droite
				\item Prendre gauche droite
				\item Prendre gauche gauche
			\end{itemize}
		\end{minipage}
	\end{tabular}

	C'est un problème de recherche dans les espaces d'états avec une optimisation des gains : c'est la différence entre un algorithme A et un
	algorithme $A^*$.

	En théorie, afin d'avoir le meilleur gain, nous devrions parcours l'intégralité de l'arbre, cependant un algorithme nous évite de faire cela :
	l'algorithme <<Meilleur d'abord>>

	On utilise une fonction d'estimation des états (heuristique) : la somme des n plus grandes valeurs de cartes avec n définis comme le nombre de
	cartes peuvent encore rapporter es gains. Cette fonction sur estime la réalité.

	\begin{figure}[H]
		\centering
		\includegraphics[width=12cm]{Diagramme6.eps} 
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=12cm]{Diagramme7.eps} 
	\end{figure}
	Notre heuristique est majorante : ainsi, il est inutile de backtraquer l'intégralité de l'arbre, les autres branches ne nous proposent pas plus
	que 14.

	\chapter{Arbres de jeux, stratégies, minimax}
	\section{Arbre de jeu, stratégies}
	\begin{figure}[H]
		\centering
		\includegraphics[width=16cm]{Diagramme8.eps}
		\caption{Arbre de jeu}
		\label{fig:diag8}
	\end{figure}

	A commence, on choisit A comme joueur de référence, donc
	B est l'adversaire.

	\begin{description}
		\item[G] A Gagne
		\item[P] A Perd
		\item[E] Égalité
	\end{description}

	\subsection{Hypothèse} Chaque joueur joue du mieux possible !
	\subsection{Convention Minimax}
	\begin{itemize}
		\item Le joueur de référence, A, remonte le maximum de ses fils
		\item L'adversaire, B, remonte le minimum de ses
			fils.
	\end{itemize}

	On pose $G > E > P$.

	Cet arbre représente l'ensemble des parties possibles :
	une partie est une chemin partant de la racine pour
	aboutir à une feuille.

	P remonté à la racine, A ne peut donc pas gagner : en bleu nous avons une stratégie gagnante pour B.

	\begin{definition}
		Une \textbf{stragégie gagnante} est un sous arbre de
		l'arbre de jeu tel que : 
		\begin{itemize}
			\item La racine est identique
			\item Les n\oe{}uds du gagnant (celui qui possède
				une stratégie gagnante) sont les
				n\oe{}uds OU
			\item Les nœuds du perdant sont des nœuds ET.
			\item Pour chaque nœud OU on choisi une branche
				gagnante (pour le gagnant)
			\item Pour chaque nœud ET on retient toutes les
				branches
			\item Toutes les feuilles doivent être gagnantes
				(pour le gagnant)
		\end{itemize}
	\end{definition}
	\begin{figure}[H]
		\centering
		\includegraphics[width=12cm]{Diagramme9.eps}
		\caption{Arbre de jeu}
	\end{figure}
\begin{remarque}
	La construction de cet arbre à été effectué à l'aide de
	l'arbre \ref{fig:diag8}.
\end{remarque}
	Dans ce cas là, il existe une stratégie gagnante pour celui  
	qui commence

	\begin{figure}[H]
		\centering
		\includegraphics[width=9cm]{Diagramme10.eps}
		\caption{Arbre de jeu}
	\end{figure}
	Il existe une stratégie gagnante pour A : inutile de
	développer le sous arbre gauche étant donné que nous
	savons qu'il en existe au moins une. 

	\section{Minimax d'un arbre de jeu}
	Il existe une stratégie gagnante pour B, et le minimum
	des gaints possibles pour B, si celui joue bien, est de 1
	(-1 en racine).

	Si A joue mal, pendant que B conserve son jeu, alors B
	pourrait gagner plus, jusqu'à 17.
	\chapter{Arbres de jeux, algorithme Alpha/Béta}
	La convention Négamax fonctionne ainsi : 
	\begin{itemize}
		\item Pas de joueur de référence
		\item Chaque étape de l'arbre est valué en onctino des gains de celui qui va jouer
		\item Pour un nœud on remonte le max des opposé des valeurs des fils
	\end{itemize}

	Alpha-Béta fonctionne en convention Négamax.

	\begin{tabular}{cc}
		\begin{minipage}{0.5\textwidth}
	\begin{figure}[H]
		\includegraphics[width=8cm]{Diagramme11.eps}
		\caption{Convention Minimax}
	\end{figure}
\end{minipage}
	&
		\begin{minipage}{0.5\textwidth}
	\begin{figure}[H]
		\includegraphics[width=8cm]{Diagramme12.eps}
		\caption{Convention Négamax}
	\end{figure}
\end{minipage}
\end{tabular}
	\section{Exercice 1 Minimax / Négamax}
	Si on était en Négamax, les feuilles seraient valuées par B car c'est celui qui doit jouer. Or elles sont valuées pour A, on est donc pas en
	Négamax mais en Minimax avec A comme joueur de référence.
	
	\section{Algorithme Alpha-Béta}
\begin{itemize}
	\item $\alpha$ : Maximum provisoire d'un nœud.
	\item $\beta$ : Valeur à ne pas dépasser
\end{itemize}

\begin{enumerate}
	\item On est en convention Minimax
	\item Pour appliquer Alpha-Béta, il faut passer en Négamax : prendre l'opposé des valeurs des feuilles
	\item Si on applique Négamax la valeur qui remonte est 8 : il existe une stratégie gagnante pour B.
\end{enumerate}<++>

	\appendix
	\lstlistoflistings

\end{document}

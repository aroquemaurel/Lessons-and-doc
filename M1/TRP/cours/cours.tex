\documentclass[12pt,a4paper,openany]{book}
\usepackage{lmodern}
\usepackage[svgnames]{xcolor} % Required to specify font color
\input{/home/aroquemaurel/cours/includesLaTeX/couleurs.tex}

\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{wrapfig}
\usepackage[francais]{babel}
\usepackage[top=1.7cm, bottom=1.7cm, left=1.7cm, right=1.7cm]{geometry}
\usepackage{verbatim}
\usepackage[urlbordercolor={1 1 1}, linkbordercolor={1 1 1}, linkcolor=vert1, urlcolor=bleu, colorlinks=true]{hyperref}
\usepackage{tikz} %Vectoriel
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{multido}
\usepackage{amssymb}
\usepackage{float}
\usepackage[francais]{minitoc}
\usepackage[final]{pdfpages} 
\usepackage{graphicx} % Required for box manipulation

\newcommand{\titre}{Techniques de base de résolution de problèmes}
\newcommand{\subtitle}{IA}
\newcommand{\auteur}{Antoine de \bsc{Roquemaurel}}
\newcommand{\formation}{M1 Informatique -- Développement Logiciel}
\newcommand{\semestre}{7}
\newcommand{\annee}{2014}
\newcommand{\prof}{C. \bsc{Cayrol}}


\newcommand{\pole}{}
\newcommand{\sigle}{oim}


\input{/home/aroquemaurel/cours/includesLaTeX/listings.tex}
\input{/home/aroquemaurel/cours/includesLaTeX/l2/cours.tex}
\input{/home/aroquemaurel/cours/includesLaTeX/remarquesExempleAttention.tex}
\input{/home/aroquemaurel/cours/includesLaTeX/polices.tex}
\input{/home/aroquemaurel/cours/includesLaTeX/affichageChapitre.tex}
\newcommand{\pfp}{\texttt{pfp}}

\newcommand{\ifp}{\texttt{if}}
\newcommand{\elsep}{\texttt{else}}

\input{/home/aroquemaurel/cours/includesLaTeX/couverture.tex}
\makeatother
\includeonly {
}
\begin{document}
	\thispagestyle{empty} % Removes page numbers
	\titleBC 
	\dominitoc
	\setcounter{tocdepth}{1}
	\setcounter{secnumdepth}{3}
	\setcounter{minitocdepth}{1}

	\chapter{Introduction : Les agents résolveurs de problème}
	\section*{Les agents rationnels}
	Il est dans l'environnement et peut le percevoir. 

	\begin{definition}
		L'\textbf{agent} est \textbf{rationnel} s'il agit toujours au mieux sur l'environnement de manière à atteindre ses objectifs mais en tenant compte de ses
	compétences ou capacités.
	\end{definition}

	Un agent rationnel peut possèder les fonctions importantes suivantes : 
	\begin{itemize}
		\item Perception, Modélisation, Représentation	
		\item Raisonnement (inférence)
		\item Communication
		\item Apprentissage
		\item Élaboration de projets collectifs
	\end{itemize}

	On ajoute à un agent une mesure de performance, plus ses performances seront élevés plu il sera rationnel.

	Un agent rationnel peut être plus ou moins autonome. S'il n'est pas autonome il va avoir un comportement dit << Réflexe >>, dans l'autre cas il va
	apprendre au fur et a mesure qu'il résous sont environnement, ou son comportement, il sera de plus en plus rationnel. \\

\begin{exemple}
	\begin{tabular}{cccc}
		\textbf{Perceptions} & \textbf{Environnement} & \textbf{Actions} & \textbf{Buts}\\
		\hline
		\begin{minipage}{0.2\textwidth}
			\begin{itemize}
				\item GPS
				\item Compteur de vitesse
				\item Radar
			\end{itemize}
		\end{minipage}
		&
		\begin{minipage}{0.25\textwidth}
			\begin{itemize}
				\item Piéton 
				\item Véhicules
				\item Réseau routier
				\item Client
			\end{itemize}
		\end{minipage}
		&
		\begin{minipage}{0.17\textwidth}
			\begin{itemize}
				\item Accélérer
				\item Freiner
			\end{itemize}
		\end{minipage}
		&
		\begin{minipage}{0.3\textwidth}
			\begin{itemize}
				\item Satisfaire la démarche 
			\end{itemize}
		\end{minipage}
	\end{tabular}
\end{exemple}

\section{L'intelligence artificielle : situation d'une discipline}
L'intelligence artificielle est à la fois une science et une technique. On cherche à observer, étudier, comprendre, modéliser on les appel les
capacités cognitives.

Un agent intelligent est un agent qui peut effectuer des tâches qui serait qualifiée d'intelligentes si un humain les avaient réalisés.

En Intelligence Artificiel, on utilise des notions dans plusieurs domaines : 
\begin{description}
	\item[Philosophique] Notamment les travaux de Platon ou Aristote.
	\item[Mathématiques] Utilisation de théorèmes 
	\item[Psychologie] Étude du comportement humain
	\item[Neuro-sciences] Essayer de comprendre le fonctionnement du cerveau humain
	\item[Ethologie] Étude du comportement animal dans son milieu naturel : reproduire des modèles de comportement animals. Fourmis, abeilles,
		corbeaux, pies, \ldots
	\item[Linguistique] Étude des langues naturelles
	\item[Économie] 
	\item[Informatique] Pour le développement
\end{description}

\section{Développement de l'Intelligence Artificiel}
En 1956, lors d'une conférence assez célèbre, J. Mac Carthy à lancé un projet avec l'idée que tout ce qui relève de l'intelligence peut être modéliser
afin qu'une machine puisse le reproduire.

À la fin des années 1960, il y a eu les premiers logiciel d'IA, puis l'algorithme A*

Dans la fin des années 1980, c'était la grande mode, on pensait pouvoir utiliser l'informatique n'importe où, nous étions trop ambitieux, ce qui à
provoqué une retombée néfaste due à la déception.

Dans la fin des années 1990, cela repart, souvent couplée à d'autres disciplines tel que la robotique, il y a de nouveau des avancées, mais nous
sommes devenus conscient du fait qu'il soit nécessaire de travailler avec d'autres personnes.

\begin{exemple}
	\begin{itemize}
		\item Recherche dans les jeux difficiles, tel que les Echecs, le Go.	
		\item Robotique
		\item Vision par ordinateur
	\end{itemize}
\end{exemple}

	\tableofcontents
	\chapter{Le formalisme des espaces d'états}
		\section{Introduction}

		Formalisme: 
		\begin{itemize}
			\item État initial
			\item État but (Explicite ou implicite)
			\item Actions autorisées (ou opérateurs)
		\end{itemize}
~

		\begin{definition}
			Un \textbf{Un descendant d'un état S} est un état accessible de S par une séquence non ide d'opérateurs fils (descendant immédiats)
		\end{definition}

		\begin{definition}
			Un \textbf{espace de recherche} possède les états accessibles de l'état initial\\
			~
		\end{definition}

		\begin{exemple}
			\paragraph{Ordonnance des tâches d'un robot}
\begin{itemize}
	\item N Stations
	\item Temps entre les stations
	\item Temps de durée d'une tâche
\end{itemize}
Le problème de fonctionnement est décrit.

\begin{description}
	\item[Etat] Planning partiel
	\item[Etat but] 
\end{description}
\paragraph{Missionnaires et cannibales}
$(cg,mg,sb)$ : Canibal Gauche, Missionaire Gauche, SB
\begin{description}
	\item[Etat initial] $(0,0,d)$ 
	\item[Etat but] $(3,3,g)$
	\item[Opérateur] Traversée en respectant les contraintes 
\end{description}

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{Diagramme1.eps}
	\includegraphics[width=5.5cm]{Diagramme2.eps}
\end{figure}
		\end{exemple}

		\begin{remarque}
			La taille des espaces d'états pour des problèmes réels est extrêmement importante  : nécessité de techniques ou d'algorithmes
			spécifiques pour ne pas développer tout l'ensemble d'état et pouvoir néanmoins trouver une solution.
		\end{remarque}

		\subsection{Représentation de l'espace d'états}
		\begin{description}
			\item[En extension] On explicite tous les états possibles\footnote{Pour un taquin $3\times 3 = 181440$ états, ce qui est une taille trop
				importante pour l'expliciter, c'est-à-dire le dessiner}

			\item[En intention] 3 données sont nécessaires :
				\begin{itemize}
					\item État initial
					\item But
					\item Les opérateurs de changement d'état : une modélisation astucieuse peut amener un gain de performance\footnote{Taquin
						$3\times 3$ 32 opérateurs
						$\Leftrightarrow$ 4 opérateurs pour la case vide}
				\end{itemize}
			\item[Objectif] Utiliser des algorithmes qui vont développer une partie, la plus petite possible de l'espace d'état pour trouver un
				chemin qui mène de l'état initial à un état qui satisfait le but. Pour ça l'algorithme va développer un espace de recherche
			\item[Deux catégories d'algorithmes] ~
				\begin{itemize}
					\item Algorithmes aveugles (non informés) (Profondeur d'abord, largeur d'abord, \textit{Deep First iterative Depending} DFD,
						\ldots)
					\item Algorithmes informés : Nécessite une fonction d'estimation, appelé fonction heuristique (Glouton ou Gradient, Meilleur
						d'abord, A, A$^*$, IDA$^*$, B, C,\ldots)
				\end{itemize}
		\end{description}
		\section{Recherche euristique}
		C'est une stratégie d'exploration de l'espace de recherche en fonction de choix. Il va nous dire comment choisir le prochain état à examiner.

		Une stratégie peut utiliser un heuristique.

			\begin{exemple}
				Exemples d'heuristiques : 
				\begin{itemize}
					\item Information qui classe les opérateurs applicables à un état
					\item Fonction d'évaluation d'état
			\end{itemize}
		\end{exemple}

		\begin{exemple}
			\paragraph{Coloration d'une carte}
			Carte planaire avec différentes régions colorée avec N couleurs différentes.

			Le problème est de colorer la carte tel que 2 régions adjacentes soient de couleurs différentes.

			\begin{description}
				\item[Etat]Coloration partielle. Liste de paires (région, couleur)
				\item[Etat but] Coloration acceptable complète
			\end{description}

			Ici on peut évaluer un état en mesurant la distance  au but
		\end{exemple}

		\subsection{Stratégies}
		\begin{definition}
			\textbf{Stratégie}\\ Fonction de choix du prochain état à explorer (Ou à développer)
		\end{definition}

		\begin{definition}
			\textbf{Stratégie aveugle vs stratégie informée}\\ou non informée une stratégie qui ne dépend pas du problème(Ex: en profondeurd'abord, largeur d'abord)

			Inversement, on parle de stratégie informée ou de recherche heuristique.
		\end{definition}

		\subsection{Critères d'évaluation}
		\begin{definition}
			\textbf{Complétude}\\ 
			Un algo de recherche est dit complet si l'espace d'état contient l'état but
		\end{definition}

		\begin{definition}
			\textbf{Complexité}\\
			On se base sur le facteur de branchement de l'algorithme (Membres max de fils/états, profondeur max, profondeur de l'état but le moins éloigné de la
			racine)
		\end{definition}
		\section{Algorithmes de recherche}
		\subsection{Version de base}
		\lstinputlisting[language=algo, caption=Recherche sans optimisation]{algos/1.algo}
		\lstinputlisting[language=algo, caption=Recherche avec optimisation]{algos/2.algo}
		\subsection{Recherche en profondeur d'abord}
		On met toujours le fils du prochain en file d'attente. La complétude est garantie si etseulement si lafonction est optimisée.

		\begin{figure}[H]
			\centering
			\includegraphics[width=11cm]{Diag1.eps}
			\caption{Exemple de parcours en profondeur d'abord}
		\end{figure}
		\subsection{Rercherche en largeur d'abord}
		On met le fils en queue de la file d'attente, c'est complet mais plus long.
		\begin{figure}[H]
			\centering
			\includegraphics[width=11cm]{Diag2.eps}
			\caption{Exemple de parcours en largeur d'abord}
		\end{figure}

		\subsection{Recherche informée}
		Meilleur d'abord: on doit utiliser une fonction d'évaluation d'un état. (ex: nombre de jetons mal placés).

		\textbf{Recherche d'une solution optimale à un problème} On appelle $f^*(e)$ le coût d'un chemin optima allant de $ei$ a un but passant par l'état courant $e$.

		Je cherche une fonction $f$ qui estime $f(e)=g(e)+h(e)$, $h$ étant la composante heuristique.

		\subsection{Algorithme $A^*$}
		On calcule $f(N) = \underbrace{g(N)}_{Dynamique} + \underbrace{h(N)}_{Statique}$ pour chaque nœud N, ces nœuds sont classés en fonction de
		$f(N)$ dans une lite d'attente, les plus petites valeurs d'abord. On développe toujours le nœud qui est en tête de la liste.

		Pour avoir un $A^*$ il faut que l'heuristique soit minorante, c'est-à-dire qu'elle sous estime toujours la réalité. Dans le cas contraire, nous aurons
		un algorithme $A$.
		
		\begin{definition}~\\
			$h$ est minorante si on a $h(e) \leq h^*(e)$
		\end{definition}
		\subsubsection{Propriétés d'un $A^*$}
		\begin{itemize}
			\item Si le nombre de fils par état est fini, il existe un minorant $>0$ du coût des opérateurs
			\item Complétude
			\item Si l'heuristique $h$ est minorante, ou optimiste, alors $A^*$ est admissible
		\end{itemize}

		\subsubsection{Cas particuliers d'un $A^*$}
		On prend $h=0(cst)$ un coût uniforme.

		\begin{exemple}
			Chaque opérateurs coûte 1.
		\end{exemple}

	\chapter{Le formalisme des arbres de buts}
	\begin{tabular}{cc}
		\begin{minipage}{0.5\textwidth}
		\begin{figure}[H]
			\centering
			\includegraphics[width=9cm]{diag3.eps}
			\caption{Schéma du nœud Ou}
		\end{figure}
		\end{minipage}
		&
		\begin{minipage}{0.5\textwidth}
		\begin{figure}[H]
			\centering
			\includegraphics[width=9cm]{diag4.eps}
			\caption{Schéma du nœud Et}
		\end{figure}
		\end{minipage}
	\end{tabular}

	Si l'on a un problème initial, on suppose que l'on a 3 méthodes de résolutions,ou alors qu'une seule.

	On construit alors un arbre de but qui est un cas particulier des arbres Et/Ou.

	\begin{exemple}
		\begin{figure}[H]
			\centering
			\includegraphics[width=13cm]{diag5.eps}
			\caption{Exemple de noeuds Et/Ou}
		\end{figure}
	\end{exemple}

	\section{Définitions}
	On distingue différents noeuds 
	\begin{itemize}
		\item Nœud non terminal ET
		\item Nœud non terminal OU
		\item Nœud terminal
	\end{itemize}
	On dira qu'un arbre est résolu si sa racine est résolu	On dira qu'un arbre est résolu si sa racine est résoluee

	\begin{definition}
		Un nœud terminal est :

		\begin{itemize}
			\item resolu: quand le problème associé a une solution connu sans continuer le travail
			\item en echec: 
		\end{itemize}
	\end{definition}


	\begin{definition}
		Un nœud OU est résolu ssi un de ses fils est résolu.
	\end{definition}

	\begin{definition}
		Un nœud ET est résolu ssi tout ses fils sont résolus et la contrainte est satisfaite
	\end{definition}

	\begin{remarque}
	La coloration d'une carte sera mieux formalisée ici car on peut la former en utilisant de arbres Et/Ou.
		\end{remarque}

	\section{Recherche d'une solution}
	Ici un état est un plan partiel de résolution du but initial
	\begin{description}
		\item[Etat initial]Plan vide
		\item[Etat but] Plan complet
		\item[Transition] Compléter un plan en ajoutant une action 
	\end{description}
	
~
	\begin{definition}
		Un plan partiel issu de $n$ est un sous arbre de l'arbre de but de racine $n$ qui contient au plus un fils par nœud Ou.
	\end{definition}

	\begin{definition}
		Un plan complet issu de $n$ est un sous arbre de l'arbre de but de racine $n$ contenant un fils exactement par nœud Ou et tous les fils par
		nœud Et.
	\end{definition}

	\subsection{Cas d'un environnement non déterministe}
	Dans ce cas là, on doit prendre en compte les réactions de l'environnement.
	\chapter{Recherche dans les arbres de jeux}
	\section{Arbres de jeu et arbres de buts}
		On appelle joueur de référence le joueur auquel on
		s'intéresse, c'est celui qui veut gagner.

		On construit un arbre de but, les n\oe{}représentant
		les différents choix de jeu sont des n\oe{}uds OU.
		 \begin{figure}[H]
			 \centering
			 \includegraphics[width=8cm]{ch4_1_1.eps}
		 \end{figure}

	\begin{remarque}
		On a une alternance entre les nœuds ET et les nœuds OU

	\end{remarque}

	\begin{exemple}
		 On a une pile de 7 jetons, il faut choisir une pile
		 et la couper en deux piles de tailles différentes, le
		 premier qui ne peut plus jouer à perdu.

		 On peut dessiner un arbre de jeu complet,
		 indépendant des joueurs qui représente tous les coups
		 positives.

		 \begin{figure}[H]
			 \centering
			 \includegraphics[width=15cm]{Diagramme7.eps}
			 \caption{Exemple d'arbre complet}
		 \end{figure}
	\end{exemple}
	\subsection{Définitions}
		Soit A un arbre de jeu étiqueté ET/OU.

	\begin{definition}
		Une \textbf{stratégie partielle} (Sp) est un sous arbre de A de même
		racine que A contenant au plus un fils / nœud ou.
	\end{definition}

	\begin{definition}
		Une \textbf{stratégie complète} (pour le joueur de
		référence) est 
		un sous arbre de A, de même racine, contenant un
		fils/nœud OU et tous les fils / nœud ET.
	\end{definition}

	\begin{definition}
		Une \textbf{stratégie gagnante} (pou le joueur de référence)
		est une stratégie complète dont toutes les feuilles sont
		gagnantes, on va gagner dans tous les cas 
	\end{definition}

	\begin{attention}
		Il existe au moins une stratégie gagnante pour l'un des joueurs
	\end{attention}

	\subsection{Intéressement au gain}
	On ajoute un intéressement au gain du jeu.

	\begin{definition}
		Pour un joueur J, le \textbf{gain garanti} est le gain qui est assuré à J quelque soit la réponse de l'adversaire.
	\end{definition}

	\begin{definition}
		Le \textbf{gain garanti maximal} est le meilleur gain que le joueur puisse avoir.
	\end{definition}


	\subsubsection{Trouver le gain garanti}
	Plusieurs méthodes existent : 
	\paragraph{<< Brute Force >>} On cherche toutes les stratégies gagnantes pour J, on a le gain garanti pour chaque stratégie gagnante, et on peut trouver la meilleure stratégie gagnante associée au gain garanti maximum.

	\paragraph{Procédure minimax} Soit A un arbre de jeu étiqueté ET/OU, les feuilles sont valuées pour le joueur de référence.

On remonte une valeur à la racine:
\begin{itemize}
	\item OU max(valeurs des fils);
	\item ET min(valeurs des fils);
\end{itemize}
~

	\begin{attention}
		La valeur minimax de l'arbre est le gain garanti maximum, c'est-à-dire le gain garanti par la meilleur stratégie gagnante.
	\end{attention}

	\begin{remarque}
		Si le joueur de référence commence, on obtient aussi le meilleurs 1er coup.

~
	\end{remarque}
	
	\subsection{Cas d'un arbre de jeu incomplet}
	\begin{attention}
		Les feuilles ne sont plus des situations terminales du jeu.
	\end{attention}

	Une estimation statique de la On applique une fonction à ces feuilles qui estiment l promese de la situation, pour pouvoir comprer 2 situations.
	
	La valeur minmax de l'arbre est la promesse de la situation la plus prométteuse pour J qui peut être atteinte contre toute riposte de
	l'adversaire.
	
\begin{itemize}
	\item Développer l'arbre de jeu à profondeur 4
	\item Appliquer l'estimation aux feuilles
	\item Remonter le minmax et voir le coup à jouer
	\item J Joue
	\item L'adversaire répond
	\item Recommencer
\end{itemize}

\section{Recherche du minmax}
Soit A un arbre, complet ou incomplet.


	\chapter{Le formalisme des CSP}

\end{document}


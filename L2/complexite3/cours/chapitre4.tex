\chapter{Structure de données et complexité}
\section{Les principales structures de données}
Les opérations les plus courantes: 
\begin{description}
	\item[I]Insertion
	\item[A] Test d'appartenance
	\item[S] Suppression
	\item[SD, SP, SM] Suppression du dernier élément du premier élément, de l'élément minimum.
\end{description}

\begin{tabular}{|c|c|c}
	\textbf{TDA}\footnotemark & \textbf{Opération de base} & \textbf{Réalisation pour laquelle ces opérations sont on en O(log n)}\\
	\hline
	Pile & I, SD & liste chainées\\
	\hline
	File & I, SD & liste chainée avec deux pointeurs début et fin\\
	\hline
	index statique & A & tableau trié\\
	\hline
	file de priorité & I, SM & tas\\
	\hline
	ensemble & A, I, S & table d'hâchage\footnotemark\\
	\hline
	ensemble trié & A, I, S, SM & ABR, arbre rouge-noir, arbre AVL, B-arbre\footnotemark\\
\end{tabular} 
\footnotetext{Type abstrait de données}
\footnotetext{Complexité moyenne O(log n)}
\footnotetext{Complexité moyenne O(log n)}

\remarque{Ensemble, les opérations I et Sm permettent de trier}

\section{Tas (<<Heap>>)}
\paragraph{Définition} Un tableau T[1..n] est un tas si $\forall i \in \{2,3,\cdots,n\}$ $$T[\frac{i}{2}] \leq T[i]$$
Autrement dit, $\forall k T[k] \leq T[2k]$ et $T[k] \leq T[2k+1]$.\\
On appelle l'indice $\frac{i}{2}$ le père de l'indice $i$.

\exemple{
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|}
\hline
	2&6&5&10&9&7&11&12&17&213\\
\hline
\end{tabular}

}
L'algorithme d'insertino d'un élément $x$ dans un tas $T$ de taille $n$.

\lstinputlisting[language=Algo]{4-tas.algo}
\paragraph{Ex: Insertion de x = 3}
\begin{verbatim}
			   2
			/      \
			6       5
		   /   \     / \
		 10     9   7  11             
		/  \    | \
	   12   17	13 3 
   \end{verbatim}

Soit ($b_t, \cdots, b_0$) l'écriture de $n+1$ en base 2, où $b_t=1$ et $\forall r \in \{0,\cdots, t-1\}, b_r \in \{0,1\}.$
La variable $i$ prend successivement les valeurs
$(b_t\cdots b_0)_2 (b_t\cdots b_1)_2 (b_t\cdots b_2)_2 \cdots (b_t)_2$

Dans le pire des cas, l enombre d'itérations de la boucle \texttt{tantque} est $t=[\log_2(n+1)+1]$. Donc al complexité maximale de insertion est $\Theta(\log_n)$. 

\section{Table de hâchage (<< hash table >>) ou adressage calculé}
Soit E un esemble d'enregistrements, chacun identifiabble par une clé unique\footnote{Par exemple numéro de SS}. Supposons que les clés appartiennent à un univers U de taille M. Si M n'est pas trop grand on peut utiliser l'adressage direct : un tableau T tel que T[x] contient l'enregistrement associé à la clé x.

\texttt{T[x] = NULL} si la clé d'aucun enregistrement de E ne prenne la valeur x.\footnote{Par exemple x = numéro d'une chambre d'hôtel}. La complexité est de $\Theta(M)$ car il faut initialiser tout le tableau.

La méthode d'adressage dierct est inefficace, voir impossible à mettre en \oe{}uvre si M est très grand\footnote{Par exemple x=numéro de SS}. Pour stocker n enregistrement dans un tableau de taille m où $m=\Theta(n)$ et $m << m$, on peut utiliser une fonction de hâchage $h : U \rightarrow\{0,1,\cdots,m-1\}$.

$h(x)$ est l'adresse dans le tableau où on stockera l'enregistrement de clé x que l'on notera Record(x).


Si h(x) = h(y) où $x\neq y$, alors on dit qu'il y a une collision.

Pour gérer les collisions, on peut stocker à l'emplacement $T[i]$ une liste chaînée comportant
tous les enregistrements Record(x) tels que$ h(x)=i$

\paragraph{Analyse de la complexité du test d'appartenance}
$T_max(n) = \theta(n)$ car dans le pire des cas $\forall x y h(x) = h(y)$ et il faut chercher
$x$ dans une liste chainée de longueur $n$ pour calculer $Tmoy$ on suppose une distribution
uniforme des valeurs de $h(x)$ dans l'emsemble $\{o... m-1\}$ soit $li$ la longueur de la
liste $T[i]$

On a stocké n enregistrements donc
$$ \sum^{m-1}_{i=0} L_i = n$$
donc $$\sum^{m-1}_{i=1} E(Li)  = n$$

Où $E(Li)$ représente l'espérance de Li, mais $E(Li)$ est identique pour $i = 0, ..., m-1$ d'où
$\forall i E(Li) = \frac{n}{m} = \Theta(1)$ car $m = \Theta(n))$

On en déduit $_moy (n) = \Theta (1)$
\remarque{Complexité en espace = m = Theta(n)}

\section{ABR -- Arbre binaire de Recherche (<< Binaray Search tree >>)}
\subsection{Rappel de la terminologie des arbres.}
	\begin{verbatim}
      1
    /  \
    2   3
  /  \   \ 
  4   5   6
     / \
    7   8
	\end{verbatim}
    
    \begin{description}
    \item[1, ..., 8] Noeuds
     \item[1] Racine
     \item[4,6,7,8] feuilles
     \item[2] Père de 4 et 5
     \item[1,2,5,8] Chemin de longueur 3 de la racine vers une feuille.
    \end{description}
    \paragraph{Définition} Un ABR est un arbre avec une valeur $val(\alpha)$ associée à chaque
	nœud $\alpha$ et qui satisfait les propriétés suivantes : 
    \begin{enumerate}
    \item Si $\alpha \in sous-arbre-gauche(\beta)$, alors $val(\alpha) \leq val(\beta)$
    \item Si $\alpha \in sous-arbre-droite(\beta)$, alors $val(\alpha) \geq val(\beta)$
    \end{enumerate}
    
    Soient H(n) la hauteur de l'ABR et T(n) le temps total pour construire l'ABR, où n est le nombre de noeuds dans l'arbre.
    \subsubsection{Meilleur cas}
	\begin{verbatim}
    /   \ 
   /     \
  / \   / \
 /\ /\ /\ /\
 \end{verbatim}
 
$ H(n) = \Theta(\log n)$
    \subsubsection{Pire cas}
	\begin{verbatim}
    \
     \ 
      \ 
       \
        \
 \end{verbatim}
        
$        H(n) = \Theta(n)$

\chapter{Exercices}
\section{Initiation}
	\subsection{Exercice 1}
\'Ecrire un programme qui lit une série de 10 valeurs et affiche la position du minimum et du maximum de la série.
\subsubsection{\'Etape 1: Analyser le problème}
\begin{enumerate}
	\item Lire les valeurs
	\item calculer les min et max
	\item afficher le résultat
\end{enumerate}
\subsubsection{\'Etape 2: Spécifier les sous-problèmes}
Identifier les entrée, les sorties et leurs propriétés.
\paragraph{\texttt{LireLesValeurs}}
\begin{description}
	\item[Entrée] Nombre, les valeurs à lire
	\item[Sortie] Tableau contenant les valeurs lues
\end{description}
\paragraph{\texttt{CalculerMinEtMax}}
\begin{description}
	\item[Entrée] Le tableau des valeurs et le nombre de valeur 
	\item[Sortie] Position, min et max. 
\end{description}
\newpage
\subsubsection{\'Etape 3: Le code}
\lstinputlisting[language=C, caption=Exercice 1 -- Code du programme]{annexes/exo1.c}
\newpage
\section{Tableau de situation}	
\subsection{Exercice 2}
\subsection{Exercice 3}

\lstinputlisting[language=C, caption=Exercice 3]{annexes/exo3.c}
\begin{center}
\begin{tabular}{c  |  c  c  c  c  }
\textbf{Point d'arrêt }& \textbf{T} & \textbf{j} & \textbf{i} &\textbf{n}\\
\hline
1 & 0,0,0,0,0 & 3 & 5 & 1\\
\hline
2 & 0,0,0,1,0 & 4 & 3 & @\\
\hline
3 & 5,9,1,1,1&4&5&\\
\hline
\end{tabular}
\end{center}
\newpage
\section{Effets de bords}
\subsection{Exercice 4}
\lstinputlisting[language=C, caption=Exercice 4]{annexes/exo4.c}
\begin{center}
\begin{tabular}{c |  c  c  c  c  c  c  }
	\textbf{Point d'arrêt} & \textbf{y} & \textbf{x} & \textbf{t} & \textbf{i} & \textbf{z} & \textbf{f}\\
	\hline
	2 & 10 & / & / & 1 && \\
	\hline
	1 & 11 & 1 & 2 & 1 & / & 13\\
	\hline
	3 & 11 & / & / & 1 & 24 & /\\
	\hline
\end{tabular}
\end{center}
\newpage
\subsection{Exercice 5}
\lstinputlisting[language=C, caption=Exercice 5]{annexes/exo5.c}
\begin{center}
\begin{tabular}{c |  c  c  c  c  c  }
	\textbf{Point d'arrêt} & \textbf{i} & \textbf{j} & \textbf{x} & \textbf{y} & \textbf{z}\\
	\hline
	3 & 3 & 7 &/ &/&/\\
	\hline
	1 & &&@i&@i&@j\\
	\hline
	2 & 6 & 12 & @i & @i & @j\\
	\hline
	4 & 6 & 12 & / & / & /\\
	\hline
	5 & 3 & 7 & / & / & / \\
	\hline
	1 & 3&10 &@j&@j&@i\\
	\hline
	2 & 20 & 10 & @j&@j&@i\\
	\hline
\end{tabular}
\end{center}
\newpage
\subsection{Exercice 6}
\lstinputlisting[language=C, caption=Exercice 6]{annexes/exo6.c} 
\begin{tabular}{c |  c  c  c  c  c  c  }
	\textbf{Point d'arrêt} & \textbf{i} & \textbf{j} & \textbf{x} & \textbf{a} & \textbf{a} & \textbf{f}\\
	\hline
	2&10&40&/&/&/&/\\
	\hline
	1 & 20 & 40 & / & 10 & 40 & 50\\
	\hline
	3 & 20 & 40 & 50 & / & / & /\\
	\hline
\end{tabular}

\section{Spécification}
\subsection{Exercice 7}
	\'Ecrire la spécification d'un programme qui dans un tableacu T de N entiers calcul le nombre n de nombre positifs dans le tableau.

	\begin{itemize}
		\item $N > 0$
		\item \texttt{calculeNbPos(T,N,n)}
		\item $(o \leq n \leq N) \wedge (n = \nu I : o \leq I < N T[I] \geq 0) $
	\end{itemize}
\subsubsection{Exercice 8}
	Soit T un tableau croissant (non strict) de N entier et X un entier.\\
	Spécifier un programme qui calcule la position de la dernière occurrence de T inférieure ou égale à X avec $T[0] \leq X < T[N-1]$

	\begin{itemize}
	%	\item $T[0] \leq X < T[N-1]$, $T[I] \leq T[I+1]$, $N > 0$
		\item $(N > 1) \wedge (T[0] \leq X) \wedge (X < T[N-1]) \wedge (\forall I : 0 \leq I < N - 1 \rightarrow T[I] \leq T[I+1])$
		\item \texttt{searchPosition(T, N, X, p));} 
		\item $(0 < p < N - 1) \wedge (T[p] \leq X) \wedge (T[p+1] > X)$
	\end{itemize}
	\remarque{Dans la suite du cours, nous pourrons utiliser un raccourcie afin de savoir si un tableau est trié par ordre croissant : $(T,N,\leq)$

	Celle-ci pourra être utilisée dans la copie à condition qu'elle soit définie au préalable.}

\subsection{Exercice 8}
	Soit un tableau T non vide de N entiers.  \'Ecrire la spécifications du qui programme qui calculent :
	\begin{itemize}
		\item La première position de la valeur max de T
		\item La dernière position de la valeur max de T
	\end{itemize}
	\subsubsection{Calcule de la première position}
	\begin{itemize}
		\item $N > 0$ 
		\item \texttt{searchFirstPosition(T, N, f);} 
		\item $(\forall I :0 \leq I < f \rightarrow T[I] < T[f]) \wedge (\forall I (f \leq I < N) \rightarrow (T[I] \leq T[f]))$ 
	\end{itemize}
	\subsubsection{Calcule de la dernière position}
	\begin{itemize}
		\item $N > 0$ 
		\item \texttt{searchLastPosition(T, N, l);} 
		\item $(\forall I :0 \leq I < l \rightarrow T[I] \leq T[l]) \wedge 
			(\forall I (l < I < N) \rightarrow (T[I] < T[l]))$ 
	\end{itemize}

\subsection{Exercice 9}
	\'Ecrire la spécification d'un programme qui, dans un tableau T de N entiers tous différents cherche la position d'une valeur X si elle existe ou retourne N si elle n'existe pas.

	\begin{itemize}
		\item $(N\geq0) \wedge (\forall I : 0 \leq I < N \rightarrow (\forall (I, J) : 0 \leq I < N \wedge (0 \leq J < N) \rightarrow T[I] = T[J] \leftrightarrow (I = J)$\footnote{Cela peut aussi s'écrire $N\leq 0) \wedge (\forall I (O \leq I < N) \rightarrow \forall J : J \neq I \wedge 0 \leq J < N \rightarrow T[I] \neq T[J]$}
		\item \texttt{search(T, N, x)}
		\item $(0 \leq p < N \wedge T[p] = X) \vee (p=N) \leftrightarrow \forall I (o\leq I < N) \rightarrow T[I] \neq X))$ 
	\end{itemize}

	\subsection{Exercice 10}
	Spécifier un programme qui, dans un tableau T de N éléments trié par ordre croissant non strict retourne la longueur du plus grand plateau\footnote{Un plateau est quand il y a plusieurs fois le même caractère}.

\begin{itemize}
	\item $(T, N, \leq) \wedge N > 0$
	\item \texttt{longueurPlusGrandPlateau(T,N,l);}
	\item $(1 \leq l \leq N) \wedge (\exists I : 0 \leq I < N-l)\wedge (T[I] = T[I+l-1])$ 
\end{itemize}
	\subsection{Exercice 11}
		Spécifier un programme qui, dans un tableau de N entiers calcule le nombre de doublons : un doublon est une succession de 2 nombres identiques.

		\begin{itemize}
			\item $N > 0$
			\item \texttt{calculeDoublons(T, N, n);}
			\item $n = \nu I : 0 \leq I < N \wedge T[I] = T[I+1]$
		\end{itemize}
		\remarque{
			Dans le cas ou deux doublons ne sont pas forcément côte à côte, le prédicat de sortie deviendrait : 
			$$n = \sum^{N-1}_{I=0} \nu J : I < J < N \wedge T[J] = T[I]$$
		}

\section{Preuves de programmes}
\subsection{Séquence}
\begin{itemize}
	\item \texttt{/* f = i! */}
	\item \texttt{f = f * (i + 1);\\i = i + 1;}
	\item \texttt{/* f = i! */}
\end{itemize}
\begin{eqnarray*}
	f = i! &\rightarrow& \texttt{pfp}("f = f\times (i+1); i = i +1;", f= i!)\\
	f=i!&\rightarrow&\texttt{pfp}("f=f\times(i+1);",\texttt{pfp}("i=i+1",f=i!)\\
	%f = i! &\rightarrow& \textt{pfp}("f = f \times (i + 1);" f = (i + 1)!)
\end{eqnarray*}
\begin{itemize}
	\item \texttt{/* (x = A) $\wedge$ (y = B) $\wedge$ (z = C)}
	\item \texttt{x = x + y +z;\\z = x - y - z;\\y = x - y -z;\\x = x - y - z;}
	\item \texttt{/* (x = B) $\wedge$ (y = C) $\wedge$ (z = A) */}
\end{itemize}
\begin{eqnarray*}
	PE &\rightarrow& \texttt{pfp}("x=x+y+z;z=x-y-z;y=x-y-z;x=x-y-z;", (x=B)\wedge(y=C)\wedge(z=A)\\
	PE &\rightarrow& \texttt{pfp}("x=x+y+z, z-x-y-z;y=x-y-z;", \\&&\texttt{pfp}("x=x-y-z;(x=B)\wedge(y=C)\wedge(z=A)\\
	PE &\rightarrow& \texttt{pfp}("x=x+y+z, z-x-y-z;y=x-y-z;", x-y-z=B)\wedge y=C \wedge z = A\\
	PE &\rightarrow& \texttt{pfp}("x=x+y+z,z=x-y-z", (y=B)\wedge (x-y-z=C)\wedge z = A\\
	PE &\rightarrow& \texttt{pfp}("x=x+y+z", (y=B)\wedge (z=C) \wedge (x-y-z=A)\\
	PE &\rightarrow& (y=B) \wedge (z=C)\wedge(x=A) \textmd{Vrai parceque }p\rightarrow p = \textmd{vrai}
\end{eqnarray*}

\subsection{Sélection} \label{pfpSequence}
\subsubsection{Exercice 1}
\begin{lstlisting}[language=C]
/* x = A */
if(x < 0)
x = -x;

/* x = |A| */
\end{lstlisting}

\begin{eqnarray*}
/*x = A*/ &\rightarrow& \pfp ("if(x < 0)\{ x = -x \}", x = |A|)\\
/*x = A*/ &\rightarrow& (((x<0)\rightarrow \pfp ("x=-x;", x = |A| ) \wedge (x >= 0 \rightarrow x = |A|)))\\
/*x = A*/ &\rightarrow& (((x < 0) \rightarrow (-x = |A|)) \wedge (( x >= 0) \rightarrow (x = |A|)))\\
\end{eqnarray*}
$( A ( A < 0) \rightarrow (-A = |A|) ) \wedge (A >= 0 \rightarrow (A=|A|))$
Définition de la valeur absolue $|.|$.

\subsubsection{Exercice 2}
\begin{lstlisting}[language=C]
/* x = A $\wedge$ y = B */
if (A < B) {
x = A;
y = B;
} else {
x = B;
y = A;
}
/* x $\leq$ y */ 
\end{lstlisting}
\begin{eqnarray*}
PE &\rightarrow& \pfp ("\ifp (A < B) \{ x = A; y = B\}\elsep \{ x = B; y =A\}", x \leq y)\\
PE&\rightarrow&((A<B)\rightarrow\pfp("x=A;y=B",x\leq y))\wedge((A\geq B)\rightarrow\pfp("x=B;y=A",x\leq y))\\
PE &\rightarrow& ((( A < B) \rightarrow (A \leq B)) \wedge (A \geq B ) \rightarrow (B \leq A))
\end{eqnarray*}
Vrai par définition. A et toujours inférieur à B. $(A \geq B) \rightarrow (B \leq A)$ est une Tautologie. 
\subsubsection{Exercice 3}
$$\pfp ("\ifp (x \geq y )\{z=x;\}\elsep\{z=y\}",z=\texttt{max}(x,y))$$
\begin{eqnarray*}
x \geq y  &\rightarrow&	\pfp ("\ifp (x \geq y )\{z=x;\}\elsep\{z=y\}",z=\texttt{max}(x,y))\\
x \geq y &\rightarrow& \pfp ("z = x", z = \texttt{max}(x,y))\\
x < y &\rightarrow& \pfp ("z = y", z = \texttt{max}(x,y))\\
x \geq y &\rightarrow& x = \texttt{max}(x,y)\\
x < y &\rightarrow& y = \texttt{max}(x,y)
\end{eqnarray*}
C'est une tautologie par définition de \texttt{max}.

\subsubsection{Exercice 4}
$$\pfp ("\ifp (x > y) \{ if(x \%2 ==  0) \{ x = x - 2\}\} \elsep \{y=y-1;\}", y-2 < x);$$
\begin{eqnarray*}
(x > y) &\rightarrow& \pfp("if(x\%2 == 0) { x = x-2; } ", y-2 < x)) \wedge ( ( x \leq y) \rightarrow \pfp ("y = y-1;", y - 2 < x) )\\
(x > y) &\rightarrow& ( ( (x \%2 = =0) \rightarrow \pfp ("x = x-2", y-2 < x) \wedge \\
& &(x \% 2 != 0) \rightarrow(y-2 < x)) \wedge ( (x \leq y) \rightarrow (y-z < x))\\ 
(x > y) &\rightarrow& ( (x\%2 = = 0)\rightarrow ( (y-2) < (x - 2) ) \wedge ( ( x\%2 != 0) \rightarrow (y-2 < x))) \wedge (x \leq y \rightarrow y-z < x) \\
(x > y) &\rightarrow& (x \leq y \rightarrow y - z < x)
\end{eqnarray*}

\subsubsection{Exercice 5}
\begin{lstlisting}[language=C]
/* $N \geq 0$ */

/* P Tableau de polynôme
* N Degré du polynôme
* X Point ou je veux évoluer le polynôme
* r Résultat du polynôme
*/
calculPolynome(P,N,X,r);
/* $r = \sum^N_{k=0} A[I]X^k $ */
\end{lstlisting}
\begin{lstlisting}[language=C]
/* $N \geq 0$ */

/*	INV = $(o \leq i \leq N) \wedge (r = \sum^i_{k=0} A[k]x^k) \wedge (y = x^i)$*/
while(c) {
/* c \wedge INV */
corps;
/* INV */
}
/* $\neg c \wedge INV$ */
/* $p = \sum^N_{k=0} A[k] x^k$ */
\end{lstlisting}
\paragraph{INVARIANT}
$$(o \leq i \leq N) \wedge (r = \sum^i_{k=0} A[k]x^k) \wedge (y = x^i)$$
\paragraph{Intitialisation}
\begin{enumerate} 
	\item INIT 0 \begin{lstlisting}[language=C,numbers=none]
i = 0; 
p = 0; 
y = 1;
\end{lstlisting}~
\begin{eqnarray*}
PE &\rightarrow& \pfp (\texttt{init}\ 0, \texttt{INV})\\
N \geq 0 &\rightarrow& \pfp ("i=0;p=0", p=\sum^i_k=0 A[k]x^k \wedge 1 = x^i);\\
N \geq 0 &\rightarrow& \pfp ("i=0", 0 = \sum^i_{k=0} A[k]x^k \wedge 1 = x^i\\
N \geq 0 &\rightarrow& 0 = \sum^0_{k=0} A[k]x^k \wedge 1 = x^0\\
(N \geq 0 &\rightarrow& 0 = A[0] \wedge 1 = 1) \Rightarrow \textrm{Faux et Vrai, donc le programme est Faux} \end{eqnarray*}
	\item INIT 1 \begin{lstlisting}[language=C,numbers=none]
i = 0; 
p = A[0]; 
y = 1;
\end{lstlisting}
\begin{eqnarray*}
PE &\rightarrow& \pfp (\texttt{init}\ 1, \texttt{INV})\\
N \geq 0 &\rightarrow& \pfp ("i=0;p=A[0]", p=\sum^i_k=0 A[k]x^k \wedge 1 = x^i);\\
N \geq 0 &\rightarrow& \pfp ("i=0", A[0] = \sum^i_{k=0} A[k]x^k \wedge 1 = x^i\\
N \geq 0 &\rightarrow& A[0] = \sum^0_{k=0} A[k]x^k \wedge 1 = x^0\\
(N \geq 0 &\rightarrow& A[0] = A[0] \wedge 1 = 1) \Rightarrow \textrm{Vrai et Vrai, donc le programme est correct}
\end{eqnarray*}
\end{enumerate}
L'initialisation nécessaire est donc init 1.
\paragraph{Boucles} 
\begin{enumerate} 
	\item \begin{lstlisting}[language=C,numbers=none]
while(i < N) { 
++i; 
p = p + A[i-1] * y; 
y = y * X; 
}
	\end{lstlisting}~
	\'Etape numéro \ref{etape3boucle} (Cf section \ref{pfpBoucle} page \pageref{etape3boucle})
	\begin{eqnarray*}
		\neg C \wedge INV &\rightarrow& PS\\
		(i > N) \wedge (p = \sum^i_{k=0} A[k] x^k) \wedge(y=x^i) &\rightarrow& p = \sum^N_{k=0}A[k]x^k\\
		(i > N) \wedge (p = \sum^i_{k=0} A[k] x^k) \wedge(y=x^i) &\rightarrow& p = \sum^N_{k=0}A[k]x^k\wedge (i=N)\\
		(i > N) &\rightarrow& (i = N) \Rightarrow \textrm{C'est donc faux.}\\
	\end{eqnarray*}
	\remarque{Nous sommes partis de la conclusion et avons essayé de faire apparaitre notre hypothèse en partie droite.}
	\item \begin{lstlisting}[language=C,numbers=none]
while( i != N) { 
++i; 
p = p + a[i-1] * y; 
y = y * X 
} 
\end{lstlisting}~
	\'Etape numéro \ref{etape3boucle} (Cf section \ref{pfpBoucle} page \pageref{etape3boucle})
	\begin{eqnarray*}
		\neg C \wedge INV &\rightarrow& PS\\
		(i \neq N) \wedge (p = \sum^i_{k=0} A[k] x^k) \wedge(y=x^i) &\rightarrow& p = \sum^N_{k=0}A[k]x^k\\
		(i \neq N) \wedge (p = \sum^i_{k=0} A[k] x^k) \wedge(y=x^i) &\rightarrow& p = \sum^N_{k=0}A[k]x^k\wedge (i=N)\\
		(i \neq N) &\rightarrow& (i = N) \Rightarrow \textrm{C'est donc vrai}. 
	\end{eqnarray*}
	\'Etape numéro \ref{etape2boucle} (Cf section \ref{pfpBoucle} page \pageref{etape3boucle})
	\begin{eqnarray*}
		C \wedge INV &\rightarrow& \pfp(corps, INV)\\
		C \wedge INV &\rightarrow& \pfp ("i++;p=p+A[i-1]*y;", (p=\sum^i_{k=0}A[k]x^k)\\&&\wedge(y*x=x^i)\wedge(0\leq i\leq n )\\
		C \wedge INV &\rightarrow& \pfp ("i++;", (p+A[i-1]*y = \sum^i_{k=0}A[k]x^k)\\&&\wedge(y*x=x^i)\wedge(0\leq i\leq n )\\
		(i \neq N) \wedge (0\leq i \leq N) \wedge\\ (p = \sum^i_{k=0} A[k] x^k) \wedge (y=X^i) &\rightarrow& (p+A[i] * i = \sum^{i+1}_{k=0}A[k]x^k) \wedge (y \times x = x^{i+1}) \wedge (0 \leq i+1 \leq N)\\
		(i \neq N) \wedge (0\leq i \leq N) \wedge \\(p = \sum^i_{k=0} A[k] x^k) \wedge (y=X^i) &\rightarrow& A[i] \times x^i = p+A[i+1]x^{i+1} \wedge x^i \times = x^{i+1} \wedge Tautologie \\
		(i \neq N) \wedge (0\leq i \leq N) \wedge \\(p = \sum^i_{k=0} A[k] x^k) \wedge (y=X^i) &\rightarrow& Faux \wedge Tautologie \wedge Tautologie\Rightarrow \textrm{Le programme est donc faux} \\
	\end{eqnarray*}
\item \begin{lstlisting}[language=C,numbers=none]
while(i == N) { 
++i;	
p = p +(A[i] * y * X); 
y = y * X; 
}
\end{lstlisting}
Ce programme effectue la correction de l'erreur détectée plus haut. Il est correct.
\end{enumerate}

\subsection{Exercice 6 : Suite de Fibonacci}
\remarque{
Le rang $n$ de la suite de Fibonacci est défini comme suit: \\
$F_n = 1$ si $n=0$ ou $n=1$\\
$F_n = F_n-2 + F_n-1$ si i$n > 1$}

\begin{lstlisting}[language=C,numbers=none]
/* $N \geq 0$ */
i = 0; 
a = 1; 
b = 1;
/* $INV = (F_i = a) \wedge (F_n-1 = b) \wedge (o \leq i \leq N)$ */
while(c) {
/* $c \neg INV$ */
i++;
b += a;
a = b - a;
/* $INV$ */
}
/* $\neg c \wedge INV$ */
/* $F_n = \{\cdots\}$ */
\end{lstlisting}

\remarque{Il est conseillé de commencer par l'étape la plus facile, en effet, une étape et nous n'avons pas à effectuer les autres}
\paragraph{Etape 1}
\begin{eqnarray*}
PE &\rightarrow& \pfp("init", INV)\\
N \geq 0 &\rightarrow& (F_{i+1} = 1) \wedge (F_i = 1) \wedge (i=0)\\
N \geq 0 &\rightarrow& (F_1 = 1) \wedge (F_0 = 1)\Rightarrow \textrm{Tautologie par définition}
\end{eqnarray*}
\paragraph{Etape 3}
\begin{eqnarray*}
(i = N) \wedge (F_i = a) \wedge (F_{i+1} = b) \wedge (0 \leq i \leq N) &\rightarrow& F_N = a\\
(F_n = a) \wedge (F_{N+1}) \wedge (0 \leq N) &\rightarrow& F_N = a \Rightarrow \textrm{Tautologie}
\end{eqnarray*}

\paragraph{Etape 2}
\begin{eqnarray*}
(i \neq N) \wedge (F_i = a) \wedge (F_{i+1} = b) \wedge (0 \leq i \leq N) &\rightarrow& \pfp("\cdots", F_i=b-a \wedge F_{i+1} = b \wedge \cdots)\\
&\rightarrow& \pfp ("\cdots", F_i = b+a - a \wedge F_{i+1} = b+a\\
&\rightarrow& F_i+1 = b \wedge F_{i+2} = b + a \wedge i+1 \leq N\\
&\rightarrow& T \wedge T \textrm{par définition} \wedge T 
\end{eqnarray*}

\paragraph{Etape 4}
Tester une existance de $f > 0$ avant l'execution du corps : $c \wedge INV \rightarrow f > 0$.
\begin{eqnarray*}
(i \neq  N) \wedge (F_i = a) \wedge (F_n-1 = b) \wedge (o \leq i \leq N) &\rightarrow& f > 0\\
 f = N-i \Rightarrow N \geq 0\textrm{ donc Vrai.}
\end{eqnarray*}

\paragraph{\'Etape 5}
\begin{eqnarray*}
f = F \wedge c \wedge INV &\rightarrow& \pfp("corps", f < F)\\
N-i = F \wedge c \wedge INV &\rightarrow& \pfp("corps", N-i < F)\\
N - i = F \wedge c \wedge INV &\rightarrow& N - (i+1) < F\\
&\rightarrow& N -i-1 < F \\
&\rightarrow& F-1 < F \Rightarrow \textrm{Tautologie}
\end{eqnarray*}

\subsection{Exercice 7 : plus grand plateau}
\begin{lstlisting}[language=C]
	/* $(N \geq 1) \wedge (B(N), \geq )$ */
	j = 1;
	p = 1;
	/* $INV = (1 \leq p \leq j \leq N) \wedge (\exists k : 0 \leq k \leq j - p) \wedge (B[k] = B[k+p-1]))$
	$\wedge (\forall k (0 \leq k \leq j -p - 1) \rightarrow (B[k] \neq B[k+p]))$ */
	while (j != N) {
		/* $INV \wedge c$ */
		if(B(j-p] == B[j]) 
			p++;

		j++;
		/* INV */
	}
	/* $\neg c \wedge INV$ */
	/* $R = (1 \leq p \leq N) \wedge (\exists k : 0 \leq k \leq N - p) \wedge $
	$(B[k] = B[k+p-1])) \wedge (\forall k (0 \leq k \leq N -p - 1) \rightarrow (B[k] \neq B[k+p]))$ */
\end{lstlisting}
\remarque{$(B(N), \geq)$ signifique le tableau est ordonné dans l'ordre croissant non strict}

Soit PE le prédicat d'entrée.


\begin{eqnarray*}
	x \geq 1 &\rightarrow& \pfp (j=1,p=1, Inv)\\
	x \geq 1 &\rightarrow& (0 \leq 1 \leq 1 \leq N)\wedge \exists k(0 \leq k \leq 0 (B[k]=B[k])) \wedge \forall k(0 \leq k \leq -1 \rightarrow B[k] \neq B[k+1]\\
	&& \Rightarrow \textrm{ Toujours vrai }
\end{eqnarray*}

\begin{eqnarray*}
	C \wedge INV &\rightarrow& \pfp (\ifp (B[j-p] == B[k]) p++;j++,INV)\\
	C \wedge INV &\rightarrow& \pfp (\ifp(B[j-p] == B[j]) p++, \pfp(j++, INV))\\
	C \wedge INV &\rightarrow& \pfp(\cdots
	, 1 \leq p \leq j+1 \leq N \wedge \exists k (0 \leq k\leq j + 1 - p)\\&&
			\wedge B[k] = B[k+p-1] \wedge \exists \forall k(0 \leq k < j+1-p-1 \rightarrow B[k] \neq B[k+p] )) = A\\
C \wedge INV &\rightarrow& B[j-p] == B[j] \rightarrow \pfp (p++, A) \wedge B[j-p]  \neq B[j] \rightarrow A\\
C \wedge INV &\rightarrow& (B[j-p] \neq B[j] \rightarrow (0 \leq p \leq j+1 \leq N) \wedge \exists k 0 \leq k \leq j+1-p \wedge B[k] = B[k+p-1] \\&&
\wedge \forall k 0 \neq k \leq j-p \rightarrow B[k] \neq B[k-p]\\
&\rightarrow& T \wedge \exists k 0 \leq k< j-p \wedge B[k] = B[k+1-p] \wedge B[j+1-p] = B[j+1-p+1-p] \wedge \cdots\\
\end{eqnarray*}
\subsection{Définition variante}
\begin{eqnarray*}
	C \wedge INV &\rightarrow& f > 0\\
	J \neq N \wedge INV &\rightarrow& (f = N-j) >0 \Rightarrow \textrm{ Vrai }
\end{eqnarray*}

\begin{eqnarray*}
	N-j  =F \wedge C \wedge INV &\rightarrow& \pfp(corps, N-j < F)\\
	N-j  =F \wedge C \wedge INV &\rightarrow& \pfp(\ifp(\cdots))\cdots,\pfp(j++,N-j<F)\\
	N-j  =F \wedge C \wedge INV &\rightarrow& B|j-p] = B[j] \rightarrow N - j -1 < F \wedge B[j-p] \neq B[j] \rightarrow N-j-1 < F\\
	N-j = F \wedge C \wedge INV \rightarrow N-j-1 < F \wedge F-1 < F
\end{eqnarray*}

\subsection{Exercice 8}

\begin{lstlisting}[language=C]
	/* $A \leq 0 \wedge B \geq 0 */
	x = A;
	y = B;
	z = 1;

	/* (z = x^y = A^B) \wedge y \geq 0$ */
	while(y != 0) {
		/* $z *x^y = A^B \wedge y \geq 0$ */
		while(y \% 2 == 0) {
			y = y / 2 ;
			x = x*x;
		}
		/* $z = x^y = A^B \wedge y > 0 \wedge y \%2 \neq 0 $*/
		y--;
		z = z * x;
		/* z = x^y = A^B \wedge y \geq 0 */
	}
	PS : /* z = A^b */

\end{lstlisting}
\section{\'Ecriture d'un programme à partir de sa preuve}
\subsection{Dichotomie}
\begin{lstlisting}[language=C]
/* N > 0 */
a = 1;
b = N;
while(b != a + 1) {
	m = (a+b)/2;
	if(0 <= N-m*m) {
		a = m;
	} else {
		b = m;
	}
}
/*
 * Réécriture : $a^2 \leq N \wedge N \leq b^2 \wedge (b=a+1)$
 * $a^2 \leq N \wedge N \leq (A+1)^2$  
 */
\end{lstlisting}
Variante : $b-a$ : taille de l'intervalle. Fonction décroissante.
\subsection{}

\begin{lstlisting}[language=C]
/* N $\leq$ 2 $\wedge$ B(0..N-1, $\leq$) $\wedge$ B[0] $\leq$ X $\wedge$ B[N-1] > X */
cherchep(B,N,X,p);
p = 0; 
/* 0 $\leq$ p $\leq$ i-2 $\wedge$ B(p) $\leq$ x $\wedge$ B[p+1] > x */ 
while (B[p+1] <= X) {
	++p;
}
/* 
 * 0 $\leq$ p $\leq$ N-2 $\wedge$ B[p] $\leq$ x < B[p+1] 
 */
\end{lstlisting}
Variante : $N - i$

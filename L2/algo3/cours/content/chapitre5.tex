		\chapter{Vérification formelle de programmes}\label{pfp}
	Vérifier que le programme est correct revient à démontrer l'implication suivante :\\ PE $\rightarrow$ pfp(\texttt{(action(D,r, PS);}

	Avec pfp étant la plus faible précondition\footnote{wp weakest precondition}.
	\begin{description}
		\item[pfp]	C'est un système de réécriture permetant de transformer une formule logique en une autre selon le programme qui doit s'éxécuter.
			C'est donc une réécriture syntaxique du prédicat de sortie en fonction des actions du programme.  \item[Tableau de situation] Système de réécriture des données en entrée (mémoireà vers les données en sortie (mémoire)) en fonction des actions du programme.  \end{description}
	\section{Système de réécriture Pfp}
		Ensemble de règles de réécriture permettant de transformer une formule logique en fonction des structures de base des langages de programmation.

		Les langages impératifs:
			\begin{itemize}
				\item affectation
				\item Séquence
				\item Sélection
				\item répétition
			\end{itemize}

		Règle de réécriture : \texttt{pfp(structure, formule) = formule}

	\section{Calcul de pfp d'une affectation}
	$$pfp("x=e", Q) = Q^e_n$$

	Avec la formule Q dans laquelle toutes les occurences de ``x'' sont remplacées par ``e'' (remplacement textuel)
	\exemple {
		Soit le programme suivant :
		\begin{itemize}
			\item $x > 0$
			\item $x = x-1$
			\item $x \geq 0$
		\end{itemize}
		On doit se poser la question \texttt{PE} $\rightarrow$ \texttt{pfp(programme, PS)} ?\\
		\begin{eqnarray*}
			(x > 0) &\rightarrow& \texttt{pfp}("x=x-1", x \geq 0)\\
			(x>0)&\rightarrow&(x-1 \geq 0)\\
			(x>0) &\rightarrow& (x > 0)
		\end{eqnarray*}
	}
	\section{Calcul du pfp d'une séquence}
	$$\texttt{pfp}("a1;a2;a3", Q) = \texttt{pfp}("a1;a2;", \texttt{pfp}("a3;", Q));$$
	\exemple{
	\begin{itemize}
		\item \texttt{/* f = i! */}
		\item \texttt{i = i + 1;\\f = f*i}
		\item \texttt{/* f = i! */}
	\end{itemize}
\begin{eqnarray*}
	 f = i! &\rightarrow& \texttt{pfp}("i = i + 1 ; f = f \times i;", f = i!)\\
	 f = i! &\rightarrow& \texttt{pfp}("i = i +1", \texttt{pfp}("f = f \times i", f = i !)\footnote{\'Evaluation de la "règle" la plus profonde}\\
	 f = i! &\rightarrow& \texttt{pfp}("i = i+1", f \times i = i!)\\
	 f * i! &\rightarrow& f\times (i+1) = (i+1)!\\
	 &&i! \times(i+1) = (i+1)!\ \textmd{Par définition de}\ i!
\end{eqnarray*}
}
	\section{Calcul du pfp de la séléction} \begin{center} \texttt{if(B)\{$a_1$\} [else\{$A_2$\}]}
	 \end{center}
\begin{eqnarray*}
	\texttt{pfp}("\texttt{if}(B)\{A_1\}\texttt{else}\{1_2\}", PS) &=&
	B \rightarrow \texttt{pfp}(A_1, PS) \wedge \neg B \rightarrow \texttt{pfp} (A_2, PS)\\
	\texttt{pfp}("\texttt{if}(B)\{A_1\}\texttt{else}\{A_2\}", PS) &=& B \rightarrow \texttt{pfp}(A_1, PS) \wedge \neg B \rightarrow PS 
\end{eqnarray*}

Un exemple est disponible annexe \ref{pfpSequence} page \pageref{pfpSequence}.

\section{Calcul du pfp d'une répétition.}\label{pfpBoucle}
Modélisation formelle de la répétition.
\begin{lstlisting}[language=C]
/* PE */
initialisation;
/* INVARIANT */
while(c) {
	/* $c \wedge \textsc{INVARIANT}$ */
	corps de boucle;
	/* $\textsc{INVARIANT}$ */
}
/* $\neg c \wedge \textsc{INVARIANT}$ */
\end{lstlisting}

Il y a cinq étapes pour la vérification de la boucle.
\begin{enumerate}
	\item $PE \rightarrow \pfp(\texttt{initialisation}, \texttt{INVARIANT})$
	\item $c \wedge \texttt{INVARIANT} \rightarrow \pfp (\texttt{corps}, \texttt{INVARIANT})$\label{etape2boucle}
	\item $\neg c \wedge \texttt{INVARIANT} \rightarrow PS$ \label{etape3boucle}
	\item $ \texttt{INVARIANT} \wedge c \rightarrow f > 0$\footnote{f: fonction définie positive : f est appelée ``variante''}
	\item $F = f \wedge \texttt{INVARIANT} \wedge c \rightarrow \pfp (\texttt{corps}, F > f)$\footnote{f est décroissante}
\end{enumerate}

\appendix

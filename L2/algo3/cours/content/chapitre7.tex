\chapter{Ecriture d'un programme à partir de sa preuves}
Il s'agit d'écrire un programme à partir de ses spécifications..
\begin{lstlisting}[language=C, numbers=none]
/* P */
action(N,r);
/* Q */
\end{lstlisting}
Il permet de définir un modèle de solution : 
\begin{itemize}
	\item Séquence, boucle, recherche linéaire, recherche dichotomique
	\item Déduit de l'analyse de Q et de P
\end{itemize}

\section{Modèle de boucle}
	Il faut déterminer l'invariant et la condition de boucle afin de construire complètement le programme. Nous allons ainsi utiliser la propriété suivante : 

	$$ INV \wedge \neg C \rightarrow Q $$

	On pose $INV \wedge \neg C = Q$, si cette propriété est vérifiée, alors l'implication sera vérifiée.

	\subsection{1$^{ère}$ approche: Preuve avec invariant trivial}
	$Q = \top \wedge Q$ Q étant $\neg$condition 
	\begin{enumerate}
		\item $p \rightarrow \pfp (init , \top) = p \rightarrow \top$ Toujours vrai
		\item $\top \wedge Q \rightarrow \pfp(corps, \top) = \top \wedge Q \rightarrow \top$
		\item $\top \wedge Q \rightarrow Q$ Toujours vrai\footnote{$Q\rightarrow Q$} 
	\end{enumerate}
	Toute la difficulté est de prouver la terminaison.
	\subsubsection{Exemple}
	\begin{lstlisting}[language=C]
/* (x = A)$\wedge$(y=B)$\wedge$(z=C) */
init
/* $\top$ */
while ((x >= y) || (y >= z)) {
	/* $\top \wedge (x \geq y) \wedge (y \geq z)$ */
	if(x >= y) 
		echange(&x, &y);

	if(y >= z) 
		echange(&y, &z);
	/* \top */
}
/* $\top \wedge$ (x < y) $\wedge$ (y < z) */
/* (x < y) $\wedge$ (y < z)
	\end{lstlisting}
	Nous pouvons prendre $x-z + |A+B+C|$ comme variante

	\attention{Prendre un invariant trivial complique la preuve de terminaison et cela réduit l'écriture du programme à la recherche de la variante.}
	
	\subsection{2$^{nd}$ approche : Élimination de conjoint} 
	$Q : A \wedge B \wedge C \wedge \cdots$\footnote{A, B et C sont des conjoints}
	
	Si on peut trouver une séquence d'initialisation qui permet de vérifier les conjoints de façon simple; ces conjoints forment l'invariant.

	$Q = A \wedge B \wedge E$ on peut écrire $INV \wedge E$.

	\subsubsection{Exemple}
\begin{lstlisting}[language=C]
/* N > 0 */
a = N;
/* $a^2 \leq N$ */
while ( a*a > N) {
	/* $a^2 \leq N \wedge cond$ */
	a = a - 1;
	/* $a^2 \leq N$ */
}

/* 
 * $a^2 \leq N \leq (a+1)^2$ peut aussi être écrit $a^2 \leq N \wedge N \leq (a+1)^2$ 
 * $a^2 \leq N$ : INV
 * $N \leq (a+1)^2$ : $\neg C$
 */
\end{lstlisting}
\remarque{Cette solution fonctionne, cependant le programme à une complexité linéaire (N), celui-ci peut être résolu avec une complexité logarithmique.}


\subsection{3$^{ème}$ approche : introduction d'une variable dans Q} 
	En général, $Q$ s'écrit $Q(N)$. On va le réécrit en introduisant une variable : $Q(i) \wedge (i = N)$

	Ainsi $Q(i)$ devient l'invariant et $i = N$ la condition de boucle ($\neg$condition).

	\subsubsection{Exemple}

\begin{lstlisting}[language=C]
/* N > 0 */
f = 1;
i = 1;
/* f = i! */
while (i != N) {
	++i;	
	f *= i;
}

/* 
 * f = N ! 
 * On le réécrit f = i! $\wedge$ i = N
 */
\end{lstlisting}

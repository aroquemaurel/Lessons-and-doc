\chapter{Transformation d'une spécification récursive en un programme itératif}
	Une approche récursive est équivalente en temps là une approche itérative, cependant la consommation mémoire sera beaucoup plus importante que
l'itérative, ceci étant dût à la pile système.

\remarque{Certains compilateurs peuvent transformer une approche récursive terminale en itératif\\
Notamment le compilateur Ocaml, gcc le fait également pour les types primitifs (scalaires), pour les structures de données, il n'en est pas capable.}
\section{Récursivité terminale}
	\begin{displaymath}
		G(x)
		\left\{ \begin{array}{ll}
			\textrm{si }&h(x)\textrm{ alors } a\\
			\textrm{sinon }&f(x) \oplus G(t(x)) 
		\end{array} \right.
	\end{displaymath}
	\remarque{le $\oplus$ est l'opérateur de combinaison intermédiaire}

	SI nous avons : 
	\begin{itemize}
		\item $h(x)$ fonction booléenne
		\item $\oplus$ associatif avec un élément neutre $e$ (à gauche)
	\end{itemize}
	Alors le programme suivant est correct.

\begin{lstlisting}[language=C]
/* PE: $\top$ */
x = X;
r = e;
/* INV: G(X) = r $\oplus$ G(x) */
while (!(h(x))) {
	r = r $\oplus$  f(x);
	x = t(x);
}
r = r $\oplus$ a;
/* PS: G(X) = r */
\end{lstlisting}

\exemple{
Écrire un programme qui calcule $Y=x^N$ avec $N$ entier et $N \geq 0$. X et Y des réels. 

\begin{enumerate}
	\item Spécification récursive
	\item Programme
\end{enumerate}
\begin{displaymath}
	\texttt{puissance}(X,N) = \left\{\begin{array}{ll}
		\textrm{si }  N = 0& 1\\
		\textrm{sinon} & x \times \texttt{puissance}(X,N-1)\\
	\end{array}\right.
\end{displaymath}
\begin{itemize}
	\item $\oplus$ : *réels
	\item $e$ : $1.0$
	\item $h(X, N)$: $N == 0$
	\item $f(X, N)$: $X$
	\item $t(X,N)$: $(X,N-1)$
\end{itemize}
\lstinputlisting[language=C, numbers=none]{annexes/exo7.c}
}

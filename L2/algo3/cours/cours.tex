\documentclass[12pt,a4paper,openany]{book}

\usepackage{lmodern}
\usepackage{xcolor}
\input{/home/aroquemaurel/cours/includesLaTeX/couleurs.tex}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[top=1.7cm, bottom=1.7cm, left=1.7cm, right=1.7cm]{geometry}
\usepackage{verbatim}
\usepackage[urlbordercolor={1 1 1}, linkbordercolor={1 1 1}, linkcolor=vert1, urlcolor=bleu, colorlinks=true]{hyperref}
\usepackage{tikz} %Vectoriel
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{multido}
\usepackage{amssymb}
\usepackage{float}

\newcommand{\titre}{Algorithmie en langage C}

\newcommand{\pole}{}
\newcommand{\sigle}{algo}

\newcommand{\semestre}{3}

\input{/home/aroquemaurel/cours/includesLaTeX/listings.tex} %prise en charge du langage C 
\input{/home/aroquemaurel/cours/includesLaTeX/entete-l2-cours.tex}
\input{/home/aroquemaurel/cours/includesLaTeX/remarquesExempleAttention.tex}
\input{/home/aroquemaurel/cours/includesLaTeX/polices.tex}
\input{/home/aroquemaurel/cours/includesLaTeX/affichageChapitre.tex}
\makeatother

\begin{document}
	\setcounter{tocdepth}{1}
	\setcounter{secnumdepth}{3}
	\maketitle
	\tableofcontents
	\chapter{Paradigmes de programmation}
		Un paradigme est une manière de programmer, il en existe plusieurs: 
		\begin{itemize}
			\item La programmation fonctionnelles (cf. \ref{fonctionnelles})
			\item La programmation déclarative (cf. \ref{declarative})
			\item La programmation impérative (cf. \ref{imperative}
		\end{itemize}
		\section{Programmation fonctionnelles} \label{fonctionnelles}
		\begin{description}
		\item[Type de langage] \footnote{Traduction du langage source vers le langage cible(compilation) + une édition de liens, qui est une instanciation sur la machine d'exécution (Recherche d'adresse, mémoire, résolution de fonctions) Elle peut être statique ou dynamique. Ex: C, Adda} ou interprétés\footnote{
		Le langage source est traduit en langage cible à la volée par un interpréteur. Il est ainsi possible de modifier le programme pendant le fonctionnement du programme.}. Ce paradigme
		\item[Entité de base] Appel de fonction
		\item[Structure de contrôle] Approche récursive. 


		Elle est utilisée pour des systèmes critiques\footnote{Besoin d'une sureté de fonctionnement}. Elle à une approche très mathématiques, ce qui 
		permet d'avoir des outils de preuves générique.

		Elle possède une abstraction de l'environnement d'exécution, approche détachée de la machine, pas de notion de mémoire.

		\exemple{Le Caml est un langage de programmation fonctionnelle}
	\end{description}
	\section{Programmation déclarative} \label{declarative}
		\begin{description}
			\item[Type de langage] Interprété
			\item[Entité de base] Règles de déduction logique.
			\item[Structure de contrôle  ]
			Possède une abstraction de la machine cible.
			\exemple{Le prolog est un langage de programmation déclarative}
		\end{description}
		\newpage
		\section{Programmation Impérative}\label{imperative}
			La programmation est directement liée à la machine d'exécution.
			\begin{description}	
				\item[Type de langage] Compilé ou Interprété
				\item[Entité de base] Affectation d'une valeur à une variable, qui est une place en mémoire.
				\item[Structure de contrôle] Séquence, sélection, répétition.
			\exemple{C, Python, Ada \ldots}
			\end{description}

	\chapter{Programmation impérative en C}
	Énormément de langage sont fondés sur la syntaxe du langage C.

	Il a été développé dans les années 1960 par Dennis Ritchie. 

	On trouvera toujours une partie description de l'organisation des données en mémoire\footnote{C'est un grand tableau découpé en cases mémoire.},
	nous aurons donc une déclaration de variables et un type de données.
	\begin{lstlisting}[caption=Syntaxe de déclaration de variable]
type nomVariable;		
	\end{lstlisting}
	\section{Description de l'organisation des données en mémoire}\label{types}
	Le C possède différents type de données: 
	\begin{description}
		\item[int] Entiers signés
		\item[unsigned int] Entiers non signés 
		\item[float] Nombre réel sur 32bits. 
		\item[double] Nombre réel sur 64bits.
		\item[char] Entier signé sur 8bits.
		\item[pointeur] type* ptr; La case mémoire contient une adresse.
	\end{description}
	\section{Code syntaxe}
	\subsection{Blocs}
\begin{lstlisting}[language=C, caption=Syntaxe d'un bloc]
bloc { // début du bloc
} //fin du bloc
\end{lstlisting}
	Toute variable est visible dans son bloc de déclaration et ses blocs imbriqués.

	Un bloc transforme une séquence en action.

	\subsection{Séquence}
\begin{lstlisting}[language=C, caption=Syntaxe des actions]
action 1;
action 2;
action 3;
\end{lstlisting}
	\subsection{Séléction}
\begin{lstlisting}[language=C, caption=Syntaxe d'une structure de contrôle]
if(conditon) {
	action 1;
} else {
	action 2;
}
\end{lstlisting}
Condition est une expression booléenne\footnote{Expression renvoyant vrai($\neq 0$) ou faux($=0$)}, si celle-ci est vrai, action 1 est executé, sinon action 2 est executé. 

\subsection{Répétition}
\begin{lstlisting}[language=C, caption=Syntaxe de répétition]
while(condition) {
	action;
}
\end{lstlisting}
Condition est une expression booléenne, tant que la condition est vrai, les actions se répètent.

\subsection{Affectation}
\begin{lstlisting}[language=C, caption=Syntaxe d'une affectation ]
variable = expression;
\end{lstlisting}
variable reçoit expression, si celle-ci n'est pas du même type que variable, un cast\footnote{ou conversion de type, consiste à convertir un type vers un autre. (int vers double par exemple)} peut-être effectué.
\subsection{Opérateurs de base sur les types}
\begin{description}
	\item[\texttt{=}] Affectation
	\item[\texttt{+}, \texttt{-}, \texttt{/}, \texttt{*}] Opérateurs arithmétiques.
	\item[\texttt{\&\&}, \texttt{||}, \texttt{!}] Opérateurs logiques 
	\item[\texttt{==}, \texttt{!=}, \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}] Opérateurs booléens
	\item[\texttt{+$\,$+i}, \texttt{i+$\,$+}, \texttt{-$\,$-i}, \texttt{i-$\,$-}] Opérateur unaires d'incrémentation.
\end{description}
\subsection{Opérateurs d'entrées / sorties}
\paragraph{Ecriture}~\\
\begin{lstlisting}[language=C, caption=Syntaxe de l'appel de printf]
printf('format', var1, var2);
\end{lstlisting}
La chaine format peut contenir une chaine de caractères, avec des caractères spéciaux : 
\begin{description}
	\item[\texttt{'\%d'}] Entier sous forme décimale
	\item[\texttt{'\%ox'}] Entier sous forme hexadécimale
	\item[\texttt{'\%f'}] Flottant 
	\item[\texttt{'\%c'}] Caractère 
	\item[\texttt{'\%s'}] Chaine de caractères 
	\item[\texttt{'\\n'}] Vide le buffer et fait un retour chariot 
	\item[\texttt{'\\t'}] Tabulation 
	\item[\texttt{'\\r'}] Revient en début de ligne.
	\item['\ldots'] RTFM	
\end{description}
Les différents formats doivent être dans l'ordre des variables passés en paramètres.
\paragraph{Lecture}~\newline
\begin{lstlisting}[language=C, caption=Syntaxe de l'appel de scanf]
scanf('format', &var1); // & représente l'adresse de la variable dans laquelle écrire.
\end{lstlisting}
\attention{L'utilisation de cette fonction est risquée. En effet, un utilisateur malveillant peut écrire à des cases mémoires où il n'est pas autorisé.}

\subsection{Tableaux}
Un tableau est une collection d'éléments de même type.
\begin{lstlisting}[language=C, caption=Syntaxe de déclaration d'un tableau]
// avec tableau le nom de la variable et N la taille du tableau. 
type tableau[N], i; 
i = tableau[P]; //i recoit la valeur de la case P du tableau
\end{lstlisting}
\attention{Un tableau commence toujours à 0 et finit à N-1, ainsi, il faut faire très attention au dépassement de la taille d'un tableau.}
\subsection{Les sous-programmes}
Un sous-programme est un sous-ensemble du programme dans sa hiérarchie fonctionnelle. En C, il correspond toujours à une fonction ou une procédure.
\begin{lstlisting}[language=C, caption=Syntaxe d'un sous programme]
typeRetour nomFonction (typeArg1 nomArg1, typeArg2 nomArg2) {
	/*
     *	code
	 */
	 [return (valeur)];
}
\end{lstlisting}
\texttt{typeRetour} peut posséder comme valeur les même types qu'une variable, voir \ref{types} page \pageref{types}. Celui-ci peut également être \texttt{void}, 
cela signifie que que la fonction ne renvoie rien, c'est donc une procédure.
\section{Structure d'une programme en C}
\begin{tabular}{p{8cm}|p{8cm}}
	\textbf{Interface} & \textbf{Implantation}\\
	\begin{minipage}{0.8\textwidth}
		\begin{itemize}
			\item Déclaration des fonctions (prototype)
			\item Constantes, types
			\item Comment utiliser le programme\\~~~~ $\Rightarrow$ \'Ecrire dans un fichier .h (header)
			\item Préprocesseur (define, macros, \ldots)
		\end{itemize}
	\end{minipage}&
	\begin{minipage}{0.8\textwidth}
		\begin{itemize}
			\item Définitions des fonctions: le code\\~~~~ $\Rightarrow$ \'Ecrire dans un fichier .c
		\end{itemize}
	\end{minipage}
\end{tabular}
Un programme en C ne possède qu'une seul point d'entrée : une instruction est exécuté, c'est la fonction \texttt{main}.
\begin{lstlisting}[language=C, caption=Point d'entrée du programme: le main]
int main (int argc, char **argv); 
//le programme renvoie un entier. C'est le profil d'une fonction.
\end{lstlisting}

\section{La compilation}
\begin{figure}[H]
	\centering
	\includegraphics[width=13.5cm]{compilation.png}
	\caption{La compilation}
\end{figure}
\subsection{\'Etape 1 : Le préprocesseur}
Le pré processeur sont les instructions situés en dehors d'un programme, ceux-ci sont préfixé par un dièse (\#).
\begin{description}
	\item[Entrée] fichier.c
	\item[Sortie] fichier obtenu une fois les modifications effectués.
\end{description}~
\begin{lstlisting}[language=C, caption=Exemple d'instructions pré-processeurs]
#include // remplace par le continu du fichier inclus
#define Arg1 Arg2 // remplace syntaxique de Arg1 par Arg2
\end{lstlisting}
\subsection{Etape 2 : La compilation}
\begin{description}
	\item[Entrée] fichier.c, fichier.h
	\item[Sortie] fichier.o 
\end{description}
\begin{lstlisting}[language=bash]
gcc -c fic1.c fic2.c fic3.c # Créé les fichiers .c
gcc *.o nomExe #Créer l'executable.
\end{lstlisting}
\remarque{La compilation sera étudiée en détails lors des cours de L3 et M1}
\subsection{\'Etape 3 : L'édition de liens}
Rassemble tous les fichiers binaires .o en un seul executable.
	\chapter{Méthodologie de la programmation impérative}
		\section{Programmation ``en petit''}
		\begin{description}
			\item[Données] celle-ci son simple, comme un tableau à N éléments.
			\item[Problème] Petit.
			\item[Résolution] Développement d'un algorithme afin de traiter ces données.
		\end{description}
		Cf. cours du S3.

		\section{Programmation en large}
		\begin{description}
			\item[Données] celle-ci son complexes, modélisation des données avec des types abstrait.
			\item[Résolution] Développer de nombreux algorithmes afin de traiter le type abstrait. 
		\end{description}
		Cf. cours du S4.
		\section{Développement d'un algorithme}
		C'est un processus à 4 étapes:
		\begin{enumerate}
			\item \textbf{Comprendre} le problème : identifier le ``quoi''.
			\item \textbf{Spécification} du problème : formaliser le ``quoi''
			\item \textbf{Définir} un modèle de solution : identifier le ``comment''
			\item \textbf{Développer} et trouver l'algorithme : formaliser le ``comment''.
		\end{enumerate}

		\section{\'Etape 1 : comprendre le problème}
			Analyser du texte afin d'identifier les propriétés suivantes.
			\begin{itemize}
				\item Identifier les domaines du problèmes
			Le domaine pose les fondements scientifiques à utiliser par le programme. 
				\exemple{Arithmétique : se fonder sur la théorie du calcul\\ 
						Topologique: se fonder sur les bases mathématiques de topologie}
						\newpage

						Il faut se poser la question \textit{``est-ce calculable ?''} : est-ce que le problème peut être résolu par un ordinateur.
			\exemple{
				\begin{enumerate}
					\item Corriger toutes les fautes d'orthographe dans un texte: Non calculable car il y a un manque d'informations sur la taille et la nature des
			données.  
					\item Calculer la factorielle d'un entier $N \geq 0$ : calculable puisque la taille des données est fixée.
				\end{enumerate}
				}

			\item \textit{évaluer les contraintes ``Physiques''} liées au problème. 
				\begin{itemize}
					\item Les contraintes liées à l'architecture et au fonctionnement de l'ordinateur
					\item Les restrictions du problème.
				\end{itemize}

			\item Prendre des exemples et les traiter ``manuellement''
			\end{itemize}	

			En sortie de cette étape, nous avons une description informelle des données et de leur traitements.

		\section{\'Etape 2 : Spécification du programme : spécification formelle}
		Utilisation du langage logique des précédents pour écrire le programme, la spécification est composée de 3 informations appelée le triplet de \bsc{Hoare}.
			\begin{enumerate}
				\item Prédicat d'entrée : Exprime les propriétés logiques des données en entrée. 
				\item nomDuProgramme (données en entrée E, données en sortie) 
				\item Prédicat de sortie exprime les propriétés logiques des résultats.
			\end{enumerate}
			\exemple{
			Celui du facteur de $N \geq 0$
				\begin{itemize}
					\item $ N > 0 \wedge [(N \in N)] \wedge (N < 30)$
					\item \texttt{fact(N, f);}
					\item $f = N!$
				\end{itemize}
			}
			\section{\'Etape 3: Donner un modèle de solution}
			Exprimer les différentes étapes de transformation des données en entrée vers les données en sortie. 
			\begin{itemize}
				\item En langage naturel
				\item Sous forme fonctionnelle
			\end{itemize}
		\section{\'Etape 4 : Programmer et unifier le programme}	
		\begin{itemize}
			\item \'Ecriture en C du programme traduction du modèle vers le C.
				\subsubsection{Vérification du programme}
				\begin{itemize}
					\item Test d'exécution : Tableau de situation, vérification non exhaustive.
					\item Preuve formelle par calcul de ``Plus faible Pré condition'' (Pfp)
				\end{itemize}
				\paragraph{Le tableau de situation}
				\begin{description}
					\item[Données en entrée] Programme ``instrumenté'' : code source + point d'arrêt: 
						localisation dans l'espace du programme d'une opération de photographie de l'état de l'ordinateur.
					\item[Opération de transformation] Dénuder le programme et prendre les photos. 
					\item[Donnée en sortie] Liste de ``photos'' qui déçoit l'exécution de la même mémoire au cours de l'exécution.
				\end{description}
		\end{itemize}

	\chapter{Spécification d'un programme}
	\remarque{Durant ce chapitre, nous parlerons de programme, cependant cela est valable également pour les sous-programme}
	Un programme est spécifié par un triplet : 
	\begin{itemize}
		\item Prédicat d'entrée P(E) ou précondition
		\item action (E, S)
		\item Prédicat de sortie P(S) ou postcondition
	\end{itemize}

		Les prédicats sont écrits en utilisant le formalisme de la logique des prédicats et de sopérations booléeenes.
		\section{Mots clés à utiliser dans les prédicats}
		Les mots clés pouvant être utilisés: 
		\begin{itemize}
			\item Les quantificateurs logiques : $\forall$(quelque soit), $\exists$(il existe), $\nu$(nombre de)
			\item Les connecteurs logiques : $\wedge$(et), $\vee$(ou), $\rightarrow$(implique), $\leftrightarrow$(equivalence), $\lnot$(not)
		\end{itemize}
		\section{\'Ecriture de la spécification}
		C'es une traduction de l'énoncé et de l'analyse faite dans l'étape 1 de la méthodologie : c'est un \textbf{triplet} logique.
		La démarche pour écrire la spécification est la suivante.
			\begin{itemize}
				\item Identifier les propriétés des données d'entrée et les exprimer sous forme logique
				\item Identifier les propriétés sur les données en sortie et les exprimer sous forme logique. 
			\end{itemize}
		\exemple{
			\'Ecrire un programme qui trie un tableau T de N éléments.\\
			\begin{itemize}
				\item $N > 1$
				\item \texttt{trier (T, N, t);}
				\item $(\forall I : 0 \leq I < N-1 \longrightarrow T[I] \leq T[I+1]) \wedge$\\$
					(\forall I : 0 \leq I < N \longrightarrow $\\$(\nu J : 0 \leq J < N \wedge t[I] = t[J]) = (\nu J : o \leq J < N \wedge t[I] = T[J]))$ 
			\end{itemize}
		}
	
	\appendix
	\chapter{Glossaire}
	\paragraph{Compilation} Un compilateur est un programme informatique qui transforme un code source écrit dans un langage de programmation (le langage source) en un autre langage informatique (le langage cible).
	\paragraph{Interprétation}
	Analyse, traduit et exécute un programme écrit dans un langage informatique. De tels langages sont dits langages interprétés.

	L'interpréteur est capable de lire le code source d'un langage sous forme de script, habituellement un fichier texte, et d'en exécuter les instructions après une analyse syntaxique du contenu. Généralement ces langages textuels sont appelés des langages de programmation. Cette interprétation conduit à une exécution d'action ou à un stockage de contenu ordonné par la syntaxe textuelle.
	\paragraph{Édition de liens} Lors d’un développement informatique, l'édition des liens est un processus qui permet de créer des fichiers exécutables ou des bibliothèques dynamiques ou statiques, à partir de fichiers objets.
	\include{exercices}
	\lstlistoflistings{}

\end{document}







\chapter{Types de données Abstraits (TAD)}
C'est une méthode de spécification de structures de données(SD).

C'est utile pour la programmation << En large >>, c'est-à-dire à plusieurs, pour cela nous sommes obligés de travailler sur la communication et
l'échange sur le code produit, on utilise pour cela les \textbf{spécifications} : 
\begin{itemize}
	\item Les Entrées Sorties du programme \footnote{Vu au S3}
	\item Les données\footnote{Nous nous occuperons de cette partie}
\end{itemize}
\begin{figure}[H]
	\centering
	\includegraphics[width=8cm]{1.eps}
	\caption{Principe de base d'un TAD}
\end{figure}
\exemple{\textbf{Les entiers}

\begin{description}
	\item[Utilisateur: Représentation Interne] 1, 2, 3, + ,-, /, +, \%
	\item[Programmeur: Représentation Externe] Entiers << machine >> 0000 0011 pour le 3
\end{description}
}

\section{Syntaxe des TAD}
La syntaxe d'un TAD est répartis en deux étapes : 
\begin{description}
	\item[La signature du TAD\footnote{signature de base}] Donner les interfaces de la données
	\item[La sématique abstraite du TAD\footnote{signature étandue}] Décrire logiquement le fonctionnement de la données.\\
		Une donnée c'est une ou un ensemble de valeurs mais aussi les opérations qui permettent de la manipuler. Cette étape étape nous donne : 
		\begin{itemize}
			\item Les limitations de la donnée (préconditions)
			\item Les descriptions longueur du fonctionnement de chaque opération
		\end{itemize}
\end{description}
\subsection{Signature du TAD \texttt{Pile}}
Une pile est unee structure de données qui permetn de rassembler des éléments de telle sorte que le dernier élément entré dans la pile soit le premier à
en sortir.\footnote{Last In First Out}.
\paragraph{Signature de base}
\begin{description}
	\item[Sorte] Pile
	\item[Utilise] Élément, Booleen 
	\item[Opérations]~ 
		\begin{description}
			\item[\texttt{creer}] $\rightarrow$Pile % CONSTRUCTEURS
			\item[\texttt{empiler}] Pile $\times$ Element $\rightarrow$ Pile
			\item[\texttt{estVide}] Pile $\rightarrow$ Booleen  %% OPERATEURS
			\item[\texttt{sommet}] Pile $\rightarrow$ Pile
			\item[\texttt{appartient}] Pile $\times$ Element $\rightarrow$ Booleen 
		\end{description}
\end{description}

\paragraph{Signature étandue}
\begin{description}
	\item[Préconditions]~
		\begin{itemize}
			\item \texttt{sommet(p)}$\Leftrightarrow$ $\neg$ \texttt{estVide(p)}
		\end{itemize}
	\item[Axiones]~
\end{description}
~\newline
Avant toute chose, on partitionne l'ensemble des opérations en deux sous ensembles: 
\begin{itemize}
	\item Les constructeurs
	\item Les opérateurs
\end{itemize}
L'ensemble des constructeurs est necessaire et suffisant pour pouvoir gagner n'importe quelle valeur de la donnée
\begin{lstlisting}[language=C, numbers=none]
 // On applique chaque constructeur à chaque opérateur et on decrit logiquement 
 // ce qu'il se passe
 estVide(creer()) = true;
 estVide(empiler(p, x)) = false;
 depiler(creer()) = creer();
 depiler(empiler(p, x)) = p;
 sommet(empiler(p, x)) = x;
 appartient(creer(), x) = false;
 appartient(empiler(p, x), y) = (x = y) $\vee$ appartient(p, y)
 \end{lstlisting}

\section{Implémentation d'un TAD}
\begin{enumerate}
	\item Implémenter la structure de données
	\item Implémenter les opérateurs
	\item Séparer l'interface du corps des opérations
		\begin{description}
			\item[But 1] Permet de modifier les opérations sans remettre en cause la manière d'utiliser le TAD
			\item[But 2] Protéger les données
		\end{description}
\end{enumerate}

\subsection{Implémentation de la structure de données et des opérateurs}
Trouver une représentation interne de la structure de données, celle-ci est contrainte par le langage choisi.

Celle-ci peut être statique ou dynamique. 
\begin{description}
	\item[Statique] La donnée ne peut plus changer de place ni de taille mémoire ou dynmaique.
		\begin{itemize}
			\item Problème de gaspillage de place
			\item Avantage de l'efficacité
		\end{itemize}
	\item[Dynamique] La donnée peut changer de taille ou de place pendant l'execution du programme.
		\begin{itemize}
			\item Pas de gaspillage de place
			\item Inconvénient de l'efficacité
		\end{itemize}
\end{description}

\subsubsection{Implémentation statique du TAD \texttt{Pile}}
\begin{itemize}
	\item Utilisation d'un tableau
	\item Utilisation d'un entier donnant le nombre d'éléments rangés dans la pile
\end{itemize}
\lstinputlisting[language=C]{content/1.c}

\section{Exemple de structure de données linéaires dynamiques}
\subsection{Pile}
Liste simplement chaînée dynamique à un point d'entrée

\begin{figure}[H]
	\centering
	\includegraphics[width=6cm]{content/pile.eps}
	\caption{Pile avec une liste simplement chainée}
\end{figure}

\begin{lstlisting}[language=C, numbers=none,frame=none]
	typedef struct etCel {
	Element val;
	struct etCel *suiv;
} CelSc;
\end{lstlisting}

\subsection{File}
Liste simplement chainée à deux points d'entrée

\begin{figure}[H]
	\centering
\includegraphics[width=6cm]{content/file.eps}
	\caption{File avec une liste simplement chainée}
\end{figure}
% TODO Schéma
\begin{lstlisting}[language=C, numbers=none,frame=none]
	typedef struct etCel2 {
	LSC fin;
	LSC debut;
} LSC2;
\end{lstlisting}
\subsection{Pile avec liste doublement chainée}
\begin{figure}[H]
	\centering
\includegraphics[width=12cm]{content/pileDoubleChaine.eps}
	\caption{Pile avec une liste doublement chainée}
\end{figure}

\begin{lstlisting}[language=C, numbers=none,frame=none]
typedef struct etCelDC {
	Element val;
	struct etCelDC* suiv;
	struct etCelDC* precedent;
}
typedef celDC* LDC;
\end{lstlisting}

\subsection{File avec liste doublement chaîné}
\begin{figure}[H]
	\centering
\includegraphics[width=12cm]{content/fileDoubleChaine.eps}
	\caption{File avec une liste doublement chainée}
\end{figure}

\chapter{Structures de données}
\section{Nuplets}
Permet de rassembler des informations dont on connait à l'avance le nombre et le type éventuellement hétérogène.
	\begin{lstlisting}[language=Caml, caption=Syntaxe de n-uplets, numbers=none]
(x1, x2, ..., xn)		
tx1 * tx2 * ... * txn
\end{lstlisting}

\begin{exemple}
	\begin{lstlisting}[language=Caml, caption=Exemple n-uplets, numbers=none, framerule=0pt]
# (1, 2, 3);;
-: int * int * int = 1, 2, 3
# (1, (2,3));; 
int * (int * int)
# let first = fun (x,y) -> x ;;
val first = ('a*'b) -> 'a = <fun>
# let consCple = fun x -> fun y -> (x, y);;
val consCple = 'a -> 'b -> ('a*'b) = <fun>
\end{lstlisting}
\end{exemple}

Ils permettent de mettre des informations hétérogènes, cependant la dimension doit être connue à l'avance. L'avantage étant l'accès aux informations
par filtrage.

Il faut que N soit raisonnable, pour un grand nombre d'informations ce n'est pas adapté

\section{Listes}
Elles permettent de rassembler N informations avec un N quelconque, cependant les informations doivent être homogènes.

On définie une liste par induction : la liste est vide, ou l'ajout d'un élément.

En Caml le type est list, noté \texttt{'a list}, correspondant à une liste dont tous les éléments sont de type a. Le constructeur d'une liste vide se
fait avec \texttt{[]}.  L'ajout d'un élément se fait systématiquement en tête, à l'aide de l'opérateur \texttt{::}, \texttt{e::l} ajoute l'élément e en tête de la liste.

	\begin{lstlisting}[language=Caml, numbers=none, framerule=0pt]
e1::e2::...::en::[]	
[e1;e2;...;e3]
	\end{lstlisting}
	\begin{exemple}
	\begin{lstlisting}[language=Caml, caption=Exemple de listes, numbers=none, framerule=0pt]
#[];;
- : 'a list = []
#let ex = 1::[];;
val ex : int list = [1]
#let ex1 = 1 ::2::3::[];;
val ex1 : int list = [1;2;3]
#let ex2 = 0::ex1
val ex2 : int list = [0;1;2;3]
#let ex3 = [1,2]::({3,4]::[]);;
[[(1,2)];[(3,4)]]
let ex4 = (1,tue)::[(2,false)}
ex4 : (int * bool) lt = [(1,true);(2,false)]
	\end{lstlisting}
	\end{exemple}

	On peut utiliser le filtrage sur les listes avec les filtrage \texttt[] et \texttt{::l} permettant respectivement de savoir si une liste est vide ou
	d'accéder aux informations: tête(e), reste(l)

	\subsection{Fonctions récursives sur les listes}
	Le cas d'arrêt est 1 ou plusieurs élément, le cas général correspond souvent à diminuer la taille de la liste.

\lstinputlisting[language=Caml, caption=Fonctions sur les listes]{listes.ml}

\subsubsection{La fonction \texttt{append}}
La fonction \texttt{append} est une fonction qui concatène deux listes, elle pourrait être implémenter comme ceci: 
\begin{lstlisting}[language=Caml, caption=Exemple d'implémentation de \texttt{append}]
(* Concatène deux liste, version naive *)
let rec append = fun l1 l2 
    match (l1,l2) with
     ([],[]) -> [] 
    |([]::e, t::q) -> t::q
    |([t1:::q1, []) -> t1::q1
    |(t1::q1, t2::q2) -> t1::(append q1 (t2::q2));;

(* Bonne version de append *)
let rec append = fun l1 l2 ->
    match l1 with
     [] -> l2
    |t::q -> t::(append q l2);;
\end{lstlisting}

\begin{remarque}
Cette fonction est déjà disponible dans le langage OCaml, pour cela on peut utiliser l'opérateur \texttt{@} : \texttt{l1@l2}
\end{remarque}

\subsection{La fonction \texttt{reverse}}
La fonction \texttt{reverse} retourne la liste construite à l'envers.
\lstinputlisting[language=Caml, caption=Fonction \texttt{reverse}]{reverse.ml}

\subsection{La fonction \texttt{nbOcc}}
Fonction qui compte le nombre d'occurrence d'un élément dans une liste.
\lstinputlisting[language=Caml, caption=Fonction \texttt{nbOcc}]{nbOcc.ml}

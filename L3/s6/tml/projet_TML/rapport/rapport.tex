\documentclass[12pt,a4paper,openany]{book}

\usepackage{lmodern}
\usepackage[svgnames]{xcolor} % Required to specify font color
\input{/home/aroquemaurel/cours/includesLaTeX/couleurs.tex}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[top=1.7cm, bottom=1.7cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{verbatim}
\usepackage{tikz} %Vectoriel
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{multido}
\usepackage{amssymb}
\usepackage{multicol}
\usepackage{float}
\usepackage[urlbordercolor={1 1 1}, linkbordercolor={1 1 1}, linkcolor=vert1, urlcolor=bleu, colorlinks=true]{hyperref}
\usepackage[francais]{minitoc}

\newcommand{\titre}{Simulation d'une campagne de tests}
\newcommand{\subtitle}{Tests et Maintenance Logiciel}
\newcommand{\auteur}{Antoine de \bsc{Roquemaurel}}
\newcommand{\formation}{L3 Informatique}
\newcommand{\semestre}{6}
\newcommand{\annee}{2014}
\newcommand{\prof}{Ileana \bsc{Ober}}
\newcommand{\pole}{}
\newcommand{\sigle}{TML}


\input{/home/aroquemaurel/cours/includesLaTeX/listings.tex}
\input{/home/aroquemaurel/cours/includesLaTeX/l2/cours.tex}
\input{/home/aroquemaurel/cours/includesLaTeX/remarquesExempleAttention.tex}
\input{/home/aroquemaurel/cours/includesLaTeX/polices.tex}
\input{/home/aroquemaurel/cours/includesLaTeX/affichageChapitre.tex}
\input{./couverture.tex}
\makeatother
\setcounter{tocdepth}{2}
\setcounter{secnumdepth}{2}
\begin{document}
	\thispagestyle{empty} % Removes page numbers
	\titleBC 
	\chapter*{Avant-propos}
	Ce dossier a été rédigé par Antoine de \bsc{Roquemaurel} dans le cadre de l'enseignement Tests et Maintenance Logiciel délivré en L3 Informatique parcours
	Ingénierie des Systèmes Informatiques à l'université Toulouse III -- Paul Sabatier.

	Ce projet à pour but de simuler une campagne de tests sur un logiciel de taille moyenne, logiciel développé par d'autres étudiants au semestre précédent : 
	un jeu en réseau.

	Ce rapport à été fournis dans une archive zip, contenant plusieurs fichiers : 
	\begin{description}
		\item[Document de test] Ce présent document
		\item[Répertoire contenant les jeux de tests] 
		\item[Répertoire contenant les scripts de tests] 
	\end{description}

	\paragraph{\Large Lecture de ce rapport}~\\
	Ce rapport, contient plusieurs fonctions typographiques détaillées ci-dessous : 

	\begin{attention}
		Ceci est un message afin d'attirer l'attention du lecteur	
	\end{attention}

	\begin{remarque}
		Ceci est une remarque afin d'apporter des précisions sur quelque chose\\~
	\end{remarque}

	Ce message contient une note de bas de page\footnote{Ceci est une note de bas de page}

	\tableofcontents
	\setcounter{minitocdepth}{0}
	\chapter{Spécifications}
	Le logiciel est un jeu en réseau, chaque joueur est téléporté dans une arène. Chaque personnage présent dans l'arène se battent, le gagnant est le joueur
	ayant survécu. Il est également possible d'envoyer des équipements (bonus ou malus) dans l'arène.

	\section{Spécifications générales}
		\subsection{Spécifications fonctionnelles}
		Le jeu doit posséder les fonctionnalités suivantes : 
		\begin{itemize}
			\item Téléporter un joueur ou un équipement dans l'arène
			\item Déplacer automatiquement un joueur
			\item Ramasser un objet
			\item Combattre un autre joueur
			\item Afficher les positions des différents joueurs
			\item Gagner/perdre
		\end{itemize}

		\subsection{Spécifications non fonctionnelles}
		Afin de pouvoir installer le jeu, le serveur doit posséder les fonctionnalités suivantes : 
		\begin{itemize}
			\item JVM\footnote{Java Virtual Machine} 1.5
			\item Suffisamment de RAM\footnote{Random Access Memory}(> 1Gio) alloué à la JVM afin de lancer suffisamment de joueurs simultanément
			\item Accepter le protocole RMI
		\end{itemize}~\\

		Les clients doivent posséder les fonctionnalités ci-dessous:
		\begin{itemize}
			\item JVM 1.5
			\item Une interface Graphique
			\item Être connecté en réseau au serveur
			\item Accepter le protocole RMI
		\end{itemize}

		\section{Partie de la spécifications détaillées}
		\subsection{Le déplacement dans l'arène}
		Le déplacement d'un joueur peut en prendre plusieurs critères, notamment la \textit{stratégie}, cependant nous partons du principe que le déplacement
		d'un joueur est indissociée de sa stratégie.

		Le déplacement d'un joueur s'effectue donc dans la classe \texttt{Console}, dans cette classe, deux méthodes sont concernées par le déplacement : la
		méthode \texttt{run()} et la méthode \texttt{seDirigerVers(int)}. 

		\begin{description}
			\item[\texttt{run()}] Cette méthode est appelé à chaque tour, c'est-à-dire à chaque fin du timer, cette méthode appel la fonction de déplacement avec
				les coordonnées corrects. C'est-à-dire un personnage ou un objet si il y en a un proche, ou alors signale à cette méthode que le personnage devra
				errer.
			\item[\texttt{seDirigerVers(int)}] Cette méthode déplace le personnage en fonction de son paramètre : soit le personnage se dirige vers un objet ou
				un autre personnage, soit celui-ci << erre >>, c'est-à-dire qu'il se déplacera vers un point calculé aléatoirement.
		\end{description}

		\subsection{L'interaction entre objets}
		Les interactions se font dans la classe \texttt{Arene}, avec soit une interaction entre deux personnages, soit un ramassage d'objet, ces deux cas sont
		gérés de façon différentes.

		\subsubsection{Interaction entre deux personnages}
		Une interaction entre deux personnages va générer un duel entre ceux-ci. Cette fonctionnalité est gérer dans deux parties du logiciel : 
		\begin{description}
			\item[Interface \texttt{IArene}] La classe \texttt{Arene} via l'implémentation de la méthode \texttt{interaction(int, int)} qui gère le combat entre deux références d'objets. Cette méthode appel la fonction \texttt{DuelBasic} qui va se charger d'exécuter un duel afin de connaître le vainqueur de ce combat.
			\item[Interface \texttt{IDuel}] La classe \texttt{DuelBasic} possède la méthode \texttt{realiserCombat()} permettant de réaliser le combat entre
				deux personnages, c'est cette méthode qui permettra de connaître le vainqueur de ce duel.
		\end{description}

		\subsubsection{Ramassage d'un objet}
		Le ramassage d'un objet se fait dans les classes \texttt{Arene} et \texttt{Console}, la gestion est différente que celle des combats.

		\begin{description}
			\item[Interface \texttt{IArene}]La classe \texttt{Arene} possède l'implémentation de la méthode \texttt{ramasser(int, int)} qui permet un personnage de ramasser un objet.
				Cette méthode vérifie que le personnage à le droit de ramasser l'objet, et si c'est le cas, elle fait ensuite appel à la méthode qui va ramasser
				l'objet proprement dit sur la map.
			\item[Interface \texttt{IConsole}] La classe \texttt{Console} possède l'implémentation du ramassage d'un objet, cette méthode affectera les nouvelles
				caractéristiques au personnage ayant bien ramassé l'objet.
		\end{description}
		
		\begin{remarque}
			Dans la suite de cette campagne de tests, nous allons nous intéresser aux fonctions d'interactions et de déplacement énumérés dans les spécifications
			détaillées ci-dessus.

			Nous allons donc nous intéresser aux interfaces et aux implémentations associés suivantes : \texttt{IConsole}, \texttt{IDuel}, \texttt{IArene}.
		\end{remarque}
		
		\chapter{Tests}
		\section{Tests unitaires}
		Afin de pouvoir lancer les tests unitaires, plusieurs dépendances doivent être respectées.

		Tout d'abord, le serveur doit être lancé, afin que la connexion RMI s'effectue sans problème. D'autres parts, les méthodes de déplacement ou
		d'interactions dépendent d'autres classes, ainsi les tests unitaires de chacune des méthodes dépendent d'autres méthodes.

		\begin{attention}
			Afin de simplifier notre travail, nous considérerons que les autres modules autres que ceux testés sont corrects.
		\end{attention}
		\section{Tests d'intégration}
		Afin de faire un test d'intégration, la méthode la plus simple vérifiant que tout se passe correctement consiste à faire apparaître deux personnages
		assez proche pour qu'ils se rencontrent : un combat va avoir lieu, leurs caractéristiques doivent être de sorte que nous pouvons savoir à l'avance qui va
		gagner. Une fois le vainqueur déclaré, un objet apparaîtra proche de lui, il doit le ramasser.

		Si notre scénario se déroule comme prévu : les deux personnages se rencontrent, le vainqueur est celui prévu, et le vainqueur ramasse un objet lui
		prodiguant les nouvelles caractéristiques prévues alors nous pourrons dire que les modules fonctionnent correctement entre eux.

		\section{Tests de validation et test fonctionnel}
		Il faut créer une map avec un objet et deux personnages, les deux personnages doivent combattre ensemble, et un des personnage doit ramasser un objet.

		Afin de faire un test de robustesse, il faudrait appeler la méthode \texttt{interaction} ou la méthode \texttt{ramasser} avec des valeurs négatives, ou
		des références n'existant pas, afin de vérifier si le programme gères bien ce cas.
\end{document}

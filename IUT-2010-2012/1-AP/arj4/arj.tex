\documentclass[a4paper,11pt]{report}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}
\usepackage[frenchb]{babel}
\usepackage{vmargin}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{soul}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}
%\usepackage[tight]{shorttoc}
%\usepackage[T1]{fontenc}
%\usepackage{lmodern}

\setmarginsrb{2cm}{2cm}{2cm}{2cm}{0cm}{0cm}{0cm}{0cm}

\lstset{
language=Java,
backgroundcolor=\color{exemple},
rulecolor=\color{exemple},
fillcolor=\color{exemple},
basicstyle=\footnotesize,       % taille de la police du code
numbers=left,                   % placer les numéros de lignes à droite (right) ou à gauche (left)
numbersep=7pt,                  % distance entre le code et sa numérotation
keywordstyle=\bf \color{blue},
commentstyle=\color[gray]{0.5},
stringstyle=\color{red},
showstringspaces=false,
tabsize=4,
numberstyle=\tiny \bf \color{gray},
numberfirstline=true
}

\definecolor{attention}{HTML}{eddddd}
\definecolor{remarque}{HTML}{dde5ed}
\definecolor{exemple}{HTML}{e2eddd}

\setcounter{tocdepth}{3}

\newcommand{\attention}[1]{
	\begin{center}
	\medskip
	\colorbox{attention}{
		\begin{minipage}{0.8\textwidth}\medskip\includegraphics[height=10px]{images/attention.png} #1 \medskip\end{minipage}
	}
	\medskip
	\end{center}
}

\newcommand{\remarque}[1]{
	\begin{center}
	\medskip
	\colorbox{remarque}{
		\begin{minipage}{0.8\textwidth}\medskip\includegraphics[height=10px]{images/remarque.png} #1 \medskip\end{minipage}
	}
	\medskip
	\end{center}
}

\newcommand{\exemple}[1]{
	\begin{center}
	\medskip
	\colorbox{exemple}{
		\begin{minipage}{0.8\textwidth}\medskip#1 \medskip\end{minipage}
	}
	\medskip
	\end{center}
}

\newcommand{\exemplecode}[1]{
	\begin{center}
	\medskip
	%\colorbox{exemple}{
	%	\begin{minipage}{0.8\textwidth}
			\begin{lstlisting}
				\medskip#1 \medskip
			\end{lstlisting}
	%	\end{minipage}
%	}
	\medskip
	\end{center}
}

%\hyphenation{
%	java.-rmi.-RemoteException
%	java.-rmi.-Remote
%	java.-rmi.-server.-UnicodeRemoteObject
%}



 
% Title Page
\title{Applications réparties en Java}
\author{Ophélie \bsc{FRAISIER}}
\date{Semestre 4} 
 
\begin{document} 
\maketitle
\tableofcontents
%\shorttoc{Sommaire}{3}

\chapter{Qu\rq{}est-ce qu\rq{}une application répartie ?}

Il s\rq{}agit d\rq{}un ensemble composé d\rq{}éléments reliés par un système de communication.

\exemple{Architectures basées sur la mise en série de plusieurs cartes graphiques pour faire du calcul}

 Les éléments ont des fonctions de traitement (processeurs), de stockage (mémoire) et de relation avec le monde extérieur (capteurs et actionneurs). Ils ne fonctionnent pas indépendamment mais collaborent à une ou plusieurs tâches communes.

\attention{Une partie au moins de l\rq{}état global de l\rq{}application est partagée entre plusieurs éléments, sinon on aurait un fonctionnement indépendant.}

\remarque{Les différents éléments d\rq{}une application distribuée collaborent toujours dans un but précis.}

Java propose un ensemble de classes et d\rq{}interfaces pour simplifier la réalisation d\rq{}applications réparties, en particulier il est aisé de réaliser des applications serveurs et des objets distribués. Les classes et les interfaces permettant la réalisation de serveurs sont principalement regroupées dans le package \texttt{java.net} et celles pour les objets distribués dans \texttt{java.rmi} et les packages inclus.


\chapter{Concepts et outils préliminaires}
\section{La sérialisation}
La sérialisation consiste à prendre un objet en mémoire et à en sauvegarder l\rq{}état (= les attributs) sur un flux de données, vers un fichier par exemple. Ce concept permet aussi de reconstruire ultérieurement l\rq{}objet an mémoire à l\rq{}identique de ce qu\rq{}il pouvait être initialement (création d\rq{}un clone). Le problème réside dans le fait que les attributs ne sont pas tous de type scalaire. Certains sont de type agrégat (sous-objets ou tableaux) or en Java les agrégats sont obligatoirement stockés dans la mémoire hors de la pile d\rq{}exécution. Ils sont donc  inévitablement référencés.

Par défaut les classes ne permettent pas de sauvegarder d\rq{}état d\rq{}un objet sur un flux de données (pour des raisons de performance). Par contre, pour une grande majorité des classes du JDK, elles ont été définies comme étant sérialisables : il suffit de les marquer comme étant sérialisables pour qu\rq{}elles le soient, en implémentant l\rq{}interface \texttt{java.io.serializable}, qui ne contient aucune méthode.

Comme la mise en oeuvre de l\rq{}interface est explicite le compilateur travaille maintenant en confiance et va effectuer les traitement nécessaires. Toutefois ce marquage ne fonctionne que si tous les attributs de la classe sont eux-même sérialisable.

\attention{Ne sont pas sérialisables :
\begin{itemize}
\item les threads
\item les streams
\item les sockets
\end{itemize}
\textit{(Liste non exhaustive)}}

Dans certains cas il peut donc être nécessaire d\rq{}exclure un attribut de l\rq{}état sérialisé d\rq{}une classe. Dans ce cas il suffit de rajouter le qualificateur \texttt{transient} à l\rq{}attribut en question.

\attention{Un objet peut théoriquement avoir une taille phénoménale.}


\section{Le multi-threading}
\subsection{Rappels}
Il est parfois nécessaire de découper un programme en unités d\rq{}exécution indépendantes. Chacune de ces unités est appelée un processus léger ou thread. Chaque thread est programmé comme s\rq{}il s\rq{}exécutait par lui-même et qu\rq{}il avait son propre CPU. Un mécanisme sous-jacent s\rq{}occupe de diviser le temps CPU pour le programmeur, mais en général il est inutile de gérer cet aspect. C\rq{}est ce qui rend la programmation multi-threads beaucoup plus simple.

Un thread est un flot de contrôles séquentiel à l\rq{}intérieur d\rq{}un processus. Un processus peut contenir plusieurs threads s\rq{}exécutant en concurrence.

Il y a plusieurs utilisations possibles du multi-threading, mais en général il y aura une partie du programme attachée à un évènement ou à une ressource particulière, et il ne faut pas que le reste de l\rq{}application ne dépende de cette partie.

\exemple{Le traitement d\rq{}une demande client par le serveur ne doit pas affecter son fonctionnement, il faut donc déléguer le traitement demandé à un processus léger : création d\rq{}un thread associé à cet évènement ou à cette ressource que l\rq{}on laissera s\rq{}exécuter indépendamment du programme principal.}

\subsection{Implémentation du multi-threading}
\subsubsection{Héritage de la classe \texttt{java.lang.Thread}}

Il s\rq{}agit du moyen le plus simple pour créer un thread. \texttt{Thread} contient toutes les méthodes nécessaires pour créer et faire fonctionner les threads.

La méthode la plus importante est \texttt{run()}, qui doit être redéfinie pour que le thread exécute le code attendu. Elle contient souvent virtuellement une boucle s\rq{}exécutant jusqu\rq{}à ce que le thread ne soit plus nécessaire, ainsi vous pouvez établir la condition sur laquelle vous pouvez arrêter cette boucle et donc le thread. \texttt{run()} est souvent transformée en boucle infinie : à moins d\rq{}un facteur extérieur ne cause sa terminaison elle continuera indéfiniment.

\remarque{Afin de minimiser les risques de famine, il est important d\rq{}insérer dans la boucle un appel à la méthode de classe \texttt{yield()}. Cette méthode entraîne la suspension temporaire du thread pour permettre aux autres processus légers de s\rq{}exécuter.}

Dans la méthode \texttt{main()} vous pouvez créer et démarrer un certain nombre de threads. La méthode \texttt{start()} de la classe \texttt{Thread} procède à une initialisation spéciale du thread et appelle ensuite la méthode \texttt{run()}.

Les étapes sont donc :
\begin{itemize}
\item le constructeur est appelé pour construire l\rq{}objet,
\item la méthode \texttt{start()} configure le thread et appelle \texttt{run()}.
\end{itemize}

\attention{Les threads ne sont pas exécutés dans l\rq{}ordre où ils sont créés. Cet ordre est indéterminé, à moins d\rq{}ajuster par programmation les priorités en utilisant \texttt{setPriority()}.}

\subsubsection{Utilisation de l\rq{}interface \texttt{Runnable}}
Cette méthode est utilisée si l\rq{}héritage de \texttt{Thread} est impossible ou non souhaitable. Elle ne contient que la méthode \texttt{run()} à redéfinir comme lors de l\rq{}héritage de \texttt{Thread}.

Définir un thread par cette méthode n\rq{}est pas trivial. Lors de la création d\rq{}une classe implantant \texttt{Runnable} il y a création d\rq{}un objet \texttt{Runnable} mais le thread n\rq{}est pas lancé, car ceci doit être explicitement fait : \texttt{run()} est définie dans la classe mais reste en sommeil après la création. Pour produire un thread à partir d\rq{}un objet \texttt{Runnable} il faut créer un objet thread séparé et passer l\rq{}objet \texttt{Runnable} au constructeur spécial de \texttt{Thread}. L\rq{}initialisation usuelle est alors effectuée puis \texttt{run()} est appelée une fois \texttt{start()} invoquée.

\begin{lstlisting}
public class MaClasse implements Runnable {
	public void run() {
		while(true) {
			...
			Thread.yield();
			...
		}
	}
}

public class Test {
	public static void main(String argv[]) {
		Runnable uneInstance = new MaClasse();
		Thread th = new Thread(uneInstance);
		th.start();
	}
}

\end{lstlisting}

\section{La synchronisation}
\subsection{Les méthodes synchronisées}

Java possède un support intégré pour gérer des accès concurrents sur un type de ressources, en particulier sur les données en mémoire (pour Java la mémoire est un objet).

Alors que le programmeur rend les attributs \texttt{private} et accède aux données au travers de méthodes, il peut prévoir les collisions d\rq{}accès à ces données en rendant une méthode particulière \texttt{synchronized}. Une telle méthode assure qu\rq{}un seul thread à la fois peut l\rq{}appeler pour un objet particulier, bien que ce thread puisse appeler plus d\rq{}une des méthodes de l\rq{}objet.

Chaque objet contient un seul verrou, aussi appelé moniteur, qui fait automatiquement partie de l\rq{}objet. Quand une méthode \texttt{synchronized} est appelée cet objet est verrouillé et aucune autre méthode \texttt{synchronized} de cet objet ne peut être appelée jusqu\rq{}à ce que la première soit terminée et libère le verrou. Ce verrou protège la mémoire commune de l\rq{}écriture par plus d\rq{}une méthode à un instant donné.

Il existe aussi un verrou unique par classe. Ainsi les méthodes \texttt{synchronized} statiques peuvent verrouiller les autres objets, empêchant un accès simultané aux données statiques.

\begin{lstlisting}
public class Wagon {
	public synchronized void reserverPlace() {
	}
}
\end{lstlisting}


\subsection{Synchronisation d\rq{}une partie de code}

La section de code que le programmeur veut isoler de cette manière est appelée une \emph{section critique}, et il est possible d\rq{}utiliser le mot clé \texttt{synchronized} d\rq{}une manière différente pour créer une telle section. Java supporte les sections critiques à l\rq{}aide d\rq{}un \texttt{synchronized block}. Cette fois le mot-clé \texttt{synchronized} est utilisé pour spécifier l\rq{}objet sur lequel le verrou est utilisé pour synchroniser le code encapsulé.

Avant d\rq{}entrer dans un bloc synchronisé le verrou doit être acquis sur l\rq{}objet qui veut rentrer dans la section. Si un autre thread possède déjà le verrou l\rq{}entrée dans le bloc est impossible jusqu\rq{}à ce que le verrou soit libéré.

Bien sûr toutes les synchronisations dépendent de la diligence du programmeur.

Chaque morceau de code pouvant accéder à une ressource partagée doit être emballé dans un bloc \texttt{synchronized}.

\begin{lstlisting}
public class Wagon {
	public void reserverPlace() {
		synchronized(this) {
			...
			//section critique
			...
		}
	}
}
\end{lstlisting}


\subsection{Accès à des ressources partagées}

La pose de verrou n\rq{}est pas une solution forcément suffisante lorsque le thread doit accéder à une ressource indisponible. Dans ce cas il faut faire patienter le thread jusqu\rq{}à ce que la dite ressource soit enfin disponible. Pour gérer ces cas l\rq{}environnement Java propose aussi un support pour contrôler l\rq{}activité des threads.

Tout le support nécessaire à cette gestion est fourni dans la classe \texttt{Object}. Celle-ci propose notamment trois méthodes permettant d\rq{}endormir et de réveiller un thread.
\begin{itemize}
\item Pour endormir un thread dans le moniteur : \texttt{wait{}}. Il y a plusieurs prototypes fournis afin soit d\rq{}attendre indéfiniment soit durant un délai maximum.\\
\texttt{sleep()} permet d\rq{}endormir un processus mais cette dernière ne permet au thread de reprendre son activité qu\rq{}à la fin de la durée passée en paramètre de la méthode.
\item Pour réveiller : \texttt{notify()} et \texttt{notifyAll()}. \texttt{notify()} permet de réveiller un unique thread endormi sur un objet sur lequel il faut se synchroniser, \texttt{notifyAll()} réveille tous les threads endormis.
\end{itemize}

\attention{Lors de l\rq{}invocation d\rq{}une des méthodes ci-dessus l\rq{}objet qui les invoque doit être synchronisé. Dans le cas contraire une exception est générée.}

\begin{lstlisting}
public void m() {
	synchronized(o) {
		wait(o);
	}
}
\end{lstlisting}


\subsection{Efficacité de la synchronisation}

Comme avoir deux méthodes écrivant dans le même morceau de données en même temps n\rq{}apparaît jamais être une bonne idée, il semblerait logique que toutes les méthodes soit automatiquement synchronisées, et donc d\rq{}éliminer le mot-clé \texttt{synchronized} ailleurs.

Mais il faut savoir qu\rq{}acquérir un verrou n\rq{}est pas une opération légère : cela multiplie par quatre le coût de l\rq{}appel de la méthode (c\rq{}est à dire l\rq{}entrée et la sortie de la méthode sans l\rq{}exécution du corps) et peut être très différent suivant la mise en oeuvre.

Donc si l\rq{}on sait qu\rq{}une méthode ne posera pas de problème particulier il est opportun de ne pas utiliser le mot-clé \texttt{synchronized}.

D\rq{}un autre côté supprimer le mot-clé \texttt{synchronized} pensant que c\rq{}est un goulot d\rq{}étranglement pour les performances en espérant qu\rq{}il n\rq{}y aura pas  de collision est une invitation au désastre.

\begin{lstlisting}
// Exemple ne fonctionnant pas et non pertinent
public class MaClasse implements Runnable {
	public synchronized void run() {
		while(true) {
			... // boucle infinie synchronisee
		}
	}
	
	public synchronized int getBouh() {
		... // non pertinent
	}
}
\end{lstlisting}


\chapter{Création de serveur Java}

\textit{Toutes les demandes convergent vers un serveur qui les traite ou éventuellement délègue le traitement de celles-ci à des gestionnaires spécifiques.}

\section{Conception d\rq{}une application client-serveur 2 tiers}

Un serveur est un programme qui écoute un port de la machine et qui se bloque jusqu\rq{}à ce qu\rq{}il détecte une demande de connexion. Une fois la demande détectée le serveur extrait un canal de communication permettant de recevoir le flux de données issu du client et un canal de communication permettant d\rq{}acheminer la réponse au client. Ces deux canaux devront être fermés lorsque les informations auront été acheminées.

Les bibliothèques fournies avec Java permettent de créer rapidement des applications client-serveur 2 tiers. Pour concevoir un serveur il est nécessaire de prendre en compte les points suivants :
\begin{itemize}
\item définir les services que doit rendre le serveur,
\item définir les services pouvant s\rq{}exécuter indépendamment du serveur et les associer à un thread,
\item définir les méthodes et les portions de code critique,
\item concevoir l\rq{}architecture du serveur, en UML par exemple, indépendamment de tout langage,
\item choisir une technologie et projeter la conception réalisée précédemment sur celle-ci,
\item introduire les concepts propres au langage choisi, en particulier pour les problèmes de synchronisation du code et de sérialisation des données,
\item introduire les bonnes bibliothèques et les intégrer à la conception.
\end{itemize}


\section{Bibliothèques Java utilisées pour la création d\rq{}un serveur}

Le langage Java propose le package \texttt{java.net} offrant différentes fonctionnalités pour réaliser un serveur, en particulier les classes \texttt{ServerSocket} et \texttt{Socket}.

\subsection{La classe \texttt{ServerSocket}}
Cette classe met en oeuvre un serveur basé sur les sockets. Un tel serveur attend une demande issue d\rq{}un client distant et effectue certaines opérations en fonction de la demande. Éventuellement le serveur retourne un résultat au demandeur. Elle contient deux méthodes intéressantes :
\begin{itemize}
\item \texttt{accept()} : cette méthode attend une demande d\rq{}un utilisateur en écoutant le port passé en paramètre au constructeur, et bloque son exécution jusqu\rq{}à détection d\rq{}une telle demande. Une fois celle-ci détectée elle retourne un socket permettant de dialoguer avec le serveur.
\item \texttt{close()} : cette méthode clôture le serveur et tous les threads bloqués sur une instruction \texttt{accept()} génère une \texttt{SocketException}.
\end{itemize}

\newpage

\subsection{La classe \texttt{Socket}}
Cette classe met en oeuvre un socket. Elle possède trois méthodes principales :
\begin{itemize}
\item \texttt{getInputStream()} : cette méthode fournit un \texttt{java.io.InputStream} permettant de recevoir les méthodes issues du client.
\item \texttt{getOutputStream()} : cette méthode fournit un \texttt{java.io.OutputStream} permettant d\rq{}envoyer des messages au client.
\item \texttt{close()} : cette méthode clôture le socket.
\end{itemize}

\subsection{Exemple d\rq{}application}
\subsubsection{Le serveur}
\begin{lstlisting}
import java.io.*
import java.net.*

public class Serveur {
	public static void main(String argv[]) throws IOException {
		String str;
		ServerSocket sos;
		sos = new ServerSocket(9999);
		try {
			do {
				Socket soc = sos.accept(); //Attente d'une demande
				java.util.Scanner dos = new java.util.Scanner(soc.getInputStream);
				str = dos.nextLine();
				System.out.println("Message recu : " + str);
				soc.close();
			} while(true);
		}
		catch(UnknownHostException e) {
			e.printStackTrace();
		}
		catch(IOException e) {
			e.printStackTrace();
		}
		finally {
			sos.close();
		}
	}
}
\end{lstlisting}

\subsubsection{Le client}
\begin{lstlisting}
import java.io.*
import java.net.*

public class Client {
	public static void main(String argv[]) throws IOException {
			Socket soc = new Socket(www.iut-tlse3.fr, 9999); // Creation du socket
			OutputStream os;
			PrintWriter dos;
			os = new soc.getOutputStream(); // Creation du canal d'ecriture dans soc
			dos = new PrintWriter(os, true);
			dos.println("Bonjour et bienvenue tout le monde");
			dos.close();
			soc.close();
	}
}
\end{lstlisting}


\chapter{Création et manipulation d\rq{}objet distribués}

\section{Présentation}
Le but de RMI (Invocation de Méthodes Distantes) est de permettre l\rq{}appel, l\rq{}exécution et le renvoi de résultats d\rq{}une méthode exécutée dans une machine virtuelle différente de celle de l\rq{}objet l\rq{}appelant. Cette machine virtuelle peut être sur une machine différente pourvue qu\rq{}elle soit accessible par le réseau. La machine sur laquelle s\rq{}exécute la méthode distante s\rq{}appelle le serveur. L\rq{}appel coté client d\rq{}une telle méthode consiste à obtenir une référence sur l\rq{}objet distant puis à appeler la méthode à partir de cette référence. RMI se charge de rendre transparents la localisation de l\rq{}objet distant, son appel et le renvoi du résultat.

Bien qu\rq{}il soit possible d\rq{}utililser des objets distribués pour réaliser des serveurs, l\rq{}intérêt majeur d\rq{}utiliser de tels objet est de créer un réseau d\rq{}entités pouvant communiquer entre elles pour répondre à une demande de l\rq{}utilisateur. Cela signifie que les objets jouent à la fois le rôle de serveur lorsqu\rq{}ils sont sollicités et le rôle de client lorsqu\rq{}ils sont demandeur. Pour être accessible un objet doit s\rq{}enregistrer dans un annuaire afin d\rq{}être connu par les autres objets de l\rq{}application.

La création de serveurs alliés à des objets distribués va permettre de définir des applications client-serveur 3 tiers.


\section{La conception d\rq{}une application distribuée}

La conception d\rq{}objets distribués nécessite la réalisation d\rq{}une partie serveur permettant de les contacter. La mise à disposition de la version 5 de Java a beaucoup simplifié l\rq{}utilisation de cette technologie par rapport à ce qui était de mise avant.

\subsection{La création d\rq{}un objet distribué}
Pour être distribué un objet doit être composé de trois parties :
\begin{itemize}
\item l\rq{}interface exportant les services (soit les méthodes publiques)  fourmis par l\rq{}objet. Cette interface doit étendre l\rq{}interface \texttt{java.\-rmi.\-Remote}. De plus toutes les méthodes de cette interface doivent être déclarées comme pouvant lever l\rq{}exception \texttt{java.\-rmi.\-RemoteException}. Cette erreur est levé lorsqu\rq{}une erreur issue du réseau se produit.
\item la classe mettant en oeuvre l\rq{}interface. Cette classe doit soit étendre la classe \texttt{java.\-rmi.\-server.\-UnicastRemoteObject}, soit être exportée en utilisant la méthode statique \texttt{exportObject()} de la classe \texttt{UnicastRemoteObject} (pour des raisons de problème d\rq{}héritage notamment). Dans ce cas il convient d\rq{}instancier manuellement les objets du serveur et de les transmettre à la méthode statique.
\item le serveur d\rq{}objets.
\end{itemize}


\subsection{La création de la partie serveur}

Pour être accessible un objet distribué doit être enregistré dans un annuaire. Actuellement deux solutions existent :
\begin{itemize}
\item utiliser l\rq{}annuaire \texttt{java.rmi.Naming} constituant l\rq{}annuaire par défaut.
\item utiliser les classes du package \texttt{javax.naming} permettant la définition de contextes personnalisés.
\end{itemize}

Dans le cadre de cet enseignement nous utiliserons la première solution.

Pour enregistrer un objet il faut utiliser soit la méthode de classe \texttt{bind()} soit la méthode de classe \texttt{rebind()}. La première enregistre l\rq{}objet dans l\rq{}annuaire et lève l\rq{}exception \texttt{NameAlreadyBoundException} si l\rq{}objet est déjà lié dans l\rq{}annuaire, alors que la seconde écrase l\rq{}objet existant s\rq{}il est déjà lié dans l\rq{}annuaire.


\subsection{L\rq{}accès à un objet distribué}

Lorsqu\rq{}un client veut utiliser un objet distribué il doit récupérer la référence de l\rq{}objet distant en interrogeant l\rq{}annuaire. Cette interrogation se fait en invoquant la méthode de classe \texttt{lookup()} de la classe \texttt{java.rmi.Naming}. Cette méthode retourne un objet qu\rq{}il faudra transtyper avec le type attendu.

\attention{Ce type attendu est fourni par \textbf{l\rq{}interface} exportant les services de l\rq{}objet distribué.}
\remarque{Si l\rq{}on essaye d\rq{}accéder à un objet distant via la méthode \texttt{lookup()} et que cet objet n\rq{}est pas lié actuellement l\rq{}exception \texttt{NamingException} est levée.}


\subsection{Le service d\rq{}enregistrement des objets}

Pour enregistrer un objet dans un annuaire il existe deux solutions :
\begin{itemize}
\item la plus élégante : l\rq{}utilisation de la classe prédéfinie \texttt{sun.rmi.registry.RegistryImpl} permettant d\rq{}exécuter l\rq{}adaptateur rmi vu comme un annuaire dans lequel on enregistre tous les objets distribués d\rq{}une même machine.

On passe en paramètre le numéro du port sur lequel les clients devront se connecter. Il faut aussi indiquer à l\rq{}annuaire le chemin d\rq{}accès aux paquetages contenant toutes les classes non prédéfinies utilisées en paramètres des méthodes distantes des objets distribués avec :

\texttt{java-classpath \lq\lq{}package1\rq\rq{} sun.rmi.registry.RegistryImpl 9999}

\textit{\texttt{package1} étant le ou les chemins d\rq{}accès vers les paquetages, séparés par une virgule sous UNIX et deux-points sous Windows, et \texttt{9999} étant le numéro de port}
\attention{Si le port est déjà utilisé, l\rq{}exception \texttt{ExportException} ou \texttt{BindException} est générée.

Si vous définissez mal l\rq{}accès aux packages ou si les classes utilisées ne sont pas dans le package alors vous aurez une erreur d\rq{}exécution \texttt{RemoteException} ou \texttt{UnmarshalException} non pas lors du lancement de l\rq{}annuaire mais lors du lancement du serveur.}

\item la plus simple à mettre en oeuvre :exécuter l\rq{}annuaire dans le code du serveur en utilisant la classe \texttt{java.rmi.registry.LocateRegistry} et sa méthode de classe \texttt{createRegistry()}. Toutefois il faut que le serveur se trouve dans le même package que les objets distribués afin que l\rq{}annuaire puisse y accéder.

Cette solution évite le lancement de l\rq{}annuaire manuellement mais est plus contraignante d\rq{}un point de vue architecture logicielle.

Toutefois elle est suffisante pour les TPs.
\end{itemize}

\newpage

\subsection{Les étapes de la création d\rq{}un objet distribué}

Pour concevoir un objet distribué il est nécessaire de prendre en compte les points suivants :
\begin{itemize}
\item isoler dans un même package la classe devant distribuer les objets ainsi que l\rq{}interface qu\rq{}elle réalise. Cette classe doit étendre la classe \texttt{java.rmi.server.UnicastRemoteObject} et l\rq{}interface doit étendre \texttt{java.rmi.Remote},
\attention{Toutes les méthodes de l\rq{}interface doivent être déclarées comme pouvant lever l\rq{}exception \texttt{java.rmi.RemoteException}}
\remarque{L\rq{}interface de l\rq{}objet est aussi bien utilisée du côté client que du côté de l\rq{}objet distribué lui-même}
\item définir les classes devant être sérialisables, c\rq{}est-à-dire les classes apparaissant comme types de paramètres des méthodes de l\rq{}interface,
\item définir une classe serveur chargée d\rq{}enregistrer l\rq{}objet distibué de l\rq{}annuaire. Cette classe peut éventuellement lancer l\rq{}annuaire. Si l\rq{}annuaire n\rq{}est pas exécuté il faut l\rq{}exécuter manuellement en lançant \texttt{sun.rmi.registry.RegistryImpl},
\item définir le client devant acquérir une référence sur l\rq{}objet distant en utilisant la méthode de la classe \texttt{java.rmi.Naming} et l\rq{}interface de l\rq{}objet,
\item distribuer les packages sur les différentes machines.
\end{itemize}

\attention{Lors de la distribution d\rq{}une classe il ne faut pas oublier de distribuer aussi toutes les classes dont l\rq{}objet distribué a besoin pour s\rq{}exécuter (soit les classes précédemment sérialisées).}


\subsection{Les conventions de nommage}

Java préconise des conventions de nommage qu\rq{}il est conseillé d\rq{}utiliser bien qu\rq{}il n\rq{}y ait aucune obligation.

Soit \texttt{MaClasse} le nom de la classe dont les objets doivent être distribués.
\begin{itemize}
\item Son interface : \texttt{MaClasse}
\item La classe réalisant cette interface : \texttt{MaClasseImpl}
\item La classe serveur : \texttt{MaClasseServer}
\end{itemize}


\section{Les bibliothèques Java utilisées pour créer des objets distribués}

Les méthodes nécessaires pour réaliser des objets distribués se répartissent principalement dans trois classes et une interface.

\subsection{La classe \texttt{java.rmi.Naming}}
Cette classe offre trois méthodes pertinentes :
\begin{itemize}
\item \texttt{bind()} : cette méthode de classe lie un nom à un objet. Ce nom est de la forme \texttt{rmi://adresse:port/nom}. Si le nom existe déjà alors l'exception \texttt{NameAlreadyBoundException} est levée.
\item \texttt{rebind()} : cette méthode est similaire et a les mêmes paramètres que la précédente. Toutefois si le nom existe alors l'ancien objet est écrasé.
\item \texttt{lookup()} : cette méthode permet de récupérer la référence de l'objet distant dont le nom est passé en paramètre.
\attention{Le nom doit être identique à celui utilisé dans la méthode \texttt{bind()} ou \texttt{rebind()}.}
La valeur retournée par cette méthode est de type \texttt{Object} et doit donc être convertie en utilisant \textbf{l'interface} de l'objet distant.
\end{itemize}

\subsection{La classe \texttt{java.rmi.server.UnicastRemoteObject}}
Cette classe est utilisée comme marqueur lorsqu'elle est étendue par la classe des futurs objets distribués.

La seule méthode vraiment intéressante est la méthode statique \texttt{exportObject()} utilisée lorsque l'extension de la classe \texttt{java.rmi.server.UnicastRemoteObject} est impossible. Cette méthode nécessite deux paramètres :
\begin{itemize}
\item l'objet à distribuer,
\item le numéro de port où se trouve l'annuaire.
\end{itemize}

\subsection{La classe \texttt{java.rmi.registry.LocateRegistry}}
Cette classe possède une méthode de classe permettant d'exécuter l'annuaire. Cette méthode a besoin d'un paramètre : le numéro de port sur lequel l'annuaire est enregistré.

\subsection{L\rq{}interface \texttt{java.rmi.Remote}}
Cette interface est un marqueur, elle ne possède aucune méthode.


\section{Un exemple d'application d'objet distribué}
\subsection{L'interface de l'objet}

\begin{lstlisting}
public interface Personne extends java.rmi.Remote {
	void setNom(String nom) throws java.rmi.RemoteException;
	String getNom() throws java.rmi.RemoteException;
}
\end{lstlisting}

\subsection{L'objet distribué}
\begin{lstlisting}
public class PersonneImpl extends java.rmi.server.UnicastRemoteObject
				      implements Personne {
  	private String nom;

	public PersonneImpl(String nom) {
		this.nom = nom;
	}
	public void setNom(String nom) throws java.rmi.RemoteException {
		this.nom = nom;
	}
	public String getNom() throws java.rmi.RemoteException {
		return this.nom;
	}
}

\end{lstlisting}


\subsection{Le serveur d'objet distribué}
\begin{lstlisting}
/* Ce programme de serveur cree (instancie) 2 objets distants, les enregistre aupres
du service de nom et attend les clients pour invoquer les methodes des objets distribues */
public class PersonneServer {
	public static void main(String[] args) throws Exception {
		java.rmi.registry.LocateRegistry.createRegistry(9999);
		Personne dupont = new PersonneImpl("dupont");
		Personne dulong = new PersonneImpl("dulong");
		// declaration des objets dans l'annuaire
		java.rmi.Naming.rebind("rmi:nacre.local:9999/manu", dupont);
		java.rmi.Naming.rebind("rmi:nacre.local:9999/dulong", dulong);
	}
}
\end{lstlisting}

\newpage

\subsection{Le client}
\begin{lstlisting}
public class Test throws Exception {
	public static void main(String[] args) {
		Personne unePersonne =
			(Personne)(java.rmi.Naming.lookup("rmi://nacre.local:9999/manu");
		System.out.println("Bienvenue a " + unePersonne.getNom());
		// Bienvenue a dupont
	}
}
\end{lstlisting}

\end{document}          





























































